[{"title":"产品理论书单📚","url":"/2025/01/01/%E4%BA%A7%E5%93%81%E7%90%86%E8%AE%BA/%E4%BA%A7%E5%93%81%E7%90%86%E8%AE%BA%E4%B9%A6%E5%8D%95%F0%9F%93%9A/%E4%BA%A7%E5%93%81%E7%90%86%E8%AE%BA%E4%B9%A6%E5%8D%95%F0%9F%93%9A/","content":"\n\n\n开始时间\n图书名称\n图书作者\n结束时间、阅读笔记\n\n\n\n\n产品\n\n\n\n\n2024-12-26\n《人人都是产品经理「入行版」01》\n苏杰\n2025-01-06\n\n\n2025-01-12\n《人人都是产品经理「思维版」02》\n苏杰\n2025-01-26\n\n\n\n《人人都是产品经理「创新版」03》\n苏杰\n\n\n\n2025-05-18\n《人人都是产品经理「案例版」04》\n苏杰\n2025-05-30\n\n\n2025-02-14\n《启示录-打造用户喜爱的产品》\nMarty Cagan\n2025-03-02\n\n\n2025-06-12\n《幕后产品-打造突破式产品思维》\n王诗沐\n2025-07-01\n\n\n\n《用户力-需求驱动的产品、运营和商业模式》\n郝志中\n\n\n\n\n《产品的视角-从热闹到门道》\n后显慧(鲁克)\n\n\n\n\n《结网@改变世界的互联网产品经理(修订版)》\n王坚\n\n\n\n\n《结网2-产品经理的无限游戏》\n王坚\n\n\n\n\n《精益数据分析(珍藏版)》\n阿利斯泰尔·克罗尔、本杰明·尤科维奇\n\n\n\n\n用户体验(交互设计、视觉设计)\n\n\n\n\n\n《用户体验要素-以用户为中心的产品设计(原书第2版)精装版》\n杰西·詹姆斯·加勒特\n\n\n\n\n《贴心的设计-心智模型与产品设计策略》\n茵迪·扬\n\n\n\n\n《亲爱的界面-让用户乐于使用、爱不释手(第2版)》\nLukas Mathis\n\n\n\n\n《界面设计模式(第2版)》\nJenifer Tidwell\n\n\n\n\n《触动人心-设计优秀的iPhone应用》\nJosh Clark\n\n\n\n\n《赢在用户-Web人物角色创建和应用实践指南》\nSteve Mulder、Zivv Yarr\n\n\n\n\n《点石成金-访客至上的Web和移动可用性设计秘笈(原书第3版)》\n史蒂夫·克鲁格\n\n\n\n\n《一目了然-Web软件显性设计之路》\nRobert Hoekman,Jr.\n\n\n\n\n《一目了然-Web和移动应用设计通识方法(原书第2版)》\nRobert Hoekman,Jr.\n\n\n\n\n《胜于言传-网站内容制胜宝典》\nJanice(Ginny)Redish\n\n\n\n\n《胜于言传-Web内容创作与设计的艺术(原书第2版)》\nJanice(Ginny)Redish\n\n\n\n2025-07-01\n《简约至上-交互式设计四策略(第2版)》\n贾尔斯·科尔伯恩\n2025-07-13\n\n\n\n《交互设计之路-让高科技产品回归人性(第二版)》\nAlan Cooper\n\n\n\n\n《About Face 4交互设计精髓(纪念版)》\nAlan Cooper等6人\n\n\n\n\n《信息架构-超越Web设计(第4版)》\nLouis Rosenfeld、Peter Morville、Jorge Arango\n\n\n\n\n《设计师要懂心理学(第2版)》\n苏珊·魏因申克\n\n\n\n\n《设计心理学1-日常的设计》\n唐纳德·A·诺曼\n\n\n\n\n《设计心理学2-与复杂共处》\n唐纳德·A·诺曼\n\n\n\n\n《设计心理学3-情感化设计》\n唐纳德·A·诺曼\n\n\n\n\n《设计心理学4-未来设计》\n唐纳德·A·诺曼\n\n\n\n\n项目管理\n\n\n\n\n\n《项目管理知识体系指南(PMBOK指南)(第六版)》\nProject Management Institute\n\n\n\n\n《走出软件作坊》\n阿朱\n\n\n\n\n《人件-项目与团队高效管理(第3版)》\nTom DeMarco、Timothy Lister\n\n\n\n\n运营\n\n\n\n\n\n《从零开始做运营》\n张亮\n\n\n\n\n《从零开始做运营2-运营人的进化》\n张亮\n\n\n\n\n《运营升阶笔记-解决运营日常难点的100个问答》\n张亮\n\n\n\n\n《运营制胜-从零系统学运营-构建用户增长引擎》\n张恒\n\n\n\n\n《增长黑客-创业公司的用户与收入增长秘籍》\n范冰\n\n\n\n\n市场营销\n\n\n\n\n\n《参与感-小米口碑营销内部手册(珍藏版)》\n黎万强\n\n\n\n\n《疯传-让你的产品、思想、行为像病毒一样入侵(经典平装版)》\n乔纳·伯杰\n\n\n\n\n《跨越鸿沟-颠覆性产品营销指南(原书第3版)》\n杰弗里·摩尔\n\n\n\n\n《长尾理论-为什么商业的未来是小众市场》\n克里斯·安德森\n\n\n\n\n《定位-有史以来对美国营销影响最大的观念(经典重译版)》\n艾·里斯、杰克·特劳特\n\n\n\n\n《市场营销-原理与实践(第17版)》\n菲利普·科特勒、加里·阿姆斯特朗\n\n\n\n\n《水平营销-突破性创意的探寻法》\n菲利普·科特勒、费南多·德里亚斯迪贝斯\n\n\n\n\n商业模式、创业、创新\n\n\n\n\n\n《商业模式新生代》\n亚历山大·奥斯特瓦德、伊夫·皮尼厄\n\n\n\n\n《商业模式新生代-一张画布重塑你的职业生涯(个人篇)(第二版)》\n蒂莫西·克拉克等5人\n\n\n\n\n《商业模式新生代(团队篇)》\n蒂莫西·克拉克、布鲁斯·黑曾\n\n\n\n\n《小米创业思考》\n雷军\n\n\n\n\n《有的放矢-NISI创业指南》\nNathan Furr、Paul Ahlstrom\n\n\n\n\n《四步创业法》\nSteven Gary Blank\n\n\n\n\n《精益创业-新创企业的成长思维》\n埃里克·莱斯\n\n\n\n\n《精益创业2.0》\n埃里克·莱斯\n\n\n\n\n《从0到1-开启商业与未来的秘密》\n彼得·蒂尔、布莱克·马斯特斯\n\n\n\n\n《创新者的窘境-领先企业如何被新兴企业颠覆》\n克莱顿·克里斯坦森\n\n\n\n\n《公司进化论-伟大的企业如何持续创新》\n杰弗里·摩尔\n\n\n\n\n拓展延伸\n\n\n\n\n\n《别做正常的傻瓜(全新第2版)》\n奚恺元\n\n\n\n\n《统计数据会说谎-让你远离数据陷阱》\n达莱尔·哈夫\n\n\n\n\n《美第奇效应》\n弗朗斯·约翰松\n\n\n\n\n《黑天鹅-如何应对不可预知的未来》\n纳西姆·尼古拉斯·塔勒布\n\n\n\n\n《失控-全人类的最终命运和结局(修订版)》\n凯文·凯利\n\n\n\n\n《U型理论-感知正在生成的未来》\n奥托·夏莫\n\n\n\n\n《浪潮之巅上、下册(第四版)》\n吴军\n\n\n\n\n《硅谷之谜》\n吴军\n\n\n\n\n《思考，快与慢》\n丹尼尔·卡尼曼\n\n\n\n\n《动机与人格》\n亚伯拉罕·马斯洛\n\n\n\n\n《社会心理学(第11版)》\n戴维·迈尔斯\n\n\n\n\n《格式塔心理学原理》\n库尔特·考夫卡\n\n\n\n\n《穷查理宝典-查理·芒格智慧箴言录(全新增订本)》\n彼得·考夫曼\n\n\n\n","categories":["产品理论"],"tags":["产品理论书单📚"]},{"title":"CHANEL、香奈儿","url":"/2024/12/25/%E5%93%81%E7%89%8C%E6%8E%A2%E7%A9%B6/%E5%8F%A3%E7%BA%A2/CHANEL%E3%80%81%E9%A6%99%E5%A5%88%E5%84%BF/","content":"","categories":["品牌探究"],"tags":["口红"]},{"title":"Scabal、世家宝","url":"/2024/12/25/%E5%93%81%E7%89%8C%E6%8E%A2%E7%A9%B6/%E5%AE%9A%E5%88%B6%E8%A5%BF%E8%A3%85%E9%9D%A2%E6%96%99/Scabal%E3%80%81%E4%B8%96%E5%AE%B6%E5%AE%9D/","content":"","categories":["品牌探究"],"tags":["定制西装面料"]},{"title":"计算机理论书单📚","url":"/2025/01/01/%E8%AE%A1%E7%AE%97%E6%9C%BA%E7%90%86%E8%AE%BA/%E8%AE%A1%E7%AE%97%E6%9C%BA%E7%90%86%E8%AE%BA%E4%B9%A6%E5%8D%95%F0%9F%93%9A/%E8%AE%A1%E7%AE%97%E6%9C%BA%E7%90%86%E8%AE%BA%E4%B9%A6%E5%8D%95%F0%9F%93%9A/","content":"\n\n\n开始时间\n图书名称\n图书作者\n结束时间、阅读笔记\n\n\n\n\n汇编语言\n\n\n\n\n\n《汇编语言(第4版)》\n王爽\n*\n\n\n\n操作系统原理\n\n\n\n\n\n《操作系统精髓与设计原理(原书第6版)》\nWilliam Stallings\n\n\n\n\nApple+Linux\n\n\n\n\n\n《Linux命令行大全(第2版)》\n威廉·肖特斯\n*\n\n\n\n数据库系统原理\n\n\n\n\n\n《数据库系统概论(第5版)》、《习题解析与实验指导》\n王珊、萨师煊、张俊\n\n\n\n\n《MySQL必知必会》\nBen Forta\n*\n\n\n\n《SQLite权威指南(第二版)》\nGrant Allen、Mike Owens\n\n\n\n\n计算机网络原理\n\n\n\n\n\n《计算机网络自顶向下方法(原书第8版)》\nJames F.Kurose、Keith W.Ross\n\n\n\n\n《图解TCP&#x2F;IP(第5版)》\n竹下隆史、村山公保、荒井透、刘田幸雄\n\n\n\n\n《图解HTTP》\n上野宣\n\n\n\n\n编程语言\n\n\n\n\n\n《C语言程序设计现代方法(第2版)》\nK.N.King\n\n\n\n\n《C程序设计语言(第2版·新版)》、《习题解答》\n布莱恩·W.克尼汉、丹尼斯·M.里奇、克洛维斯·L.汤多、斯科特·E.吉姆佩尔\n\n\n\n\n《C++ Primer(第5版)中文版》\nStanley B.Lippman、Josee Lajoie、Barbara E.Moo\n\n\n\n\n《C++ Primer Plus(第6版)中文版》\nStephen Prata\n\n\n\n\n数据结构\n\n\n\n\n\n《程序员的数学(第2版)》\n结城浩\n\n\n\n\n《数据结构与算法分析-C语言描述(原书第2版)》\n马克·艾伦·维斯\n\n\n\n\nLeetCode算法\n\n\n\n\n\n《剑指Offer-名企面试官精讲典型编程题(第2版)》\n何海涛\n计算机理论&#x2F;LeetCode算法\n\n\n\n《LeetCode 101: 和你一起你轻松刷题(C++)》\n高畅\n计算机理论&#x2F;LeetCode算法\n\n\n","categories":["计算机理论"],"tags":["计算机理论书单📚"]},{"title":"运营基础","url":"/2023/05/31/%E4%BA%A7%E5%93%81%E7%90%86%E8%AE%BA/%E8%BF%90%E8%90%A5/%E8%BF%90%E8%90%A5%E7%AC%94%E8%AE%B0/1_%E8%BF%90%E8%90%A5%E5%9F%BA%E7%A1%80/","content":"互联网运营是为达到产品目标进行的一系列符合产品定位的行为总和\n运营的岗位和职责：\n\n编辑：文案撰写、话题策划、软文发布\n运营策划：数据为依据的产品运营、方案的策划\n活动营销：基于口碑、用户、营收等为目的的活动方案的营销、事件运营\n品牌运营\nPR：业界的PR传播\nBD、推广：合作需要、跨部门接触公司内销售、甚至外部客户对接的市场合作\n新媒体运营\n数据分析：数据是运营的灯塔\n\n按架构，运营一般这么分：\n\n基础运营：质量安全、渠道管理\n功能运营：用户运营、功能运营\n数据运营：数据分析和提升\n市场运营：对外合作、商务拓展\n商业营收：商业化营收\n营收运营：应用特权、营收体系\n\n按工作内容，运营一般分为：\n\n新媒体运营\n活动运营\n品牌运营\n数据运营\n运营推广\n用户运营\n\n运营在腾讯的职业通道和能力要求：\n运营是连接“客户”、“产品”和“商业”，首先需要找到核心的客户，然后通过我们的产品去解决他们现实生活中所存在的问题，从而达到我们商业挣钱的目的\n运营的价值：拉新、活跃、留存、获客、口碑，最重要的是成交\n运营的终极成长目标：\n运营方法论七种武器：\n\n目标：可量化、可落地\n有趣、共鸣\n产品、销售、客服\n四个阶段：启动、初级、快速增长、衰退\n做好一件事、做好一批事、带人一件事、带人一批事、开创新市场\n看、写、复制、动手、总结、创新\n用户、内容、数据、活动、渠道、生命周期、运营进阶\n\n定位：定位的核心就是占领心智定位四步法：\n\n分析外部环境\n避开竞争对手\n为用户提供一个信任的支点\n企业内部运营的方方面面\n\n","categories":["产品理论"],"tags":["运营-运营笔记"]},{"title":"新媒体运营","url":"/2023/05/31/%E4%BA%A7%E5%93%81%E7%90%86%E8%AE%BA/%E8%BF%90%E8%90%A5/%E8%BF%90%E8%90%A5%E7%AC%94%E8%AE%B0/2_%E6%96%B0%E5%AA%92%E4%BD%93%E8%BF%90%E8%90%A5/","content":"新媒体：比如说微信公众号、朋友圈、B站等\n新媒体运营是指基于新兴媒体所进行的运营活动，核心是通过向目标用户传达产品带来的核心价值，从而促进成交的一系列行为的总和。（传播、接触、转化、订单）\n微信公众号是获取资讯的重要途径：\n朋友圈：58%的用户每天都会使用朋友圈，其次是收发消息和公众号，分别占比为53.5%和39.8%\n新媒体运营的核心是什么（以微信公众号为例）？是内容，内容的核心是给谁看（目标用户是一切的根源，弄清目标用户）、看什么（内容是核心，搞清楚他们喜欢的内容点）、怎么看（通过什么样的形式展示更吸引人）\n加强内容中的行业属性，更能够加强该内容在某个特定行业传播的动力。如果能够带上一些行业特有的属性和恩怨情仇，则更甚之。比如产品经理与程序员的，设计师与产品经理的。\n朋友圈运营：有温度的人（基本属性：享受生活、工作属性：职业、特殊属性：个人品牌）通过朋友圈更具情感化的接触目标用户，从而占据他们的心智，达到运营目的\n如何开始一个新媒体的运营？以微信公众号为例\n\n定位\n数据分析\n输出方案\n逐步执行\n\n新媒体矩阵：\n\n权威：维护一个权威的高端号，站在行业的角度上呼风唤雨，打造影响力\n专业：偏向于自身产品的官方账号，用于给目标用户传递与定位相关的知识\n宽泛：泛新媒体号的掌控，更多的用来吸引流量，增加曝光\n\n少做地推（地面推广人员的简称，指针对以网吧、高校和社区为主要组成部分的各种地面市场资源，实地宣传来进行传播的一种市场营销推广人员），多做投票\n","categories":["产品理论"],"tags":["运营-运营笔记"]},{"title":"用户运营","url":"/2023/05/31/%E4%BA%A7%E5%93%81%E7%90%86%E8%AE%BA/%E8%BF%90%E8%90%A5/%E8%BF%90%E8%90%A5%E7%AC%94%E8%AE%B0/4_%E7%94%A8%E6%88%B7%E8%BF%90%E8%90%A5/","content":"用户运营的价值用户运营是以用户为中心而进行的达成产品目标的运营行为（目标用户）\n\n获客：拉新、留存、活跃\n商业化（赚钱）\n\n用户常见心理\n色欲\n虚荣：朋友圈\n偷窥：匿名功能\n傲慢\n妒忌\n暴怒\n懒惰：外卖\n贪婪：商品折扣\n贪食\n恐吓：安全需求是人最为基本的需求，生老病死是每个人都极为关注的（朋友圈转发一些健康文章）\n权威：影响力、法则之权威\n宣泄：更多的还是寻求一种共鸣，同时也是自我压力发泄的一种有效途径\n情感\n\n无论是内容运营、活动运营、软文公关、事件营销等核心的依旧是对用户的运营，所以对用户心理的把控是运营的关键\n我们或许真的可以把控用户的心理，但我们不能玩弄用户的心理，同时，永远记得初心！\n用户心理怎么用：\n\n定位\n场景\n有趣\n底线\n\n运营规划\n商业计划书\n\n找用户：产品与用户需求的匹配度\n找同行：他们是怎么做的？\n找投资人：他们是怎么看的？\n\n市场背景15分+市场机会15分+核心产品商业模式30分+项目战略10分+组织架构30分\n站在投资人的角度早期项目更看重创始团队\n如何快速拓展前一万个用户用户在哪儿？\n\n内部员工：精准、聚集、高效、可控、凝聚\n微博找人：精准、开放、互动、信任，微博拥有海量的用户，通过关键词可以很好的锁定目标用户群，加以日前的微博运营，可以快速获取第一批的核心用户\n抱大腿：用户量大、背书，与相关平台合作举办活动，搞清楚平台的需求，不要找平台市场部或者卖广告的部门合作，要找内部没有明显金钱kpi的部门合作，比如社区部\n找小腿：逆袭、成长\n线下推广：高效、互动、认同\n免费宣传：免费、品牌\n\n产品的核心价值点：这是每一款产品的核心，也是运营需要第一时间捕捉到的\n\n满足需求：解决痛点，满足需求\n差异化：无与伦比、独一无二\n免费\n视觉交互：逼格满满，用户体验\n\n挖掘运营点：\n\n满足需求：解决痛点，满足需求\n差异化：无与伦比、独一无二\n免费：免费的才是最贵的\n互惠：人情债永远还不完\n社会认同：大家好才是真的好\n权威：自愿服从\n稀缺\n\n用户是谁、精准场景、占领心智\n用户的活跃如何保持\n日常消费品类：养成习惯，心智绑定\n增值类产品：等级奖励、人文关怀、礼包奖品等\n内容社交类：达人UGC推送、编辑专题、标签用户推荐等\n游戏类：升级快、连续登录奖励多、关系链互动等\n电商类：细分人群运营（分析人群-&gt;营造场景气氛-&gt;迎合用户预期-&gt;聚集人群）\n\n业绩靠普通用户、帮手靠热心用户、口碑靠核心用户\n\n普通用户：运营提高、保持其活跃，减少流失\n热心用户：产品的粉丝，运营的智囊团\n核心用户：运营关系维护，关注领袖用户意见\n\n运营要培养用户的忠诚度，提高健康度、活跃度，充分挖掘其价值。判断标准：\n\n增值类&#x2F;游戏类产品：口碑用户、高ARPU、累计重复消费\n社交类产品：高度日活跃用户、产生大量UGC\n内容类产品：有关注度，有粉丝、创造原创内容\n\n\n","categories":["产品理论"],"tags":["运营-运营笔记"]},{"title":"活动运营","url":"/2023/05/31/%E4%BA%A7%E5%93%81%E7%90%86%E8%AE%BA/%E8%BF%90%E8%90%A5/%E8%BF%90%E8%90%A5%E7%AC%94%E8%AE%B0/5_%E6%B4%BB%E5%8A%A8%E8%BF%90%E8%90%A5/","content":"量化落地、多个方案、及时优化、复盘标准\n运营与产品密不可分，必须具备产品sense运营是润物细无声的过程，要带着产品目标和运营节奏来做\n活动运营概念解读活动运营是为了短时间内达成目标而开展的具有爆发性的运营手段，是互联网产品运营当中的重要运营手段\n活动运营是有节奏、有明确目的的运营手段，通过友好交互降低用户门槛，从而达成运营指标\n常见的运营活动形式\n拉新：拉新活动是针对用户量不够或新增用户量缺乏的情况，帮助产品注入新用户血液的活动类型，大多是在产品初期阶段。（常见形式：注册类、充值类、征集类）\n拉活跃：拉活跃活动是针对已经在产品内的用户进行活跃度拉动的活动（常见形式：竞赛类、限时类、任务类、签到类）\n拉回流：拉回流活动是针对流失用户召回的活动，在活动前需要了解用户流失的理由（常见形式：回归礼包、好友召回）\n拉收：拉收活动是为了增加收入而设计的活动，核心在于拉收的“度”（常见形式：刺激用户充值或返利、限时或限量刺激用户消费）\n品牌类：品牌类活动的主要目的是品牌或产品曝光、口碑和影响力（常见形式：线上轻量体验活动、线下发布会活动）\n\n活动运营的执行步骤\n活动预算运营的预算是指公司提供给运营人员的，期望通过运营的工作达成一定的产品目标，所愿意承担的费用\n活动会有哪些预算和支出：\n\n推广费（广告投放费、传播费用、渠道地推费）\n奖品采购费\n场地费\n播出费\n演出费\n现场物料费\n媒体费用\n工作人员费用\n执行公司费用\n备用金\n\n成本预算与活动运营的矛盾：\n活动策划活动策划最核心的思路：借势\n借势法则：\n\n借品牌的势\n借热点的势（热点运营的原则：时效性、用户、场景）\n借IP的势\n借节日的势\n\n活动策划第二个思路：根据目的思考\n活动策划怎么做：\n\n确定活动主题\n确定目标用户\n确定活动时间\n设计用户参与动机\n引导用户分享（用户主动分享的原因：对自己有好处、对身边的人有好处）\n\n活动策划中应该避免的问题：\n\n活动设计过于复杂\n活动体验与产品无关\n活动噱头大于或不符合实际\n活动缺乏创意和趣味性\n\n怎样写一份规范的活动策划文档：活动运营的推广节奏：\n活动执行过程中的坑\n无法按时上线\n协调各部门\nBUG\n\n监测数据的类型：\n\n流量来源数据\n页面数据（页面浏览数据、页面点击数据）页面浏览数据：\n后台结果数据\n\n风险管理和应急措施：\n\n活动原生风险（流量缺乏、体验不畅）\n底层风险（服务器崩溃、开发缺陷、奖品池超限）\n\n活动总结与复盘活动总结是活动的效果评估和经验沉淀，是活动运营步骤中的最终环节\n怎么写活动总结：\n活动复盘最早来源棋类术语，指对局完毕后复演记录，检查优劣得失。活动复盘是指对一场活动的执行过程反复回溯、解剖和分析，主动思考过程及产生原因，最终总结出一套经验方法\n如何做活动复盘：\n活动总结与活动复盘的不同：\n活动运营需要具备的技能\n善于沟通，表达清晰\n富有创造力和洞察力\n善于抓住热点营销\n对数据敏感，有归纳总结能力\n\n活动运营在运营工作中的价值\n短期爆发帮助产品达成某阶段的运营指标\n长期持续进行帮助产品维持健康的用户结构\n\n活动运营与其他运营手段的关系\n活动运营进阶高阶活动运营必备技能：\n\n系统和全局化思路\n活动运营三大进阶法宝（流量、用户心理、运营节奏感）\n活动运营两大进阶思路（活动产品化、产品活动化）\n\n活动运营进阶法宝之一：流量，常用的流量渠道：\n\n社交媒体渠道：微信朋友圈和公众号、微博粉丝通、社群（QQ群、微信群、百度贴吧、QQ空间、知乎，还有一些垂直类社区论坛）\n广告渠道：微信广告、视频网站广告、网盟广告\n传播渠道：传播通稿、明星代言\n\n如何0预算做一场活动：\n\n资源盘点（人、推广资源、合作伙伴、库存物料）\n活动玩法：周期短、体验平、见效快（玩法要有话题性，引发公众讨论的观点，PK、话题、传播、引爆；玩法要有引导性，不要过于复杂，逻辑简洁）有趣的线上活动玩法：\n文案的吸引力\n活动推广（用户积累）\n\n活动运营进阶法宝之二：用户心理，如何把握用户心理？\n用户心理：\n\n猎奇心理\n趣味心理\n游戏化心理\n从众心理\n攀比心理\n得失心理\n贪便宜心理\n贪心心理\n惰性\n成就感\n\n线上活动的奖品可以有哪些：\n\n实物奖励\n电子奖励\n体验式奖励\n\n奖品设置原则：\n\n合法抽奖式有奖销售：以偶然的方式决定是否中奖奖品金额如何判断：非现金或其他利益，以正常价格折算，超过5000元禁止，如有违反，可根据情节处1万元以上10万元以下的罚款\n预算：实物奖品成本高、电子礼品成本低或无需\n目标用户：奖品的选择要基于目标用户喜好的判断\n应用场景：要选择符合应用场景的奖品\n\n活动运营进阶法宝之三：运营节奏感\n\n运营成熟的标志\n一种有规律的进程\n对运营的掌控能力\n\n优秀的运营节奏满足的条件：\n\n有规律可循\n整体趋势向上，S型或J型\n\n节奏感是“做”出来的，通过有节奏的活动运营，驱动用户，从而为产品带来生命力\n产品不同时期节奏不同：\n\n初创期：补齐功能，运营节奏慢\n发展期：节奏加快，提高用户使用频率\n成熟期：节奏稳定，进入商业化阶段\n衰退期：节奏放慢，维持老用户\n\n高阶运营思路：\n\n活动产品化：将活动当成产品活动产品化的表现一：类产品设计活动产品化的表现二：结构化思维，让流程清晰化、事项具体化、内容模版化\n产品活动化：从产品功能出发的活动体验\n\n","categories":["产品理论"],"tags":["运营-运营笔记"]},{"title":"运营进阶","url":"/2023/05/31/%E4%BA%A7%E5%93%81%E7%90%86%E8%AE%BA/%E8%BF%90%E8%90%A5/%E8%BF%90%E8%90%A5%E7%AC%94%E8%AE%B0/7_%E8%BF%90%E8%90%A5%E8%BF%9B%E9%98%B6/","content":"基于产品生命周期的运营模型具备规划业务生命周期中不同阶段的运营工作的能力，了解高阶运营需要跟进的预算和品牌相关工作，掌握成长为高阶运营的秘籍\n如何选择一份运营工作了解自己的状态，并且不要忘记评估趋势：\n\n靠谱运营应当具备哪些特征：（当然还有一些每个岗位都实用的：用数据说话的能力、言出必行的意识、管理预期的意识，永远多追问为什么）\n\n系统的思维能力\n具备时间和空间的格局\n协调和多线程能力\n\n如何快速开始一份新运营工作找到业务的抓手，理清业务逻辑，开始做：\n如何识别业务当前所处的阶段识别当前业务所处阶段主要看什么指标：\n\n流量：流量大小（业务成长外观阶段）、流量构成（业务均衡成长的阶段）\n转化率：波动的因素、趋势（业务的机会与瓶颈）\n\n⭐️初生阶段、增长阶段（稳健增长、野蛮增长）、业务稳定阶段、原有主营业务流失阶段\n如何规划业务不同阶段的运营工作在每一个业务阶段会有不同的业务目标，运营应该围绕业务目标来进行规划工作\n产品发布流程中运营可以参与的工作：\n\n产品需求及开发阶段：产品使用流程校验、推广方案设计、AB方案设计、灰度方案设计、数据埋点、产品上线后目标预估\n灰度发布&#x2F;ABTEST阶段：分析数据、确认上线版本、确认上线功能、确认上线时间点、预估线上效果\n产品上线、线上数据监控、提炼需求点阶段：日常数据监控、建设风控机制、产品新版发布目标校准、反馈问题、搜集新数据特征\n\n预算管理工作：预算目标怎么设计？预算目标的设计其实就是业务目标的设计，在关注业务目标设计的同时，清楚对应目标所需要消耗的成本\n预算和目标的关系：\n品牌规划工作：品牌工作是怎么回事？\n品牌体系的根本逻辑：\n\n品牌内容：品牌定位（清楚自己到底是谁）、品牌属性（清楚自己是什么气质)\n品牌传播为什么有的品牌让你没有印象？品牌传播需要连续且一致，品牌传播需要组织多元化的方式\n\n品牌通过嗅觉（比如香水）、听觉、味觉、触觉传播\n品牌传播组织内容的三要素：\n\n传播的内容有不同类型，比如故事、新闻、产品等\n内容呈现的形式：图片、音频、视频、实体类产品、文字、交互体验等\n和用户接触的所有点有效结合\n\n运营工作中会遇到的那些坑初级运营要注意绕过这些坑：中级运营要注意绕过这些坑：高级运营容易踩的坑：\n","categories":["产品理论"],"tags":["运营-运营笔记"]},{"title":"产品面试题🔐","url":"/2024/05/05/%E4%BA%A7%E5%93%81%E7%90%86%E8%AE%BA/%E4%BA%A7%E5%93%81/%E4%BA%A7%E5%93%81%E9%9D%A2%E8%AF%95%E9%A2%98/1_%E4%BA%A7%E5%93%81%E9%9D%A2%E8%AF%95%E9%A2%98%F0%9F%94%90/","content":"\n冰山模型：是美国著名心理学家麦克利兰于1973年提出的一个著名的模型，将人员个体素质的不同表现形式划分为表面的“冰山以上部分”和深藏的“冰山以下部分”。其中，“冰山以上部分”包括知识、技能，是外在表现，是容易了解与测量的部分，相对而言也比较容易通过培训来改变和发展。而“冰山以下部分”包括角色定位、自我认知、价值观、品质和动机，是人内在的、难以测量的部分，它们不太容易通过外界的影响而得到改变，但却对人员的行为与表现起着关键性的作用。\n\n知识：指一个人对某特定领域的了解，如管理知识、财务知识、文学知识等。\n技能：指一个人能完成某项工作或任务所具备的能力，如表达能力、组织能力、决策能力、学习能力等。\n角色定位：指一个人对职业的预期，即一个人想要做些什么事情，如管理者、专家、教师等。\n自我认知：指一个人对自己的认识和看法，如自信心、乐观精神等。\n价值观：指一个人对事物是非、重要性、必要性等的价值取向，如合作精神、献身精神等。\n品质：指一个人一致、持续而稳定的行为特性，如正直、诚实、责任心等。\n动机：指一个人内在的自然而持续的想法和偏好驱动、引导和决定个人行动，如成就需求、人际交往需求等。\n\n\nHR问题：\n请做一下自我介绍？\n\n面试官您好，我叫廖家龙，软件工程专业，大学期间有两次实习经历和一次秋招经历，第一次实习是以iOS开发实习生的身份加入到墨墨背单词项目组，完成一些开发工作，在此期间接触到产品经理这一岗位，很感兴趣，实习结束后自学产品相关知识，然后作为产品实习生加入一家做元宇宙社交的公司，实习期间主要负责App的登录注册模块以及配合产品经理完成产品的需求调研、原型图绘制和产品迭代等任务。秋招时拿到了一家做电力线载波通信芯片的上市公司的产品经理offer，主要负责公司内部移动端管理平台，主要负责对接财务、人力、供应链、销售等部门的业务需求，协调开发排期上线。平常生活中，我的兴趣爱好是美食、阅读和电影，以上是我的自我介绍，谢谢。\n\n\n为什么想做产品经理？你的专业是软件工程，怎么会想到做产品的工作？\n\n你是如何学习产品的？\n\n列举一项最能体现你具有产品经理潜力的事情？\n\n跟其他人相比，你的产品优势是什么呢？体现在哪里？\n\n心态，我喜欢做有挑战的事情，而产品经理是对整个产品负责的人，每时每刻都在经受挑战。\n\n\n产品经理的工作流程是什么？\n\n市场&#x2F;竞品分析、需求挖掘、产品规划、结构设计、原型设计、PRD撰写、需求评审、交互视觉设计、交互视觉评审、开发、测试用例评审、测试、上线验收、灰度发布、效果评估\n流程中伴随着用户体验、项目管理、项目风险及沟通\n\n\n你期望的产品工作是怎样的，工作内容有哪些？\n\n你平时的工作日常是什么样的？\n\n如果你进入了公司，你准备如何度过试用期呢？\n\n产品方法论是什么？\n\n产品方法论是通过总结、抽象日常产品工作过程和细节，创建一套标准、系统、可复用的理论方法以解决特定产品问题。方法论本质是解决问题的工具，具备标准化、系统化和可复用性的特点。\n\n标准化能少走弯路，而标准的产品方法论不仅可以让我们按部就班的执行任务，还能提高工作效率和减少错误率。\n系统化可减少遗漏，帮助我们有序的展开思路，从而避免因考虑不周而导致问题遗漏。\n可复用性能提高效率，避免重复造轮子，提高解决问题的效率。\n\n\n\n如何理解产品经理？产品经理的核心价值是什么？产品经理将为什么结果负责？\n\n产品经理就是通过敏锐的用户洞察力和同理心挖掘出用户的核心痛点，通过沟通能力、项目管理能力等让项目团队将满足用户核心痛点的产品落地，最终让产品给公司带来收益。\n核心价值：做出一款满足用户核心痛点的产品，最终让产品给公司带来收益。\n\n\n你觉得产品经理需要哪些能力？最重要的能力是什么？\n\n产品经理就是通过敏锐的用户洞察力和同理心挖掘出用户的核心痛点，通过沟通能力、项目管理能力等让项目团队将满足用户核心痛点的产品落地，最终让产品给公司带来收益。\n所以产品经理需要敏锐的用户洞察力、同理心、沟通能力、项目管理能力和商业能力等。最重要的能力是敏锐的用户洞察力。\n\n\n什么样的产品经理是个好产品经理？\n\n器：过硬的产品技能；法：有属于自己的产品方法论；道：向内心深处探索。\n\n\n你未来3-5年的职业规划是什么样的？\n\n上家公司的离职原因是什么？\n\n是否接受加班，上家的加班情况如何？\n\n期望薪资是多少？上家呢？\n\n生活中遇到的最大困难是什么？是怎么解决的？\n\n平时最有成就感的事？最开心的事？最不能忍受的事？\n\n你最大的缺点是什么？最大的优点是什么？兴趣爱好是什么？\n\n你今天面试不怎么样，你还有什么要说的吗？\n\n你给本次面试打多少分？\n\n不要说出分数，要说自己是带着信心来的，也做了充足的准备，希望面试官指出不足，回去改正。\n\n\n从你的经历来看，你不适合我们的工作？\n\n目前有没有收到其他公司的offer？\n\n有\n\n\n我的问题问完了，你还有什么要问的吗？\n\n\n可以请您介绍一下公司的大致情况和正在做的项目吗？\n您对产品经理这个岗位是怎么理解的？\n\n\n\n\n项目问题：\nB端：鼎信管理平台\nC端：墨墨背单词、Project Z、蜗牛记账\n\n\n什么是元宇宙Metaverse？\n\n元宇宙是人类运用数字技术构建的，由现实世界映射或超越现实世界，可与现实世界交互的虚拟世界，具备新型社会体系的数字生活空间。元宇宙是具有高度沉浸感、虚实互动的数字世界，和现实世界一样，人们可以在里面社交、学习、娱乐、生活和工作，也可以理解为是一个独立但又和现实世界交融的平行数字世界。\n\n\n什么是ERP（Enterprise Resource Planning）？\n\nERP系统是企业资源计划系统，是以信息技术为基础，以企业的业务、生产、销售、采购、库存、物流、结算等全过程为对象，通过整合企业内外部所有的经营管理信息和资源，以实现企业资源的统一管理、协调控制和高效利用为目的的管理信息系统。\n\n\n什么是软件即服务SaaS？\n\n软件即服务SaaS是一种云计算解决方案，它使企业和个人能够通过Web浏览器或API使用软件应用程序，而不是在本地硬盘或服务器上安装软件。在SaaS模式中，第三方供应商在云平台的服务器上安装和管理应用程序，使基于Web的软件可供多个客户使用。云供应商负责维护、更新和保护软件，从而将内部IT团队从管理软件部署的例行任务中解放出来。\n优势：\n\n成本更低：企业可以避免为整个公司的服务器购买和安装软件系统，从而节省大量前期费用。\n可扩展性更出色：SaaS 等基于云的服务旨在提供近乎无限的可扩展性，使企业能够轻松应对新的机会和业务需求。\n可自动更新：企业可以依靠 SaaS 应用程序来确保他们的软件始终保持最新，而不是让 IT 团队来承担“不断更新和修补软件解决方案”这一重要而繁琐的任务。\n使用更高效：由于 SaaS 解决方案采用随用随付的模式，企业可以减少软件成本支出，消除浪费性支出和过度调配。\n支持移动工作团队：SaaS 可以轻松支持移动工作团队，允许员工通过互联网，使用任何设备随时随地访问他们需要的应用程序。\n访问更好的软件：SaaS 解决方案允许企业访问高度复杂的软件（如果没有 SaaS 解决方案，他们可能在经济上没有能力利用现有的 IT 资源来部署和管理此类软件）。\n正常运行时间更长：SaaS 公司在安全方面进行了大量投资，并针对正常运行时间和性能提供了出色的服务级别协议 (SLA)。\n部署速度更快：传统软件的采购和现场安装可能需要几天、几周或几个月的时间，而 SaaS 软件通常可以在几分钟或几小时内实施。\n成本可预测：借助 SaaS，IT 团队可以依靠每月可预测的价格（除非出现计划外的流量激增），而不需要划拨预算来进行定期升级，购买硬件来运行软件或安排内部 IT 人员来安装和维护应用程序。\n\n缺点：\n\n失去控制权：IT 团队可以自由选择或坚持使用首选的本地软件版本，而 SaaS 供应商通常会决定他们将向所有客户推出的 SaaS 软件版本。\n安全问题：由于 SaaS 解决方案中的数据不存储在本地，数据隐私和数据安全依赖于 SaaS 供应商的安全态势（这可能因供应商而异）。\n性能缓慢：由于 SaaS 解决方案依赖于互联网连接，中断或缓慢的互联网连接可能会影响应用程序的性能。\n供应商锁定：一旦客户采用了 SaaS 软件并将数据迁移到云端，更换供应商或采用其竞争对手的解决方案可能会很困难。\n影子IT：由于 SaaS 产品非常容易调配，用户往往会在企业的 IT 人员不知情的情况下采用这些产品，进而造成安全问题，使企业更容易受到威胁。\n\n\n\n蜗牛记账数据库？\n\n详细介绍一下你做过的项目？\n\nSTAR法则：\n\n情境situation：描述工作的背景，HR想知道你为什么会去做这件事？\n任务task：你当时的任务是什么？HR想知道你是怎样在上述情境下明确自己的任务的？\n行动action：你做了什么？为什么这么做？还有其他方案吗？\n结果result：结果怎么样？有没有完成目标呢？从你的行动中得到了什么？获得了哪些经验教训？之后有没有再用到这些经验教训呢？\n\n\n⭐️蜗牛记账是一款个人独立从0-1上架App Store的记账软件，做这个项目的原因是觉得从0-1做出来一款产品是一件很有挑战性的事情，并且在这一过程我可以同时巩固所学的产品和开发的知识。项目过程中我经历了产品上架的全过程，包括竞品分析、需求分析、产品规划、产品设计、产品研发、产品测试以及如何配置各种上架证书和文件。其中在竞品分析阶段选择随手记和鲨鱼记账作为竞品，需求分析阶段用两个星期的时间访谈了20位记账产品的用户，线上发放了600份调查问卷，手机整理了100条有效用户需求，产品规划阶段确定了“简约精致的记账app”的产品定位，产品设计阶段使用Azure 9进行原型图的绘制。最终完成了在App Store上架的目标。项目最大的收获是完整的经历了产品上架这一系列流程，其中也踩了不少坑，主要是在开发阶段，比如说代码写崩了以后无法回退，所以建了仓库进行版本控制，测试的时候打包流程重复且麻烦，所以搭建了Jenkins自动构建平台，最大的感受就是该踩的坑一个不少的都会踩，但是只要想办法去做，最终都会将困难解决掉。\n\n\n\n项目主要是做什么的？做了多久了？\n有什么样的竞品？和竞品的差异化&#x2F;区别在哪里？优势在哪里？劣势在哪里？\n市场规模有多大？占了多少份额？日活是多少？月活是多少？\n\n日活10w，月活一般是日活的3-5倍\n\n产品解决了用户哪些痛点？你们的产品需求主要来自于哪些地方？\n产品设计中有没有遇到一些无法解决的问题？\n设计阶段需要多久？原型图尺寸画多大？\n你负责前端还是后端，你们的后端是做什么的？\n产品有哪些模块？\n产品的核心业务流程是什么？核心功能有哪些？解决了什么问题？\n功能如何设计的？为什么增加这个功能？\n原型做到什么程度？有没有做交互？\n产品体验怎么做的？有没有产品体验师？\n运营搞了什么活动？\n产品迭代周期是多久？\n产品是怎么盈利的？商业模式是什么？一年收益多少钱？成交量是多少？客单价是多少？\n\n做过的项目中，每个项目最有收获的地方？每个项目的难点在哪里？哪些功能可以优化？产品的未来趋势如何？\n\n做过的最成功的项目？做过的最失败的项目？如果这个项目再让你做能否做的更好？\n\n你有什么失败的职业经历吗？你做过什么失败的项目吗？工作中遇到的最大困难&#x2F;挑战&#x2F;最大失败是什么？都是怎么解决的？\n\n你觉得你以前工作最有成就感&#x2F;最成功的一件事是什么？\n\n介绍下你公司的业务，你接触过最复杂的业务规则是什么，你是如何得到该信息的？\n\n说说你在工作中策划的功能和逻辑？说说你印象最深、引以为豪的产品设计方案，产出了什么成果，试着复盘当时的决策？\n\n你做了那么多功能，试着对做过的功能方案进行分类？\n\n\n产品问题：\n产品的一些名词？\n\nUI：用户界面\nUE&#x2F;UX：用户体验\nUCD：以用户为中心的设计\nUED：用户体验设计\nIXD&#x2F;IAD：交互设计\nGUI：图形用户界面，指采用图形方式显示的计算机操作用户界面\n\n\n如何0-1实现一款产品，讲一下过程？并且你认为其中最重要的五个点是什么？其中你遇到的最困难的一件事是什么？\n\n市场&#x2F;竞品分析、需求挖掘、产品规划、结构设计、原型设计、PRD撰写、需求评审、交互视觉设计、交互视觉评审、开发、测试用例评审、测试、上线验收、灰度发布、效果评估\n流程中伴随着用户体验、项目管理、项目风险及沟通\n\n我们产品对比市面上其他产品的优势在哪？\n产品定位：我们要做什么样的产品？我们的产品在用户心目中的形象是什么？\n核心用户：我们产品的核心用户是谁？满足了他们的什么需求？\n核心功能：产品的核心功能有哪些？\n商业模式：在满足用户需求的基础上，我们如何获取收益？\n\n蜗牛记账项目最困难的一件事情在于如何在开发时间、开发能力、开发人手有限的情况下满足用户庞大的产品需求。我采用MVP最小化可实行产品方法，用最快、最简明的方式建立一个可用的产品原型，通过这个最简单的原型来测试产品是否符合市场预期，并通过不断的快速迭代来修正产品，最终适应市场需求。\n\n如何确定最小mvp产品？\n\n你觉得B端产品设计过程需要注意什么？C端产品设计过程需要注意什么？\n\n如何快速了解一个行业？如何快速了解一个企业？如何快速熟悉企业业务？\n\n你是怎么做竞品分析的，竞品分析文档有哪些内容？你是怎么做市场分析的，市场分析文档有哪些内容？\n\n\n明确竞品分析的目的\n行业和市场分析\n行业背景相关信息：\nPEST：指宏观环境的分析，通过政治、经济、社会、技术这四个因素来分析企业所面临的状况。\n竞争态势：波特五力模型分析一个行业的基本竞争态势，竞争的五种主要来源，即供应商和购买者的讨价还价能力，潜在进入者的威胁，替代品的威胁，以及最后一点，来自在同一行业的公司间的竞争。\n产业地图：产业格局的结构化总览，产业地图可以获得行业运转规律（上下游关系、如何玩）、行业拆解、竞争环境。\n\n\n市场相关信息：市场所处阶段、市场规模、用户画像\n处理搜集的资料，得出结论\n\n\n确定竞品\n确定分析维度\n根据分析维度搜集数据，对比分析得出结论\n从自身产品出发分析之前的结论，最终得出总结论\n\n\n如何建立用户画像？如何进行用户特征分析？\n\n特征范围：用户年龄、性别、地区、学历、知识水平、家庭背景、个人成长环境、理性&#x2F;感性成分、操作习惯、消费能力等。\n\n\n你是怎么做需求分析的，需求分析文档有哪些内容？\n\n\n需求定义：需求是用户在一定场景下产生的某种欲望或解决某些问题的需要，分为用户需求、业务需求、产品需求。\n用户需求和业务需求都是产品需求的来源\n用户需求和业务需求分别满足用户和公司的基本诉求，但有时候这两者是冲突的（比如说穿插广告）\n产品需求就是一种解决方案\n\n\n需求挖掘\n自主分析法（头脑风暴）\n业务驱动法：解决老板、产品、运营、市场、技术、客服等公司其他人员的问题\n竞品追踪分析法\n用户研究分析法：定性研究、定量研究，比如用户反馈（App内的用户反馈意见、应用商店中用户的评价、核心用户群里的反馈）、用户访谈、可用性测试、调查问卷等\n数据分析法：通过对数据进行分析，找到引起数据波动的原因，发现需求\n\n\n需求管理\n区分真伪需求：没有绝对的真伪需求的分界线，重点是理解我们的目标用户的真实诉求，结合场景和时机综合判断需求是否在当下为真需求\n需求优先级\n形成需求池，定期更新和复盘\n\n\n\n\n如何将用户需求转化为产品需求？\n\n\n搜集完用户需求后，分析用户背后真正的诉求，比如用户想要一匹跑得快的马，他的真正诉求是快而不是马，找出更好的解决方案。\n站在自身产品的角度来分析这个需求在当前情境下是真需求还是伪需求，这个需求在当前版本要不要做。\n产品团队内部审核讨论。\n\n\n怎么搜集需求的？产品的需求来源有哪些？\n如何做满意度调查？\nB端怎么做业务调研？C端怎么做用户调研的？\n如何挖掘到用户的真正痛点？\n怎么做用户访谈的？\n\n\n明确访谈目标\n围绕目标设置访谈提纲\n根据目标邀约用户\n行业资深用户：深度了解你产品所在行业的各类产品的人\n核心用户：能带来资源、现金流，能够给你带来更多用户的人\n低频用户：用你的产品但是不经常用的人\n流失用户：曾经用过你的产品但现在已经不用的人\n边缘用户：指未使用你的产品而使用其他类似服务的人\n非用户：指完全不使用此类产品的用户\n\n\n访谈过程\n访谈总结\n\n\n怎么做可用性测试的？\n\n可用性测试是用来评估产品或系统的一种方法，让一群具有代表性的用户对产品进行典型操作，同时观察员和开发人员在一旁观察，聆听，记录。目的是为了发现用户真实使用情况中遇到的问题，来提升产品的可用性，同时发现优化需求。\n\n怎么做调查问卷的？\n\n\n明确目标\n问卷设计\n问卷投放\n回收分析\n输出结论\n\n\n怎么做需求管理的？\n如何评估与分析需求是否可做？如何辨别真伪需求？\n\n分为前期判断和后期验证的方式。\n\n前期判断：根据自身经验、市场调研、网上搜集资料、调查问卷的结果结合产品自身情况进行评估。\n后期验证：用户反馈（App内的用户反馈意见、应用商店中用户的评价、核心用户群里的反馈）、用户访谈、调查问卷、数据埋点（了解用户对某个按钮的点击次数、在某个页面的停留时长去判断用户是否喜欢该功能）等。\n\n\n如何划分需求的优先级？\n\n\n企业层面：分为公司战略和产品当前所处的生命周期\n初始期：培养市场，优先做一些基础功能和特色功能的需求\n成长期：扩张市场，优先做一些增加产品品类、保证产品服务质量的需求\n成熟期：保持市场占有率，优先做一些打磨产品功能的需求\n衰退期：提高生产效率、降低成本，优先做一些剔除产品短板，拓展产品方向，产品创新的需求\n\n\n用户层面：使用紧急重要四象限\n用户量越大、频次越高或满意度越低的需求则优先级更高\n优先满足大部分用户的诉求，尤其是核心用户的诉求\n涉及影响可用性的需求，优先级更高\n\n\n技术层面：技术实现难度、投入人力成本、投入资金成本等\n\n总结：公司战略、核心功能、拉新促活、交互优化、提升运营效率，优先级是逐渐递减的\n\n产品的生命周期是什么？如何完成产品生命周期的管理？\n\n你是怎么做产品规划的？\n\n\n产品定位：产品定位是指确定某产品在消费者或用户心目中的形象和地位，即通过塑造产品或企业的鲜明个性或特色，树立产品在市场上的形象，从而使市场上的目标用户了解和认识本企业的产品。\n\n我们要做什么样的产品？我们的产品在用户心目中的形象是什么？\n我们产品的核心用户是谁？满足了他们的什么需求？\n我们产品对比市面上其他产品的优势在哪？\n\n\n蓝图\n\n节奏Roadmap：每个目标分解为几个阶段？每个阶段的行动点是哪些？（时间周期、项目事件、路标）\n\n目标：目标的SMART原则：具体的、可衡量的、可达到的、与其他目标具有相关性、有明确截止期限。最终量化成具体的目标和数字（产品四大指标：用户体验、业务指标、财务指标、技术难度）。\n\nSMART原则：SMART目标管理原则是一种常用的目标管理方法，通过采用SMART原则，可以帮助组织和个人设定具体的、可衡量的、可达到的、与其他目标具有相关性、有明确截止期限的目标，并且更容易跟踪和评估进度，最终实现目标。\n\nS（Specific）：明确目标。目标要具体、明确、不能太抽象。\nM（Measurable）：可测量目标。目标要具有可测量性，可以用数量或比例来衡量。\nA（Achievable）：可实现目标。目标要具有可实现性，需要考虑到资源和能力的限制。\nR（Relevant）：相关性目标。目标要与组织或个人的目标相关，与业务或组织的战略相一致。\nT（Time-bound）：时限性目标。目标要有明确的时间表，并在规定时间内完成。\n\n\n\n\n\n什么是产品定位？\n怎么做产品roadmap？\n\n为什么要做产品规划？\n\n\n目标聚焦，团队达成共识（接下来解决什么问题？）\n路径清晰（分几个阶段？先做什么？再做什么？什么时候做？）\n价值显性化，资源支持，更容易拿到结果\n提升团队价值感、向心力和团队士气，让每个人以后都有故事可讲\n提升思考力，向上进阶必备（系统思考、学会选择、做正确的事比正确的做事更重要）\n\n\n\n请描述一个完整的产品规划方案包括哪些部分？\n\n详细的需求分析文档\n风险评估分析、可行性分析、时间规划、资源需求分析\n各个部门配合流程、方式、分工安排\n开发、推广资源诉求文档\n运营、推广方案、市场销售方案\n\n\n如何进行产品架构的设计？讲一下你自己产品的产品架构？\n\n\n\n产品架构设计是产品设计的最顶层，它描述了整个产品运作的架构原理，告诉我们各个产品单元之间是怎么进行运作的。\n\n人性法（产品设计中常被利用的人性弱点）\n任性：用拼多多的人如果买一样东西比别人便宜她会感到满足，实际她也不缺这点便宜的钱，满足了用户的任性心里，证明她会买东西（产品战略转型，就是对用户心智的改变）\n恐惧：利用恐惧（得到App，天天宣传不学习就会淘汰）、消除恐惧（淘宝的物流信息，用户可以实时查看快递进度）、（喜欢确定感）\n懒惰：比如说用户想在App上买西瓜，打开App后出现了智能推荐猜你喜欢，用户可能就看中了推荐上的葡萄，懒得买西瓜了（喜欢简单的事物）\n虚荣：朋友圈（喜欢展示自己、喜欢被关注）\n贪婪：理财、陌陌（喜欢美好的事物）\n从众：买家秀卖家秀（被大众影响）\n\n\n映射法：互联网最大的价值和魅力在于，它让人们在虚拟世界中模拟各种各样现实生活场景，并使这些生活变得更加便捷、有趣（在线购物也有购物车、收银台）。\n参考法：腾讯（一直在模仿，从未被超越），模仿不等于抄袭，接地气微创新。\n\n\n\n常见的产品结构？\n\n产品结构是基于前期的需求分析以及市场竞品分析等为依据，将各个需求点以某种逻辑系统化的组织起来所形成的立体结构，基于该结构，可以顺利的引导用户行为或将各类信息进行顺畅的流转。\n\n不同的结构，代表了你产品未来的扩展性和扩展方向（比如快手和抖音仅仅从用户发现内容这一层，结构上就有很大的不同，抖音是沉入式，快手是寻找式）。\n用户了解产品的第一印象，结构决定用户对产品理解的难易程度\n\n\n线性结构：如同看电影一般，一个场景向一个场景推进，引导用户跟着走，目的性较强（注册登录）\n层级结构：结构清晰易懂、有较高的操作效率、扩展性强（苹果官网顶部导航引导用户快速的去想要去的地方）\n矩阵结构：可以同时满足不同用户，承载的信息更多，展示效率更高（PC端的携程网页）\n自然结构：鼓励人们探索，提高产品趣味性，常见在游戏、资讯等类型产品（抖音）\n\n\n\n交互设计中会遵守哪些原则？\n\n\n用户心理：同时努力平衡用户需求、商业发展目标和科技发展水平之间的关系\n操作可预期\n状态可感知：比如说点击播放视频，提示播放视频需要多少流量；或者角标提示有多少未读消息\n单一任务，逐次呈现：线性结构，单一任务的方式有利于用户在有限的屏幕上一次只关心并解决一件事情（注册、问卷调查等可用）\n阻断与非阻断式的平衡：比如说卸载360需要很繁杂的步骤\n一致性：在一个&#x2F;类产品内部，在功能相同或相似的场景上，应尽量使用表现、操作、感受等相一致的设计\n展示原则：页面选择元素不要超过5个，Less is more\n\n\n\n安卓设计规范？苹果设计规范？小程序设计规范？Web设计规范？\n\n你掌握哪些产品经理工具？\n\n列举移动设计中常用的导航方法？\n\n\n标签式导航：最常用、最不易出错，请第一时间考虑它\n底部tab式导航\n顶部tab式导航\n底部tab的扩展导航\n\n\n抽屉式导航：如果你的信息层级繁多，可以考虑将辅助类内容放在抽屉中\n列表式导航：作为辅助导航来展示二级甚至更深层级的内容，每个App必不可少，但请注意数量与分类\n平铺式导航：如果你的内容是随意浏览，无需来回跳转的，可以考虑它。\n宫格式导航：不建议在App中作为主导航使用，如果非使用不可，请增加跳转的关联性\n悬浮icon导航：更适应大屏的导航模式，不妨试一试，但注意不要让它遮挡住某些页面的操作\n\n\n\n你的PRD文档有哪些内容？用什么工具写的？你觉得好的PRD文档是怎么样的？有没有作品可以看看？\n\n\n需求背景：让项目参与者明白为什么启动该项目\n项目目标：让项目参与者共识目标，找到价值感；目标尽可能量化；上线后验证目标达成情况的依据\n修订记录：修订日期、修订人、修订说明、修订原因、修订文档版本号\n功能列表：拆分成最小的功能点；功能点之间相互独立；方便参与者理解需求，评估工作量\n逻辑展示（流程图）：弥补与程序员的思维差异、帮助自己梳理思路、避免需求遗漏考虑不周\n单角色流程图：基本流程图\n多角色流程图：泳道图、跨职能流程图\n\n\n详细描述：正常逻辑描述、不同状态逻辑描述、异常逻辑描述、边界情况（一般指输入和输出的边界）\n数据需求（如果没有BI支持，需要产品经理自己定义埋点事件，不同的数据统计工具，不同的埋点规范）\n数据需求的采集标准：理论上所有用户端新增功能都需要采集、改动&#x2F;优化点需要进行前后数据对比、版本的核心数据指标\n数据采集的类型：基础数据、交互数据、用户路径\n业务数据是通过服务端存库完成的；用户行为数据是通过前端埋点实现的\n\n\n风控说明或性能需求：可能出现的风险点和策略\n\n\n产品经理如何进行版本管理？\n画一个原型需要多久？写一篇PRD文档需要多久？\n为什么要写PRD文档？你写的PRD文档开发人员会看吗？\n\nBRD：商业需求文档，给老板、CEO、项目总负责人看，他们需要了解：要做什么样的产品、需要什么样的资源、最终做成什么样？\nMRD：市场需求文档，给商务、市场、运营看，他们需要了解：我们要找什么样的客户进行资源合作、找到客户后我们该怎么和他们说、产品针对什么样的用户群体？\nPRD：产品需求文档，是通过文字的形式将产品的需求特性与逻辑描述出来。核心就是以表达为目的，让查看的人清晰易懂。交互设计、视觉设计、项目经理、开发、测试、其它产品经理、其它需要了解业务逻辑的人都会看。\n\n准确、直观、完整传达产品需求\n保证各角色沟通有依据\n保证产品质量控制有标准\n存档\n\n\n\n需求评审会怎么做的？一周几次？什么阶段会开需求评审会？有遇到过哪些问题？\n\n\n需求内审：评定需求可行性，评定需求优先级\n需求评审：todo list（做什么？为什么要做这些？）、基本交互原型\n小技巧：提前找负责该模块的开发及leader沟通思路\n\n\n\n\n\n项目是怎么排期的？你如何参与整个项目开发的？涉及什么流程？\n\n\n需求评审会后，开发leader将对应每个需求所需的人&#x2F;日同步到产品\n产品经理适度评估时间的准确性，有预留风险的预判\n\n\n\n版本的验收标准是怎样的？\n\n按照需求文档来验收\n\n确保产品的基本功能与需求是一致的，无核心问题的。\n确保产品的交互及UI符合设计要求。\n\n\n多久进行一次版本更新？你的迭代经验有多少？在迭代经验中新旧功能的占比是多少？项目的最多迭代频率是多少呢？\n\n验收不通过怎么办？\n\n\n如果是严重级别Bug，且是核心功能或流程，不可发布\n如果Bug较多，且有严重级别的Bug，需要根据出现场景及频率来判断\n如果Bug较多，但没有严重级别的Bug，且版本的功能重要，可发布，但需尽快发布修复版本\n\n\n\n上家公司的团队构成如何？你在上家公司的角色是？你与团队是怎么配合的呢？\n\n你平时是怎么和技术沟通的？与测试如何沟通的？与UI如何沟通的？与运营如何沟通的？\n\n举一个例子说明你的沟通能力？\n\n有没有与同事发生过矛盾？有矛盾怎么解决？\n\n如果开发不愿意做需求或者与你有分歧，你要怎么处理？\n\n如果老板和你产生分歧，不支持你提的需求，你该怎么办？\n\n首先我先阐述我的观点，尝试用数据事实去说服，若已表明自己的观点，老板也理解但并没有接受，尝试理解老板的思路，不一定自己就是对的，在理解完老板的思路后，看能否找到第三种方案既能满足老板又能满足自己的需求，很多时候产生分歧是缺乏沟通。\n\n\n遇到不可沟通的人怎么办？\n\n我会用数据分析来证明我的观点，以数据服人。\n\n\n如何保证产品按期上线？项目进度与计划不一致如何解决？\n\n主动报告项目的进度，随时将项目进度调整内容发布出来以及调整的原因。\n\n\n如果产品开发过程中有一个需求导致项目延期，怎么办？\n\n一般来说是开发人员没有料想到这个问题这么难解决，没有预留足够时间导致延期。这个时候需要判断该问题是否会影响产品核心功能，若评估后没有影响则可以在下个版本再上线，作为遗留问题记录，同时发邮件汇报给老板说明情况。若会影响到核心功能，则与开发主管商讨是否有替代方案马上上线，若无替代方案，将情况汇报给老板定夺，若延期上线，需要研发给出最终解决的时间节点并延期上线。\n\n\n如果现在有一个产品的重大故障，你会怎么处理？\n\n如果遇到开发页面与实际页面相差较大，你如何解决？假设仅差1px，你觉得有必要较真吗？\n\n项目管理中，遇到项目风险如何处理？\n\n你会如何组织复盘会议？\n\n你是怎么做用户体验的？\n\n用户体验是用户在接触产品及服务过程中建立起来的一种纯主观感受\n\n认知过程中的体验\n名称：为什么互联网公司起名喜欢用动物、植物和叠词？\nSlogan：品牌认知Slogan应该具有的功能有且只有一个：传递企业或者产品关于精神、理念、品味等方面的感知，所以其很少改变，而且变化多伴随着整体战略的调整。\n包装：你有没有仅仅因为颜值而冲动下单的经历？\n气质：品牌的特异功能：人格化，建立产品与目标用户的情感和认知连接，做人做产品，都得“有个性”（真诚、教养、强韧、能力、刺激）\n场景（网易考拉的快递员关怀行动）\n\n\n使用过程中的体验\n交互设计：尼尔森十大交互设计原则\n状态可见：系统应该让用户时刻清楚当前发生了什么事情，也就是快速的让用户了解自己处于何种状态、对过去发生、当前目标、以及对未来去向有所了解（苹果电脑磁吸充电器亮灯）\n环境贴切：软件系统应该使用用户熟悉的语言、文字、语句，或者其他用户熟悉的概念，而非系统语言\n用户可控：用户常常会误触到某些功能，我们应该让用户可以方便的退出或降低误触的概率（笔记废纸篓）\n一致性：结构一致性、色彩一致性、操作一致性、反馈一致性、文字一致性\n防错：是在一个错误发生之前就避免它（微信朋友圈退出编辑时提示保留、携程订票选择日期不可选择当日之前的）\n易取：通过把组件、按钮及选项可见化，来降低用户的记忆负荷（鼠标移动到某个按钮上会有说明文字，减少用户记忆）\n灵活高效：允许用户定制常用功能\n优美简约：对话中的内容应该去除不相关的信息或几乎不需要的信息\n容错：错误信息应该使用简洁的文字（不要用代码），指出错误是什么，并给出解决建议\n人性化帮助：根据场景透出帮助渠道或内容（淘宝客服）\n\n\n视觉设计：视觉设计4个原则：\n亲密：将彼此相关联的项，在空间的角度上更靠近些\n对齐：根本目的是使页面统一而且有条理\n重复：目的是统一，并增强视觉效果，但要避免过多的重复一个元素，让人感觉不太舒服\n对比：可以通过字体选择、线宽、颜色、形状等来增加对比，重要的是对比一定要强烈\n\n\n文案\n一致性规范：词汇一致、句式一致、行动点与目的页面标题一致、时间表达规范、数字一致性规范、标点一致性规范\n准确性规范：用词准确、不累赘、不缺失、不模糊\n懂用户：从用户视角描述价值、正确使用人称代词、让用户听得懂、告诉用户Why not\n\n\n\n\n服务过程中的体验：主要是客服，要及时回复\n\n\n\n如何制定产品的KPI和运营的KPI？\n\n如何看产品功能上线后的效果？产品上线后关注哪些指标？\n\n\n产品上线后，运营通过渠道投放让用户接触到产品，通常用户会经历如下过程：渠道曝光、应用下载、新用户注册、注册成功成为真正的用户。\n\n拉新指标：\n\n曝光量&#x2F;浏览量：指产品的推广信息在朋友圈、搜索引擎、应用商店等渠道被多少用户看到\n点击量：指用户看到推广信息后，点击进入广告进一步了解产品信息\nCTR：点击量&#x2F;浏览量，很多广告平台会用CTR来评估广告质量\n下载量：指的是App的安装次数，是衡量拉新效果的结果指标\n新增用户：下载并不是意味着就是用户，如果某个“用户”只下载了并没有注册，那它就是一个无效的用户，对于用户的界定，每个产品是不一样的，大部分的产品是用户注册了App就被定义为用户了\n获客成本：CPM（千次曝光成本）、CPC（单次点击成本）、CPA（单次获客成本）\n\n活跃指标：\n\n活跃用户数：DAU（24小时内去重后活跃用户数）、WAU（周活跃）、MAU（月活跃）\n活跃率：DAU&#x2F;注册用户总数，活跃用户数衡量的是产品的市场体量，活跃率看的则是产品的健康\n在线时长：指用户访问产品并停留于产品界面所花费的时间，研究一款App的活跃健康度就需要去研究在线时长（它是视频类网站的核心数据指标）\n启动次数：指用户在固定时间段内启动产品的次数，也就是产品的使用频率，用户的日均启动次数越多，说明用户对产品的依赖性越高\nPV页面浏览量\nUV是一定时间内访问网页的人数\n\n留存指标：\n\n留存用户：指用户在某段时间内使用产品后，过了一段时间后，仍旧继续使用的用户\n留存率（次日留存率、7日留存率、30日留存率）：目前留存的用户数量&#x2F;当初新增的用户数量（假设某产品某天在某渠道新增了用户1000个，第二天仍旧登陆产品的用户有350个，第七天仍旧登陆产品的用户有100个，那么这个渠道获取来的用户次日留存率为35%，7日留存率为10%）\n流失率：与留存率相反，流失率在一定程度上能预测产品的发展，如果产品某阶段有用户10万，月流失率为20%，简单预测5个月后产品将失去所有的用户。\n生命周期：（1&#x2F;流失率）*流失率的时间维度，比如产品的周流失率为50%，那么平均用户生命周期为14天。\n\n交易类产品转化指标（淘宝、京东）：\n\nGMV：只要用户下单，生成订单号，便可以算在GMV里，不管用户是否真的购买了\n成交额：指的是用户付款的实际流水，是用户购买后的消费金额\n销售收入：成交金额-退款金额\n付费用户量（首单用户、忠诚消费用户、流失消费用户）：在产品里面产生过交易行为的用户总量\n付费用户比例：付费用户量&#x2F;总注册用户\nARPU：在单个促销活动中，它指的是每一笔用户订单的收入，ARPU&#x3D;总收入&#x2F;订单数；在整个产品生命周期中更关注用户平均付费，ARPU&#x3D;总收入&#x2F;用户数；当普通用户占比太多，往往还会采用每付费用户平均收入：ARPU&#x3D;总收入&#x2F;收费用户数\n复购率：单位时间内，消费两次以上的用户数占购买总用户数的比例\n\n社区类产品转化指标（知乎、豆瓣、小红书）：社区类产品的首要目的是将用户聚集在一起，并且引入用户生产内容，它的核心关键在于培养一个能够生成内容的活跃用户社区。\n\n内容生成者：参与内容生成的用户总量，我们以内容生产比例（内容生成者&#x2F;用户总量）来衡量一个社区的内容生成健康度\n内容互动者：指在产品中有生成内容、阅读内容、评论、分享、收藏、投票等任一行为的用户总量，我们以内容互动比例（内容互动者&#x2F;总用户量）来衡量整个产品的用户参与度\n内容价值：指通过内容产生的实际收入（广告收入、分成收入、订阅付费等）\n\n企业类产品转化指标（印象笔记）：目前大部分企业型产品会通过免费试用来吸引用户，通过后续的运营来将试用用户转化为付费用户。\n\n体验用户量：申请体验企业服务的用户总量，我们通常以体验率（体验用户量&#x2F;用户量）来衡量产品的包装吸引力\n付费用户量：对于企业服务类产品来说，最需要非常关注的是有多少免费用户最终成为了付费用户，我们需要以转化率（付费用户总量&#x2F;体验用户总量）来衡量产品的市场匹配度\n追加销售量：有多少人升级到了更贵的服务级别，我们需要以追加销售比例（总追加销售用户&#x2F;总付费用户）来衡量产品的售后服务能力\n平均客户营收&#x2F;平均客单价：单位时间内平均每位客户带来的营收（销售额&#x2F;付费用户）\n客户终身价值CLV：客户使用产品过程中的付费总额\n\n传播指标：现在产品都会内嵌分享功能，对内容型平台或者依赖传播做增长的产品，对病毒式增长的衡量就会变的至关重要。\n\n邀请率：发出的邀请数&#x2F;现有用户数\n邀请的接受率：新注册数或新用户数&#x2F;总邀请数\n病毒K因子：现有用户能够成功获取的新用户数，邀请率*邀请的接受率&#x3D;新注册数或新用户数&#x2F;现有用户数，当K因子大于1时，每位用户至少能带来一个新用户，用户量会像滚雪球般变大，最终达成自传播，当K因子足够大时，就是快口相传的病毒营销\n在一个社群裂变活动中，有2000名用户对外发出了500次邀请，其中有1000人进入了社群。现有用户数：2000，发出的邀请数：500，邀请率：500&#x2F;2000&#x3D;25%，进群人数：1000，接受率：1000&#x2F;500&#x3D;2，病毒K因子：25%*2&#x3D;50%\n\n\n病毒传播周期：用户从传播到转化新用户所需要的时间，通常传播周期越短意味着用户裂变传播的效果越好\n\n\nB端用哪些数据向你的客户推销你的产品？\n\n产品数据是如何收集的？你是怎么做数据分析的？\n\n埋点（比如漏斗模型）：在需要统计数据的地方植入代码，统计用户的关键行为并接入第三方统计工具。\n\n\n第三方统计工具：友盟、神策、Talkingdata、GrowingIO等。\n\n\n你懂运营吗？\n\n黑客增长模型：用户增长是一套系统化的动作\nAARRR：获取用户、活跃、留存、收入、自传播\nRARRA：留存、活跃、自传播、收入、获取用户\nAARRR已经过时了，现在流行RARRA，因为用户越来越缺乏耐心，和用户接触的第一个瞬间就要想办法留存他，而不是想办法获取他（“标题党”就是典型的先获取用户，所以他现在行不通了）。\n\n\n如何制定定价策略？互联网常见的商业模式？\n\n\n实物商品的商业模式\n自己直接生产，自己直接销售给用户\n把生产环节外包出去，自己负责销售给用户\n自己负责生产，交给分销商销售\n自己作为分销商，或者提供销售商品的交易市场（亚马逊、京东）\n\n\n广告模式\n展示广告：一般形式是文字、banner图片、通栏横幅、文本链接、弹窗等，通常是按展示的位置和时间收费，也就是我们所说的包月广告或包天、包周广告。\n广告联盟：广告联盟相当于是互联网形式的广告代理商，广告主在广告联盟上发布广告，广告联盟再把广告推送到各个网站或App里去。百度联盟、Google AdSense是最大的两个广告联盟。基本上网站流量还没有到一定程度时，都会选择跟广告联盟合作，只有做到一定流量后，才会跟确定的广告主直接建立合作关系。广告联盟一般是按广告的点击次数收费。\n电商广告：最常见的就是阿里妈妈了，京东、亚马逊、当当都有自己的电商广告，凡客当年也是靠这个突然窜红的。这些广告一般是按销售额提成付费。很多导购网站，就是完全靠这种收入的，特别是海淘导购网站，会接入各个海外购物网站的广告，佣金还挺不错。\n软文：是指把广告内容和文章内容完美结合在一起，让用户在阅读文章时，既得到了他想需要的内容，也了解了广告的内容。很多媒体网站或者微博、微信大号，都是靠软文赚钱的。\n虚拟产品换广告效果：为用户提供虚拟产品，但是代价是用户必须接受一定的广告，比如看完一段广告就可以复活。\n\n\n交易平台模式\n实物交易平台：用户在你的平台上进行商品交易，通过你的平台支付，你从中收取佣金。\n服务交易平台：用户在你的平台上提供和接受服务，通过你的平台支付，你从中收取佣金。\n沉淀资金模式：用户在你的平台上留存有资金，你可以用这些沉淀的资金赚取投资收益回报。\n\n\n直接向用户收费模式\n定期付费：买了爱奇艺的VIP用户，在一段时间内所有会员免费的电影都可以看，这是定期付费。\n按需付费：爱奇艺里看到想看的某一部电影，花5块钱只看这一部，这是按需付费。\n打印机模式：是指先以很便宜的价格卖给消费者一个基础性设备，比如打印机，用户要使用这个设备，就必须以相对较高的价格继续购买其他配件，比如耗材。（比如Switch）\n\n\n免费增值模式：这一模式就是让一部分用户免费使用产品，而另外一部分用户购买增值服务，通过付费增值服务赚回成本和利润。不过通常采取免费增值模式的产品，可能只有0.5%-1%的免费用户会转化为付费用户。\n限定次数免费使用：这种模式是在一定次数之内用户可以免费使用，超出这个次数的就需要付费了。\n限定人数免费使用：这种模式是指用户数量在一定人数之内就是免费的，如果用户数量超出这个限定额就要收费了。比如很多企业邮箱服务，如果你的公司注册了某个域名，打算用这个域名做你的企业邮箱，企业邮箱服务商可以要求，5个以内邮箱地址免费，超过5个邮箱地址就要购买他们的服务。\n限定免费用户可使用的功能：免费用户只能使用少数几种功能，如果想使用所有功能，就得付费。\n核心功能免费，其他功能收费：一个产品分为免费版和收费版，免费版里基本功能都有了，但是要获得更多的功能就要收费。（比如照片滤镜功能）\n核心功能免费，同时导流到其他付费服务：比如微信，微信聊天是免费的，但是微信内置了很多其他服务，游戏、支付、京东、滴滴打车，这些服务都有可能是收费的。\n应用内购买：应用的下载和安装是免费的，但是在使用的过程中，可以为特定的功能付费。（游戏）\n下载和安装收费，应用内免费\n试用期免费：让用户在最初一定的期限内可以免费使用，超过试用期之后就要付费了。\n组织活动：通过免费服务聚齐人气，然后组织各种下线活动，这些活动可以获得广告或赞助，或者在活动中销售商品或服务。比如很多媒体通过组织线下行业峰会赚钱。还有的地方社区会组织线下展销会、推荐会，比如装修展销会、婚纱摄影秀等，销售商品或服务。\n\n\n\n\n\n产品和运营的区别是什么？\n\nB端产品和C端产品的区别？B端产品的价值？C端产品的价值？\n\n\nC端产品的中的关键词是“用户自己”，用户在使用一个C端产品时，例如抖音、高德等；这些C端软件满足了用户某一方面的核心需求，用户自己使用即可满足需求，不需要和其他用户进行协作进行。\nB端产品（CRM、ERP、OA等）中的关键词是“连接”，B端产品服务于特定的组织，B端产品要解决部门内外、各层级间的信息流转需求，用户在这一组织中并不是独立的存在，必须和他人进行协作才能完成某一项或者某几项事情的处理；这时，用户就跟他人产生了连接。\n\n从用户侧来说：\n\n使用人群：B端产品面向组织内部人员，C端产品面向普通用户\n个人诉求和使用者特点：B端产品用户关心能否高效便捷的完成工作任务，以工作需求为主，专家型用户居多；C端产品用户关心是否能解决自身的某个需求，以社交、娱乐等个性化需求为主，新手型用户居多。\n使用流程：B端产品单流程多人参与，比如一条流程多人审批；C端产品单流程单人参与。\n交互视觉：B端产品更注重品牌的塑造，更注重业务功能，效率优先；C端产品以用户为主，个性化更强，用户群体的喜好更明显。\n用户量级：B端产品的用户量级在几千、几万；C端产品用户量级可达到几十万、几千万甚至上亿。\n决策权：B端产品的决策权一般在客户手中，但客户不一定是B端产品的用户，这就需要产品经理去权衡使用者和决策者的需求；C端产品的使用决策权在用户手中，大部分会照顾用户的体验，更注重商业模式和用户体验之间的平衡。\n\n从场景侧来说：\n\n什么场景用：B端产品多为办公场景用，长时间专注使用；C端产品几乎不受使用场景的限制。\n使用设备：B端产品以PC端为主；C端产品以移动端为主。\n\n从业务侧来说：\n\n竞品数量：B端产品竞品数量相对较少；C端产品竞品几乎随处可见，数量较多。\n业务复杂程度：B端业务复杂，专业词汇多，需要对业务进行更深的理解；C端业务相对简单，专业词汇少。\n核心特点&#x2F;驱动方式：B端产品以完成业务目标、提升组织效率为核心，在功能和体验进行权衡时，B类往往是要用户牺牲体验去适应功能，而不会为了体验去删改功能；C端产品以用户体验为核心。\n权限：B端产品有着复杂的权限系统，大部分用户都只能使用系统的一部分功能和看见其中的一部分信息，例如客服人员一般看不到财务模块的信息；C端产品每一个C端用户都是自己在使用的产品的默认的超级管理员，拥有产品上的所有权限。\n\n从产品思维来说：\n\nB端产品是效率思维；C端产品是流量思维。\n\n\n\n中国未来是否能够出现像微信这类大用户产品，你如何看待00后的需求？\n\n如果让你删除微信一个功能，你觉得哪个功能需要删除？\n\n拼多多、淘宝、京东区别\n\n\n起家生意品类不同：拼多多起家的品类是食品，淘宝是服装，京东是计算机、通信、消费类电子产品（高频打低频，比如今日头条和百度的竞争，PC时代，搜索是一个绝对高频的应用，但到了移动互联网时代，搜索只是字典，需要的时候才会查一下，而今日头条在移动互联网时代采用的是推送的策略，推动要比搜索高频，所以百度在跟今日头条的竞争中处在了下风）\n用户画像不同：京东主要服务的是大明用户，没办法有效转化腾讯上的小闲用户；淘宝主要服务笨笨用户；拼多多主要服务笨笨用户，但可以将腾讯上的小闲用户转化为笨笨用户（拼多多通过限时秒杀、熟人拼团、现金签到、好友帮忙砍价等各种新奇好玩的活动转化），使用户完成消费。而小闲用户群体大于笨笨用户群体，笨笨用户群体大于大明用户群体。因此谁能够转化小闲用户就能得到爆炸性的用户量增长。\n大明用户的特点是我知道我要什么，我要最有效率的，性价比好的东西。就像男性买衬衫。\n笨笨用户的特点是我不知道买什么，我得看。就像女孩子买裙子，买什么样的得看，然后就是两个女生去商场逛了10几家店，看了几百件衣服，最后买了一顶帽子。\n小闲用户的特点是我没有需求，我现在就是闲，需要解解闷儿。就像聊天儿、看视频、打游戏的这类用户。\n\n\n购物场景不同：在淘宝和京东，用户的购物习惯93%是直接搜索，按照销量和评价来选购，而拼多多是从秒杀、特卖、清仓、免单的区域进去购买。这就像用户在一个超市里面购物，淘宝和京东的用户会直接找到存放相应品类的货架挑自己想要的东西，甚至必须是某个牌子和生产日期的。拼多多则是超市里的打折区，用户在打折区选货是看什么东西打折，从里面挑选我需要的，或者我没见过，正好在打折，我就试试，这是不同的用户场景。\n获客、开店和供货的逻辑不同：\n拼多多获客方式更丰富。获客上除了和淘宝、京东相同的平台流量、广告流量、运营位、搜索展示等等完全相同外，拼多多还独有的增加了社交裂变的流量。也因为拼多多一系列承接腾讯小闲用户的方法，才让社交裂变的流量能够有效地在拼多多的场景里沉淀下来。\n拼多多开店更简单，不以开店为目的，而以甩货为目的。在京东或者天猫开店有多难，相信大家有所耳闻，反正你不是大牌就休想，而且基本要抽5-10个点的水。在淘宝开店，也需要百度百科或者淘宝大学来指导，基本上你得提一口真气，下巨大的决心才能在淘宝开店。相反拼多多则简单到上传商品，送一个店铺的程度，亲测在拼多多上开店只要三分钟。\n拼多多在供货逻辑上实现了工厂直接向消费者供货。淘宝有了越来越复杂的规则，而且线下长期以来都是多级分销的体系，厂家通过各级分销商向消费端供货，因此出现了一批的专业代运营淘宝的中间商，厂家面对中间商供货。中间商要生存就会提高产品价格，最终由消费者买单。而拼多多开店规则简单，在买家和厂家之间没有中间商存在的价值，因此消费者购物时就不会被中间商剪羊毛。\n\n\n\n\n微信、QQ、微博区别\n抖音、快手区别\n\n\n抖音是精致的表演舞台，快手是随性的街头分享。\n抖音舞台是中心化的，是所有观众注意力的集中点，这是中心化内容的逻辑。抖音依靠强大的推荐算法对头部内容生产者的作品进行强力宣发，就好像给艺人搭建动感的舞台，以期招揽更多的观众。\n快手街头是去中心化的，不同的人会在不一样的街道遇到，这是去中心化的分发逻辑。快手构建了一个多元的社区，同时依靠去中心化的推荐策略保证每个人都有被看到的机会。\n\n\n抖音是媒体，快手是社区：抖音在乎内容和分发，快手在乎人和关系，其次是内容。\n内容：抖音记录美好生活，来这里发现美好，是一个带着滤镜的世界，未必真实，但一定让你流连忘返，强调内容质量。快手记录世界记录你，来这里看到不同的人生百态，不一定华丽，但重在真实，强调的是生存环境以及人。\n关系：快手比抖音的人之间关系属性更强，内容分发没有完全的算法化，有相对较高比例的用户是因为人而消费内容，社区属性明显。\n价值观：抖音是美好、时尚，最流行的都在抖音，明星、热点、趋势、精彩。快手是真实、存在感，记录世界记录你，是记录真实世界下的每个人的存在感。\n\n\n\n\n\n为什么有的产品能成功有的产品会失败？\n\n微信的三个阶段？\n微信成功，米聊失败？\n微博成功失败又成功？\n\n\n生活中有没有遇到糟糕的产品，如何看待这些产品呢？\n\n你觉得什么样的产品是成功的产品？\n\n满足用户核心痛点并且产品能给公司带来收益，这两者是相辅相成的。\n\n\n说一款平时使用的APP，核心功能是什么？好在哪里？不好在哪里？为什么？针对缺点如果是你你会怎么做？\n\n用户体验五要素：\n\n战略层Strategy：\n\n用户需求：产品的核心用户是谁？满足了他们的哪些需求？\n商业目标：公司想从这个产品中获得什么？盈利还是品牌宣传？\n\n\n范围层Scope：为了满足战略层的目标，产品需要有哪些功能？\n\n工具型产品：就是作为一种工具帮助用户高效便捷的完成某件事情，其最核心的是功能，例如浏览器、计算器等。\n信息型产品：最核心的是内容，例如各种新闻资讯App、博客App等。\n平台型产品：将功能与内容组合起来，形成更加复杂的平台，例如购物平台、微信、支付宝等。\n\n\n结构层Structure：在收集完用户需求并将其排列好优先级后，需要将这些分散的片段组成一个整体，并通过固定的流程行进，这就是结构层。\n\n交互设计：描述“可能的用户行为”，定义系统如何配合与响应这些用户行为。不要让用户去适应产品，而要让产品与用户互相适应。交互设计应该至少包括概念模型和错误处理。\n信息架构：主要关注如何将信息表达给用户，着重于设计组织分类和导航结构，让用户容易找到。（线性结构、层级结构、矩阵结构、自然结构）\n\n\n框架层Skeleton：框架层决定某个板块或按钮等交互元素应该放在页面的什么地方。结构层中形成了大量的需求，框架层中，我们需要更进一步提炼这些需求，确定详细的界面外观、导航和信息设计，使晦涩的结构变得实在。在设计框架层的内容时，要遵循两条原则：遵循用户日常使用习惯、恰当使用生活中的比喻。\n\n界面设计：为用户提供做某些事的能力。做界面设计时，要选择合适的元素，让用户一眼就能看到最重要的东西。\n导航设计：为用户提供去某个地方的能力。做导航设计时，要提供网页之间的跳转方法，传达元素与内容之间的关系，传达内容与页面之间的关系。\n信息设计：将想法传达给用户。信息设计是将各种设计元素聚合到一起，反映用户的思路，支持他们的任务和目标。包括视觉、分组等各个方面。\n\n⭐️结构层关注的是功能与功能（页面与页面）间的跳转以及某个功能内部流程的逻辑性，框架层重点关注单个的功能引导性，具体说就是在一个新用户打开App的情况下，能够在没有提示的前提下能够按照以往的用户习惯顺利的完成某个任务。\n\n表现层Surface：是用户所能看见的一切，字体的大小、导航的颜色、整体给人的感觉。在这一层，内容、功能和美学汇集到一起来产生一个最终设计，从而满足其他层面的所有目标。成功的界面设计有两个特点：\n\n他们遵循的是一条流畅的路径。用户在浏览过程中有流畅感，不会被阻碍。\n在不需要用太多细节来吓倒用户的前提下，为用户提供有效选择的、某种可能的“引导”。\n\n\n\n\n⭐️Percento\n战略层：\n\n产品的核心用户是谁？满足了他们的哪些需求：核心用户有两类，一类是那些不喜欢传统的一笔一笔记账，更愿意定期统计自己所有资产的人，第二类是想要在一个平台跟踪自己的投资（基金、股票、加密货币、贵金属等），并且可以实时看到最新价格的人。\n公司想从这个产品中获得什么？主要还是盈利，产品是如何给公司盈利的：只要满足了以上两类核心用户的需求，用户就会愿意为产品付费。该产品定价采用基础功能免费，高级功能收费的方式（升级到无限账户添加、货币汇率自动换算、股票价格自动更新、更换主题配色、可视化图表报告），可按月、按年付费，也可终身买断。\n\n范围层：该产品为工具型产品，主要有以下功能\n\n添加账户：流动资金、投资、固定资产、应收款、负债，其中投资账户金额实时更新\n资产分配比：了解五个账户所占的比例\n收支统计、净资产与负债趋势图、流动资金与投资趋势图\n可选择记账的货币类型、选择主题色彩\niCloud同步、Face ID、自动刷新、导出数据\n\n结构层\n框架层：抛弃了传统的导航栏和tabBar标签栏，很新颖。\n表现层：主题色专门适配暗黑模式。\n\n\n\n列举一个你认为最好的音乐类网站或App，说明其独特之处？\n\n为什么加入我们公司？对我们公司的产品了解情况？你对我们的产品有什么修改意见？\n\n我对贵公司也做过一些调研，知道贵公司是做XXX的，我认为贵公司所处的XXX行业很有发展前景，原因是XXX，贵公司的产品我也很看好，原因是XXX。\n\n\n请陈述一下对XXX行业的看法？最近互联网发生了哪些大事？\n\n说说你对当前科技行业（元宇宙、区块链、Web3.0、ChatGPT、AIGC），今天国内和国外处于什么阶段，未来五年会怎么样？作为产品经理，你的角色职能会有哪些转变，需要储备哪些能力？\n\n说出你喜欢的获取互联网资讯的途径？\n\n平时有看哪些书？看过什么样的产品书籍？\n\n目的有四个层次：\n\n有没有学习的意愿？\n学到了没有，书中对你印象最深刻的点是哪些点？\n学到了以后有没有去用？\n用了之后的效果怎么样？\n\n\n\n\n场景问题：\n设计一个双十一活动，如何才能吸引用户参与？\n做一款社交软件，请描述一个完整的产品规划到实施的过程，包括哪些部分？\n设计一个跨境电商产品，请说明你需要多少费用和什么样的团队，将在一年内将这个产品做到什么样，达成什么目标？\n如果你是上门服务O2O的产品经理，你将通过何种方式保证上门服务的质量？\n团队想做知识付费视频，包括需求如何去做，产品如何设计，需要多少人力成本？\n请根据自己的购物经验设计淘宝的产品展示详情页，包括pc端和移动端两个方案，可根据自己的经验合理发散，创新设计。建议交付物有设计方案详解、流程图、产品定位分析、技术可行性分析等（利用axure根据业务画一个产品）\n\n思维问题：\n费米估算题：\n上海有多少产品经理？\n北京有多少公交车？\n深圳有多少租房数量？\n一辆公交车能装下多少乒乓球？\n楼下便利店一天卖出多少牛奶？\n\n井盖为什么是圆的？\n\n为什么地铁座位和火车座位方向不一样？\n\n\n","categories":["产品理论"],"tags":["产品-产品面试题"]},{"title":"内容运营","url":"/2023/05/31/%E4%BA%A7%E5%93%81%E7%90%86%E8%AE%BA/%E8%BF%90%E8%90%A5/%E8%BF%90%E8%90%A5%E7%AC%94%E8%AE%B0/3_%E5%86%85%E5%AE%B9%E8%BF%90%E8%90%A5/","content":"什么是内容运营内容分为：文字、图片、视频、音频\n一切皆内容，进入一个产品我们其实都在消费内容，比如说产品功能可以理解为“骨架内容”，产品里的文字可以理解为“肉体内容”，产品里的活动可以理解为“交际内容”\n肉体内容：\n\n单点切入，不断丰富（关注用户需求变化、丰富内容品类）\n保持持续、新鲜（定时更新内容，让优质内容持续产出）\n\n内容的可传播性的属性：\n\n刺激性：金钱、情色、贪婪、虚荣、懒惰\n社交货币性：利他利己、饭后谈资、表达某一类人的心声\n\n运用内容带动数据增长的就叫内容运营，以原创、伪原创、整合、引入等手段来产出产品需要的内容，结合新媒体、专题、专栏等形式推广出去，带动拉新、留存、活跃、转化等数据目标的增长\n内容运营的核心价值：通过拉新、留存、促活、转化来消费用户的时间或金钱\n内容的安全内容的安全&#x3D;生死存亡（敏感内容）内容审核：\n从零开始搭建内容运营框架\n内容定位：\n内容定位是用户对内容的需求：比如说打发时间（朋友圈+微博+影视剧）、了解资讯（门户+今日头条）、自我提升（人人产品经理+知乎）、购物（小红书+天猫）\n内容定位是产品的切入点\n定位也要差异化\n\n内容生产：内容生产的形式：\n\nUGC：用户生产内容，比如知乎\nPGC：专业生产内容\nOGC：品牌生产内容自媒体以UGC为主，穿插不收取报酬纯粹爱好产出内容的PGC和因为某领域某职业收取报酬产出内容的OGC。\n\n内容生产的方式：\n\n原创伪原创：一篇内容如果70%是自己写的，30%是引用别人的，那可以说这篇内容是原创的\n引入汇编\n智能推荐：今日头条\n修改标题\n\n建立内容的标准：定性决定产品调性\n内容整合：内容整合的常见四种形式：\n\n日报\n周刊\n排行榜\n专题\n\n内容为何而聚：\n\n天时借好天时：\n地利：产品的板块就是内容的阵地，根据热点、用户需要可以构建好的内容消费阵地\n人和：因某一个人或某一类人而进行内容聚合推荐，方便用户集中进行内容的选择和消费\n\n内容推广内容推广的渠道：\n内容运营如何跨部门协同作战\n社区中的内容该如何运营\n链接内容生产者（激励的核心路径：让用户产生用户行为，进而带来产品收益，反过来再反馈给用户收益）\n链接内容消费者\n\n机制化的呈现：根据用户的有效反馈来呈现优质内容（比如知乎文章点赞量高的优先呈现出来）\n“标题党”是怎么样练成的（人人都是标题党）标题成为内容的首要战场原因：信息过载、阅读量下降、国民时间竞争\n检验是否是好的标题党的标准：是否脱离内容真实本身\n合格标题党的定义：以基于内容真实情况，根据用户心理使用一些技巧激发用户对内容的感知，促使用户获取对自己有价值的信息\n标题党自我修炼的技巧\n疑惑法\n震惊法\n数字法\n抱大腿法\n悬念法\n冲突法\n人性法\n限时法\n标签法\n总结法\n\n如何写出优秀的产品文案基于\n\n产品现状\n用户需求：常遇到的问题、不喜欢产品的原因、希望创造什么新的可能\n使用场景\n卖点归类\n\n文案写作的一些技巧：\n\n关联用户熟悉的东西\n突出为用户定制\n具像化利益\n\n","categories":["产品理论"],"tags":["运营-运营笔记"]},{"title":"产品人需知晓的互联网运营","url":"/2023/09/30/%E4%BA%A7%E5%93%81%E7%90%86%E8%AE%BA/%E4%BA%A7%E5%93%81/%E4%BA%A7%E5%93%81%E7%AC%94%E8%AE%B0/12_%E4%BA%A7%E5%93%81%E4%BA%BA%E9%9C%80%E7%9F%A5%E6%99%93%E7%9A%84%E4%BA%92%E8%81%94%E7%BD%91%E8%BF%90%E8%90%A5/","content":"运营的本质：定目标（拉新活跃变现）、找路径\n产品运营本是一体，未来对产品人和运营人的要求都会越来越趋同；运营的抓手越来越多的要依赖产品，用户已经不会因为一个瞬间就留存下来了；而产品也越来越需要有社会化营销的原生属性\n有没有同学操作过广告投放？有没有感觉到怎么扩大广告投放都没啥用：品牌的边界决定了你在一个具体的渠道上能够引来有效用户的天花板\n没有资本助力的小品牌很难做疯狂的新增累计，即便偶然引爆，用户也仍然会快速流失\n虽然对产品而言有用户的累积新增期和成熟期，但是运营的方向并没有本质的差别，只是受制于品牌和产品的成熟度，运营的手段会有差别，拉新、转化、变现都需要持续做\n运营规划通常是围绕着“拉新活跃变现”为目标，并设定路径来做的，要关注公司当前的重心是什么，这和产品的阶段关系不大，和公司要规模还是要盈利关系更大，规划只是一部分，持续的跟进进展，以及效果更为重要，在跟进和规划的同时要明白下一个阶段性的方向大致是什么\n目标更难设定？还是路径更难规划？\n用更运营产品的方式了解数据：\n怎么做运营增长运营的目标一定都是增长么？是的，比如用户增长、品牌增长。\n运营增长运营增长包含了供应方、产品和服务、用户等的增长，所以运营增长不等于用户增长，运营增长是一个长期的事情，而用户增长是一个阶段性的事情\n我们怎么来做运营增长：\n用户增长裂变裂变：以用户带用户的方式快速形成传播和用户获取（低成本获客）\n完成裂变有什么必要条件：\n\n足够的存量用户\n裂变的落地海报页：裂变的规则和参与路径、内容（创意）\n用户激励\n\n用户增长也不等于用户拉新，拉新之后流量的承接和服务同样重要，用户是延续性的\n黑客增长模型黑客增长模型：用户增长是一套系统化的动作AARRR已经过时了，现在流行RARRA，因为用户越来越缺乏耐心，和用户接触的第一个瞬间就要想办法留存他，而不是想办法获取他（“标题党”就是典型的先获取用户，所以他现在行不通了）用户增长模型下的增长因子：（过去增长因子是完全相反的，比如步步高，一开始先投大量资金拿下央视广告做品牌提高知名度，然后通过数字营销全国商场铺货，最后才到用户手上体验产品，现在行不通了)\n做好流量引入和内容的设计，还有用户增长的系统搭建，就能做好用户增长么？选择品牌与用户中间的平衡点，以用户能够接受的表达方式表达价值，这就是营销思维的根本：\n","categories":["产品理论"],"tags":["产品-产品笔记"]},{"title":"产品设计-风险及沟通(验收及发布)","url":"/2023/09/30/%E4%BA%A7%E5%93%81%E7%90%86%E8%AE%BA/%E4%BA%A7%E5%93%81/%E4%BA%A7%E5%93%81%E7%AC%94%E8%AE%B0/10_%E4%BA%A7%E5%93%81%E8%AE%BE%E8%AE%A1-%E9%A3%8E%E9%99%A9%E5%8F%8A%E6%B2%9F%E9%80%9A(%E9%AA%8C%E6%94%B6%E5%8F%8A%E5%8F%91%E5%B8%83)/","content":"\n风险管理风险管理是指如何在项目或者企业一个肯定有风险的环境里把风险可能造成的不良影响减至最低的管理过程\n风险管理的方法：\n\n风险识别：是经济单位和个人对所面临的以及潜在的风险加以判断、归类整理，并对风险的性质进行鉴定的过程\n风险估测：是指在风险识别的基础上，对风险点及相关数据进行分析，估计和预测风险发生的概率和损失程度\n风险管理：事前管理：事前规避风险或将风险概率降至最低的方案及实施事后管理：事后将风险损失降至最低的备案及实施\n风险管理效果评价：是分析、比较已实施的风险管理方法的结果与预期目标的契合程度【复盘：风险是否发生？风险没有发生是因为哪些事前措施发挥了效用？风险发生后事后备案是否将损失控制到预期范围内？】\n\n思考：风险能被预防么？领导预期过高怎么办？开发过程中需求变更怎么办？不论哪种情况变更，都要做好变更说明、通知、项目同学情绪安抚和复盘\n项目沟通沟通的目标：\n验收及发布产品验收：在产品完成测试之后，发布上线之前，需要执行产品验收，产品验收的目标在于保证产品质量，达到设计预期。跟测试不同的是，我们在验收时不仅需要验证产品功能，同时需要考虑使用场景，把自己当成用户，看看产品在真实的使用场景下能否跑通。所以，产品验收有时不仅会涉及到bug修改，可能还需要进行需求调整。经验告诉我，每次产品验收总有一些让产品经理感到不满意的地方，有的是自己的设计问题，有的是项目执行失真问题，有的是开发的落地问题。面对这些不满意的地方，你也需要做出判断“它在不在一个及格线上，我们是否需要发布”。当你宣布验收不通过的时候，也就意味着各种计划的延期开始了，思考下，到底什么风险的失控导致了这一点\n","categories":["产品理论"],"tags":["产品-产品笔记"]},{"title":"产品经理进阶","url":"/2023/09/30/%E4%BA%A7%E5%93%81%E7%90%86%E8%AE%BA/%E4%BA%A7%E5%93%81/%E4%BA%A7%E5%93%81%E7%AC%94%E8%AE%B0/13_%E4%BA%A7%E5%93%81%E7%BB%8F%E7%90%86%E8%BF%9B%E9%98%B6/","content":"术是学习来的，它需要我们向外探索道是修行来的，它需要我们向内萃取\n","categories":["产品理论"],"tags":["产品-产品笔记"]},{"title":"产品设计-用户体验","url":"/2023/09/30/%E4%BA%A7%E5%93%81%E7%90%86%E8%AE%BA/%E4%BA%A7%E5%93%81/%E4%BA%A7%E5%93%81%E7%AC%94%E8%AE%B0/11_%E4%BA%A7%E5%93%81%E8%AE%BE%E8%AE%A1-%E7%94%A8%E6%88%B7%E4%BD%93%E9%AA%8C/","content":"用户体验（User Experience，简称UE）是用户在接触产品及服务过程中建立起来的一种纯主观感受\n用户与产品递进关系：\n认知过程中的体验\n名称：为什么互联网公司起名喜欢用动物、植物和叠词？\nSlogan：品牌认知Slogan应该具有的功能有且只有一个：传递企业或者产品关于精神、理念、品味等方面的感知，所以其很少改变，而且变化多伴随着整体战略的调整。\n包装：你有没有仅仅因为颜值而冲动下单的经历？\n气质：品牌的特异功能：人格化，建立产品与目标用户的情感和认知连接，做人做产品，都得“有个性”\n\n1997年，J.Aaker通过人格问卷，借鉴人格特质论中的“大五”模型，总结出最容易被感知的5种人格：真诚、教养、强韧、能力、刺激\n“真诚”类的品牌人格，传达“稳”、“安全”、“踏实”的信息，品牌个性常见于：服务型、食品、儿童类、家用电器、快消品等产品和品牌\n“教养”类的设计传达一种“精英主义”的品质，设计风格精细、色彩平和低调、优雅，品牌个性常见于：奢侈品、女性产品、高端定位的产品等\n“强韧”类的人格最核心的是传达“人的力量”、“运动的形态”，设计元素棱角分明，品牌个性常见于：健身、户外、力量型、运动等相关产品和品牌\n“能力”型的人格，始终要传达一种“贵”或者“领袖”的感觉，沉稳的大地色系使用的较多，设计元素要简洁、规整，品牌人格常见于：科技类、智能类、国际性、技术导向的、团队协作的产品和品牌\n“刺激”类的人格，个性张扬、叛逆，设计元素绝对不能循规蹈矩，配色大胆有冲击力，品牌个性常见于：目标用户为年轻人、新兴产业、创意类、娱乐类等的产品和品牌5. 场景（网易考拉的快递员关怀行动）\n场景STEP四要素：空间、时间、事件、人物\n场景化营销是针对于消费者在以特定情景为背景，通过环境、氛围的烘托，提供相应的产品和服务以激发消费者产生情感共鸣来触及消费者的购买欲望，产生消费行为\n使用过程中的体验交互设计尼尔森十大交互设计原则：\n\n状态可见：系统应该让用户时刻清楚当前发生了什么事情，也就是快速的让用户了解自己处于何种状态、对过去发生、当前目标、以及对未来去向有所了解（苹果电脑磁吸充电器亮灯）\n环境贴切：软件系统应该使用用户熟悉的语言、文字、语句，或者其他用户熟悉的概念，而非系统语言\n用户可控：用户常常会误触到某些功能，我们应该让用户可以方便的退出或降低误触的概率（笔记废纸篓）\n一致性：结构一致性、色彩一致性、操作一致性、反馈一致性、文字一致性\n防错：是在一个错误发生之前就避免它（微信朋友圈退出编辑时提示保留、携程订票选择日期不可选择当日之前的）\n易取：通过把组件、按钮及选项可见化，来降低用户的记忆负荷（鼠标移动到某个按钮上会有说明文字，减少用户记忆）\n灵活高效：允许用户定制常用功能\n优美简约：对话中的内容应该去除不相关的信息或几乎不需要的信息\n容错：错误信息应该使用简洁的文字（不要用代码），指出错误是什么，并给出解决建议\n人性化帮助：根据场景透出帮助渠道或内容（淘宝客服）\n\n视觉设计《视觉设计基础：四个设计原则》\n视觉设计4个原则：\n\n亲密：将彼此相关联的项，在空间的角度上更靠近些\n对齐：根本目的是使页面统一而且有条理\n重复：目的是统一，并增强视觉效果，但要避免过多的重复一个元素，让人感觉不太舒服\n对比：可以通过字体选择、线宽、颜色、形状等来增加对比，重要的是对比一定要强烈\n\n对于产品经理来说，了解基本的视觉设计规范、原则，多与设计师沟通，多体验产品，提高审美\n文案不要忽视文案的力量！\n\n一致性规范：词汇一致、句式一致、行动点与目的页面标题一致、时间表达规范、数字一致性规范、标点一致性规范\n准确性规范：用词准确、不累赘、不缺失、不模糊\n懂用户：从用户视角描述价值、正确使用人称代词、让用户听得懂、告诉用户Why not\n\n服务过程中的体验主要是客服\n为什么要及时回复：\n\n让用户感觉到被关注\n有利于塑造产品的正面形象\n减少公关危机\n获取更多用户反馈\n\n如何提升回复质量：\n\n尽量直接联系\n感谢用户，肯定用户\n换种方式解决问题\n适度的奖励\n\n","categories":["产品理论"],"tags":["产品-产品笔记"]},{"title":"什么是产品经理","url":"/2023/09/30/%E4%BA%A7%E5%93%81%E7%90%86%E8%AE%BA/%E4%BA%A7%E5%93%81/%E4%BA%A7%E5%93%81%E7%AC%94%E8%AE%B0/1_%E4%BB%80%E4%B9%88%E6%98%AF%E4%BA%A7%E5%93%81%E7%BB%8F%E7%90%86/","content":"PM：突出的是Manager，产品的管理者，产品的第一负责人PD：突出的是Designer，有时候也称其为功能经理成为PD或者PM，一方面要看你自己的素质，另一方面，也要看公司内部的权力博弈\n另一个维度上来说，公司的模式也可以分为交易驱动和用户驱动，产品经理在不同模式下的境遇也不尽相同。\n\n交易为核心的公司（阿里、苏宁、京东、饿了么、携程、支付宝）：主要包括新零售企业、电商企业、O2O企业、互联网金融企业。这一类企业的核心在于“订单交易”或者说“商品&#x2F;服务的销售”。这一类企业基本都是运营驱动，公司初创的时候产品的话语权就很低，到A轮业务模式验证成功之后，产品经理很快就成为PD的角色，在这样的公司里，很多产品经理都不背负业绩指标，只背负IT指标。\n以用户为核心的公司（扇贝、微信、QQ、抖音）：主要包括短视频、工具应用、社交等领域，这一类的企业在于“用户的关注度”。这一类企业基本都是产品驱动，运营配合。公司一直到C轮成为行业独角兽并积攒大量用户群后，企业开始变现，运营变得越来越重要。产品经理才开始渐渐成为PD的角色，在这样的公司里，产品经理往往很长一段时间都是业绩指标的主要背负者。\n\n在初创公司、独角兽公司和巨头公司，对产品经理的定位往往会不同。另外，通过个人素质的提升而去改变话语权的难度也是不一样的。\n并不是成为一个PM就是牛的，而成为一个PD就是low的，这要看很多因素，即使在一个巨头级的交易驱动的公司，产品经理也能获得创新和创造的机会，成为PM。但是，在创业公司尤其是用户驱动型的创业公司，产品经理天生就是PM，基本不需要争取\n\n产品经理的工作：\n\n明确产品目标用户群和特征\n获取、评估和管理用户需求\n完成产品需求文档、产品原型和流程图\n重视用户体验，代表用户说话\n运用交互设计和信息架构技能与程序员完成工作交办\n项目管理、需求变更管理和需求验收\n产品运营数据的分析和总结\n提供运营、市场和销售等支持产品经理工作流程：\n\n产品经理的能力模型：\n更深层的解构下产品经理我们到底是谁？我们职业的核心竞争力到底在哪里？我们到底因为什么而不可取代？\n\n不是建设者，而是一个包装者。（举例：一般快递要两三天到达，现在用户需要买菜买厨房调料，需求是几个小时之内送达，产品经理通过包装“猜你喜欢”功能和小区附近的配送站，提前将用户订单多的产品放到配送站中，用户通过App中的某个模块，选择想要的产品，将“用户需要什么我就送什么”变成“我有什么用户选什么”）\n必须很好的平衡来自各方面的矛盾，是唯一必须帮助用户说话的人。（双11是一次成功的运营，将用户训练出来了；整个部门里没有人帮用户说话，只有产品经理在谈用户体验）\n有靠谱的创意，因为产品经理具备上帝的视角。\n产品经理是一个经营软实力的岗位，他本身必须对各方面知识都足够渊博，充满人格魅力，有说服力和感染力拥有广阔的视野和清晰的思维，同时充满创造力。（过去几十年中，互联网基础的协议看起来没有多少发展，那么这些年我们在干什么？例如云计算、机器学习、AI等技术同样也是如此，其最基础的部分几十年都没有变化）与20年前相比，用户的“需求”有没有变化，互联网是否“创造”了新的需求？没有，下一个20年依然如此，用户需求没有变化，变化的是我们满足需求的方法，对，就是产品。\n\n什么是好的产品经理“是个做什么都能成功的人” ——余军评价李明远\n进阶之路\n","categories":["产品理论"],"tags":["产品-产品笔记"]},{"title":"市场与竞品分析","url":"/2023/09/30/%E4%BA%A7%E5%93%81%E7%90%86%E8%AE%BA/%E4%BA%A7%E5%93%81/%E4%BA%A7%E5%93%81%E7%AC%94%E8%AE%B0/2_%E5%B8%82%E5%9C%BA%E4%B8%8E%E7%AB%9E%E5%93%81%E5%88%86%E6%9E%90/","content":"输出竞品分析报告\n市场分析-从了解行业开始什么是竞品分析竞品分析是项目如何成功的重要前提之一\n竞品分析的含义：对竞争对手进行全面的分析，进而制定有利于自身的竞争策略。（分析竞争格局，剖析竞争优势，基于自身优势，拟定解决方案）\n做竞品分析的根本目的就是如何做这个事能成功，能利益最大化。\n如何做竞品分析，哪些方法可以保证我们利益最大化：\n\n挑的市场好：前期充分市场分析验证了项目前景好\n产品定位好：足够恰当的竞品分析促使形成良好的产品策略\n\n为什么要做竞品分析：\n\n战略选择：产品核心竞争力的建立、资源分配的合理化布局、合理制定预期目标\n产品优化：需求来源之一、竞争压力迫使产品优化\n个人成长：逻辑思维的锻炼、行业理解力的提升、用户导向概念的深化、书面表达能力的加强\n\n竞品分析的一般方法竞品分析基本步骤：\n\n明确目的：不同时间段做竞品分析目标不同\n行业分析：通过了解基本行业概况、熟悉行业发展阶段、了解行业内竞争基本情况，达到“总结所处行业的发展基本特征，以便于后续提炼方向结论”的初步阶段目标\n\n行业：行业是指从事国民经济中同性质的生产或其他经济社会的经营单位或者个体的组织结构体系，如林业、汽车业、银行业等。\n怎么做？1、搜集分析资料：行业背景相关信息（政策经济状况等）、市场相关信息（市场规模、用户情况等）\n行业背景分析基本方法：\n\nPEST：指宏观环境的分析，通过政治、经济、社会、技术这四个因素来分析企业所面临的状况。\n竞争态势：波特五力模型分析一个行业的基本竞争态势，竞争的五种主要来源，即供应商和购买者的讨价还价能力，潜在进入者的威胁，替代品的威胁，以及最后一点，来自在同一行业的公司间的竞争。\n产业地图：产业格局的结构化总览，产业地图可以获得行业运转规律（上下游关系、如何玩）、行业拆解、竞争环境\n\n市场相关分析基本方法：\n\n市场阶段：导入阶段、发展阶段、成熟阶段、退出阶段\n市场规模：主要是研究目标产品或行业的整体规模、可能包含目标产品或行业在一定时间内的产量、产值等，具体根据人口数量、人们的需求、年龄分布、地区的贫困度调查所取得的结果如何计算市场规模：（面试题）\n用户画像：是建立在一系列真实数据之上的目标用户模型用户画像怎么来：1、直接搜索获取现有结论——针对从未接触的行业2、搜索+自身产品验证——针对已经所处某行业\n\n⭐️行业分析结论：作为行业分析，为了给竞品分析的结论提供一定的支持，也必须有相关的方向结论输出\n行业数据源：互联网数据资讯网-199IT | 发现数据的价值-199IT | 中文互联网数据研究资讯中心-199IT数据采集：\n2、处理加工资料：通过资料搜集，进行加工分析，得出对项目有帮助的结论。\n\n确定竞品：通过搜集分析竞品相关情况，以达到选择恰当的竞品进入下一阶段的分析\n\n如何找到竞品：\n竞品分级：选择竞品时，还可以多考虑竞品的细分方向\n\n核心竞品：产品直接相关的细分市场内第一梯队的竞争对手\n\n重要竞品：产品相关细分市场内排名第一的竞争对手\n\n普通竞品：一般就是产品直接和相关细分市场的其余竞品\n\n确定维度：通过选择好分析维度，以达到根据对应的维度去搜集基本信息资料数据等常见分析维度：\n\n搜集数据：通过相应维度下的数据搜集，以达到便于后续的分析以及为结论提供相应的定量客观数据或信息的支持数据来源：【百度指数：趋势研究、舆情洞察、需求图谱、人群画像，应用市场的评论和迭代记录】\n\n对比分析：通过对比分析，输出每个模块对比的小结论，为提炼大结论打基础【基本思路：竞品定位 + 竞品功能 + 竞品策略 -&gt; 分析结论】\n\n\n竞品定位：竞品产品面对的是怎样的市场和怎样的用户\n营销学上的定位理论：占领用户心智。核心是通过竞品分析找一个竞品还没有占领的山头，让自己的产品成为这个山头的NO.1，通过定位理论，我们可以在竞品分析后，找到一个可以的切入角度去包装营销我们的产品。\n竞品定位分析：\n\n竞品的核心功能特色与自己的差异，竞品的目标市场与自己的差异\n竞品与自身之间的用户有什么差异，用户使用场景、用户不同的标签\n\n竞品功能分析：\n\n核心功能：围绕定位，分析竞品到底做了什么核心功能\n功能结构与核心流程逻辑：研究竞品的功能结构及流程是如何更好的，哪里是好的值得借鉴，哪里不好值得优化\n交互体验：研究竞品的交互细节哪里做得好，是否有值得借鉴的部分\n\n策略：围绕战略的战术竞品策略分析：\n\n商业模式：赚钱逻辑\n产品策略：不同时期做了什么功能\n运营策略：都做过哪些特别的运营事件\n\n7.输出结论：可利用SWOT分析法汇总信息，输出核心结论，以便于产品方向的探索及确定（SWOT分析实际上是将对企业内外部条件各方面内容进行综合和概括，进而分析组织的优劣势、面临的机会和威胁的一种方法）\n竞品分析的核心思想：方案重于分析，分析重于罗列，模仿不等于抄袭，结合自身情况，微创新，结论有理有据\n竞品分析文档的撰写明确文档目标预研分析：为新项目或项目优化做分析预研分析文档要点：\n常规跟进：日常搜集分析行业竞品动态常规跟进文档要点：\n","categories":["产品理论"],"tags":["产品-产品笔记"]},{"title":"需求挖掘与分析","url":"/2023/09/30/%E4%BA%A7%E5%93%81%E7%90%86%E8%AE%BA/%E4%BA%A7%E5%93%81/%E4%BA%A7%E5%93%81%E7%AC%94%E8%AE%B0/3_%E9%9C%80%E6%B1%82%E6%8C%96%E6%8E%98%E4%B8%8E%E5%88%86%E6%9E%90/","content":"\n基本产品工作流程：\n\n了解市场\n确定需求：需求定义（提升对需求的理解和认知）、需求挖掘、需求管理\n产品设计\n产品运营\n\n需求定义需求是用户在一定场景下产生的某种欲望或解决某些问题的需要常见的需求：\n\n用户需求和业务需求都是产品需求的来源\n用户需求和业务需求分别满足用户和公司的基本诉求，但有时候这两者是冲突的（比如说穿插广告）\n产品需求就是一种解决方案\n\n用户痛点：解决问题用户痒点：满足欲望用户兴奋点：超出期望\n需求分析的目标：各个需求来源出发，为产品需求生成提供基础，通俗的说，就是明确我们的工作执行任务\n需求要素：\n用户：用户属性：角色（使用者、购买者、决策者）、特点、规模，由于产品属性不同，每个产品的用户角色分类会有所差别\n场景：存不存在？频次咋样？\n任务：为了实现目标可以做什么？有哪些方案？什么是最佳解决方案？\n目标：直接目标、终极目标\n\n在我们所听到的需求中，很多时候会直接说出任务而不会提到目标\n为了更好的平衡用户需要和企业利益，我们需要更好的了解用户，了解用户场景，这样才能知道用户的真实目标，继而才能更好的给出解决方案\n需求分析：从用户需求&#x2F;业务需求出发，挖掘其真实目标，并转化为产品需求的过程需求分析工作的要点：\n\n需求挖掘：即找到真实的用户需求、业务需求、市场需求等，以便于可以转化更多的更合适的产品需求\n需求辨识\n需求优先级\n需求管理\n需求转化\n\n需求挖掘的方法：无论哪种方法，其核心都是要找到更多的可以需要转化为产品需求\n\n自主分析法：通过自身的思考分析得出需求，建议多头脑风暴（当一群人围绕一个特定的兴趣领域产生新观点的时候，这种情境就叫做头脑风暴）多体验：感知用户、感知抱怨、感知产品多分析：分析形势、分析竞品、分析变化、分析结果多实战：执行、观察、思考头脑风暴法准备：准备议题明确会议目标、人数5～10人、时间一小时以内、主持人合理引导会议头脑风暴法原则：自由发言不受约束、禁止批评规避自谦、独立思考杜绝讨论、追求尽可能多的设想\n业务驱动法：（1）解决运营&#x2F;市场的问题，为了达到某一业务目标而产生的需求，例如营销工具、广告资源位交换（2）解决技术的问题：（3）客服或其它人员（采购、物流）需求（4）战略目标变化：基于战略的发展，会产生很多新的产品需求\n市场竞品追踪分析法：长期定期的跟踪竞品，也可以发现需求，根据竞品及行业的动态来挖掘新需求（深刻理解竞品做法的真实原因，适当的考虑到如何指导自己的产品）\n用户研究分析法：通过用户研究了解用户是否有需求、验证想法、怎样的实现方式最贴近用户需求、用户迫切程度如何，以此来判断方向是否可行，用户研究就是需求挖掘的重要方法之一\n\n用户研究：是一种理解用户并将用户目标及需求与企业商业宗旨相匹配的理想方法。目的是使用户的实际需求成为产品设计的导向，使产品更符合用户的习惯、经验和期待。\n用户画像：是真实用户的虚拟代表，是建立在一系列真实数据之上的目标用户模型（使用Axure工具）\n常用的用户研究方法：\n\n定性研究：从小规模的样本中发现新事物的方法，通过与少数用户（10～20个）互动来得到新想法或揭露以前未知的问题\n定量研究：用大量的样本来测试和证明某些事情的方法，可验证通过定性研究而发现的假说\n\n用户研究分析法用户反馈分析用户反馈：是指使用某一产品的客户对其产品所提出的关于产品的情况反馈，用于收集问题，了解用户的使用现状和意见\n为什么搜集用户反馈：用户反馈是做产品必须建立一套机制的长期工作\n\n自身产品问题：聆听用户真实的声音\n竞品问题：对手的弱点可能就是自己的机会\n可能的机会点：集思广益\n\n用户反馈收集方法：\n用户反馈搜集后最重要的是做好分类，然后根据不同类型、Bug修复、建议转需求\n用户访谈用户访谈是一种定性的研究方法，用于定位问题，挖掘问题背后的用户需求用户访谈是指通过访员和用户面对面的交流来了解用户的心理和行为的基本研究方法。\n为什么要做用户访谈：\n\n用户价值至上：保持做产品的初衷\n用户的认知并非产品经理的认知：学会理解小白用户\n用户的个体差异：获得新的灵感\n\n用户访谈适用于探索性研究、验证性研究（开拓新业务、现有功能优化、探索新可能）\n用户访谈基本流程：\n用户的类型：\n\n行业资深用户：深度了解你产品所在行业的各类产品的人\n核心用户：能带来资源、现金流，能够给你带来更多用户的人\n低频用户：用你的产品但是不经常用的人\n流失用户：曾经用过你的产品但现在已经不用的人\n边缘用户：指未使用你的产品而使用其他类似服务的人\n非用户：指完全不使用此类产品的用户\n\n不同的目标会促使选择不同类型的访谈对象\n访谈中最关键的就是避免引导受访者，访谈结论不局限在产品层面，记录所有访谈结论\n可用性测试可用性测试是用来评估产品或系统的一种方法，让一群具有代表性的用户对产品进行典型操作，同时观察员和开发人员在一旁观察，聆听，记录。目的是为了发现用户真实使用情况中遇到的问题，来提升产品的可用性，同时发现优化需求。\n调查问卷问卷调查是社会调查里的一种数据收集手段。当一个研究者想通过社会调查来研究一个现象时（比如什么因素影响顾客满意度），他可以用问卷调查收集数据。这些问题会通过一定渠道让用户进行填写，然后收回整理分析，从而得出结论（获取反馈优化产品、了解市场需求确认产品价值、了解满意度）。\n数据分析（比如营销漏斗模型）用适当的统计分析方法对收集的数据进行分析，提取有用信息和形成结论而对数据加以详细研究和概括总结发现需求的过程数据分析的方法：数据分析如何变成需求：从数据表现到得出结论需要的是全面的分析，结合当下情况再进行优化\n需求管理纷繁世界里有大量的需求，包括真需求、伪需求，因此需要产品经理用自己的判断去甄别选择需求。\n需求管理需要先解决的问题：\n\n区分真伪需求：没有绝对的真伪需求的分界线，重点是理解我们的目标用户的真实诉求，结合场景和时机综合判断需求是否在当下为真需求\n\n同样的需求在不同的场景下可能是真需求也可能是伪需求。同样的需求在不同的时机下可能是真需求也可能是伪需求。同样的需求针对不同的用户痛点程度就是不一样的。\n\n需求优先级：因为资源有限，在有限的时间、开发资源、金钱等资源条件下我们需要用最简单的产品逻辑去验证商业模式优先级priority是一种约定，优先级高的先做，优先级低的后做。需求优先级的判断，可以帮助确认后续开发阶段什么需求先做，什么后做。\n\n优先级判定的基本影响因素：\n\n企业层面：公司战略产品生命周期（不同的生命周期相同的需求也有不同的优先级）\n用户层面：紧急重要四象限场景分析（在不同的场景下，需求的优先级会有差异。用户量越大、频次越高或满意度越低的需求则优先级更高）用户等级分析（我们需要优先满足大部分用户的诉求，尤其是核心用户的诉求）从可用到易用（涉及影响可用性的需求，优先级更高)\n技术层面：开发成本（开发的难易程度也会影响需求的优先级，难易程度的影响因素有技术实现难度、投入人力成本、投入资金成本等）\n\n需求优先级的金字塔模型：\n\n形成需求池（表述清晰、优先级明确、合理分类）需求池：把搜集来的需求经过分析后，将确认需要实现的需求放入一个可统一管理的地方，可以使用EXCEL、公司内部管理系统、Xmind等多种方式进行记录\n\n需求池表述：一般来说，根据需求4要素（用户、用户场景、用户目标、用户任务）来描述一个需求，但需求池内的记录可以简化，不要求写出需求的具体执行方案\n需求池的复盘：产品经理应该培养习惯，定期如按季度进行原需求池规划的复盘，看已经规划的需求是否完成，完成的需求实际效果如何，以便于更好的调整需求规划\n需求管理：互联网需求管理，是指包含需求挖掘、需求分析，到形成需求清单，并将需求实现的过程，在分析阶段需确认需求的优先级，并进行简单的需求分类，形成可存档的文件\n","categories":["产品理论"],"tags":["产品-产品笔记"]},{"title":"产品设计-交互设计","url":"/2023/09/30/%E4%BA%A7%E5%93%81%E7%90%86%E8%AE%BA/%E4%BA%A7%E5%93%81/%E4%BA%A7%E5%93%81%E7%AC%94%E8%AE%B0/7_%E4%BA%A7%E5%93%81%E8%AE%BE%E8%AE%A1-%E4%BA%A4%E4%BA%92%E8%AE%BE%E8%AE%A1/","content":"毫不夸张的说，近23年来（1995年-2018年，以X86指令集和win95系统的应用为标志），计算机的核心技术并没有什么突破性的进展，我们看到的这些变化，除了移动端的崛起造成的环境变化影响以外，其他的均是产品经理和交互设计师的功劳。\n产品经理的交互设计被称之为“原型”，其作用是为了向交互设计师表述其对于交互的设想、定义以及要求。你要明白自己的定位，你表达的是你的“诉求”而不是结论，不要让交互设计师成为根据你的原型来画画的。\n产品经理三大设计：结构设计、交互设计、功能设计\n交互设计（Interaction Design，缩写IXD），是定义、设计人造系统的行为的设计，它定义了两个或多个互动的个体之间交流的内容和结构，使之互相配合，共同达成某种目的\nUI：User interface，用户界面UE：User Experience，用户体验IXD：Interaction Design，交互设计UCDUXD\n\n原型：是用线条、图形描绘出的产品框架，也称线框图\n原型与交互的区别：\n\n原型表达的是一种诉求\n交互是结果，是根据原型的诉求和用户的体验思考进行的重新构架\n\n为什么要画原型：\n\n抽象转化为具象的过程\n提升沟通效率\n便于理解：运营、开发、设计、测试\n便于整理设计思路\n细化设计，防止遗漏\n\n原型要保真到什么程度：\n\n原则：能清晰表达想要的结果\n不建议产品花过多时间追求原型保真程度和动效等交互细节（不迷恋工具和动效，以表达为目的）\n\n⭐️画原型的基本工具：墨刀、Axure\n交互设计的核心任务：使用界面语言向用户传递信息，并接收用户的反馈\n交互设计3步走：\n\n概括待表达的信息，清理需求点\n信息排序，需求点进行归类\n组织界面语言，画原型\n\n交互设计的基本原则：\n\n用户心理：同时努力平衡用户需求、商业发展目标和科技发展水平之间的关系\n操作可预期\n状态可感知：比如说点击播放视频，提示播放视频需要多少流量；或者角标提示有多少未读消息\n单一任务，逐次呈现：线性结构，单一任务的方式有利于用户在有限的屏幕上一次只关心并解决一件事情（注册、问卷调查等可用）\n阻断与非阻断式的平衡：比如说卸载360需要很繁杂的步骤\n一致性：在一个&#x2F;类产品内部，在功能相同或相似的场景上，应尽量使用表现、操作、感受等相一致的设计\n展示原则：页面选择元素不要超过5个，Less is more\n\n好的交互是可学习的，研究透一个平台的性质对你和用户都是有好处\n产品经理与交互产品经理要不要懂交互？要不要画交互？产品经理必须懂交互：\n","categories":["产品理论"],"tags":["产品-产品笔记"]},{"title":"产品设计-产品规划","url":"/2023/09/30/%E4%BA%A7%E5%93%81%E7%90%86%E8%AE%BA/%E4%BA%A7%E5%93%81/%E4%BA%A7%E5%93%81%E7%AC%94%E8%AE%B0/4_%E4%BA%A7%E5%93%81%E8%AE%BE%E8%AE%A1-%E4%BA%A7%E5%93%81%E8%A7%84%E5%88%92/","content":"\n从0到1的产品是如何诞生的：\n产品规划就是确定产品迭代的目标、主线、节奏，它将散碎的需求进行了分类，并形成了几个独立的板块，让后面的产品功能设计工作变得更加清晰和可行。\n产品规划是指产品规划人员通过调查研究，在了解市场、了解客户需求、了解竞争对手、了解外在机会与风险以及市场和技术发展态势的基础上，根据公司自身的情况和发展方向，制定出可以把握市场机会，满足消费者需要的产品的远景目标（Vision）以及实施该远景目标的战略、战术的过程。\n99%的复杂项目，需求调研的结果都只有一种可能：一地碎片\n⭐️产品规划三段论：JUMP IN、JUMP OUT、JUMP IN（跳入细节做调研，跳出细节做规划，跳入细节做验证）\n产品规划的意义：\n\n目标聚焦，团队达成共识（接下来解决什么问题？）\n路径清晰（分几个阶段？先做什么？再做什么？什么时候做？）\n价值显性化，资源支持，更容易拿到结果\n提升团队价值感、向心力和团队士气，让每个人以后都有故事可讲\n提升思考力，向上进阶必备（系统思考、学会选择、做正确的事比正确的做事更重要）\n\n产品规划四要素：\n\n定位：定位是贯穿整个产品的一条基准线\n蓝图\n节奏：每个目标分解为几个阶段？每个阶段的行动点是哪些？（Roadmap：时间周期、项目事件、路标）\n目标：先确认目标方向，为改善哪些目标而存在目标的SMART原则：具体的、可衡量的、可达到的、与其他目标具有相关性、有明确截止期限⭐️最终量化成具体的目标和数字（产品四大指标：用户体验、业务指标、财务指标、技术难度）\n\n","categories":["产品理论"],"tags":["产品-产品笔记"]},{"title":"产品设计-项目管理","url":"/2023/09/30/%E4%BA%A7%E5%93%81%E7%90%86%E8%AE%BA/%E4%BA%A7%E5%93%81/%E4%BA%A7%E5%93%81%E7%AC%94%E8%AE%B0/9_%E4%BA%A7%E5%93%81%E8%AE%BE%E8%AE%A1-%E9%A1%B9%E7%9B%AE%E7%AE%A1%E7%90%86/","content":"项目管理：项目管理是项目的管理者，在有限的资源约束下，运用系统的观点、方法和理论，对项目涉及的全部工作进行有效的管理，即从项目的投资决策开始到项目结束的全过程进行计划、组织、指挥、协调、控制和评价，以实现项目的目标\n项目经理PM（Project Manager）：目标驱动，系统思维，风险意识，数据量化\n开发模式：\n\n瀑布式开发\n敏捷式开发\n\n互联网的项目多以敏捷开发为主，敏捷开发的核心理念是以简单有效的方式快速达成目标，并在这个过程中及时响应外界的变化，做出调整（版本迭代）\n互联网产品研发项目主流程图：\n\n需求准备\n需求内审：评定需求优先级，评定需求可行性\n需求评审会：评审什么？⭐️小技巧：提前找负责该模块的开发及leader沟通思路产品经理的原则与调性：产品经理需要有自己的原则，以及愿意为此负责的担当和自信，对需求足够把握的时候，该强势的需要强势，当然，该听的意见要听。\n产品在研发阶段的定位：\n开发时间评估：\n测试用例评审：测试用例评审主针对研发和测试，产品经理建议在初期多参与，完善需求的异常逻辑及边界情况\n开发阶段常见问题：\n产品体验与测试：体验与测试阶段问题：\n发布阶段todo list：\n灰测：是在版本稳定后，让少部分用户参与提前体验，达到发现隐藏问题的目的Bug Review：\n发布阶段的产品验收：可能的问题：\nFAQ和客服培训：\n提示升级：提前预埋逻辑\n发布：发布后至少留守一个小时以确保服务稳定；协助客服处理紧急问题，适当的给予关怀；群的维护与核心用户周知（适合发布的时间是周二或周四的下午）\n上线邮件很重要\n数据汇报：汇报的意义：\n用户反馈：\n运营推广：对内运营就是对自己已有用户的运营，对外运营是对不知道自己产品的人的运营（百度搜索定义再完善一下）\n\n","categories":["产品理论"],"tags":["产品-产品笔记"]},{"title":"产品设计-原型及需求文档","url":"/2023/09/30/%E4%BA%A7%E5%93%81%E7%90%86%E8%AE%BA/%E4%BA%A7%E5%93%81/%E4%BA%A7%E5%93%81%E7%AC%94%E8%AE%B0/8_%E4%BA%A7%E5%93%81%E8%AE%BE%E8%AE%A1-%E5%8E%9F%E5%9E%8B%E5%8F%8A%E9%9C%80%E6%B1%82%E6%96%87%E6%A1%A3/","content":"产品原型使用工具：墨刀、Axure需求文档使用工具：墨刀使用工具Axure（Visio）进行流程图绘制\n产品设计阶段：\nPRD（Product Requirements Document），通过文字的形式将产品的需求特性与逻辑描述出来\n需求文档给谁看：交互设计、视觉设计、项目经理、开发、测试、其它产品经理、其它需要了解业务逻辑的人\n需求文档的作用是什么：\n\n准确、直观、完整传达产品需求\n保证各角色沟通有依据\n保证产品质量控制有标准\n存档\n\n需求文档的核心：以表达为目的，让查看的人清晰易懂\n需求文档主要结构：\n\n需求背景：让项目参与者明白为什么启动该项目\n项目目标：让项目参与者共识目标，找到价值感；目标尽可能量化；上线后验证目标达成情况的依据\n修订记录：修订日期、修订人、修订说明、修订原因、修订文档版本号\n功能列表：拆分成最小的功能点；功能点之间相互独立；方便参与者理解需求，评估工作量\n逻辑展示（流程图）：弥补与程序员的思维差异、帮助自己梳理思路、避免需求遗漏考虑不周流程图的基本结构：顺序结构：选择结构：循环结构：\n详细描述：正常逻辑描述、不同状态逻辑描述、异常逻辑描述、边界情况（一般指输入和输出的边界）\n数据需求（如果没有BI支持，需要产品经理自己定义埋点事件，不同的数据统计工具，不同的埋点规范）：数据需求的采集标准：理论上所有用户端新增功能都需要采集、改动&#x2F;优化点需要进行前后数据对比、版本的核心数据指标数据采集的类型：基础数据、交互数据、用户路径⭐️业务数据是通过服务端存库完成的；用户行为数据是通过前端埋点实现的\n风控说明或性能需求：可能出现的风险点和策略\n\n产品经理既能宏观至战略，又能微观至一个文本框的各种边界和异常\n","categories":["产品理论"],"tags":["产品-产品笔记"]},{"title":"数据运营","url":"/2023/05/31/%E4%BA%A7%E5%93%81%E7%90%86%E8%AE%BA/%E8%BF%90%E8%90%A5/%E8%BF%90%E8%90%A5%E7%AC%94%E8%AE%B0/6_%E6%95%B0%E6%8D%AE%E8%BF%90%E8%90%A5/","content":"基础数据运营都在做什么\n不同拉新渠道，效果好坏不清楚？\n活跃下降的原因是什么？\n活动结束后效果如何？\n版本迭代后，用户是否买账？\n内容规划完后怎么知道效果？\n\n数据运营分成四个环节：数据收集、数据加工、运营策略、数据反馈。这是一整体完成的数据运营闭环。\n基于业务框架如何做数据分析按运营业务工作进行数据框架梳理。脑图中是我们需要关注的数据指标，一般在第三方数据平台都能查询。只要制定好可衡量的业务目标，再通过数据去分析，基本就算是“入门”了，入门之前，请先确认自己对所负责的业务足够熟悉！\n用户运营重点数据指标：留存\n\n次留在40%～50%+就很高了，主要影响因素是“产品体验好、刚需（马斯洛）”\n7留在25%～30%+很高，主要影响因素是“关系黏性、场景”\n14留在20%+很高，主要影响因素是“场景、刚需”\n30留在15%～20%+很高，主要影响因素是“场景、刚需”\n\n留存基于业务的分析：用户留存的情况一般用留存率来衡量。所谓留存率，就是指一组用户在初始时间（比如首次打开应用）之后第N天，还在使用产品的用户比例（即留存下来的用户比例），一般称之为N天留存率\n\n新增用户留存（通过渠道进行对比）\n内容对用户的留存\n活跃用户的留存：活跃用户留存与新增用户留存很相似，只不过不再以用户首次使用作为初始条件，而是只要用户在某一天使用过应用，就从这天开始计算他的留存\n\n用户运营重点数据指标：活跃\n\n按小时纬度的活跃：用户都在哪些时间段活跃\n按月、周、日纬度的活跃：用户对产品使用情况如何\n按用户分层的活跃：用户分群的活跃情况如何\n按渠道、版本、区分的活跃：用户画像、产品改版的活跃情况如何\n\n内容运营重点数据指标：内容转化互动，指标体系有业务数据、页面数据CTR、行为数据（滑动&#x2F;切换）、用户数据（新老用户）\n活动运营重点数据指标：行为路径转化，指标体系有业务数据、页面数据（曝光、CTR）、分层数据、用户数据（新老用户）\n\n如何运用第三方数据分析平台市面上经常用的第三方统计平台：可视化、简单、实时\n数据分析运用在拉新业务中当我们需要为产品拉新，我们如何操作：（数据分析三步走）策略前分析：周期推广、基于产品调性我需要什么用户策略中分析：周期推广、日常数据监控哪些指标（实时新增、留存、活跃、用户忠诚度、黏性)策略后分析：数据指标对比\n⭐️数据分析和运用是贯穿在运营策略中的，脱离了业务本身的数据分析并没有什么用。\n数据分析的常用四种方法：\n数据分析在运营中的基本原则：策略+方法+数据分析\n如何提数据需求\n需求表达要有逻辑\n清楚需求本身的意义\n提数据需求之前应该基于业务分析、提数据需求最好站在业务之上全局考虑\n\n利用excel做原生数据时简单分析：\n\n柱形图反映一段时间内数据的变化，或者不同项目之间的对比。\n条形图是显示各项目之间的对比，其分类轴设置在横轴上。\n饼图显示组成数据系列和项目在项目总和中所占的比例。\n圆环图也显示部分和整体之间的关系，但是可包含多个数据系列。\n\n如何根据业务写数据分析报告\n日常数据通报（日报、周报）：以定期数据分析报表为依据，反映计划的执行情况，并分析其影响和形成原因的一种数据分析报告（进度性、规范性、时效性）\n专题分析报告：对项目的某一方面或某一问题进行专门研究的一种数据分析报告，为决策者制定某项政策，解决某个问题提供决策参考和依据\n\n","categories":["产品理论"],"tags":["运营-运营笔记"]},{"title":"产品设计-产品设计理念","url":"/2023/09/30/%E4%BA%A7%E5%93%81%E7%90%86%E8%AE%BA/%E4%BA%A7%E5%93%81/%E4%BA%A7%E5%93%81%E7%AC%94%E8%AE%B0/5_%E4%BA%A7%E5%93%81%E8%AE%BE%E8%AE%A1-%E4%BA%A7%E5%93%81%E8%AE%BE%E8%AE%A1%E7%90%86%E5%BF%B5/","content":"产品是指能够供给市场，被人们使用和消费，并能满足人们某种需求的任何东西，包括有形的物品、无形的服务、组织、观念或它们的组合。\n产品思维：如何把自己打造成满足用户需求的产品经理？\n互联网产品：通过互联网为介质，提供给市场，被人们使用和消费，并能满足人们某种需求的东西\n互联网产品设计：是指基于战略需要和用户需求，形成方案，直至实现方案完成为止的一系列工作的准备和管理（互联网产品设计不等于画原型、写文档）\n产品设计的基本流程：自下而上，从抽象到具体，从概念到落地方案，注意，一个产品不一定都有这些内容\n如何做模块拆解：\n\n系统不等于模块，拆系统不等于拆模块\n模块是从产品应用诉求出发的一种功能分类，拆解模块需要考虑功能的类同性和用户的操作便利性\n\n什么是产品架构：产品架构设计是产品设计的最顶层，他描述了整个产品运作的架构原理，告诉我们各个产品单元之间是怎么进行运作的\n什么是应用逻辑：他分成逻辑链和逻辑说明两种，核心逻辑中，很多用逻辑说明图说不清楚的，也需要在PRD文件中用文字来表述\n产品设计的基本方法：产品设计的那些“套路”\n\n人性法（产品设计中常被利用的人性弱点）：\n\n任性：用拼多多的人如果买一样东西比别人便宜她会感到满足，实际她也不缺这点便宜的钱，满足了用户的任性心里，证明她会买东西（产品战略转型，就是对用户心智的改变）\n恐惧：利用恐惧（得到App，天天宣传不学习就会淘汰）、消除恐惧（淘宝的物流信息，用户可以实时查看快递进度）、（喜欢确定感）\n懒惰：比如说用户想在App上买西瓜，打开App后出现了智能推荐猜你喜欢，用户可能就看中了推荐上的葡萄，懒得买西瓜了（喜欢简单的事物）\n虚荣：朋友圈（喜欢展示自己、喜欢被关注）\n贪婪：理财、陌陌（喜欢美好的事物）\n从众：买家秀卖家秀（被大众影响）\n\n映射法：互联网最大的价值和魅力在于，它让人们在虚拟世界中模拟各种各样现实生活场景，并使这些生活变得更加便捷、有趣（在线购物也有购物车、收银台）\n参考法：腾讯（一直在模仿，从未被超越），模仿不等于抄袭，接地气微创新\n\n","categories":["产品理论"],"tags":["产品-产品笔记"]},{"title":"产品设计-产品结构","url":"/2023/09/30/%E4%BA%A7%E5%93%81%E7%90%86%E8%AE%BA/%E4%BA%A7%E5%93%81/%E4%BA%A7%E5%93%81%E7%AC%94%E8%AE%B0/6_%E4%BA%A7%E5%93%81%E8%AE%BE%E8%AE%A1-%E4%BA%A7%E5%93%81%E7%BB%93%E6%9E%84/","content":"设计落地三节课：\n产品结构是基于前期的需求分析以及市场竞品分析等为依据，将各个需求点以某种逻辑系统化的组织起来所形成的立体结构，基于该结构，可以顺利的引导用户行为或将各类信息进行顺畅的流转\n结构的意义：\n\n不同的结构，代表了你产品未来的扩展性和扩展方向（比如快手和抖音仅仅从用户发现内容这一层，结构上就有很大的不同，抖音是沉入式，快手是寻找式）\n用户了解产品的第一印象，结构决定用户对产品理解的难易程度\n产品结构体现了产品定位和发展方向\n\n设计产品结构的依据有哪些：\n\n用户特性\n战略方向\n产品定位\n功能相关性\n\n常见的产品结构：\n\n线性结构：如同看电影一般，一个场景向一个场景推进，引导用户跟着走，目的性较强（注册登录）\n层级结构：结构清晰易懂、有较高的操作效率、扩展性强（苹果官网顶部导航引导用户快速的去想要去的地方） \n矩阵结构：可以同时满足不同用户，承载的信息更多，展示效率更高（PC端的携程网页）\n自然结构：鼓励人们探索，提高产品趣味性，常见在游戏、资讯等类型产品（抖音）⭐️产品发展分不同阶段，不同的结构有不同的特点，适应不同的场景，各个结构的组合能更好的解决问题\n\n常见的产品构建方式产品的主要功能架构是骨骼，先做产品结构，再做功能细节，将要迭代的功能，融入现有产品结构中\n产品结构的构建方法：从粗到细、从上到下、从下到上\n一个好的产品结构所需的要素：\n\n与产品目标和用户需求相对应\n具有一定的可扩展性\n层级深度适合\n用户理解\n\n","categories":["产品理论"],"tags":["产品-产品笔记"]},{"title":"《简约至上-交互式设计四策略(第2版)》","url":"/2025/07/01/%E4%BA%A7%E5%93%81%E7%90%86%E8%AE%BA/%E4%BA%A7%E5%93%81%E7%90%86%E8%AE%BA%E4%B9%A6%E5%8D%95%F0%9F%93%9A/%E7%94%A8%E6%88%B7%E4%BD%93%E9%AA%8C(%E4%BA%A4%E4%BA%92%E8%AE%BE%E8%AE%A1%E3%80%81%E8%A7%86%E8%A7%89%E8%AE%BE%E8%AE%A1)/%E3%80%8A%E7%AE%80%E7%BA%A6%E8%87%B3%E4%B8%8A-%E4%BA%A4%E4%BA%92%E5%BC%8F%E8%AE%BE%E8%AE%A1%E5%9B%9B%E7%AD%96%E7%95%A5(%E7%AC%AC2%E7%89%88)%E3%80%8B/","content":"话说简单关于简单的故事为什么安装打印机不能像插电源插座那么简单？\n简单的威力简单易用，因此能够为大众所接受；值得信赖，因此会赢得用户；适应性强，因此总会发展出别具一格的应用方式\n简单是极具破坏性的策略\n复杂的产品不可持续我们渴望简单，却被复杂的产品吸引，这种现象称为“夸耀效用原理”，人们喜欢自己被包围在不必要的功能中\n不断向软件中增加功能，同样也是不可持续的\n客户希望增加功能，投资人也希望通过新功能提振产品。有时候他们是对的。然而功能越多，就越难发现真正对用户有价值的东西。新功能总有一天会归于平淡。增加复杂性意味着遗留代码越来越沉重，导致产品维护成本越来越高，而且也越来越难以灵活应对市场变化。与此同时，用户也会渐渐地对你的产品越来越不满意，因为增加的复杂性导致他们很难找到自己真正需要的功能。况且，想到为那么多没用的功能买了单，他们会不高兴。无法理解的功能也让他们感到害怕\n功能吸引人，并不意味着到手后用户会喜欢，虽然用户的胃口看起来很大，但转眼间他们可能就会跟你反目成仇\n所有不必要的功能都是要付钱的\n冒充简单比如说明书、操作向导、减肥药，它们会让事情变得更复杂，效果更差\n借助这种额外的东西不可能营造出简单的用户体验来，用户只会觉得又多了一件事要做\n问题不可避免面对复杂，为什么用户不能学习？\n\n压力会导致技能出问题，越复杂或少用的知识，忘记就越快，这也解释了为什么技能会在我们最需要的时候出问题\n复杂系统的专家经过训练，在紧急时刻能放慢自己的节奏\n所以，复杂的代价不仅是学习，还包括知道在压力下放松自己。要做到这些需要经验，还需要更多的训练，因为这不是每天都要做的，用户不可避免地会赶时间，会分心，会忘记自己学过的东西\n\n在最大的压力下，用户需要最简单的方案\n寄希望于用户学习是不可持续的\n真正的简单有两种简单：第一种发生于我们探索问题之初。此时，我们的知识不完整，我们的想法简单化，并因为过于简化而抓不着重点。但随着问题理解得越来越深入，我们了解到它有多复杂。各种问题、微妙之处，还有相互关联的地方，都是我们始料不及的。此时，我们的解决方案也是复杂的，没有说明书就很难理解。某一天，我们开始意识到更底层的模式，并发现一种不同的简单方案。这个方案试图把整个宇宙的复杂性都打包到几个问题里。复杂性还在，只是随时准备被拆开，但我们现在可以通过包装来实现真正的简单\n不是那种简单法在做技术产品的设计时，至少有三个角度：管理人员、工程师和用户\n有时候，通过简单的技术或者简单的管理，就可以创造简单的用户体验，但也不尽然。Google背后的技术可谓复杂，但他们雇用了几千人就是为了让用户在因特网上搜索信息变得简单\n一个人在一种情形下感觉简单的事物，换一个人或者换一种情形，可能就不会觉得简单了\n特征简单并不意味着最少化，朴素的设计仍然具有自身的特征和个性（夏克椅和安乐椅）\n材料、要突出的设计要素，甚至组合几个要素的方式，都会直接影响到最终设计\n简单并不意味着欠缺或低劣，也不意味着不注重装饰或者完全赤裸裸，而是说装饰应该紧密贴近设计本身，任何无关的要素都应该予以剔除\n抛开极简主义，也能够成就简单，简单的特征和个性应该源自你使用的方法、所要表现的产品，以及用户执行的任务\n专心致志简单源自专注，明确自己的目标，更容易迷途知返\n针对个别客户进行优化是一个有效的策略，只要客户愿意支付额外的代价即可。围绕简化产品线进行优化也是一个有效的策略，只要你愿意忽略某些客户的特殊需求就行\n如果你追求简单，就需要明确知道如何在用户头脑中建立简单的感觉。但在你能够做到这一点之前，先要有专注的视野。为此，我们必须协调不同的观点。应该服务哪些客户？应该解决什么问题？应该考虑为明天优先积累技术，还是应该快速满足用户今天的需求？协调各利益相关方冲突的声音，协调你自己头脑中冲突的声音，都需要仔细和专注\n愿景：一张蓝图绘到底搞清状况在设计功能时，你需要一种方式来评判自己是否在坚持简单之道。当几种想法互相抵触时，复杂性就显现了，好的愿景让你明确什么是必须做的（提问的方式非常重要：用户在这里真正想干的是什么？）\n不管问题大还是小，你的愿景都应该聚焦于用户，应该能帮你理解发生了什么，以及为什么\n起点往往是一堆纠结的想法\n共识如果是为一家组织设计，那么其他人以及利益相关方都会牵扯进来。一般来说，这些人会从不同角度引入分歧，从而拖慢进度。事情糟糕到一定程度，项目就宣告失败\n为推动项目进展，似乎应该听取每个人对设计的意见，但是，没有人喜欢委员会的设计，因为大家都知道那是个杂糅各种想法和折中的结果\n不要通过交换和折中达成一致，而要通过共识。如果大家都觉得自己在为同一个目标努力，摩擦就会减少，就能找到正确的方案（做对组织的最终用户有利的事）\n把所有利益相关方的目标都统一到最终用户身上，通过共识构建愿景，然后，阻力和争斗就会减少\n但不要期望他们能很快理解用户需求，不同部门会从不同的视角看待最终用户\n走出办公室用户体验是否简约，必须要在纷乱、多变的环境中才能考察出来\n如果你想给所有人设定一个愿景，那需要先到用户实际使用你产品的环境中做个调查。实地调查经常会转变你的设计思路\n无法控制用户使用软件的环境，必须使软件设计符合环境需求\n产品使用环境是观察用户的最佳地点\n观察什么办公室、家里、户外\n在家里、在公司、在户外，你的设计必须能够适应各种干扰，能够在人们被打断的间隙生存\n三种用户可以把用户分为三种类型：\n\n专家型用户愿意探索你的产品或服务，并且会给你提出各种改进建议。他们希望看到为他们量身定做的前所未有的技术。即便拿到的是一个从未见过的产品，他们也会摆出专家的态度。换句话说，他们舍得花时间研究新产品，探索产品的新功能。不过，这一类用户总体上占少数\n第二类可以叫作随意型用户，他们可能使用过类似的产品或服务。他们有兴趣使用更高级、更复杂的产品，却不愿意接触全新的东西，要想让他们认可新功能，那么新功能必须足够简单。这一类用户比你想象得少，而且他们的学习意愿不强烈\n最大的一个用户群体是主流用户。他们自己不会因为你的技术而使用你的产品，使用你产品的目的是完成某项任务。他们会掌握一些重要功能的使用方法，但永远不会产生学会所有功能的想法，大多数人属于这一类\n\n即便一个产品用了很多年，用户类型的标签也是不会变的。各人对技术所持的态度与他们在使用产品或服务上花费的时间相比，前者对他们的影响更大\n针对前两种类型的用户设计产品或许更有诱惑力，他们更识货，不过，感觉简单的体验却是主流用户所喜爱的\n主流用户占绝对的主体地位，专家型和随意型用户只是少数派\n为什么应该忽略专家型用户大多数公司都会在听取专家型用户的意见上花费很多时间，这些用户都是使用他们产品或服务时间最长的，因为跟这些用户会有很多共同语言\n专家型用户都是技术狂热者，他们能够畅所欲言，对如何改进当前产品固执己见\n然而，专家并不是典型用户，他们的判断会出现偏差，他们不会体验到主流用户遇到的问题，他们追求主流用户根本不在乎的功能\n你会发现，要想说服投资人不去轻信专家型用户的意见是很困难的\n可是，一旦先听了他们的意见，你的产品就会让主流用户感到太复杂，不好用\n专家想要的功能往往会吓倒主流用户\n为主流用户而设计如果你想设计简单的产品，记住要为主流用户而设计\n想吸引大众，必须关注主流\n主流用户想要什么在设定愿景时，要时刻把主流用户放在心坎上，这样才不至于无意间切换到专家视角，从而避免一些难以察觉的设计问题\n不要指望你能教会用户多少东西，或者认为说明书可以帮助他们。在面临压力的时候，他们很容易忘记已经掌握的知识，对操作说明视而不见，回到初学者的层次上\n简单的用户体验是初学者、新手的体验，或者是压力之下的主流用户的体验\n深层需求问“用户在这里真正想做的是什么”，意味着要发现用户的深层需求（深层的感情需求）\n为什么用户会使用我们的软件？\n体现品牌特征如果你在为一家组织设计，那么你的产品必须符合它们的品牌定位，符合这种期望的设计，就会让人觉得简单\n品牌的三方面特征如下：\n\n实用性：这个品牌能做什么对我有帮助的事情？\n情感：这个品牌给了我什么感觉？\n价值观：这个品牌崇尚什么？\n\n关键在于包含恰到好处的特征，同时不要忘记你要追求的简单\n品牌不是标志，而是体验\n简单意味着控制从简单这个角度来看，最重要的是让用户感到自己在掌控一切\n\n用户希望感觉是在掌控自己使用的技术，主流用户可不管什么软件或者技术，也不想让产品告诉自己该做什么，他们只希望自己掌控起来容易、可靠、迅速。你的设计不能跟这种掌控的感觉有什么抵触，而是应该放大这种感觉。简单的体验会让用户自信做出了正确的选择。简单的体验会让用户没有后顾之忧，因为产品的响应方式都是意料之中的\n\n只有知道用户是谁以及他们的真实想法，你才可能有自己深刻的见解\n正确选择“做什么”设计之所以会变复杂，通常是因为某些不重要的步骤挤占了核心特性，或者忽略了为设计提供上下文的步骤（比如拍完照片可以很方便的分享出去）。在设定愿景时，正是这些步骤保证你简化体验\n对于创建简单的体验而言，这些“上下文”步骤与那个“核心”步骤同样重要\n你最应该关注的是用户行为而不是你的设计，关注核心行为，并且从用户的视角把它描述出来，绝对不要漏掉关键环节\n描述用户体验在研究某个问题的时候，你需要把它转换成一种认识。故事是描述认识的一种好方式。与一大堆需求描述相比，故事更容易让读者明白什么重要和为什么重要\n故事应该用三言两语把核心体验表达出来\n故事可以把大量信息浓缩到寥寥数语之中，效率极高。而且，故事很容易记住，很方便与人分享\n有必要多花点儿时间把故事的每一个细节都想清楚。如果你想让自己的设计简单，每一个细节都至关重要\n讲故事不要担心故事的表现形式，关键是通过这种形式把约束条件表达清楚，以便与他人分享。故事可以是几句话，也可以是一串故事板、一组原型或一段视频\n\n故事的情节要简短，要通过一个小故事展示出每一个需求点，并确定满足该需求的功能（核心功能）\n展示，而不是讲。描述用户的行为与介绍用户的性格相比，前者给人留下的印象更深刻\n不要编造\n\n好的用户故事应该简明、具体、可信，并且拥有相关细节\n环境、角色、情节我们讨论的愿景，大致可以分为三个层次：\n\n可信的环境（故事中的“时间”和“地点”）\n可信的角色和动机（“谁”和“为什么”）\n流畅的情节（“什么”和“怎么样”）\n\n很多复杂的设计都是因为没有考虑到现实世界的压力而导致的，或是因为设计者期望用户自己能够应付一切，或是因为他们不小心漏掉了某个重要的环节。你的设计应该与你所讲的故事完美契合\n如果在情节上遇到麻烦，就返回到角色，设想角色会怎么做。如果在角色上无法做文章，就去挖掘环境，看看环境会如何影响角色\n把你的设计放在一个情节中，情节中有可信的角色，发生在可信的环境中\n极端的可用性设计简单的体验意味着要追求极端的目标\n争取你不可能达成的目标有一个重要的好处：保持正确的方向\n瞄准极端的目标，即使是那些无法完全实现的目标，也能够帮你保持产品简单\n简便的方式尽可能用最简单的词汇描述你的想法\n洞察力\n回顾一下你从用户那里收集的素材、他们面对的问题、他们生活的世界，把那些对用户行为影响最大的事情放在前面\n从你的故事中寻找突破口\n把这些设计要点按先后次序排列出来，哪一个因素影响最大？哪方面容易改变？\n验证你的见解。如果你的见解有偏差，会导致什么结果？有哪些不可控因素会影响你的看法？有没有正反面的例子可供参考？这些例子能否反映出你的看法有问题，或者例子本身就有问题（例如，没有将设计贯彻到底）？\n\n验证你的想法意味着还要花更多时间观察现实中的人，通常可以使用原型或者竞争性产品作为辅助。只有通过验证，才能知道你的见解到底有没有价值\n花点时间深入构思你的故事，花点时间观察和研究你的故事背后的数据\n总结出正确的愿景作为设计者，我们希望马上开始设计，但克制自己非常重要，太早开始意味着会遗漏重要的见解，甚至意味着设计思路完全错误\n花点时间理解这个问题可以帮你想出更好、更简单的方案\n乍一看到某个问题，你会觉得很简单，其实你并没有理解其复杂性。当你把问题搞清楚之后，有会发现真的很复杂，于是你就拿出一套复杂的方案来。实际上，你的工作只做了一半，大多数人也都会到此为止，但是，真正伟大的人还会继续向前，直至找到问题的关键和深层次原因，然后再拿出一个优雅的、堪称完美的有效方案\n不要匆忙着手设计，理解核心问题需要时间\n分享比如在公司里到处张贴海报\n与别人分享你的愿景，即使你不在场也能保证做出正确的决定。而且，你的所有利益相关方都能说出什么是好的决定，什么是坏的决定\n让最核心的理念随处可见，提醒人们时刻谨记。随时随地使用，让它成为人们时刻不忘的追求。把它公之于众，意味着团队所有成员都知道自己应该交付什么样的功能\n简约四策略变化曲线简化意味着改变，而改变始终意味着痛苦，多数人会不惜代价避免痛苦，因此简单的愿景总会遇到阻力，这时候，只谈收益而不谈痛苦是不可取的\n变化的三个阶段：\n\n第一阶段是当前大家都很舒适的状态。此时要问的问题是，你认为我们今天在用的方案100年后还会再用吗？答案当然是不会。改变不能避免。我们要知道的只是什么时候改变最合适。收集需要改变的证据很重要（也许你知道竞争对手要发布更新了）\n第二阶段是痛苦时期，改变了某些东西后，现有的一些客户会抱怨，你的同事必须做出相应调整，业绩会下滑。此时的问题是，下滑幅度多大，下滑时间多长？凭经验或用户研究也很难估计。关键在于，你知道痛苦一定会来，因此你们可以讨论自己准备承受多大的损失。如果改变复杂且耗时长，那可能需要两个产品并行（很多网站在全量上线新版本之前，都会先放量一部分用户进行测试）\n最后阶段是收益，如果新设计不错，可以看到曲线上扬，而这最终带来收益。用户研究可以预测这个提高幅度有多大。有时候，根据这个预测就足以证明会有提升了。如果不行，说明还需要更多数据，那必须进行大规模研究\n\n面对不可避免的改变，你会做什么？\n改变策略终有回报\n\n愿景与战略怎么让利益相关方听自己的？必须理解他们的想法\n你的愿景应该涵盖客户和他们的需求，以及如何实现他们的需求。而要兑现承诺，必须再回头考虑你服务的组织，你需要理解自己组织的策略\n战略是对当前状况的一种诊断，基于它可以制订优秀的方案和长期规划，以便在竞争中立于不败之地\n一家公司为寻求竞争优势，有三种战略可以选择：\n\n差异化：通过树立壁垒来维持较高价格\n低成本：通过控制成本费用实现利润最大化\n专一化：专注于某个细分人群或细分市场\n\n组织应该聚焦于一个战略，或总有一种主战略和一种辅战略，做设计决策时总有一个优先级\n不管什么战略，目标都是建立稳固的用户群以保证生存（通过获得收入或保持黏性）\n理解组织的战略有助于把愿景统一到公司目标上，并且有助于确定简单的方向\n每家公司背后的简单方程多数公司的背后都有一个方程，大致如下：（售出汽车的数量）*（汽车价格）-（总成本）&#x3D;（盈利）\n\n你需要理解简单的用户体验对这个方程的每个部分都有什么影响\n然后，需要对改变排出优先级，对比每项改变的重要性与可行性，对重要性和可行性加以量化，用固定的分数来表示\n\n改变的优先级列表：\n\n摒弃“速效方案”只考虑成本（或可行性）来排列改变的优先级会导致一个问题：预期的改变列表中会充斥着“速效方案”，专注于实施“速效方案”慢慢地会累积很多问题\n既要看到“影响”，也要看到“可行性”（或成本）\n改变分为三类：\n\n速效方案：快速生效\n基础方案：会产生巨大影响或让其他改变更容易\n战略方案：让产品与公司战略及愿景统一起来\n\n好的产品管理方式能在这三类改变中有效地分配时间，无论短期的还是长期的。通过这样改变分类，可以认识到要做的不同工作，让改变有了可比性\n触手可及的果子不一定总鲜美\n积跬步而至千里组织经常在希望看到令人激动的变化和希望变化安全可控之间摇摆\n无论大小，任何组织都由各种人构成，因此肯定会遇到优先级冲突的问题\n一种应对策略是不再关注改变，而是关注用户的问题\n\n通过最小的变化给用户和团队传达一个信息，即“我们正关注这件事”，不仅能简化流程，而且会让所有人都参与到解决问题中来。这一步很安全，而且能够迅速看到回报，但高层领导可能会不耐烦\n研究如何交付更让人眼前一亮的方案，根据情况尝试可用的技术\n大规模交付，去实现高层领导所期望的亮眼方案\n\n通过把想法与解决用户问题联系起来，可以得到一个粗略的路线图：从“有所改进”到“哇噢”，并且，借此可以获取组织中不同人群的支持\n注重细节研究任何简单的体验都会发现，设计团队在很小的细节上面都会付出可观的时间\n边际效用累加：假如把骑行相关的一切都细分，然后每一项都提高一个百分点，那么汇总起来就是巨大的提升\n最好与其他的差别在于细节\n四个策略怎么判断什么是不必要的复杂性，怎么简化这种复杂性？（以遥控器为例）\n\n删除：去掉所有不必要的按钮，直至减到不能再减\n组织：按照有意义的标准将按钮划分成组\n隐藏：把那些不是最重要的按钮安排在活动仓盖之下，避免分散用户注意力\n转移：只在遥控器上保留具备最基本功能的按钮，其它控制通过电视屏幕上的菜单、语音或手势来实现，从而将复杂性从遥控器转移到电视\n\n每个策略都有其优点和不足，针对手上要解决的问题，从中选择正确的策略，是取得成功非常重要的一环\n删除删除很多大公司虽然现金充裕、产品畅销，却无法持续成功和创新的原因？技术不断进步，大公司跟不上，但大公司通常会推动技术发展，因为他们在研发上投入巨大\n简单的产品更容易制造（成本也更低），也更容易使用（市场也更广）\n删除杂乱的特性可以让设计师专注于把有限的重要问题解决好，而且也有助于用户心无旁骛地完成自己的目标\n完美并非加无可加，而是减无可减。删除作为一个策略难就难在明白怎样做到这一点\n简化设计最明显的方式就是删除不必要的功能\n什么不能删截止日期当前，首先被砍掉的往往是实现难度大的功能。理由是这样能保证先发布一个MVP（最低限度可用产品），其他功能以后可以再加。但MVP应该符合愿景并提供某种价值，而以后再加功能必须是你有时间，而且有钱去做才行\n不要等着别人不分青红皂白地、无情地删除最有意思的功能。要总揽全局，保证只交付那些对用户体验而言真正有价值的功能和内容\n找到核心所在体验的核心是最能打动用户的东西。找到它，删什么留什么就一目了然了\n在按照优先级对功能排序时，要记住关系到用户日常使用体验的功能很有价值，但不一定是最常用的功能，以此为起点，可以开始编写你的用户故事\n另外，能够消除用户挫折感的功能同样也会受到欢迎，在描绘用户故事时，别忘了寻找常见的挫折和难题，解决这些问题的功能的优先级次之\n与新增功能相比，客户更关注基本功能的改进\n砍掉残缺的功能删掉实现得不够理想的功能也是很重要的（注意沉没成本误区）\n功能和内容会给用户造成精神上的负担（“这个需要看吗”），会导致一定的维护开支（总要有人保证内容与时俱进，功能持续有效）\n任何功能都需要你和用户付出代价，因此功能必须有价值\n问题绝非“为什么应该去掉它”，而是“为什么要留着它”\n以“去掉它们是一种浪费”作为理由而抓住残缺的功能不放，可能会妨碍你成功\n假如用户…“假如用户想…”意味着任何待删功能都可以安然无恙地回到产品中\n搞清楚这个功能对用户是否真的重要？我的目标用户经常会遇到这个问题吗？\n不要猜测用户可能会或者可能不会怎么样\n但我们的用户想要不要简单地因为客户要求就增加功能\n对用户的要求做逆向工程：搞清楚用户到底遇到了什么问题，仔细斟酌这个问题是不是应该由我们的软件来解决\n功能多了之后，通常会导致在其他某些方面做出一些牺牲，而客户则不会考虑这方面的问题\n增加功能不一定会让用户体验更简单，反而经常会导致更多的迷惑\n要倾听用户的意见，但不能盲从\n导致出错的功能如果一个小变化导致了复杂的流程，就应该退一步想，把注意力集中到客户的目的上，去寻找更好的解决方案\n错误提示即使非常小的错误提示也会让用户烦恼，消除错误提示是简化用户体验的重要途径\n在设计简单的体验时，关键的一步是确定哪些地方需要错误提示\n如果功能不是必要的想要设计一款引人注意的产品时，删除功能表面上看会冒一定的风险，却能获得长期的收益\n功能多对于没有机会试用的消费者有吸引力，但是消费者使用了产品之后，他们的偏好就会改变，一下子从重视功能变成了更重视可用性\n今天，口碑、用户评论、个人推荐以及产品试用的重要性已经远远超过了大众媒体广告。消费者在选择产品之前，都要听一听用户的意见，他们是已经对产品的可用性有所了解的人。因此，痛下决心砍掉不必要的功能，要强过无意义地堆砌功能\n你设计的产品如果承载过多的功能，更有可能降低主流用户的满意度，从而对产品的长期盈利能力造成损害\n长远来看，增加功能有害无益\n真有影响吗某项功能一旦发布，就一定会有人在某个地方使用它。如果用户喜欢它，就会改变自己的行为来适应这项功能。当用户离不开这项功能时，你再把它砍掉，即使是一个很不起眼的变化，都会激怒用户\n不过，有的依赖性还是比较容易消除的。对用户来说，真正重要的是什么？是你的设计能不能解决他的大问题。如果能，那么他就会顺从你，即使你的改变会让他不舒服\n最开始应该考虑的，是哪项功能最接近用户的核心需求\n要知道人们真正关心什么，探知他们对删掉某个功能后的产品有什么意见，最好的方法就是先做个原型让他们试用\n想在任何时候取悦所有用户是不可能的。因此，我们只能退而求其次，专注于目标客户的核心任务，只要让他们高兴、让他们满意就行了\n删除一项功能，对不同的用户影响不同\n排定功能优先级在确定什么功能该保留、什么功能该删除的时候，遵循如下原则：\n\n确定用户想要达到的目的，并排定优先次序\n专注于寻找能够完全满足优先级最高的用户需求的解决方案，找到之后再考虑满足用户的其他目标。不要因为多提供功能而影响核心功能的交付\n确定用户在使用产品过程中最常见的干扰源，并将解决这些问题的功能按难易程度排出优先次序\n去掉执行相同任务的重复方式\n\n不要以功能的多寡来认定产品的价值，而应该看产品能否满足用户最高优先级的目标。换句话说，观察人们如何使用原型\n负担人在处理信息、学习流程和记忆细节方面的能力是有限的。现实中，人所面临的干扰和最后期限压力是无法在测试中模拟的，这些都进一步限制了人的能力\n界面中的各种小细节会增加用户的负担，会像公路上的减速带或坑坑洼洼一样降低用户的效率\n去掉那些可有可无的选项、内容和分散人们注意力的玩意儿，可以减轻用户的负担，让用户专心去做自己想做的事。去掉分散注意力的视觉元素，可以让用户感觉速度更快、更可靠。把干扰性的细节都删除\n决策我们通常会为用户提供尽可能多的选择，但选择过多很容易让用户无所适从\n在为用户提供少量选择的情况下，用户购买的可能性要大于为他们提供大量选择的情况\n在选择少的情况下，用户购买之后的满意度要高于选择多的情况\n给用户提供选择会让人感觉自己在把控着局面，而在某些情况下人们更愿意少一些选择。如果选择超过了一定的界限，特别是在很多选择都相似的情况下，选择反而变成了负担\n分心如果想设计简单的用户体验，就该删除那些干扰因素，让用户注意力保持集中\n聪明的默认值选择聪明的默认值可以减少用户的选择，聪明的默认值指的是适合大多数人口味的选择\n当客户再次光顾网站或应用时，他通常愿意以上次离开的状态作为起点\n真正智能的默认值会“关注”你（或跟你一样的人）在做什么，然后预测你接下来的行动。很多消息类应用的建议回复就是很好的例子\n默认值是节省用户时间和精力的有效方式，也是清除设计蓝图中“减速带”的首选方式\n选项和首选项通常，选项是让用户自定义设置的。可以说，这是典型的专家行为，专家想要掌握自己的汽车，并且选择很多个性的配置，但主流用户只想买辆车开开\n网站导航设计一般有两种形式：面包屑链接和下拉菜单\n简单的用户体验不会强迫用户去做这种选择，哪种方式最有效应该是设计团队考虑的问题。解决这个问题的最佳途径就是请一些用户来测试。如果测试结果是两种方式不分伯仲，都没有明显的缺陷，就意味着没有“错误”的设计。赶紧选择一种方式实现，然后继续\n主流用户不喜欢为设置选项和首选项劳心费神\n如果一个选项还嫌多在向用户提供选择时，务必要考虑周全一些，想清楚用户会不会因为这些选项而不知所措，或者这些选项会不会动摇他们的决心\n主流用户希望“够好就行了，快点”，而专家则希望“尽可能完美，等多长时间都愿意”。如果你想要设计主流用户喜爱的简单体验，就问问自己，向用户提供这些选项会不会因为追求完美而牺牲速度和简单。如果是，就删除那些选项\n视觉混乱删除视觉混乱的元素意味着人们必须处理的信息变少了，能够把注意力集中到真正重要的内容上。用户所说的“干净”的界面，意思就是其中没有杂乱的元素\n要让“数据墨水率”越来越高，墨水（或像素）不应该浪费在那些不是内容的地方或者重复的内容上\n删除混乱元素很简单。观察设计方案中的每一个元素，想一想为什么需要它。它能够提供重要的信息，还是能够提供支持？先把它从方案中删掉，如果方案中没它不行，再把它拿回来\n以下是一些减少视觉混乱的方法：\n\n使用空白或浅背景色来划分页面，不要使用线条，因为线条在前景中，而空白和颜色在背景上，前景会更多地吸引人的注意力\n尽可能少使用强调\n别使用粗黑线，匀称、浅色的线更好\n控制信息的层次，如果页面中信息的层次超过了2或3个层次，就会导致用户迷惑\n减少元素大小的变化\n减少元素形状的变化\n\n删减文字多余的文字通常是浪费，用户不会一字不落地看完\n删除文字有下列三大好处：\n\n重要的内容“水落石出”\n消除了分析满屏内容的麻烦\n读者会对自己看到了什么更有自信\n\n删除引见性文字、删除不必要的说明、删除烦琐的解释、使用描述性链接\n精简句子对话一次交互就是用户与设备之间的一次对话\n两个人之间对话时，人会因为时间紧迫，共享的知识，以及出错的风险而长话短说，或者短话长说进行闲聊（人会随机应变）\n而计算机通常没办法感知用户是否赶时间，结果，很多交互都详尽、复杂、冗长\n时间压力、出错的风险和后果、以及共享的知识，这三个因素是人类用于简化对话的核心因素。在设计交互体验时，可以基于这几个因素，再视用户的情况来决定如何提供简单的体验\n砍掉时间使用软件、设备或服务也是有成本的，成本不一定是钱，而是时间\n砍掉功能和内容可以节省时间，因为决定少了、按钮少了、思考少了、阅读少了，而且服务本身更简单，开发更高效，运行也更快，这些都会节省时间\n要在对用户真正重要的事情上节省他们的脑力\n节省时间对用户很重要，焦点是怎么让人更快达到目标\n删减过多人们希望自己能够掌控局面，他们更愿意成为导航员，而不是过路人（没有操控装置的电梯）\n这里的关键在于让人们能够控制结果，换句话说，足够多的控制可以让他们消除因基本需求得不到满足而引发的焦虑，但要避免控制太多导致他们因选择而浪费时间（比如，电梯走多快，停多久？）\n你能做到一个大型组织的团队，能不能重新设计他们的网站，说服利益相关方删除内容和功能？\n简单的设计通常出自一位眼光独到的设计师、一位“无情的”或“毫不妥协的”创新者之手。但是，我们大多数人所在的组织中，妥协和让步已经成为常态。但是在共同愿景的基础上，在关注主流用户的前提下，通过彻底重新设计是可以达到简约之效的\n焦点“删除”策略的核心就是干掉那些分散注意力的因素，聚焦于项目\n\n聚焦于对用户有价值的功能。这意味着专注于那些承载用户核心体验的功能，也意味着交付的功能必须能够消除用户的挫折感，能够消除他们的焦虑\n聚焦于可用资源，通过删除残缺的功能、不切题的元素和花里胡哨的东西为用户提供价值\n聚焦于达成用户的目标，纠结于流程会陷入细节的泥潭而无法自拔\n删除那些干扰性的、增加用户负担的“减速带”，比如错误消息、不知所云的文字、不必要的选项和造成视觉混乱的元素\n\n注意不可避免的法律要件，不能删除里面必须包含的特定的内容或信息\n不能脱离环境删除某些功能\n删除混乱的要素可以让用户聚焦于真正重要的功能\n组织组织组织是简化设计的另一个重要策略，组织往往是简化设计的最快捷方式，组织是简化设计最常见的一种方式，而且这种方式一般不用太大投入，只是改变一下按钮的布局和标签即可，花不了多少钱，也不会面临像删除功能那样艰难的抉择\n在重新组织界面时，你会发现有各种各样考虑问题的角度，尺寸、颜色、位置、形状、层次。但是，从这些角度进行选择必须把握一个度\n如果想通过组织的方式来简化设计，要点在于只强调一两个最重要的主题。随随便便地组织不会让用户的注意力集中，只能让他们眼花缭乱\n分块用户界面设计离不开分块，这些烦琐的功能通过分块，被组织成了清晰的层次结构\n围绕行为进行组织用户会提出的第一个问题是：“我可以用它来做什么呢？”，因此，着手组织之前首先要理解用户的行为：他们想做什么，先做什么，后做什么\n人们一般都希望按照某种特定的步骤做事。打乱这个步骤就会造成迷惑，令人沮丧。此时最大的障碍是注册流程和有效性检查，如果不能去掉这个步骤，至少要想办法推迟，如果不能推迟，就要尽量简化它。要悉心了解用户心中的操作步骤，然后尽全力让流程与各个步骤的顺序吻合\n如果你可以把用户划分成两个完全不同的类别（如医生和病人），他们在网站上的行事方式截然不同，那么这就是一个良好的起点\n问题在于很多用户都具有类似的或重叠的目的，如果你没有很特别的用户群，可能就不应该按用户分类了\n画出用户的行为有助于理解如何组织你的软件产品\n是非分明在对一组性质相同的产品进行分类时，确定清晰的分类标准对用户非常重要\n简单的组织模式具有清晰的界限，是非分明。这样，用户才能明确知道到哪里去找自己想要的东西。因此，要多找一些用户，询问他们的分类标准。如果众口不一，或者根本就难以回答，你就有麻烦了\n有时候，你会遇到必须放到两个类别里去的东西，太多的重叠会导致困惑，但有时候确实无法避免。所谓最简单的分类，通常指的是重复交叉最少的分类方法\n好的分类是非分明\n字母表、热门程度和格式按字母排序的结果仍然很乱，虽然按字母排序看起来简单，但其结果通常很难用。按字母排序适合名词的索引，其中有一个“正确的”词描述某种东西，比如姓氏或国家\n按热门程度排序也有问题，因为不可能知道其他人喜欢什么\n按照格式（文本、图片和视频）来组织内容，也是一种看似简单其实没用的分类方式\n关键在于根据相关索引来组织项目。字母顺序适合人名，热门程度适合排名前100的电影，格式分类适合某些大会议程。选择与任务相关的索引很重要\n模式与锚定找到组织信息的正确方式，可以极大简化用户体验。恰当的模式可以让用户对信息一目了然，同时也让你提取出本质的信息\n按照人们都熟悉的模式来组织信息，用户识别和处理起来会非常快。找到其中的模式是简单的关键\n搜索有的用户认为搜索比浏览更容易，然而没有一个人始终会把搜索作为第一选择，只有在网站没有提供有效导航的情况下，用户才会使用搜索（当然也有例外）\n有的用户认为设计搜索功能要比组织内容链接更容易（其实设计简单的搜索界面要困难得多）\n如果你想设计简单的用户体验，那么最好先对内容有效地组织，然后再考虑如何设计搜索\n无论是设计还是使用，搜索都比浏览困难得多\n时间和空间按照时间来组织活动是一种简单又通用的方式\n一些实体对象，如酒店和国家之类的，全都可以按照空间来组织，只要用户对排列方式不感到陌生即可\n网格布局是否清晰明了，对于设计能否让用户感觉简单实在是太重要了\n利用不可见的网格来对齐界面元素，是吸引用户注意力的一种有效方式\n大小和位置在利用网格来布局界面项时，请注意参考如下关于大小和位置的提示：\n\n重要的元素要大一些，即便比例失调也可以考虑\n不太重要的界面元素应该小一些，要想办法表现出不同的重要性，否则用户就会被搞迷糊（如果一个元素的重要性为1&#x2F;2，那就把它的大小做成1&#x2F;4）\n把类似的界面元素放在一起，能够有效减少视觉上的干扰因素（如色标、标签或边框），也不必解释它们之间的关系。这样也可以让用户更容易集中注意力，因为他们不必在屏幕上东张西望了\n\n真正应该担心的问题是用户能不能轻易地找到想找的按钮\n感知分层利用感知分层技术，我们可以把一些元素放在另一些元素上方，或者把两组元素并排放置（比如地铁线路图），甚至还可以让散落在用户界面各个地方的元素之间建立联系（比如为购买按钮和购物车图标应用相同的颜色）。在使用感知分层的情况下，不一定要把界面严格分割成几个区域\n感知分层借助于颜色很容易实现。除了颜色之外，使用灰度、大小缩放，甚至形状变化，都可以实现感知分层\n\n尽可能使用较少的层，内容越复杂，所需的分层反而越少\n考虑把某些基本元素放在常规背景层，因为一个元素很难放在两层里\n尽量让任意两层之间的差别最大化，20%的灰度和30%的灰度很难让人分清。类似的，在选择颜色时不能忘记色弱的用户\n对于相对重要的类别，使用明亮、高饱和度的颜色，可以让它们在页面上更加突出\n对于同等重要的类别，利用感知分层技术，使用相同的亮度和大小，只是色调要有所区别\n\n色标色标系统是随处可见的，医院、文件夹、交通信号灯、尺码表、地图、仪表板，几乎无处不在\n期望路径人们并不总是走你为他们铺好的路\n如果你在描述用户使用软件的路径，千万不要被自己规划图中清晰的线条和整洁的布局所迷惑\n仔细观察其他人，问：“你为什么选择这条路径？”\n简单的组织意味着你在使用软件时会对什么感觉不错，而不是你在规划中看到了什么逻辑\n隐藏隐藏隐藏比组织具有一个明显的优势：用户不会因不常用的功能分散注意力\n无论隐藏什么功能，都意味着你在用户和功能之间设置了一道障碍，为了避免给用户造成不必要的麻烦，必须仔细权衡要隐藏哪些功能\n隐藏部分功能是一种低成本的方案\n不常用但不能少那些主流用户很少使用，但自身需要更新的功能，通常是适合隐藏的功能\n\n事关细节\n选项和偏好\n特定于地区的信息\n\n如果你的网站或应用程序中缺少了这些功能或控件，就会变得太通用，无法满足用户的个性化需求\n在寻找要隐藏的功能时，设置通常都是首选。设置与不常用的任务有很大的区别，因为后者一般会涉及外部目标（如给朋友发短信），而设置的目的则是让用户更好地使用软件\n自定义主流用户确实会自定义自己的设置，但是他们更感兴趣的是展示自己的个性，而不是重新设计用户界面\n让用户自定义自己的用户界面，是假设用户知道如何布局最有效、最高效\n自动定制有些程序会根据用户的行为自动显示或隐藏某些功能（程序会记住你经常使用的命令，并对菜单自动调整，最终只显示你最常用的命令，隐藏其他命令）\n自动定制不会让界面变得更简单，反而会把界面搞得很复杂，给用户带来极大不便，主要原因有三个：\n\n很难保证默认菜单的准确性\n缩短菜单后，用户需要把每个功能看两遍才能确定。首先是看短菜单，然后再看长菜单。延长时间或多余的点击只会增加用户的反感\n用户最终不知道去哪里找自己想用的命令，因为这些命令的位置有可能会变\n\n渐进展示通常，一项功能会包含少数核心的供主流用户使用的控制部件，另有一些为专家级用户准备的扩展性的精确控制部件。隐藏这些精确控制部件是保持设计简单的好选择（比如Mac的文件保存框）\n类似这种“核心功能加扩展功能”的模式，不仅能够简化设计，更是一种强大的交互手段\n对于用户期望的功能，要在正确的环境下给出明确的提示\n阶段展示如果所有用户都会随着搜索的深入而寻找较为复杂的功能，那么就可以使用阶段展示。例如，用户一开始可能只会使用简单的文本框来搜索，如果效果不好，他还会在结果页面上寻找筛选和排序选项\n用户希望每个环节都能像讲故事一样层层展开，在理解了这是个什么故事之后，他们自然会跟着一步步地去做\n说用户的语言，对于业内人士，行业术语简洁明确。但对外行来说，一个看不懂的词，要比一段能看懂的话还复杂\n把信息分成小块展示，如果这个块太大，用户会认为表单很复杂。如果把表单切分成过多小块，用户又会觉得表单太琐碎、太麻烦。因此，每个块必须完整而又自成一体（例如，不能把地址分到两个屏幕上）\n在流程中的每一步都符合用户心理预期的情况下，阶段展示的效果最好\n适时出现这种设计的聪明之处在于它隐藏了功能，该功能会在你需要时出现在合适的位置上（例如英文文章内单词翻译）\n但是，隐藏得如此之深却需要极大的勇气。设计团队一定会担心有用户永远不会知道他们还提供了这么一项功能\n过分强调隐藏的功能会导致混乱\n尽可能彻底地隐藏所有需要隐藏的功能，只在合适的时机、合适的位置上显示相应的功能\n提示与线索我们经常可以看到为隐藏功能打上的标签（比如更多、高级等）\n隐藏复杂性的一个原因，就是不想让用户产生自己什么都不懂的感觉\n应邀探索设计模式，而非一个试图介绍更多功能的标签：比如苹果官网中，主流用户关注产品图片和重要新闻，而专家用户可以点击“技术规格”链接去看更详细的数据介绍；Adobe Illustrator中有些具备高级特性的绘图工具在工具箱中会以一个小三角形图标表示，单机一次选择基本工具，单机并按住鼠标不放就会看到高级选项\n隐藏处理得好的界面会给人一种优雅的感觉：界面中包含的线索尽管细微，却能恰到好处地提示出隐藏功能的位置和功用\n细微的线索足以提示隐藏的功能\n让功能容易找到把标签放在哪里比把标签做多大要重要得多\n用户关注点，即用户关注的屏幕区域，用户在一开始端详屏幕或者新建一个任务时，他的关注点很宽泛。当用户打开一个新站点时，他会扫视整个屏幕，而当用户专注于一项任务时，他的关注点就会聚焦。研究表明，用户会盯住屏幕中的一两个区域，或者在做出判断之后，再开始阅读正文内容，在遇到问题时，他们会更多地关注屏幕上的问题区域（这就是为什么用户找不到所需的帮助）\n就算标签再大，如果把它放到了用户关注点之外，用户也看不到。即使是一个非常小的标签，只要把它放在了用户关注点上，也会收到良好的效果\n保证用户在前进的过程中能够遇到提示。但不要挡住他们的去路\n隐藏的要求使用隐藏策略必须做到以下几点：\n\n隐藏一次性设计和选项\n隐藏精确控制选项，但专家用户必须能够让这些选项始终保持可见\n不可强迫或寄希望于主流用户使用自定义功能，不过可以给专家提供这个选项\n巧妙地隐藏，换句话说，首先是彻底隐藏，其次是适时出现\n\n删除不必要的，组织要提供的，隐藏非核心的，转移则涉及对界面进行重新布局\n只要不让人找太久，隐藏就是有效的\n转移转移设计简单体验的一个秘密，就是把正确的功能放到正确的平台或者正确的系统组件中去\n在设备之间转移对于有些平台来说简单的功能，在另一些平台上就会变复杂\n简单的体验优先于完整的服务\n虽然同一款应用在不同设备上的功能不同，但整个服务却让人感觉简单。其中的秘密是让重要的功能触手可得，同时转移那些过度复杂的东西\n桌面、移动与可穿戴设备随着技术不断进步，不同设备的限制也会发生变化，但始终都会有各自的长处与不足。在“错误的”设备上执行某些操作只会让人觉得“别扭”\n最合适的设备始终都是离你最近的那个，为了省事（比如不用再寻找或打开其他设备），人们还是会愿意忍受某种程度的“别扭”\n如果你的设计要面向桌面和移动设备，最好能让它们共享某些重要的功能。移动设备更常用，同时也比笔记本电脑更方便，因此设计要坚持移动优先\n根据不同设备的长处和不足来设计\n为多个设备而设计多个设备共享同一个功能的秘密，就是把功能拆分成更小的组件，然后在每一步检测是否适合用户的需求。首先要将其分层：用户需求、功能、内容和设备\n在与用户交谈时，应该注意不同的人（用户群体）具有不同的行为模式。“专家”和“主流用户”就是两类群体\n把目标用户群最关心的活动重点标识出来，这样就有了一组纵向的需求：用户做什么、为什么做这个、哪些用户做这个\n有了这个维度的分组，就可以分别列出相应的功能和内容。你会发现自己是否有遗漏或重复，然后再决定添加或删除什么。随着时间推移，你的功能和内容会逐步演进到比较适合用户需求。在这些需求下面画一条线\n在这条线下面，再列出你想要支持的设备（比如网站、移动应用或Facebook页面），以及服务在相应设备中展现的方式\n分层有助于发现谁、为什么、什么、怎么样之间的联系。这样有助于设计好一个大系统的小组件。同样，借此也能发现哪些内容、功能，甚至组件可以重用，从而让用户体验保持一致\n向用户转移制定旅行规划的复杂之处在于对模棱两可情况的处理，但简单的界面把这项复杂的工作留给了用户，把复杂性转移到了每一位用户的头脑中\n用户最擅长什么让用户和计算机各自去做最擅长的事\n计算机擅长精确地保存各种信息、计算机擅长精确地计算、人喜欢控制结果\n让用户感觉简单的一个重要前提，就是先搞清楚把什么工作交给计算机，把什么工作留给用户\n用户指挥，计算机操作，就会给人简单的感觉\n提醒与打断计算机非常适合监控不可预测或缓慢变化的情况，因为它们从不厌烦，这也让我们减少了麻烦，而当它们需要提醒我们的时候，问题就来了\n提醒似乎总在不合适的时候出现\n在合适的时候提醒并不简单，因为设备已经融入我们生活的方方面面，所以打断、分心、搅扰总是不断出现\n这就是让计算机代替我们去监控生活的代价，持续搅扰令人厌烦，但如果把提醒关掉，又可能错过一些重要的事情\n在设计提醒时，想想一位出色的助理在社交场合下会怎么提醒你\n监控是计算机所擅长的，知道什么时候可以打断别人则是人所擅长的。如果要在这两者间架起桥梁，要么多借助人工，要么多教会计算机了解人类的社交场景\n创造开放式体验聪明设计师的简化秘诀中经常有一条，就是让一个组件具有多种用途\n把相似的功能绑定到一起，这种简化方式非常巧妙。虽然多合一的功能不一定能完美实现各种用途，但具有明显的优点：找一个功能总比在几个类似功能中选择容易，学习一个功能也比学习多个功能容易，且一个功能更容易维护\n菜刀与钢琴简单界面的最高境界，应该是专家和主流用户都会感觉它非常好用\n这些体验之所以让人觉得简单，就是因为专家和主流用户可以分别设置自己不同的目标，根据他们的经验，实现这个目标需要怎么做，他们自己心里非常清楚\n让用户自己定义成功很重要，我们要做的就是为他们提供一个简单的工具，让他们能自由发挥想象力，最终帮他们达成目标\n非结构化数据不要让用户填写结构化的表单\n如果收集到的数据需要使用计算机来处理（例如，需要对数据按照日期进行排序），那么数据必须是结构化的。不过，计算机有能力识别并将用户提供的数据结构化\n让计算机负责完成数据的结构化工作，用户体验就会简单多了\n信任如果把一组任务分解为两部分，分别交给两个设备来完成，而且这两个设备必须以某种特定的方式配合使用，那么这种情况下最容易实现任务的转移\n在难以分清设备之间如何协同工作时，要实现功能的转移是比较困难的\n要想有效地实现功能转移，必须找到一种确定的感觉。当面对这种不确定性的时候，你就会在两个平台上重复相同的功能\n如果想把任务转移到用户一方，你必须相信用户有能力完成该任务（相信用户是非常困难的）\n编写软件的一个没人肯明说的目的，就是要让用户的种种行为都对设计人员更有利。我们经常把用户当成孩子，但在保护用户不受错误干扰，或者说应该让他们自己找出解决方案的时候，我们习惯于剥夺他们自己的决定权\n构筑信任关系的唯一方式，就是让用户参与测试原型或实物模型。在能够正确地把握如何分配任务之后，让用户专注于选择和指挥，让计算机专注于存储和计算。这样你就能够创造出简单而令人惊叹的体验，因为用户能够充分发挥自己的创造力了\n简单的体验需要信任，计算机之所以让用户不舒服，就是因为它们总是控制和指挥用户\n最后的话顽固的复杂性任何应用程序都会有一些无法消除的复杂性，关键的问题在于：谁会面对这些复杂性？（是用户还是开发人员？）\n到了设计简单用户体验的最后，往往不是问“怎样才能把这个功能设计得更简单”，而是问“到底应该把这个复杂性放到哪里”\n\n这个任务应该是自动化的（比如衡温器），还是应该由用户来控制（比如电灯开关）？\n界面中是应该包含很多功能特定的按钮（比如Word软件），还是只放一些通用的按钮（比如笔记应用）？\n这个任务是应该一次完成（比如注册领取驾驶证），还是应该分几段时间来完成（比如在LinkedIn上填写个人简介）？\n这个任务是应该让用户有意识地去处理（如使用屏幕上的控件来筛选搜索结果），还是应该在无意间完成（如查看伦敦地铁图中的绿色线路）？\n\n创造简单用户体验的秘诀就在于把复杂性转移到正确的地方，让用户每时每刻都能感受到简单之美\n让用户成为明星如果你在计算机中打开了很多程序，每个程序都会运行得非常慢\n让软件具有可用性，意思就是绝不能超出用户的能力范围。可是，用户总是想拥有更详细的信息、更多的选择、更多的功能，这是人类的本性。因此，好像我们应该尽可能朝着最大化的方向努力，然后在快要给用户带来麻烦时戛然而止\n设计简单体验不能这样。这种设计思想会导致用户手里大量的功能闲置，那些“从未使用过的”功能怎么办？\n简单的体验应该为用户留出足够的空间，让他们能够想象到当前正在做的事情同样也是自己生活的一部分\n不要让你的设计干扰用户的思绪，简单的设计能够为用户留出足够的空间，他们会用自己的生活来填充这些空间，从而创造出更丰富、更有意义的体验\n取得共识简单需要统一认识，这意味着整个团队的认同\n你越是努力试图“说服”别人，他们给你设置的障碍就会越多，即使看起来跟你是一个战线，他们也会在第一次麻烦出现时改变主意\n谁也说服不了谁，他们必须自己判断\n\n先从倾听他们和理解什么对他们最重要开始。把汇总的意见恰当地反馈给他们，他们会知道你已经明白了，在感觉被人倾听后，他们才会乐意敞开心扉\n然后，找到他们行动必需的信息\n\n不要尝试说服别人，听他们说，让他们自己判断，让他们自己承认问题\n简单是一门深奥的学问在实际使用后，人们更倾向于认为功能较少的产品更有价值，这足以得出一个结论：简单是一种体验\n如果你把简单作为策略，那就要推销体验，而不是产品。这意味着你要把产品送到用户手上，让他们免费试用。你要展示做到什么有多简单，而不是你的产品有多强大，你要关注的是创造用户口碑，而不是引人注目\n同样，这也意味着体验的其他方面，比如客户服务、退货、维修和更换，也都必须容易（保证这些环节不会让产品的使用体验打折扣）\n过不了多久，你会发现自己在重塑整个组织。如果没有，那你会发现组织在慢慢地腐化你的产品，让它变得不再简单，而你也没有选择\n这也就意味着你需要创造一种寻求简单的文化。这样当他们遇到没有规则可循的新情况时，仍然能够习惯性地去做正确的事\n行为、仪式、语言和独特目标构成的文化，会从组织重视什么中浮现出来。因此，需要把组织成功的标准清晰地构建在产品的简单上\n决定寻求简单是一段长途旅行的开始。能够做到什么程度，取决于有多少人受你影响，成为你的追随者\n简单策略对你的影响之深远，超乎你的想象\n","categories":["产品理论"],"tags":["产品理论书单📚-用户体验(交互设计、视觉设计)"]},{"title":"常用前端技术分类","url":"/2023/08/31/%E4%BA%A7%E5%93%81%E7%90%86%E8%AE%BA/%E6%8A%80%E6%9C%AF%E6%80%9D%E7%BB%B4/Web%E5%89%8D%E7%AB%AF%E6%8A%80%E6%9C%AF/1_%E5%B8%B8%E7%94%A8%E5%89%8D%E7%AB%AF%E6%8A%80%E6%9C%AF%E5%88%86%E7%B1%BB/","content":"产品经理为什么要懂一些前端技术？\n前端载体分类前端（客户端）技术是指用来开发客户端产品所用到的技术\n\n网页：HTML5\nApp（小程序）：Android、iOS\n桌面软件：Windows、macOS、Linux\n\n前端职能分类及技术能力前端工程师按技术能力分为多种职能，虽然都叫前端工程师，但是技术职能不一样：\n\nHTML5：HTML、CSS、JavaScript\nAndroid：Java\niOS：Objective-C、Swift\n小程序：WXML、WXSS、WXS\n桌面软件：C&#x2F;C++、Objective-C\n\n","categories":["产品理论"],"tags":["技术思维-Web前端技术"]},{"title":"HTTP协议和URL","url":"/2023/08/31/%E4%BA%A7%E5%93%81%E7%90%86%E8%AE%BA/%E6%8A%80%E6%9C%AF%E6%80%9D%E7%BB%B4/Web%E5%89%8D%E7%AB%AF%E6%8A%80%E6%9C%AF/3_HTTP%E5%8D%8F%E8%AE%AE%E5%92%8CURL/","content":"HTTP协议全称HyperText Transfer Protocol，是互联网应用最为广泛的一种网络协议，所有的www文件都必须遵守这个标准。设计HTTP最初的目的是为了提供一种发布和接收HTML页面的方法\nHTTP协议格式：http://www.xxx.com，http://xxx.com\n客户端与服务器之间的通讯都是基于HTTP协议进行数据传输\n如何在互联网唯一定位一个资源？URL：Uniform Resource Locator，统一资源定位符，访问一个网站、打开一张图片、观看一个视频，都是在访问一个唯一的URL\nURL的构成：\n","categories":["产品理论"],"tags":["技术思维-Web前端技术"]},{"title":"HTTP请求、GET方法、POST方法","url":"/2023/08/31/%E4%BA%A7%E5%93%81%E7%90%86%E8%AE%BA/%E6%8A%80%E6%9C%AF%E6%80%9D%E7%BB%B4/Web%E5%89%8D%E7%AB%AF%E6%8A%80%E6%9C%AF/4_HTTP%E8%AF%B7%E6%B1%82%E3%80%81GET%E6%96%B9%E6%B3%95%E3%80%81POST%E6%96%B9%E6%B3%95/","content":"HTTP请求基于HTTP协议发起的网络请求叫HTTP请求，HTTP请求可以携带参数进行数据传递，目前大部分的互联网应用程序都是基于HTTP协议进行网络通信。HTTPS是一种基于HTTP的加密协议，通常需要申请单独的加密证书，保证数据安全。\nGET方法\nPOST方法\nHTTP请求常用的方法GET和POST对应不同的场景，主要区别就是参数传递方式不一样\n","categories":["产品理论"],"tags":["技术思维-Web前端技术"]},{"title":"Cookie和Session","url":"/2023/08/31/%E4%BA%A7%E5%93%81%E7%90%86%E8%AE%BA/%E6%8A%80%E6%9C%AF%E6%80%9D%E7%BB%B4/Web%E5%89%8D%E7%AB%AF%E6%8A%80%E6%9C%AF/5_Cookie%E5%92%8CSession/","content":"Cookie是什么？\nSession是什么？\n\nCookie和Session的主要区别是状态的保存和维护，前者在客户端，后者在服务端\n","categories":["产品理论"],"tags":["技术思维-Web前端技术"]},{"title":"什么是Ajax","url":"/2023/08/31/%E4%BA%A7%E5%93%81%E7%90%86%E8%AE%BA/%E6%8A%80%E6%9C%AF%E6%80%9D%E7%BB%B4/Web%E5%89%8D%E7%AB%AF%E6%8A%80%E6%9C%AF/7_%E4%BB%80%E4%B9%88%E6%98%AFAjax/","content":"Ajax（Asynchronous JavaScript and XML）是一种在Web应用程序中进行异步通信的技术。它使用JavaScript和XML（现在通常使用JSON）来实现在不刷新整个页面的情况下与服务器进行数据交换的能力。\n\n客户端发起Ajax请求：通过JavaScript代码，在客户端发起一个异步请求到服务器。这可以通过XMLHttpRequest对象或现代的Fetch API来实现。\n服务器处理请求：服务器接收到Ajax请求，并根据请求的内容进行处理，通常是处理特定的URL或API端点。\n服务器响应：服务器将处理结果封装在HTTP响应中，并返回给客户端。响应通常是在JSON格式下返回数据，但也可以是XML或其他格式。\n客户端处理响应：客户端接收到服务器的响应后，使用JavaScript代码对响应进行解析和处理。可以根据响应的数据更新网页的特定部分，动态修改内容或执行其他操作。\n客户端更新页面：在客户端接收到响应后，根据需要更新网页的特定部分，而不需要重新加载整个页面。这使得网页可以实现部分刷新和动态交互，提供更好的用户体验。\n\n优点：\n\n异步通信：Ajax请求是异步的，不会阻塞页面的其他操作。这允许网页在后台发送请求并继续执行其他任务。\n部分刷新：通过更新页面的特定部分，可以避免重新加载整个页面，提高性能和用户体验。\n动态交互：通过与服务器进行实时数据交换，可以实现动态更新内容和交互式功能。\n减少带宽：由于只更新部分页面内容，Ajax请求可以减少数据传输量，节省带宽和加载时间。 XMLHttpRequest是一种用于在JavaScript中进行HTTP请求的内置对象。它允许客户端与服务器进行异步通信，并在不刷新整个页面的情况下获取数据或更新部分页面内容。\n\n","categories":["产品理论"],"tags":["技术思维-Web前端技术"]},{"title":"Web静态页和动态页","url":"/2023/08/31/%E4%BA%A7%E5%93%81%E7%90%86%E8%AE%BA/%E6%8A%80%E6%9C%AF%E6%80%9D%E7%BB%B4/Web%E5%89%8D%E7%AB%AF%E6%8A%80%E6%9C%AF/6_Web%E9%9D%99%E6%80%81%E9%A1%B5%E5%92%8C%E5%8A%A8%E6%80%81%E9%A1%B5/","content":"Web页面分为静态页面和动态页面两种\n静态页面：静态页面通常只需要加载渲染一次，将内容完整呈现出来即可，无需再进行数据加载\n\n内容固定不变\n无需单独的数据请求和加载\n以说明类页面内容为主\n\n工程师口中的静态页面，有可能是纯静态页，例如功能说明页，有可能是需要做功能接口的“静态页”，例如没有实现功能的登录页面也被工程师叫做“静态页”\n产品经理需要区分需要通过接口实现功能的都不是静态页，与工程师沟通时，明确双方对静态页的理解是否一致，避免误解\n动态页面：动态页面通常指页面内容会随着场景变化而变化，页面数据需要通过服务端接口获取\n\n页面结构一致，数据差异化\n需要请求和加载数据，数据动态获取\n功能类、业务逻辑类页面为主\n\n大部分功能页面都属于动态页面\n","categories":["产品理论"],"tags":["技术思维-Web前端技术"]},{"title":"Web技术特点及应用","url":"/2023/08/31/%E4%BA%A7%E5%93%81%E7%90%86%E8%AE%BA/%E6%8A%80%E6%9C%AF%E6%80%9D%E7%BB%B4/Web%E5%89%8D%E7%AB%AF%E6%8A%80%E6%9C%AF/2_Web%E6%8A%80%E6%9C%AF%E7%89%B9%E7%82%B9%E5%8F%8A%E5%BA%94%E7%94%A8/","content":"什么是Web技术？用来开发网页的一种前端技术，包括HTML语言、CSS样式、JavaScript脚本语言及一些前端框架\nWeb技术的特点：\nHTML页面是骨架，CSS是给HTML页面装饰的衣服，同一个HTML页面根据不同的CSS可实现不同的展示效果（风格切换、换肤）\nWeb页面可实现对PC浏览器和手机浏览器的适配，一套网页可在不同的设备上呈现不同的展示效果\n修改网页内容不需要重新发布客户端产品，只需要将网页代码重新部署，可进行热更新\n\n","categories":["产品理论"],"tags":["技术思维-Web前端技术"]},{"title":"脚本语言、非脚本语言","url":"/2023/08/31/%E4%BA%A7%E5%93%81%E7%90%86%E8%AE%BA/%E6%8A%80%E6%9C%AF%E6%80%9D%E7%BB%B4/%E6%8A%80%E6%9C%AF%E5%B8%B8%E8%AF%86/11_%E8%84%9A%E6%9C%AC%E8%AF%AD%E8%A8%80%E3%80%81%E9%9D%9E%E8%84%9A%E6%9C%AC%E8%AF%AD%E8%A8%80/","content":"脚本语言是读一行执行一行而无需关注下一行的语言。\n非脚本语言则是必须读取整个源程序内容，建立完执行环境后执行的语言。\n","categories":["产品理论"],"tags":["技术思维-技术常识"]},{"title":"什么是联调","url":"/2023/08/31/%E4%BA%A7%E5%93%81%E7%90%86%E8%AE%BA/%E6%8A%80%E6%9C%AF%E6%80%9D%E7%BB%B4/%E6%8A%80%E6%9C%AF%E5%B8%B8%E8%AF%86/10_%E4%BB%80%E4%B9%88%E6%98%AF%E8%81%94%E8%B0%83/","content":"联调是一种功能开发的分工模式。一个功能，往往是由前端+后端共同实现的。前端开发主要负责用户界面(UI)和用户体验(UX)，而后端开发则负责处理数据和服务器相关的功能。例如，对于一个在线购物网站，前端负责商品页面展示，购物车设计等，后端则负责库存管理，订单处理等。这种分工开发方式可以让多个开发并行工作，从而提升上线效率。然而，分工开发后，需要一个对接、联合调试的过程，以保证前后端代码能够准确地进行协作。这就叫做联调。比如用户在页面上添加商品到购物车，前端需要发送请求到后端，后端处理后返回新的购物车信息给前端显示，这就需要”联调”。\n产品经理理解联调的意义：作为产品经理，我们不需要亲自参与联调过程。\n\n更快地定位问题：例如，如果我们有一个餐饮预订系统，用户在选择菜品并下单时，按钮可以正常点击、但点击之后提示“系统繁忙”。我们就可以猜测，可能是服务器交互环节，也就是后端出了问题。\n更准确地估算开发排期时间：以我们正在开发的一款新的社交应用为例，我们必须在计划中考虑到前后端的联调时间。联调通常是开发过程中的最后一步，但这并不意味着它可以被忽视。反而，因为联调中可能会发现和修复大量的问题，所以它可能会占据整个开发周期的很大一部分时间。\n\n","categories":["产品理论"],"tags":["技术思维-技术常识"]},{"title":"什么是程序","url":"/2023/08/31/%E4%BA%A7%E5%93%81%E7%90%86%E8%AE%BA/%E6%8A%80%E6%9C%AF%E6%80%9D%E7%BB%B4/%E6%8A%80%E6%9C%AF%E5%B8%B8%E8%AF%86/4_%E4%BB%80%E4%B9%88%E6%98%AF%E7%A8%8B%E5%BA%8F/","content":"程序 &#x3D; 数据结构 + 算法，程序是一个整体，它按照一句一句的代码来表达程序逻辑\n程序中的数据结构单一数据项根据一定的规则形成的结构，用来对零散数据进行结构化管理，用数据类型来为每一个数据项或者数据结构标记类别，用来区分不同数据类型的符号叫关键字\n程序中的算法通过程序的逻辑结构表达业务逻辑和系统功能\n程序中的基本逻辑结构：\n\n判断逻辑\n选择逻辑\n循环逻辑\n\n理解程序结构，是帮助产品经理理解技术思维的最好切入点\n","categories":["产品理论"],"tags":["技术思维-技术常识"]},{"title":"工程师“写代码”写的是什么","url":"/2023/08/31/%E4%BA%A7%E5%93%81%E7%90%86%E8%AE%BA/%E6%8A%80%E6%9C%AF%E6%80%9D%E7%BB%B4/%E6%8A%80%E6%9C%AF%E5%B8%B8%E8%AF%86/2_%E5%B7%A5%E7%A8%8B%E5%B8%88%E2%80%9C%E5%86%99%E4%BB%A3%E7%A0%81%E2%80%9D%E5%86%99%E7%9A%84%E6%98%AF%E4%BB%80%E4%B9%88/","content":"什么是代码？代码是按照一定规则组成的计算机执行指令，代码表达的是一种程序规则和逻辑结构，计算机通过运行代码逻辑来执行程序指令，每一个产品功能都是由一系列的程序指令构成的\n工程师“写代码”写的是什么？代码是工程师对逻辑的理解和表达，同样功能的系统，两个工程师写出来的代码会完全不一样\n写什么：\n\n给代码中的特定标识起名（命名）\n把功能逻辑用代码写出来（实现功能）\n告诉系统要使用哪些基础库（使用组件）\n给代码加注释（备注）\n\n代码命名给代码所在的文件命名，给代码中的变量名称命名\n实现功能\n使用组件很多基础组件都是系统或者组件包已经实现的，工程师需要告诉系统该功能需要使用哪些组件包\n写注释理论上，每一段代码都需要标记注释，用来记录该代码的作用和逻辑，便于后来人阅读和使用\n","categories":["产品理论"],"tags":["技术思维-技术常识"]},{"title":"什么是编程语言","url":"/2023/08/31/%E4%BA%A7%E5%93%81%E7%90%86%E8%AE%BA/%E6%8A%80%E6%9C%AF%E6%80%9D%E7%BB%B4/%E6%8A%80%E6%9C%AF%E5%B8%B8%E8%AF%86/1_%E4%BB%80%E4%B9%88%E6%98%AF%E7%BC%96%E7%A8%8B%E8%AF%AD%E8%A8%80/","content":"现实世界：人与人打交道用语言计算机世界：人与计算机打交道用编程语言\n编程语言：人与计算机进行通讯的指令集\n\n机器语言（0和1）\n汇编语言（符号标记）\n高级语言（语义表达）\n\n不同编程语言分类，对应不同的工程师职能，常用编程语言及使用场景：\n\nC、C++：世界范围内使用最广泛的编程语言之一，可用于各种应用软件系统开发及硬件开发（Linux、塞班系统）\nJava：主流编程语言，可用于客户端和服务端软件开发（Android、J2EE-Java企业级Web应用开发）\nPython：高级编程语言，具有丰富而强大的可扩展库，被称为“胶水语言”，可快速构建程序原型架构，然后支持多语言的模块集成\n\n","categories":["产品理论"],"tags":["技术思维-技术常识"]},{"title":"程序是如何组装成功能的","url":"/2023/08/31/%E4%BA%A7%E5%93%81%E7%90%86%E8%AE%BA/%E6%8A%80%E6%9C%AF%E6%80%9D%E7%BB%B4/%E6%8A%80%E6%9C%AF%E5%B8%B8%E8%AF%86/5_%E7%A8%8B%E5%BA%8F%E6%98%AF%E5%A6%82%E4%BD%95%E7%BB%84%E8%A3%85%E6%88%90%E5%8A%9F%E8%83%BD%E7%9A%84/","content":"\n程序中的最小执行单元：方法方法是通过数据类型和逻辑判断的组合完成某个特定任务方法的组成：方法名、参数、执行结果类型、方法体\n程序块：多个“方法”的组合\n产品功能：多个程序块的组合拼装不同的方法之间，通过相互“调用”的方式来实现协同，从而组成了产品功能\n","categories":["产品理论"],"tags":["技术思维-技术常识"]},{"title":"什么是写死","url":"/2023/08/31/%E4%BA%A7%E5%93%81%E7%90%86%E8%AE%BA/%E6%8A%80%E6%9C%AF%E6%80%9D%E7%BB%B4/%E6%8A%80%E6%9C%AF%E5%B8%B8%E8%AF%86/9_%E4%BB%80%E4%B9%88%E6%98%AF%E5%86%99%E6%AD%BB/","content":"程序员所说的是指对一些参数或配置写死。写死意味着除非发下一个版本，否则这个数据不可更改。比如微信下面的四个TAB，就是写死的，因为那四个TAB永远不会变。在程序实现的时候，程序员问是否要写死，其实是探求这里是否会变化。如果不变，那就写死。\n不写死意味着这个数据是变化的，可运营的，那这个运营数据应该在服务器端进行配置，再由客户端拉取下来，然后运行时启用新的配置数据，多出的成本是需要设计一条协议拉取这项配置或参数，然后应用到程序中，如果已经有这样的运营配置协议，那直接配置即可。\n\n二者的本质区别是一个发生在编译时，一个作用于运行时。\n二者并不互斥，有的时候是要一起配合的，既要本地写死，也要云端可控。\n\n假设你是一个资讯客户端的产品经理，一个资讯客户端经常有这些TAB或者叫频道：推荐、热点、视频、本地、美图、娱乐、体育、汽车。可这些频道的数据是可运营配置的，可以调整顺序，可以调整文案，可以新增一个频道，也可以删除某一个运营效果不好的频道。一个好的产品设计是，本地要默认写死一些频道，这些频道通常是一个资讯客户端不怎么变化的，每次都要展示的，这些成为打底数据或者叫default默认数据，如果没有这份写死的数据，你的客户端运行起来，就会头部没有任何信息，等网络数据回来才有展示，或者无网络时，就像出了bug一样没有任何展示。所以打底数据主要解决用户体验问题，无网络或初次启动时，给用户隐喻这个客户端已经在正常运行。展示了打底数据之后，此刻发起云端请求，请求云端运营数据，拉取成功之后，将新的频道数据覆盖本地数据，如果此次请求失败，则继续展示本地数据，保障用户浏览。在拉取成功的情况下，应该把新的频道数据覆盖本地Default打底数据，保证客户端下次启动展示上一次成功拉取的频道数据。这是客户端产品和程序设计的基本逻辑，希望不要割裂开看本地数据和云端数据的问题，二者配合效果更佳。\n","categories":["产品理论"],"tags":["技术思维-技术常识"]},{"title":"为什么简单的功能在程序上很复杂","url":"/2023/08/31/%E4%BA%A7%E5%93%81%E7%90%86%E8%AE%BA/%E6%8A%80%E6%9C%AF%E6%80%9D%E7%BB%B4/%E6%8A%80%E6%9C%AF%E5%B8%B8%E8%AF%86/7_%E4%B8%BA%E4%BB%80%E4%B9%88%E7%AE%80%E5%8D%95%E7%9A%84%E5%8A%9F%E8%83%BD%E5%9C%A8%E7%A8%8B%E5%BA%8F%E4%B8%8A%E5%BE%88%E5%A4%8D%E6%9D%82/","content":"工程师实现功能需要做什么？\n视角及思维的切换，形成技术思维：\n","categories":["产品理论"],"tags":["技术思维-技术常识"]},{"title":"什么是框架","url":"/2023/08/31/%E4%BA%A7%E5%93%81%E7%90%86%E8%AE%BA/%E6%8A%80%E6%9C%AF%E6%80%9D%E7%BB%B4/%E6%8A%80%E6%9C%AF%E5%B8%B8%E8%AF%86/8_%E4%BB%80%E4%B9%88%E6%98%AF%E6%A1%86%E6%9E%B6/","content":"框架是可重复使用的软件组件的集合，能提高新应用程序的开发效率。\n\n重复利用现有开发和研究是所有工程领域的基本原则。\n软件框架包含基于特定软件标准和协议的可重复使用的代码模块。\n框架还可以定义和强制执行某些软件架构规则或业务流程，以便能够以标准化方式开发新的应用程序。\n\n","categories":["产品理论"],"tags":["技术思维-技术常识"]},{"title":"技术架构(MVC、BS、CS)","url":"/2023/08/31/%E4%BA%A7%E5%93%81%E7%90%86%E8%AE%BA/%E6%8A%80%E6%9C%AF%E6%80%9D%E7%BB%B4/%E6%8A%80%E6%9C%AF%E5%B8%B8%E8%AF%86/6_%E6%8A%80%E6%9C%AF%E6%9E%B6%E6%9E%84(MVC%E3%80%81BS%E3%80%81CS)/","content":"为什么需要架构？架构是地基，地基不牢，地动山摇。架构是工程实施的第一步。好的架构满足这么几个特点：\n\n框架稳定\n可扩展\n易于开发\n\nMVC框架\nB&#x2F;S架构B&#x2F;S就是在浏览器中打开的应用系统，即WEB系统。不需要下载客户端，在浏览器上即可运行。\n优点：\n\n分布性强，客户端零维护。只要有网络、浏览器，可以随时随地进行查询、浏览等业务处理。\n业务扩展简单方便，通过增加网页即可增加服务器功能。\n维护简单方便，只需要改变网页，即可实现所有用户的同步更新。\n开发简单，共享性强。\n\n缺点：\n\n个性化特点明显降低，无法实现具有个性化的功能要求（但能通过账号体系进行个性化设置）。\n在跨浏览器上，B&#x2F;S架构不尽如人意(在不同浏览器上会产生兼容问题)。\n客户端服务器端的交互是请求-响应模式，通常动态刷新页面，响应速度明显降低(Ajax可以一定程度上解决这个问题)。无法实现分页显示，给数据库访问造成较大的压力。\n在速度和安全性上需要花费巨大的设计成本（可以使用安全的 HTTPS 协议，安装控件的方式实现较好的安全性）。\n功能弱化，难以实现传统模式下的特殊功能要求。\n\nC&#x2F;S架构C&#x2F;S分布式模式，是计算机用语。C是指Client，S是指Server，C&#x2F;S模式就是指客户端&#x2F;服务器模式。是计算机软件协同工作的一种模式，通常采取两层结构。服务器负责数据的管理，客户机负责完成与用户的交互任务。客户端是需要安装专用的客户端软件。\n优点：\n\n能充分发挥客户端PC的处理能力，很多工作可以在客户端处理后再提交给服务器，所以C&#x2F;S客户端响应速度快。\n操作界面漂亮、形式多样，可以充分满足客户自身的个性化要求。\nC&#x2F;S结构的管理信息系统具有较强的事务处理能力，能实现复杂的业务流程。\n安全性能可以很容易保证，C&#x2F;S一般面向相对固定的用户群，程序更加注重流程，它可以对权限进行多层次校验，提供了更安全的存取模式，对信息安全的控制能力很强。一般高度机密的信息系统采用C&#x2F;S结构适宜。\n\n缺点：\n\n需要专门的客户端安装程序，分布功能弱，针对点多面广且不具备网络条件的用户群体，不能够实现快速部署安装和配置。\n兼容性差，对于不同的开发工具，具有较大的局限性。若采用不同工具，需要重新改写程序。\n开发、维护成本较高，需要具有一定专业水准的技术人员才能完成，发生一次升级，则所有客户端的程序都需要改变。\n用户群固定。由于程序需要安装才可使用，因此不适合面向一些不可知的用户，所以适用面窄，通常用于局域网中。\n\n区别：\nC&#x2F;S响应速度快,安全性强，一般应用于局域网中,但是开发维护成本高; B&#x2F;S可以实现跨平台,客户端零维护，但是个性化能力低，响应速度较慢。所以有些单位日常办公应用B&#x2F;S,在实际生产中使用C&#x2F;S结构。\n产品经理为什么需要了解技术架构？基于对业务和产品能力的理解，抽象基础服务，形成组件，在技术上实现组件化架构，提前预知，避免重复开发\n","categories":["产品理论"],"tags":["技术思维-技术常识"]},{"title":"常用数据结构","url":"/2023/08/31/%E4%BA%A7%E5%93%81%E7%90%86%E8%AE%BA/%E6%8A%80%E6%9C%AF%E6%80%9D%E7%BB%B4/%E6%8A%80%E6%9C%AF%E5%B8%B8%E8%AF%86/3_%E5%B8%B8%E7%94%A8%E6%95%B0%E6%8D%AE%E7%BB%93%E6%9E%84/","content":"数据结构：单一数据项根据一定的规则形成的结构，用来对零散数据进行结构化管理（比如队列、树状结构）\n\n队列\n树状结构\n数组\n键值对\n\n数据结构在代码中起到什么作用：\n\n按一定规则组织数据，数据结构可嵌套使用\n存储临时数据\n为业务逻辑提供结构化数据管理\n\n","categories":["产品理论"],"tags":["技术思维-技术常识"]},{"title":"项目风险管理","url":"/2024/08/05/%E4%BA%A7%E5%93%81%E7%90%86%E8%AE%BA/%E9%A1%B9%E7%9B%AE%E7%AE%A1%E7%90%86/%E9%A1%B9%E7%9B%AE%E7%AE%A1%E7%90%86%E7%AC%94%E8%AE%B0/10_%E9%A1%B9%E7%9B%AE%E9%A3%8E%E9%99%A9%E7%AE%A1%E7%90%86/","content":"基本概念风险：某一事件发生的概率和其后果的组合（不确定事件，风险的大小&#x3D;概率*后果）\n\n好的风险、积极的风险、机会\n坏的风险、消极的风险、威胁\n\n项目风险：风险是一种不确定事件或条件，一旦发生，会对至少一个项目目标造成影响（范围、进度、成本、质量）\n项目管理三约束：范围（包括质量）、进度、成本\n项目风险一般用进度、成本这两个指标来计算\n⭐️项目的未来充满风险\n风险要素：风险的大小&#x3D;概率*后果，还有风险的紧迫性、可识别性\n\n事件：特定情况的发生，事件可能是确定的，也可能是不确定的，可能是单一的，也可能是系列的风险的两个组成因素\n概率：风险发生的可能性，对于给定时间内事件发生的概率可以估算出来，其值介于0与1之间，高可信度概率接近1\n影响：风险一旦发生造成的后果，后果可以是正面的和负面的，后果可以定性或定量表述\n条件：可能引发项目风险的各种项目&#x2F;组织环境因素（不成熟的项目管理实践、缺乏综合管理系统、多项目并行实施、不可控的外部参与者等）\n\n风险分解结构RBS：作用是给风险分类\n\n风险分类：\n\n已知风险：已经识别并分析过的风险（概率和影响都清楚，可以进行主动管理，对这些风险规划应对措施）\n未知风险：无法进行主动管理\n已知-未知风险：已知但无法主动管理的风险（概率和影响只知道其中之一，要使用应急储备&#x2F;应对计划&#x2F;应急计划，应急储备是储备时间和成本，应急计划专门处理特殊风险）\n未知-未知风险：事先无法识别的风险，当然更无法知道发生的概率和影响，无法主动进行管理（要使用管理储备，管理储备也是储备时间和成本）\n\n\n\n当风险发生以后，应对措施是不需要向上汇报的，直接按照应对措施处理就可以了；但是应急储备&#x2F;应对计划&#x2F;应急计划是需要向上汇报的，项目经理可以决定是否使用；管理储备需要高层或上级决定是否动用\n风险：没有发生的项目风险\n问题：已经发生的项目风险\n风险可能有一种或多种起因：\n\n引起积极&#x2F;消极结果需求\n假设条件\n制约因素：比如强制的结束日期、规定的项目预算、可动用的资源、苛刻的质量标准要求\n某种状况\n\n风险承受力：\n\n风险应对：\n\n过程和目的规划过程组：\n\n规划风险管理：定义如何实施项目风险管理活动，得到风险管理计划\n识别风险：判断&#x2F;记录风险对项目影响&#x2F;特征，使用穷尽法得到一份风险清单&#x2F;风险登记册，这是一份项目管理文件\n实施定性风险分析：评估、综合分析、排序、后续（将风险进行分类&#x2F;排序&#x2F;分级，更新风险登记册）\n实施定量风险分析：对项目整体目标影响进行定量分析（继续更新风险登记册）\n规划风险应对：制定提高机会、降低威胁方案&#x2F;措施，应急计划&#x2F;弹回计划&#x2F;次生风险（弹回计划是指实际情况下应急计划不管用，需要启动备用计划；次生风险指由于应急计划的执行又带来的新风险）（继续更新风险登记册）\n\n执行过程组：\n\n实施风险应对：执行商定的风险应对计划（继续更新风险登记册）\n\n监控过程组：\n\n监督风险：监督商定的风险应对计划的实施&#x2F;跟踪已识别风险&#x2F;监测残余风险&#x2F;识别新风险&#x2F;评估风险过程&#x2F;删除不存在风险释放储备\n\n规划风险管理\n定义如何实施项目风险管理活动。本过程仅开展一次或仅在项目的预定义点开展\n\n制定风险管理计划前，要遵循公司风险量表的定义\n\n识别风险\n识别单个项目风险以及整体项目风险的来源，并记录风险特征。本过程需要在整个项目期间开展\n\n风险登记册：已经识别的风险清单、潜在风险应对措施清单、潜在风险责任人\n\n风险报告：整体项目风险的来源、已识别单个项目风险的概述信息、风险管理计划中规定的报告要求、其他信息\n\nSWOT分析：\n\n\n\n实施定性风险分析\n通过评估单个项目风险发生的概率和影响以及其他特征，对风险进行优先排序，为后续分析或行动提供基础。本过程需要在整个项目期间开展\n\n更新风险登记册和风险报告\n\n假设日志：可能做出新的假设、识别出新的制约因素，或者现有的假设条件或制约因素可能被重新审查和修改\n\n概率和影响定义&#x2F;概率和影响量表：下表是一个属性量表，来自于组织和公司\n\n\n概率和影响矩阵&#x2F;企业风险地图：下表是一个数字量表，来自于组织和公司\n\n\n气泡图：\n\n\n\n实施定量风险分析\n就已识别的风险和不确定性的其他来源对整体项目目标的影响进行定量分析。本过程在整个项目期间持续开展\n\n主要分析大的风险\n\n更新风险登记册和风险报告\n\n模拟（蒙特卡洛技术）：主要分析时间和成本，不分析质量\n\n\n敏感性分析：用的图形叫龙卷风图，下图为龙卷风图的变形\n内部收益率IRR是敏感性指标，左边一列叫做敏感性因素，下图为单因素敏感性分析\n\n龙卷风图：\n\n\n决策树分析（预期货币价值）\n\n\n\n规划风险应对\n为处理整体项目风险敞口以及应对单个项目风险而制定可选方案、选择应对策略并商定应对行动。本过程需要在整个项目期间开展\n\n更新风险登记册和风险报告\n\n威胁应对策略：转移比如说买保险&#x2F;外包，减轻的措施可以是提前储备时间和成本\n\n\n机会应对策略：分享指的是合作共赢\n\n\n整体项目风险应对策略：由高层人物进行\n\n\n\n实施风险应对\n执行商定的风险应对计划。本过程需要在整个项目期间开展\n\n更新风险登记册和风险报告\n\n监督风险\n在整个项目期间监督商定的风险应对计划的实施、跟踪已识别风险、识别和分析新风险，评级风险管理有效性。本过程需要在整个项目期间开展\n\n更新风险登记册和风险报告\n\n储备分析用在规划过程组也用在监控过程组，估算活动持续时间、估算成本、预算成本是规划过程组，控制成本、控制风险是监控过程组\n\n估算活动持续时间：估算时考虑应急储备（时间储备或缓冲时间），纳入项目进度计划\n估算成本：为应对成本的不确定性，成本估算中可以包括应急储备\n预算成本：可以计算项目的应急储备与管理储备\n控制成本：监督项目中的应急储备和管理储备的使用情况，判断是否还需要这些储备，是否需要增加额外的储备\n控制风险：在项目的任何时点比较剩余应急储备与剩余风险量，确定剩余储备是否仍然合理\n\n储备分析只考虑时间和成本这两个量\n\n风险审计：\n\n检查并记录风险应对措施的有效性（残余风险是否在风险承担的临界值内）\n\n检查并记录风险管理过程的有效性\n\n\n\n\n\n知识领域概要风险管理最是无形\n\n要尊重经验但不要盲目相信经验\n风险管理要未雨绸缪\n有远虑\n无后患\n\n好的风险管理往往让人察觉不到它的存在，这和危机管理不同，在危机管理中，会有一个危及项目成功的很明显的威胁，危机会得到密切关注，成功的化解危机有着更大的可视性，并常常伴随着管理部门的奖励，相反，当有效开展风险管理时，它会导致问题的减少，外部不易判断\n","categories":["产品理论"],"tags":["项目管理-项目管理笔记"]},{"title":"项目采购管理","url":"/2024/08/07/%E4%BA%A7%E5%93%81%E7%90%86%E8%AE%BA/%E9%A1%B9%E7%9B%AE%E7%AE%A1%E7%90%86/%E9%A1%B9%E7%9B%AE%E7%AE%A1%E7%90%86%E7%AC%94%E8%AE%B0/11_%E9%A1%B9%E7%9B%AE%E9%87%87%E8%B4%AD%E7%AE%A1%E7%90%86/","content":"基本概念采购一词广泛用于政府，许多私人企业使用“外购”、“外包”。那些提供采购服务的组织和个人通常被称为供应商、供货商、承包人、分包人或销售商，其中供应商是应用最广的一个词语（广义上的采购包括物资（实物）、劳务（人力）、外包、租赁）\n采购意味着从外界来源获得商品或服务\n采购的作用：\n\n降低固定成本和经常性费用。外包服务提供商往往可以利用规模经济优势提供所需商品和服务，可节省雇佣&#x2F;解雇&#x2F;派遣员工成本\n使企业专心于其核心业务。通过采购，集中精力，提升核心业务能力，专注于自己擅长的工作\n获得技术和技能。通过采购，企业可以获得所需的特殊技能和技术\n提供灵活性，提升责任感。采购可以在项目处于工作压力高峰时提供额外的员工。一份精心拟就的合同可以明确责任，合同属于法律条款，有责任按照合同交付工作\n\n采购注意事项：\n\n供应商的工作往往得不到自身的控制\n组织不能过分依赖于某一特定的供应商\n组织要注意保护自己的战略性信息&#x2F;敏感信息\n组织要注意保护自己技术秘密和商业秘密\n组织要衡量购买和租赁的商业权衡\n\n过程和目的⭐️在项目采购管理中，我们属于甲方，其他九大知识领域，我们都是乙方\n规划过程组：\n\n规划采购管理：买不买&#x2F;买什么&#x2F;什么时候买&#x2F;怎样买，得到一份采购管理计划\n\n执行过程组：\n\n实施采购：获取卖方回应&#x2F;选定卖方&#x2F;授予合同\n\n监控过程组：\n\n控制采购：监督卖方绩效&#x2F;变更决定&#x2F;关系管理\n\n规划采购管理\n记录项目采购决策，明确采购方法，识别潜在卖方。本过程仅开展一次或仅在项目预定义点开展\n\n注意商业文件不是项目管理文件，它是项目成立之前的文件\n\n采购文件（就是标书）：在不同的场合下有不同的名字，比如说信息邀请书、投标邀请书、建议邀请书、报价邀请书、投标通知、谈判邀请书、卖方初始应答\n\n\n\n实施采购\n获取卖方应答，选择卖方并授予合同。本过程应根据需要在整个项目期间定期开展\n\n投标人会议：也叫承包商会议&#x2F;供应商会议&#x2F;投标前会议，它是一个投标前的准备会&#x2F;答疑会，提交投标书之前，买方和所有潜在卖方之间召开的会议，目的是保证所有潜在卖方了解采购要求，有清楚一致的理解，体现公平，在一个公开的平台做出回答（在这个会议以外，甲方不会再私下跟任意一个乙方进行答疑、沟通，保证公平）\n\n控制采购\n管理采购关系，监督合同绩效，实施必要的变更和纠偏以及关闭合同的过程。本过程应根据需要在整个项目期间开展\n\n工作绩效数据和工作绩效信息都是指乙方&#x2F;卖方的，上面用到的数据分析&#x2F;检查&#x2F;审计等也是针对乙方&#x2F;卖方的\n结束采购是在监控过程组，不是在收尾过程组\n\n知识领域概要采购管理最要懂法\n\n要懂法律\n遵守契约\n比三家\n择卖方\n\n采购管理涉及到所在国家、地区的法律法规，必须熟谙法律法规，如合同法、招投标法、政府采购法规等，保证采购符合这些法规，选择卖方时，要履行相应的过程。采购大多是由组织中的相关职能部门完成的，但项目经理要参与其中\n","categories":["产品理论"],"tags":["项目管理-项目管理笔记"]},{"title":"项目整合管理","url":"/2024/07/26/%E4%BA%A7%E5%93%81%E7%90%86%E8%AE%BA/%E9%A1%B9%E7%9B%AE%E7%AE%A1%E7%90%86/%E9%A1%B9%E7%9B%AE%E7%AE%A1%E7%90%86%E7%AC%94%E8%AE%B0/3_%E9%A1%B9%E7%9B%AE%E6%95%B4%E5%90%88%E7%AE%A1%E7%90%86/","content":"基本概念项目管理过程的三从四得：\n\n三从：从过程想结果、从结果知输入、从输入选工具\n四得：一得文件和计划（统称文档）、二得成果和数据、三得变更请求、四得事业环境因素和组织过程资产的更新（比如项目过程中企业文化&#x2F;团队氛围的变化、经验教训等）\n\n什么是整合兼具统一、合并、沟通和建立联系，这些行动贯穿项目始终。整合管理包括识别、定义、组合、统一与协调项目管理各过程\n项目整合管理包括选择：资源分配、平衡竞争性需求、研究各种备选方法、为实现项目目标而剪裁过程、管理各个项目管理知识领域之间的依赖关系\n整合管理是整个项目成功的关键，项目经理因整合而存在（整合的唯一方法是沟通和协调，项目经理要花大于90%的时间用于沟通和协调上）\n敏捷环境中的整合迭代和敏捷方法：能够促进团队成员以相关领域专家的身份参与整合管理，团队成员自行决定计划及其组件的整合方式\n适应型环境下：对项目经理的期望保持不变，把具体产品的规划和交付授权给团队来控制，项目经理关注营造一个合作型的决策氛围，确保团队有能力应对变更\n项目整合管理的发展趋势\n使用自动化工具（PMIS）\n使用可视化管理工具\n项目知识管理（团队共享共同维护知识文档）\n增加项目经理的职责\n混合方法\n\n剪裁需要考虑的因素项目生命周期、开发生命周期、变更、经验教训、效益、管理方法、知识管理、治理\n项目整合管理的过程\n启动过程组：制定项目章程（目的是批准项目并授权项目经理在项目活动中使用组织资源，最终得到一份项目管理文件叫项目章程）\n规划过程组：制定项目管理计划（目的是整合所有子计划为一份综合项目管理计划，最终得到一份文件叫项目管理计划）\n执行过程组：指导与管理项目工作（目的是执行项目管理计划和批准的变更，实现项目目标）、管理项目知识（目的是利用现有知识生成新的知识，帮助组织学习）\n监控过程组：监控项目工作（目的是跟踪、审查、报告整体项目进展，实现绩效目标）、实施整体变更控制（目的是审查变更请求、批准变更，管理变更）\n收尾过程组：结束项目或阶段（目的是终结项目、阶段或合同的所有活动）\n\n制定项目章程\n制定一份正式批准项目并授权项目经理在项目活动中使用组织资源的文件。主要作用：明确项目与组织战略目标之间的直接联系，确立项目正式地位，展示组织对项目的承诺。本过程只开展一次或在项目预定义点开展\n\n商业论证（商业需求和成本效益分析）\n\n成本效益分析可以使用定性的非数学模型分析，也可以使用定量的经济计量模型也就是数学模型分析\n\n效益管理计划\n\n目标效益：如可以创造的有形&#x2F;无形商业价值，财务价值体现：净现值\n战略一致性：如项目效益与组织业务战略的一致程度\n实现效益的时限：如阶段效益、短期效益、长期效益和持续效益\n效益责任人：如计划确定时限内负责监督、记录、报告已实现效益负责人\n测量指标：如直接测量值和间接测量值\n假设：如预计存在或显而易见的因素\n风险：如实现效益的风险\n\n项目效益：为发起组织和项目预期受益方创造价值的行动、行为、产品、服务或成果的结果\n项目效益管理计划：描述了项目实现效益的方式和时间，应制定的效益制衡机制\n⭐️商业论证和效益管理计划不是项目管理文件，而是项目开始之前就具备的商业文件\n\n协议：合同（外部客户）、谅解备忘录、服务品质协议、协议书（口头）&#x2F;意向书、电子邮件&#x2F;其他书面协议\n\n假设日志：假设条件、制约因素\n\n\n制定项目管理计划\n制定一份项目管理计划，定义&#x2F;准备&#x2F;协调所有子计划，把它们整合为一份综合项目管理计划。包括：12+4+2个文档，12个子计划，4个基准，2个重要描述文档。本过程只开展一次或在项目预定义点开\n\n12个子计划：范围管理计划、进度管理计划、成本管理计划、质量管理计划、相关方参与计划、需求管理计划、配置管理计划、变更管理计划、资源管理计划、沟通管理计划、风险管理计划、采购管理计划\n4个基准：范围基准、成本基准、进度基准、绩效测量基准PMB\n2个重要描述文档：项目生命周期描述、开发方法\n\n指导与管理项目工作\n为实现项目目标，领导和执行项目管理计划中确定的工作，实施已批准的变更请求。本过程需要在整个项目期间开展\n\n三个重要输出：可交付成果、工作绩效数据、变更请求\n项目管理信息系统PMIS：项目管理系统[项目管理信息系统[配置管理系统[变更控制系统]]]\n配置管理系统最少要有3个配置项：文档（计划&#x2F;文件）配置项、产出配置项、变更配置项，对这三个配置项要分别进行3个管理活动：定义&#x2F;识别、记录、检查\n\n\n\n管理项目知识\n使用现有知识生成新知识，实现项目目标，帮助组织学习。本过程需要在整个项目期间开展\n\n经验教训登记册：\n\n情况的类别和描述\n与情况相关的影响、建议和行动方案\n遇到的挑战、问题、意识到的风险和机会\n其他内容\n\n\n项目团队派工单：\n\n团队成员名录\n\n在项目中的职责、角色\n\n人员姓名插入项目管理计划的其他组成部分\n\n姓名插入组织机构图、进入计划\n\n\n\n\n知识管理：\n\n合作生成新知识\n分享隐性知识\n集成不同团队成员拥有的知识\n知识管理的工具将员工联系起来\n\n\n\n监控项目工作\n跟踪、审查和调整项目进展，以实现项目管理计划中确定的绩效目标。本过程需要在整个项目期间开展\n\n变更请求\n变什么？\n\n变更请求：配置要素的任何内容变更的正式提议，书面形式记录\n\n怎么变？\n\n预防措施：可以避免过去人们常犯的错误\n纠正措施（小问题小偏差）：可以提示如何输入信息并使人知道应该去做什么\n缺陷补救（大问题大偏差）：可能让某人将错误的部分重做\n更新：对正规受控的文件或计划等变更，反映修改的内容\n\n\n数据-信息-报告-知识-经验-智慧\n工作绩效数据：从执行项目的活动中收集到的原始观察结果和测量值，数据是最低层的细节，交由各控制过程做进一步分析，由其他过程提炼出项目信息，脱离背景的数据本身不能用于决策\n工作绩效信息：从控制过程中收集并结合相关背景和跨领域关系整合分析得到，将工作绩效数据转化为工作绩效信息，考虑了背景和关系，可以作为项目决策可靠基础\n工作绩效报告：汇编工作绩效信息，形成纸质或电子项目文件，包括状态报告、备忘录、论证报告、信息札记、推荐意见和情况更新\n\n常用分析方法：分析完成后会得到一个决策，要不要继续下去的决策\n\n模型分析：回归分析、分组方法、失效分析、储备分析、挣值管理、故障树分析\n对比分析\n因果分析\n相关分析\n趋势分析\n\n\n有效的会议\n\n\n实施整体变更控制\n审查所有变更请求，批准变更，管理对可交付成果、项目文件和项目管理计划的变更，并决定对变更请求的处置方案。本过程需要在整个项目期间开展\n\n整体变更控制流程\n\n变更控制是一个机制，由变更控制系统来进行，它是项目管理信息系统PMIS的一个重要子系统，它包括变更管理流程&#x2F;制度、变更沟通程序、变更控制委员会CCB\n\n\n\n\n\n结束项目或阶段\n终结项目、阶段或合同的所有过程。本过程只开展一次或仅在项目的预定点开展\n\n注意交付和移交的区别，交付是指已经验收了合格了，移交是指交到客户手里去\n\n\n\n\n项目管理重要会议\n会议名称\n英文名称\n主要内容\n召开时间\n\n\n\n\n项目启动会议\nInitiating meeting\n发布项目章程、任命项目经理、赋予项目经理动用组织资源的权力\n启动阶段结束\n\n\n\n项目开踢&#x2F;开工会议\nkick-off meeting\n团队成员彼此认识、自上而下要求、自下而上承诺、建立沟通关系、建立责任关系\n规划阶段结束\n\n\n\n焦点小组会议\nFocus groups\n干系人和主题专家一起会议收集需求\n收集需求\n\n\n\n引导式研讨会\nFacilitated Workshops\n跨职能干系人与团队的会议收集需求\n收集需求\n\n\n\n规划会议与分析\nPlanning Meetings and Analysis\n制定风险管理计划、项目团队举行\n规划风险管理\n\n\n\n状态297、352（审查276&#x2F;413）会议\nStatus（review）Meetings\n交流和分析有关干系人参与的信息、项目进展沟通&#x2F;风险管理\n沟通计划&#x2F;控制风险控制干系人参与&#x2F;团队建设活动\n\n\n\n投标人会议\nBidder Conferences\n保证所有潜在卖方对技术要求和合同要求有清楚且一致的理解，公平公正\n投标书或建议书提交之前\n\n\n\n评估会议（经验教训总结会议）\n\n收尾报告会&#x2F;客户总结会&#x2F;经验教训总结会&#x2F;庆祝会\n结束项目或阶段\n\n\n\n\n知识领域概要三字言：观六路、听八方、思统筹、掌乾坤（格局）\n整合管理最为重要\n\n必须有人来协调项目所需人员&#x2F;工作&#x2F;计划\n必须有人集中精力管理项目的总体框架，引导团队成员成功完成项目\n必须有人在当项目目标&#x2F;人员出现冲突时作出最终决策\n必须有人与高管&#x2F;干系人沟通主要项目信息\n\n这个人就是项目经理，这种管理就是项目整合管理\n项目管理过程4W1H\n\nwhat：做什么？\nwhy：为什么做？\nwho：谁来做？\nwhen：什么时候做？\nhow：如何做？工具？\n\n","categories":["产品理论"],"tags":["项目管理-项目管理笔记"]},{"title":"项目管理探讨","url":"/2024/08/08/%E4%BA%A7%E5%93%81%E7%90%86%E8%AE%BA/%E9%A1%B9%E7%9B%AE%E7%AE%A1%E7%90%86/%E9%A1%B9%E7%9B%AE%E7%AE%A1%E7%90%86%E7%AC%94%E8%AE%B0/1_%E9%A1%B9%E7%9B%AE%E7%AE%A1%E7%90%86%E6%8E%A2%E8%AE%A8/","content":"项目管理的起源与发展项目管理自古就存在，比如埃及金字塔、万里长城\n项目管理的思路：想-谋（规划）-动（执行）-成\n项目管理起源于二战时期的曼哈顿计划，阿波罗登月计划使项目管理风靡全球，北极星计划被认为是现代项目管理的起点\n项目管理方法很久以来就是一些行业做生意的风格，其中有建筑业、美国国防部、好莱坞以及大的咨询公司。现在项目管理正扩散到所有工作领域。越来越多的组织开始认识到管理项目是每个人工作的关键部分。企业正开始认识到他们的所有员工而不仅仅是项目经理都会从项目管理培训中受益\n\n项目管理从远古走来，起源于战争，推广于社会，不断演进中\n项目管理学科载体和PMI1965年，以欧洲国家为主的一些国家成立了“国际项目管理协会IPMA”，1969年，美国成立了一个相同性质的组织，取名为“项目管理学会PMI”\n二十世纪中期，项目经理开始致力于将项目管理确立为一种职业，对项目管理达成一致意见\n项目管理学会PMI：\n\n1969年成立（5名志愿者发起、分享、讨论）\n\n1976年提出制定标准\n\n1983年发表一个报告，报告中的“标准”部分成为著名的项目管理知识体系指南\n\n1987年推出项目管理知识体系指南，简称PMBOK Guide，PMBOK Guide是项目管理职业的知识总和，是职业和实践的一个共同术语汇编，动态演进中\n\n\n\nPMI项目管理相关标准：\n\n《项目管理知识体系指南》PMBOK标准仅适用于单个项目\n《项目集管理标准》对项目集的管理\n《项目组合管理标准》对项目组合的管理\n\nPMP认证（项目管理专业人员资质认证）目标是致力于项目管理专业的实践知识和应用\n\n\n2000年，国家外国专家局培训中心与美国项目管理协会签订了合作协议，正式将PMP认证引入中国，国家外国专家局培训中心成为中国大陆独家代理PMP认证考试的管理合作机构\nPMP备考学习方法学习方法：结构化+发散式+滴灌法（广而不深、耗时渐进、充分理解）\n\n项目管理多视角解读管理的历史视角\n[英]亚当·斯密（1723-1790年）和劳动分工《国民财富的性质和原因的研究》（1776年）\n\n\n[美]弗雷德里克·温斯洛·泰勒（1856-1915）和科学管理《科学管理原理》1911年\n\n\n[法]亨利·法约尔（1841-1925年）和一般行政管理《工业管理和一般管理》1916年\n\n\n[美]乔治·埃尔顿·梅奥（1880-1949）和人际关系理论《工业文明中人类问题》1933年，《工业文明的社会问题》1945年\n\n\n[美]赫伯特·西蒙（1916-2001）和组织决策管理《管理行为》1947年，唯一获得诺贝尔奖经济学奖的管理大师\n\n\n[美]彼得·德鲁克（1909-2005）和目标管理《管理的实践》1954年\n\n\n\n\n管理者的活动：研究分析管理者的活动大致可分为四类\n\n传统管理：决策、计划和控制\n\n沟通：交流理性信息和处理文书工作\n\n人力资源管理：激励、惩戒、调解冲突、人员配备、培训和管理\n\n网络关系：社交活动、政治活动\n\n与外界交往\n\n\n\n有效的管理者和成功的管理者：\n\n有效的管理者：较好实现目标绩效和下属员工满意度高的管理者\n\n成功的管理者：组织中提升最快的管理者\n\n\n\n管理就是理事调人相得益彰、效率效果平衡兼顾\n管理要做的事情就是：计划、组织、领导、控制\n单项目视角单项目框架：十大知识领域、五大管理过程组、生命期阶段\n\n项目是为创造独特产品、服务或成果而进行的临时性工作\n项目是组织创造价值和效益的主要方式。在当今商业环境下，组织领导者需要应对预算紧缩、时间缩短、资源稀缺以及技术快速变化的情况，商业环境的动荡不安，变化越来越快，为了在全球经济中保持竞争力，公司日益广泛利用项目管理，来持续创造商业价值\n项目可以创造有形的、无形的成果\n\n项目的特点：\n\n临时性：每个项目都有确定的开始和结束，不意味时间短。项目具有时间约束（临时性不适用于项目产生的产品，产品我们希望它是长期的，比如万里长城）\n\n独特性：项目创造独特的可交付成果\n\n渐进明细：意味着分步开发，连续积累\n\n项目驱动变更：推动组织状态（当前状态）转到另一状态，获得期望结果（将来状态）\n项目驱动组织变更&#x2F;变革：结构、规模、职责、角色（组织通过项目进行状态转换）\n\n\n\n项目启动背景：\n\n符合法规、法律或社会要求\n满足相关方的要求或需求\n创造、改进或修复产品、过程或服务\n执行、变更业务或技术战略\n\n项目结束：\n\n达成项目目标（项目结束）\n不会或不能达成目标，资金缺乏，无法获得所需人力或物力资源（提前终止）\n需求不复存在，客户不再要求完成项目，战略优先级的变更致使项目终止，组织管理层下达项目终止指示（项目终止）\n出于法律或便利原因终止项目（项目终止）\n\n商业价值：从商业运作中获得的可量化净效益。效益可以是有形的、无形的或二者兼有之。在商业分析中，商业价值被视为回报，即以某种投入换取时间、资金、货物或无形的回报\n\n有形价值：货币资产、固定设施、股东权益、公共事业、工具、市场份额等\n无形价值：商誉、品牌认知度、公共利益、商标、战略一致度、声誉等\n\n项目管理：将知识、技能、工具和技术应用于项目活动，以满足项目的要求。项目管理通过合理运用与整合特定项目所需的项目管理过程得以实现。项目管理使组织能够有效且高效地开展项目\n有效项目管理的重要性：\n\n达成目标，满足相关方期望，提高可预测性，提高成功概率，在适当时间交付正确产品\n解决问题和争议，及时应对风险，识别、挽救或终止失败项目\n优化组织资源的使用\n管理制约因素（范围、质量、进度、成本），平衡制约因素对项目的影响，以更好的方式管理变更\n\n项目经理的道德与专业行为规范：（4个2）\n\n项目与运营：\n\n项目与运营在产品生命周期的不同时点交叉：在每个交叉点，可交付成果及知识在项目与运营之间转移，项目趋于结束，项目资源被转移到运营中，项目开始时，运营资源被转移到项目中\n\n在每个收尾阶段\n在新产品开发、产品升级或提高产量时\n在改进运营或产品开发流程时\n在产品生命周期结束之前\n\n项目生命周期：life cycle，是通常按顺序排列而有时又相互交叉的各项目阶段的集合。生命周期能为管理项目提供基本框架\n项目阶段是为有效完成某些重要的可交付成果而在需要特别控制点将项目分界。阶段结束点是对项目进行重新评估，并在必要时变更或终止项目的一个当然时点。这些时点可称为阶段出口、里程碑、阶段关卡、决策关卡、时段关卡或关键决策点（启动项目、组织与准备、执行项目工作、结束项目）\n\n项目生命周期类型：\n\n\n预测型（完全计划驱动型）：在项目生命周期的尽早时间，确定项目范围和交付此范围所需的时间和成本，也称瀑布开发模型\n\n\n适应型（变更驱动方法或敏捷方法）：为应对大量变更，获取干系人的持续参与。通常在每次迭代中都会执行多个过程（螺旋或迭代开发模型）\n\n\n\n迭代开发：就是反复求精，增量开发：就是逐块构建\n\n项目生命周期通用结构：\n\n\n典型的生命周期结构（三个阶段）：\n\n项目阶段的关系：\n\n顺序关系：时间长，技术稳妥，有时赶不上市场需求，技术风险低，市场风险大，计划阶段经常这样做\n\n\n交叠关系：也被叫做搭接，时间短，市场经济快，但加大了技术风险\n\n\n迭代关系：\n\n\n\n项目商业文件：项目立项之前的文件\n\n项目商业论证：文档化的经济可行性研究报告，用来对尚缺乏充分定义的所选方案的收益进行有效性论证，是启动后续项目管理活动的依据\n项目效益管理计划：对创造、提高和保持项目效益的过程进行定义的书面文件\n\n需求评估与关键业务&#x2F;项目文件的相互关系：\n\n项目目标（工作所指向的结果）：SMART原则\n\nSpecific：明确的\nMeasurable：可测量\nAchievable：可实现\nRelevant：相关联的\nTime bound：有时限的\n\n项目成功标准：\n\n项目成功标志之一：以产品与项目的范围（质量）、进度和预算达成度以及相关方满意度来测量成功\n\n项目管理三约束&#x2F;三坐标：\n\n项目约束目标间的关系：\n\n项目所处环境对项目的影响：\n\n事业环境因素EEF：项目团队不能控制的，将对项目产生影响、限制或指令作用的各种条件，可能提高或降低项目管理的灵活性，对项目结果产生积极或消极影响\n\n组织文化、结构、治理、设施资源地理分布、政府行业标准、基础设施、现有人力资源状况、组织规章制度、公司授权系统、干系人的风险承受力、政治氛围、组织已有的沟通渠道、商业数据库、项目管理信息系统等\n\n组织过程资产OPA：执行组织所特有并使用的计划、流程、政策、程序和知识库，包括来自任何（或所有）项目参与组织的可用于执行或治理项目的任何产物、实践或知识。还包括组织知识库（经验教训和历史信息）\n\n流程与程序、共享知识库\n\n组织系统：\n\n组织系统因素：管理要素、治理框架（规则、政策、程序、规范、关系、系统、过程）、组织结构类型\n组织系统的原则：系统是动态的、系统是可以优化的、系统组件是可以优化的、系统及其组件不能同时优化、系统呈现非线性响应（输入的变更并不会产生可预测的输出）\n\nPMO：项目管理办公室&#x2F;项目集管理办公室&#x2F;项目组合管理办公室，对与项目相关的治理过程进行标准化，并促进资源、方法论、工具和技术共享的一个组织结构。PMO的职责、范围可大可小，从提供项目管理支持服务到直接管理一个或多个项目\n三种不同类型的PMO：具体是哪种要看公司的事业环境因素\n\n组织结构：组织结构是企业正式的配置机制、程序机制、监督机制、治理机制、授权和决策机制\n选择组织结构类型考虑的因素：\n\n组织结构要跟公司战略一致\n组织结构要体现公司的专业能力\n要考虑这种组织结构管理的效率与效果\n授权、职责（终责）分配、权限、决策\n设计简单、灵活\n考虑成本因素\n地理位置\n部门设置\n沟通便利\n\n组织结构类型：\n\n简单型：\n\n\n\n职能型：会带来资源专属的浪费，比如市场营销部门需要1个质量控制的人员，它不可能去生产部门去借，生产部门的质量控制人员也不太想去市场营销，所以市场营销部门只能再招一个，这就造成了浪费\n\n\n\n多部门：\n\n\n\n项目型：项目都是临时的，人员没有归属感，也没有晋升通道\n\n\n\n矩阵型：缺点是员工既是部门内人员又是项目组成员，但是员工会更偏向于听从部门经理的\n\n\n\n虚拟型：\n\n\n\n混合型：\n\n\n\nPMO型：\n\n\n\n\n项目经理PM：是执行组织委派其实现项目目标的个人\n\n责任：对项目成果负责\n知识和技能：管理知识、技术知识、理解和经验、关注行业发展、跨领域\n沟通：充当发起人、团队成员和其他相关方之间的沟通者\n成功的项目经理：持续有效地使用某些基本技能，展现出超凡的人际关系和沟通技能以及积极的态度\n对组织的了解：战略、使命、目的、目标、优先级、策略、产品和服务、风险、商务知识\n\n项目相关方&#x2F;项目经理影响范围：（PPP经理：项目经理、项目集经理、项目组合经理）\n\n项目经理的能力：PMI人才三角\n\n领导者的品质和技能：\n\n有远见，积极乐观\n重点关注系统思维\n乐于合作，管理冲突\n服务导向，结果&#x2F;行动导向\n高效团队，幽默分享\n管理关系，进行沟通\n尊重他人，终生学习\n批判性思维，推动变革\n诚信正直，文化敏感\n\nPM行使权力的方式：\n\n管理与领导力比较：\n\n管理力风格：放任型、交易型、服务型、变革型、魅力型、交互型等\n\n考虑要素：领导者的特点、团队成员的特点、环境的特点、组织的特点\n\n领导力风格：软性技能\n情商：指一个人控制自己和他人情绪的能力（四种情绪：喜怒哀惧，让自己快乐，让别人舒服）\n\n要素：自我认知、自我管理、自我激励、认知他人、管理他人\n\n执行整合：整合是项目经理的一项关键技能，与发起人携手合作，指导团队协同工作，整合过程、知识和人员（过程层面、认知层面、背景层面）\n项目管理与其他学科的关系：\n\n项目管理学科独有的（PM应有的四个知识）：项目生命期概念、工作分解结构WBS、关键路径法、挣值技术\n其他领域知识的支持：一般科学知识（如系统科学、行为科学、财务、组织、经济、政治、心理、社交、管理、商业环境等）、各种应用领域（如软件开发、医药学、工程设计与施工）\n\n整合与复杂性：\n\n复杂性定义：\n包括多个部分\n不同部分之间存在一系列连接\n不同部分之间有动态交互作用\n这些交互作用所产生的行为远远大于各部分简单相加\n\n\n复杂性三个维度：\n系统行为（组成部分与系统之间的依赖关系）\n人类行为（不同个体和群体之间的相互作用）\n不明确性（出现问题、缺乏理解或造成困惑引发的不确定性）\n\n\n\n资源集成视角资源是一切具有现实和潜在价值的东西，包括自然资源和人造资源、内部和外部资源、有形资源和无形资源，工程类的项目管理会将资源分为人力和人才、材料、机械、资金、信息、科学技术、市场等七类，即7M，项目管理作为方法和手段，也是一种资源\n在复杂多变的环境中，集成资源做好一件事\n资源分解结构RBS：\n\n项目管理是最有效地整合资源、高效地实现目标的理论和技术，已在全球范围内迅速发展和应用\n\n资源集成模型：多组织级之间、组织级之间、项目级之间\n资源集成机制：项目级外、组织级外\n总价合同：买方必须准确定义要采购的产品或服务，对采购规范的任何变更都可能增加买方的成本（总价合同是一种封口合同，也就是总价是有边界的）\n固定总价合同FFP：采用总价合同买方必须定义要采购的产品或服务，虽然允许范围变更，但范围变更通常会导致合同价格提高\n总价加激励费合同FPIF：设置一个价格上限，卖方必须完成工作并且要承担高于上限的全部成本\n总价加经济价格调整合同FP-EPA：持续时间较长的合同，允许根据条件变化以事前确定的方式对合同价格进行最终调整\n\n\n成本补偿合同：工作范围无法准确定义，项目工作存在较大风险，以便重新安排卖方的工作（成本补偿合同是一种开口合同）\n成本加固定费合同CPFF：固定费只能针对已完成的工作，不因卖方的绩效而变化，范围发生变化才可考虑费用的改变\n成本加激励费合同CPIF：基于卖方的实际成本按一定的比例分担超过或低于目标成本的部分，便于卖方重视控制成本\n成本加奖励费合同CPAF：适用于成果评价标准不易或无法量化的项目，如管理咨询项目等，支付的奖励费用完全由买方主观判断决定，卖方无权申诉\n\n\n工料合同T&amp;M：增加人员、聘请专家、寻求外部支持，可规定价格和时间限制，防止成本无限增加\n\n\n\n\n项目式做事风格视角项目式做事风格5过程：\n\n项目式做事风格可以培养我们的目标能力、专业能力、用人能力、社交能力、营销能力、转化能力、把控能力、革新能力\n组织级视角项目的三种不同管理模式：\n\n有效&#x2F;高效的项目管理应被视为组织的战略能力\n\n项目集和项目集管理：\n\n项目集是一组相互关联且被协调管理的项目、子项目和项目集活动，以便获得分别管理所无法获得利益1+1&gt;&gt;2\n项目集不是大项目，大项目是指10亿美元及以上成本、影响上百万人，持续数年\n项目集管理是指在项目集中应用知识、技能与原则来实现项目集目标，获得分别管理项目集组成部分所无法实现的利益和控制。项目集中的项目通过产生共同的结果或整体能力而相互联系。如果项目间的联系仅限于共享雇主、供应商、技术或资源，那么这些项目就应作为一个项目组合而非项目集来管理\n项目集管理重点关注项目间的依赖关系，并有助于找到管理这些依赖关系的最佳方法（共同目标关联，协同收益交付）\n\n项目组合和项目组合管理：\n\n项目组合是指为实现战略业务目标而组合在一起管理的项目、项目集、子项目组合和运营运作。项目组合中的项目或项目集不一定彼此依赖或有直接关系\n项目组合管理是指为了实现特定的战略业务目标，对一个或多个项目组合进行的集中管理，包括识别、排序、授权、管理和控制项目、项目集和其他有关工作\n项目组合管理重点关注通过审核项目和项目集来确定资源分配的优先顺序，并确保对项目组合的管理与组织战略协调一致\n\n项目组合、项目集、项目和运营：\n\n项目集管理和项目管理是以正确的方式开展项目集和项目，项目组合管理是开展正确的项目集和项目\n组织项目管理：\n\n战略：与战略有关的词（使命、愿景、目标）\n\n组织&#x2F;企业战略：组织以未来为主导，为寻求和维持持久竞争优势而做出的有关全局的重大筹划和谋略\n\n战略目标：对企业战略经营活动预期取得的主要成果的期望值\n项目与战略规划：\n\n企业使命：企业在社会中存在的根据&#x2F;价值或在社会中应担当的角色和责任，体现了企业总的发展方向，企业的长期目标和企业行为活动的总原则，一般包括四个要素：企业哲学、企业宗旨、企业形象、企业社会责任，由内、外部因素决定企业使命（解决我们要做什么？为什么这样做？）\n使命陈述：\n\n愿景：彼得·圣吉《第五项修炼》中愿景是愿望的景象，企业愿景是对企业长期发展前景、发展方向、目标、目的等自我设定的社会责任，企业的共同愿望体现企业的价值观，是企业的灵魂，是企业发展愿望和长远目标的情景式描述（解决我们要成为什么？）\n项目管理和组织战略之间的关系：\n\n企业管理地图：\n\n业务运营实现的是源源不断的现金流维持着短期的公司的发展，项目考虑的是公司的未来，为未来注入活力\n运营管理可以使用项目管理的方法进行，但是项目管理不能使用运营管理的方法\n\n\n基于项目的组织PBO：指建立临时机构来开展工作的各种组织形式。在各种不同的组织结构中，都可以建立PBO，采用PBO可以减轻组织中的层级主义和官僚主义，因为在PBO中，考核工作成败的依据是最终结果，与职位或政治因素无关\n组织治理：\n\n\n组织驱动因素：组织结构、组织文化、组织技术、人力资源实践\n组织治理由董事会执行\n\n项目治理：项目治理是在组织治理的框架之下\n\n项目治理框架：\n\n敏捷方法：描述了一组交付软件的原则和实践，2001年17位“轻量级”方法学家在Utah的Snowbird会晤，提出包含4个敏捷价值观、12条敏捷宣言原则\n\n4个敏捷价值观：个人与互动胜于过程和工具、可用的软件胜于复杂的文档、与客户协作胜于合同谈判、相应变更胜于遵循计划\n12条敏捷宣言原则\n我们最重要的目标，是通过及早和持续不断地交付有价值的软件使客户满意\n欣然面对需求变化，即使在开发后期也一样。为了客户的竞争优势，敏捷过程掌控变化\n经常地交付可工作的软件，相隔几星期或一两个月，倾向于采取较短的周期\n业务人员和开发人员必须相互合作，项目中的每一天都不例外\n激发个体的斗志，以他们为核心搭建项目。提供所需的环境和支援，辅以信任，从而达成目标\n不论团队内外，传递信息效果最好效率也最高的方式是面对面的交谈\n可工作的软件是进度的首要度量标准\n敏捷过程倡导可持续开发。责任人、开发人员和用户要能够共同维持其步调稳定延续\n坚持不懈地追求技术卓越和良好设计，敏捷能力由此增强\n以简洁为本，它是极力减少不必要工作量的艺术\n最好的架构、需求和设计出自自我组织的团队\n团队定期地反思如何能提高成效，并依此调整自身的行为表现\n\n\n\n项目管理良好实践项目交付方面出众公司拥有的4个最佳实践&#x2F;良好实践：\n\n使用完整的工具箱：\n\n数据收集技术：访谈、问卷调查、资料收集、现场参观与调查、观察法、原型法\n数据分析技术：模型分析、对比分析、因果分析、相关分析、趋势分析\n\n\n\n培养项目经理\n\n《阿尔法项目经理：什么是2%的顶尖人才知道，而其他人不知道的》收集了860名项目经理的资料，发现除了实施过程外，最好的阿尔法项目经理在每个过程上花费的计划时间比其他项目经理多，阿尔法项目经理在计划过程所花时间通常是其他项目经理的2倍\n\n\n\n\n使用标准过程管理：49个标准过程\n\n项目管理往往体现为相互关联的若干过程，尊重管理项目的标准过程可以协助预防新的和有经验的项目经理都会遇到的一些典型问题\n\n\n使用度量体系检测\n\n采取有效监控方法，建立度量体系，控制风险，控制变更\n\n\n\n项目管理知识领域：\n\n整合管理：项目经理是整合者\n范围、进度、成本、质量：4个核心知识领域（偏硬性技能）\n资源、沟通、风险、采购、相关方：5个辅助知识领域（偏软性技能）\n\n","categories":["产品理论"],"tags":["项目管理-项目管理笔记"]},{"title":"项目相关方管理","url":"/2024/08/07/%E4%BA%A7%E5%93%81%E7%90%86%E8%AE%BA/%E9%A1%B9%E7%9B%AE%E7%AE%A1%E7%90%86/%E9%A1%B9%E7%9B%AE%E7%AE%A1%E7%90%86%E7%AC%94%E8%AE%B0/12_%E9%A1%B9%E7%9B%AE%E7%9B%B8%E5%85%B3%E6%96%B9%E7%AE%A1%E7%90%86/","content":"基本概念识别能影响项目或受项目影响的全部人员、群体或组织，分析相关方对项目期望和影响，制定合适的管理策略，有效调动相关方参与项目决策和执行\n相关方管理还关注与相关方的持续沟通，了解相关方的需求和期望，解决实际发生的问题，管理利益冲突，促进相关方合理参与项目决策和活动，把相关方满意度作为一个关键项目目标来进行管理\n每个项目都有相关方，他们受项目的积极和消极影响、或者能对项目施加积极或消极影响。有些相关方影响项目的能力有限，而有些相关方可能对项目及其期望结果有重大影响\n项目经理正确识别、合理管理相关方的能力，能决定项目的成败\n过程和目的启动过程组：\n\n识别相关方：谁是你特定项目的相关方，利益&#x2F;参与情况&#x2F;影响，形成一份项目管理文件叫项目相关方登记册\n\n规划过程组：\n\n规划相关方参与：分析相关方对项目成功的潜在影响，制定合适的管理策略，得到一份相关方参与计划\n\n执行过程组：\n\n管理相关方参与：与相关方沟通协作，满足其需求与期望，解决问题，促进相关方合理参与项目活动\n\n监控过程组：\n\n监督相关方参与：监督项目相关方之间的关系，调整策略和计划，调动相关方参与过程\n\n识别相关方\n定期识别相关方，分析和记录他们的利益、参与度、相互依赖性、影响力和对项目成功的潜在影响。本过程应根据需要在整个项目期间定期开展\n\n使用穷尽法（注意识别潜在的项目相关方）\n\n相关方映射分析&#x2F;表现分析：权力-利益方格\n\n\n\n规划相关方参与\n根据相关方需求、期望、利益和对项目潜在影响，制定相关方与项目参与的方法。本过程应根据需要在整个项目期间定期开展\n\n相关方参与度评估矩阵：\n\n\n\n管理相关方参与\n与相关方沟通和协作以满足其需求与期望、处理问题，促进相关方合理参与。本过程需要在整个项目期间开展\n\n更新相关方登记册\n基本规则就是指规章制度\n\n监督相关方参与\n监督项目相关方关系，并通过修订参与策略和计划来应对相关方合理参与项目。本过程需要在整个项目期间开展\n\n工作绩效数据和工作绩效信息都是指相关方的\n\n知识领域概要相关方管理最善关系\n\n要准确识别相关方\n要清楚相关方对项目的影响有多大\n善平衡\n维关系\n\n每个项目都有相关方，一些潜在的相关方不易识别，项目经理正确识别并合理管理项目相关方的能力，能决定项目的成败\n","categories":["产品理论"],"tags":["项目管理-项目管理笔记"]},{"title":"项目管理标准","url":"/2024/08/14/%E4%BA%A7%E5%93%81%E7%90%86%E8%AE%BA/%E9%A1%B9%E7%9B%AE%E7%AE%A1%E7%90%86/%E9%A1%B9%E7%9B%AE%E7%AE%A1%E7%90%86%E7%AC%94%E8%AE%B0/2_%E9%A1%B9%E7%9B%AE%E7%AE%A1%E7%90%86%E6%A0%87%E5%87%86/","content":"项目管理过程单个项目管理的三维坐标框架：过程+阶段+知识\n项目管理过程：为完成预定的产品、成果或服务而执行的一系列相互关联的行动和活动（输入-工具和技术-输出）\n\n49个项目管理过程\n五大管理过程组（不能把启动过程组理解为最开始，也不能把收尾过程组理解为最末尾，这五大管理过程组在项目执行的任何时间段都可能进行）\n启动过程组：定义一个新项目或现有项目的一个新阶段，授权开始该项目或阶段（已经有了一个项目目标）\n规划过程组：明确项目范围，优化目标，为实现目标制定行动方案\n执行过程组：完成项目管理计划中确定的工作以满足项目要求，执行批准的变更\n监控过程组：跟踪、审查和调整项目进展与绩效，识别必要的机会变更并启动相应变更\n收尾过程组：正式完成或结束项目、阶段或合同（不仅仅在结束项目时进行收尾，阶段结束也可以进行收尾）\n\n\n\n过程组与应用领域无关，因具体项目需求不同，过程通常分为三类：\n\n仅一次或在预定义点（比如制定项目章程、结束项目或阶段）\n依需定期开展（比如获取资源、实施采购）\n贯穿始终持续开展（比如定义活动、监控）\n\n项目或阶段中过程组相互作用：\n\n项目商业文件：商业论证、项目效益管理计划\n项目管理计划12+6、项目管理文件：\n\n关键组成部分在项目中的相互关系：\n\n项目边界：项目结束一般都很清晰，但是项目开始很模糊，需要公司或组织进行定义\n\n五大管理过程组之间的联系：\n\n启动过程组及典型方法启动过程组：定义一个新项目或现有项目的新阶段，授权开始该项目或过程\n\n目的：协调相关方期望与项目目的，告知相关方项目范围和目标，并商讨他们对项目及相关阶段的参与将如何有助于实现期望，正式立项\n作用：确保只有符合组织战略目标的项目才能立项，在项目开始时就认真考虑商业论证、项目效益和相关方\n2个过程：制定项目章程、识别相关方\n\n界定项目成功是项目管理中最常见的挑战之一\n启动过程组典型方法：\n\n项目选择方法：业务需求&#x2F;成本效益分析\n\n商业论证：文档化的可行性研究报告，用来对尚缺乏充分定义的所选方案的收益进行有效性论证（商业论证中记录已商定的财务指标）\n\n非数学模型（定性分析）：圣牛模型、经营需要模型&#x2F;战略需要模型、专家意见模型、比较利益模型&#x2F;Q分类\n\n数学模型&#x2F;经济计量模型（定量分析）：赢利能力模型【（静态指标：不考虑资金的时间价值，回收期、收益成本比BCR、投资回报率ROI）、（动态指标：考虑资金的时间价值，净现值NPV、内部收益率IRR）】\n\n没给原始投入，默认为0：\n\n折现因子表：\n\n\n项目计算期：指投资项目从投资建设开始到最终清理结束整个过程的全部时间，即该项目有效持续时间。完整项目计算期包括建设期（s）和经营期（p）\n原始投资：企业为使项目完全达到设计生产能力、开展正常经营而投入的全部现实资金，包括固定资产投资、流动资产投资、其他长期资产投资\n投资总额：反映项目投资总体规模的价值指标，投资总额&#x3D;原始投资+资本化利息\n净现金流量：又称现金净流量，指在项目计算期内各年现金流入量与现金流出量之差，某年净现金流量&#x3D;该年现金流入量-该年现金流出量\n静态回收期：用投资项目所得的净现金流量来回收原始投资所需的年限\n互斥项目：指在多个项目的选择中只能选取一个项目，其他项目必须放弃，即项目之间具有排他性，只能选择一个最优方案\n\n\n评分模型：评分标准未加权模型、加权模型\n\n\n\n\n一个好的投资决策方法应具有的三个特征：\n\n考虑项目整个寿命期内的现金流量\n考虑资金的时间价值，对现金流量按资本成本或项目的预期收益率折现\n对互斥项目进行比较和优选时，应能选出使公司股票价值最大的项目\n\n规划过程组及典型方法规划过程组：明确项目全部范围、定义和优化目标，为实现项目目标制定行动方案\n\n目的：制定项目管理计划的组成部分、用于执行项目的项目文件\n作用：确定成功完成项目或阶段的行动方案\n24个过程\n\n为使一个项目成功，必须有良好的计划与控制，但良好的计划与控制并不能确保项目的成功\n\n计划要回答的问题：\n明确谁是顾客\n客户的需要是什么\n我们工作处在什么位置\n我们工作应该在什么情况下结束\n技术性能要求是什么\n费用限额是多少\n项目期是多长\n\n\n\n计划能否对行动起到有效的指导，依赖于对不确定性的正确评估和预测\n不同的项目有不同的不确定性，高复杂性不等于高风险性，高风险性也不等于高复杂性\n\n具有高度不确定性项目计划，要听取专家意见、借鉴类似项目的经验、根据过去的项目进行推断、进行风险分析\n\n规划过程组典型方法：\n\n分解：工作分解结构WBS（WBS的最底层叫做工作包，其余叫做工作组件）\n\n结果型WBS、任务型WBS\nWBS有三种表现形式：表格型、层级结构图、气泡图\n是一种必须执行的任务清单\n作为制定活动计划的基础\n越来越趋向于被用作面向产品（可交付成果）的工具而不是面向活动\n制定WBS的步骤：\n识别和分析可交付成果及相关工作\n确定WBS的结构和编排方法\n自上而下逐层细化分解\n为WBS组件制定和分配标识编码&#x2F;帐户编码（帐户编码只代表这个组件和工作包的ID，唯一识别码）\n核实可交付成果分解的程度是否恰当\n\n\n\n\n甘特图（横道形式）：可以用来表示项目的进度\n\n甘特图（替换形式）：\n\n\n里程碑图：\n\n\n网络图-单代号网络图（也叫结点图，结点表示活动，箭线表示关系）：网络图是表示活动间逻辑关系的图形\n\n单代号网络图节点表示法&#x2F;七格图：最早结束时间EF&#x3D;ES+D\n\n单代号网络图-前导图PDM的4种逻辑关系：\n\n网络图-双代号网络图（也叫箭线图，箭线表示活动）：\n\n双代号网络图节点的表示法：\n\n双代号网络图的特点：（虚活动：不消耗时间也不消耗资源，为定义活动，定义逻辑关系）\n\n绘制网络图必须遵守以下规则：\n\n\n\n\n\n计划评审技术PERT：三点估算\n\n基于正态分布的三点估算：\n\n\n\n\n关键路径法CPM：通过分析项目过程中哪个活动序列进度安排的总时差最少来预测项目工期的网络分析\n\n产生目的：为了解决在庞大而复杂的项目中，如何合理而有效地组织人力、物力和财力，使之在有限资源下以最短的时间和最低的成本费用下完成整个项目\n\n关键路径是相对的，也可以是变化的\n\n关键路径可以有多条，关键路径上的活动时差为0\n\n使用CPM方法计算进度时间参数\n\n正推法：\n\n\n\n逆推法：\n\n\n总浮动时间TF&#x3D;LS-ES&#x3D;LF-EF，总浮动时间为0的路径就是关键路径（关键路径ADEF），关键路径决定了项目的工期，非关键路径时间都短于关键路径时间\n自由浮动时间FF不影响工期，但是影响紧后活动的开始时间（活动B的FF&#x3D;活动F的ES-活动B的EF&#x3D;4），有自由浮动时间的路径不是关键路径\n关键路径上总浮动时间TF和自由浮动时间FF都是0\n\n\n\n在进行前导图PDM排序的过程中，取决于所用的制约因素，关键路径的总浮动时间TF可能是正值、零或负值\n\n\n\n\n\n\n资源管理\n\n最根本的问题：\n\n应该如何为项目分配人力和物质资源\n需要考虑的因素：项目的技术要求、拟选用的项目成员的能力、哪些人力和物质资源是可用的\n\n\n资源矩阵\nP&#x3D;主要负责人，S&#x3D;第二负责人\n\n\n资源数据表\n\n\n资源甘特图-以任务为索引\n\n资源甘特图-以资源为索引\n\n\n资源直方图\n\n\n\n\n资源优化技术\n\n资源平衡：资源平衡往往会延长关键路径推导出来的时间（资源固定、调整工期）\n\n\n资源平滑：资源平滑技术前提是ABC活动之间是软逻辑关系，资源平滑技术受到活动逻辑关系的制约（工期固定，调整资源）\n\n\n\n\n编制进度计划的步骤：\n\n获取WBS\n列出活动清单\n排列活动顺序\n编制网络图（WBS工作是不能用来画网络图的，只有活动才可以）\n进度时间参数计算\n确定关键路径\n资源优化（资源平衡&#x2F;资源平滑）\n\n\n路径汇聚：\n\n\n折旧方法：\n\n一般折旧\n\n直线折旧法\n\n\n工作量法\n每月（年）折旧额&#x3D;该月（年）工作量*单位工作量折旧额\n\n\n\n\n加速折旧\n\n双倍余额递减折旧法\n\n\n年数总和折旧法\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n自制外购分析\n\n\n项目管理是最有效地整合资源、高效地实现目标的理论和技术，已在全球范围内迅速发展和应用\n\n资源集成模型：多组织级之间、组织级之间、项目级之间\n\n资源集成机制：项目级外、组织级外\n\n总价合同：买方必须准确定义要采购的产品或服务，对采购规范的任何变更都可能增加买方的成本（总价合同是一种封口合同，也就是总价是有边界的）\n\n固定总价合同FFP：采用总价合同买方必须定义要采购的产品或服务，虽然允许范围变更，但范围变更通常会导致合同价格提高\n总价加激励费合同FPIF：设置一个价格上限，卖方必须完成工作并且要承担高于上限的全部成本\n总价加经济价格调整合同FP-EPA：持续时间较长的合同，允许根据条件变化以事前确定的方式对合同价格进行最终调整\n\n\n成本补偿合同：工作范围无法准确定义，项目工作存在较大风险，以便重新安排卖方的工作（成本补偿合同是一种开口合同）\n\n成本加固定费合同CPFF：固定费只能针对已完成的工作，不因卖方的绩效而变化，范围发生变化才可考虑费用的改变\n成本加激励费合同CPIF：基于卖方的实际成本按一定的比例分担超过或低于目标成本的部分，便于卖方重视控制成本\n成本加奖励费合同CPAF：适用于成果评价标准不易或无法量化的项目，如管理咨询项目等，支付的奖励费用完全由买方主观判断决定，卖方无权申诉\n\n\n工料合同T&amp;M：增加人员、聘请专家、寻求外部支持，可规定价格和时间限制，防止成本无限增加\n\n\n\n\n\n\n\n\n\n\n\n敏捷发布规划\n\n\n\n执行过程组及典型方法执行过程组：完成项目管理计划中确定的工作，满足项目规范要求，按照项目管理计划来协调人员和资源，管理相关方参与，整合并实施项目活动（不仅要执行计划，还要执行被批准的变更）\n\n目的：管理执行，完成项目\n作用：执行计划，完成项目目标，相当多的项目预算、资源和时间将用于开展执行过程组的过程\n10个过程\n\n执行过程组典型方法：\n\n保证体系（国际标准化组织ISO中著名的管理体系：质量管理体系）\n\n持续改进PDCA循环（戴明环）：P计划、D实施、C检查、A行动\n\n成熟度模型：（持续改进模型）\n\nSQFD软件质量功能展开\n\nCMMI能力成熟度模型集成\n\n\nOPM3组织项目管理成熟度模型\n\n\n\n\n\n项目管理信息系统PMIS：项目管理系统[项目管理信息系统[配置管理系统[变更控制系统]]]\n\n配置管理系统最少要有3个配置项：文档（计划&#x2F;文件）配置项、产出配置项、变更配置项，对这三个配置项要分别进行3个管理活动：定义&#x2F;识别、记录、检查\n\n\n\n监控过程组及典型方法监控过程组：跟踪、审查和调整项目的进展与绩效，识别必要的计划变更并启动相应变更\n\n目的：收集项目绩效数据，计算绩效指标，报告和发布绩效信息\n作用：按既定时间间隔，在待定事件发生时或在异常情况出现时，对项目绩效进行测量和分析，以识别和纠正项目管理计划的偏差\n12个过程\n所做的工作：跟踪、测量、偏差计算、偏差分析、评估结论、是否需要变更、是否需要采取纠正、预防、缺陷补救措施、重新估算、预测、趋势分析（预测是监控过程组，不是规划过程组）\n\n监控过程组典型方法：\n\n进度压缩\n\n时间成本平衡法&#x2F;赶工：通过权衡成本与进度，确定如何以最小的成本来最大限度地压缩进度\n\n优点：不增加项目风险和管理难度\n缺点：会因加班而增加成本\n基本假设：活动历时可从正常历时缩减到要压缩历时、压缩历时与成本增加呈线性关系、有足够的资源\n\n\n快速跟进：把正常情况下按顺序执行的活动或阶段并行执行\n\n\n\n\n\n\n\n\n\n\n\n\n挣值管理&#x2F;挣值分析：用来监督项目的绩效和进行情况\n\n下图只能看出项目进行的时间、成本，项目完成的范围看不出来，无法计算项目绩效，无法衡量项目做的好不好\n\n\n\n挣值分析：分析项目进度、成本、范围三个约束的关系（用钱来衡量这三个约束）\n计划价值PV是一条S曲线，代表项目基准，也被叫做绩效测量基准PMB，表示计划在当前时间花费这些费用完成这些工作量\n进度偏差SV&#x3D;EV-PV（图中是负数，进度不满足绩效）\n成本偏差CV&#x3D;EV-AC（图中是负数，成本不满足绩效）\n\n\n挣值法模型：通过五个输入（PV、EV、AC、BAC、BDAC）得到九个输出（绩效指标CV、SV、CPI、SPI，预测指标TCPI、EAC、ETC、VAC、EDAC）\n\nEAC的四种计算方法：\n\n挣值管理术语：\n\n\n\n偏差分析（评估）：\nSV、CV大于0说明目前项目绩效是好的，小于0说明项目绩效是不好的，但是也不是说大的越多越好，需要自己分析\nSPI、CPI大于1说明目前项目绩效是好的，小于1说明项目绩效是不好的\nTCPI小于1说明目前项目绩效是好的，大于1说明项目绩效是不好的\n\n预算是规划做的事情，预测是监控做的事情\n\n挣值管理的缺陷：\n\nEV进度在实际项目中是不好界定的，特别是IT项目中，所以需要采用一些其他方法\n\n加权里程碑法：为里程碑分配权重\n\n固定公式法：50&#x2F;50法则、20&#x2F;80法则、0&#x2F;100法则\n\n\n完工百分比法：根据合同完工进度确认合同收入和成本\n\n\n\n挣值管理分析项目进度、成本、范围三个约束的关系，无法将质量管理整合进去\n\n\n\n\n\n迭代燃尽图\n\n\n整体变更控制流程\n\n变更控制是一个机制，由变更控制系统来进行，它是项目管理信息系统PMIS的一个重要子系统，它包括变更管理流程&#x2F;制度、变更沟通程序、变更控制委员会CCB\n\n\n\n\n\n收尾过程组及典型方法收尾过程组：正式完成或关闭项目、阶段或合同\n\n目的：核实为完成项目或阶段所需的所有过程组的全部过程均已完成，正式宣告项目或阶段关闭\n作用：确保恰当的关闭阶段、项目或合同\n1个过程：结束项目或阶段\n\n收尾过程组典型方法：\n\n知识管理：显性知识、隐性知识\n\n知识管理要遵循以下三条原则：\n积累原则：知识积累是实施知识的管理基础\n共享原则：知识共享，是指一个组织内部的信息和知识要尽可能公开，使每一个员工都能接触和使用公司的知识和信息\n交流原则：知识管理的核心就是要在公司内部建立一个有利于交流的组织结构和文化气氛，使员工之间的交流毫无障碍\n\n\n\n\n项目管理过程工具与技术：\n\n数据收集技术：访谈、问卷调查、资料收集、现场参观与调查、观察法、原型法\n数据分析技术：模型分析、对比分析、因果分析、相关分析、趋势分析\n\n\n\n\n","categories":["产品理论"],"tags":["项目管理-项目管理笔记"]},{"title":"项目质量管理","url":"/2024/08/03/%E4%BA%A7%E5%93%81%E7%90%86%E8%AE%BA/%E9%A1%B9%E7%9B%AE%E7%AE%A1%E7%90%86/%E9%A1%B9%E7%9B%AE%E7%AE%A1%E7%90%86%E7%AC%94%E8%AE%B0/7_%E9%A1%B9%E7%9B%AE%E8%B4%A8%E9%87%8F%E7%AE%A1%E7%90%86/","content":"基本概念质量就是满足需求并符合要求（适用性、符合性）\n质量与等级：\n\n低质量是个问题\n低等级不一定是个问题\n\n精确与准确：\n\n精确是指重复测量结果聚合\n\n准确是指测量值接近实际值\n\n\n\n项目质量管理包括项目管理质量（过程）、项目产品质量（结果）\n项目管理领域引用现代质量管理领域的一些术语：\n\n质量管理的发展历程：统计控制阶段利用数理统计方法，对于普通人来说太难了，基本上都是专家大师在操控，所以会进入到全面管理阶段\n\n质量管理主要流派\n爱德华·戴明于《走出危机》一书中提出PDCA循环，也叫戴明环（持续改进）\n\n\n朱兰于《质量管理手册》中提出三部曲（改进、计划、控制），并提出质量是符合要求、适于使用\n\n\n克劳斯比《质量是免费的》提出质量成本包括第一次没有做好工作所有的成本，提出零缺陷概念（一致性成本不叫质量成本，不一致性成本才叫质量成本，如果在第一次就把工作做好，没有花费不一致性成本的话，就叫做零缺陷，就叫做质量是免费的）\n\n\n石川馨在《质量控制指南》中提出了要进行质量小组活动QC，使用因果图（5whys法）\n\n\n田口玄一在《稳健设计方法》中提出质量品质可以用金钱损失（损失函数）来表示\n\n\n费根鲍姆在《全面质量管理：工程与管理》中提出了全面质量控制TQC，产品质量比生产率更重要\n\n\n\n过程和目的规划过程组\n\n规划质量管理：识别要求和标准，描述如何达到标准，得到一份质量管理计划\n\n执行过程组\n\n管理质量：审计要求&#x2F;测量结果，确保标准&#x2F;操作合理（QA质量保证针对过程）\n\n监控过程组\n\n控制质量：监测&#x2F;记录结果，评估绩效，建议变更（QC质量控制针对结果&#x2F;产出）\n\n规划质量管理\n识别项目及其可交付成果的质量要求和标准，并书面描述项目将如何证明符合质量要求和标准。本过程仅开展一次或仅在项目预定义点开展\n\n质量管理计划要得到上级或者高层批准\n\n质量测量指标包括过程指标和产出指标\n\n成本效益分析：就是考虑性价比，用一些财务指标进行商业论证，比较质量成本与预期收益（比如收益成本比BCR、投资回报率ROI）\n\n达到质量要求的主要效益：减少返工、提高生产率、降低成本、提升干系人满意度\n\n\n组织系统流程图：SIPOC模型\n\n\n逻辑数据模型\n\n\n矩阵图\n\n\n思维导图\n\n\n管理质量\n把组织的质量政策用于项目，将质量管理计划转化为可执行的质量活动。本过程需要在整个项目期间开展\n\n管理质量是对过程的管理\n\n质量报告：它是一份项目管理文件，包括团队上报的质量问题、改善建议、纠正措施建议、质量控制中出现的情况等\n\n核对单\n\n过程分析：检查过程运行中遇到的问题，发现非增值活动，包括采用根本原因分析\n\n因果图：帮助找根本原因的\n\n\n直方图（数频直方图、质量分布图）\n\n特殊直方图：排列图（帕累托图、柏拉图），是帮助找众多原因中哪个原因是最主要原因的❓\n\n\n散点图（相关图、散布图），是帮助找相关原因的\n\n\n审计，也叫审核，是由内部或外部审核员进行的，通过检查和测试寻找证据向相关方&#x2F;客户&#x2F;外界证明产品质量过硬（证明的不是某一件产品质量过硬，而是证明公司保证机制良好，这才是管理质量过程该做的事，前者是控制质量过程做的事）\n\n确认过程对已批准的变更请求实施情况，不是对某一个变更请求做结论，而是对变更机制作出评价\n\n\n\n面向X的设计DFX，在设计阶段就对质量进行保证\n\n\n\n控制质量\n为评估绩效，确保项目输出完整、正确且满足客户期望而监督和记录质量管理活动执行结果。本过程需要在整个项目期间开展\n\n控制质量是对项目结果和过程结果进行检查\n\n核查表\n\n\n统计抽样\n\n\n控制图\n\n\n\n知识领域概要质量管理最难定义\n\n要知道质量管理发展的历程\n要知道质量管理中的主要流派\n质量管理既要管产出的质量，又要管过程的质量\n预防胜于检查\n\n项目质量管理是一个难以定义的知识领域，人们常常对标准的质量定义不知所云，不同的人、不同的组织、不同需求的项目，对项目质量的定义大相径庭，对质量管理学科的基本思想和发展沿革的理解影响项目质量管理\n","categories":["产品理论"],"tags":["项目管理-项目管理笔记"]},{"title":"项目范围管理","url":"/2024/07/28/%E4%BA%A7%E5%93%81%E7%90%86%E8%AE%BA/%E9%A1%B9%E7%9B%AE%E7%AE%A1%E7%90%86/%E9%A1%B9%E7%9B%AE%E7%AE%A1%E7%90%86%E7%AC%94%E8%AE%B0/4_%E9%A1%B9%E7%9B%AE%E8%8C%83%E5%9B%B4%E7%AE%A1%E7%90%86/","content":"基本概念范围：项目中应包括什么，不包括什么\n范围管理：确保项目做且只做成功完成项目所需的全部工作（项目管理中最重要&#x2F;最难的问题之一）\n\n产品&#x2F;产出范围：某项产品、服务或成果所具有的特征和功能（对结果负责）\n项目范围：为交付具有规定特性与功能的产品、服务或成果而必须完成的工作。项目范围有时包括产品范围（对过程负责）\n\n范围管理的关键：\n\n预测型生命周期：项目开始对可交付成果定义，对任何范围变化进行渐进管理\n适应型或敏捷型生命周期：通过多次迭代开发可交付成果，并在每次迭代开始时定义和批准详细的范围\n\n过程和目的规划过程组：\n\n规划范围管理：制定项目范围管理计划和需求管理计划（12个子计划其中之二），上级批准后才可执行\n收集需求：定义、记录干系人的需求，得到一份需求清单文件\n定义范围：制定项目和产品详细描述，得到一份项目范围说明书文件（文字）\n创建WBS：将可交付成果分解成WBS（根据项目范围说明书文件拆解得到WBS图&#x2F;表，未批准之前叫做项目管理文件，批准之后叫做项目管理计划）\n\n监控过程组：\n\n确认范围：正式验收可交付成果（正式验收是在监控过程组，不是在收尾过程组，由客户或发起人进行验收）\n控制范围：监督项目和产品的范围状态，管理范围基准变更\n\n规划范围管理\n创建范围管理计划，记录如何定义、确认和控制项目范围及产品范围。本过程只开展一次或仅在项目预定点开展\n\n范围管理计划：项目或项目集管理计划的组成部分，包括如何收集需求、如何定义范围、如何记录范围、如何创建WBS、如何确认范围、如何控制范围\n需求管理计划：项目管理计划的组成部分，如何分析、记录和管理项目或产品需求，包括\n为项目选择最有效的阶段与阶段间关系\n如何规划、跟踪、汇报各种需求活动\n需求优先级排序过程\n配置管理活动（如何启动产品、服务或成果变更、如何分析影响、如何跟踪汇报，谁有权批准变更）\n测量指标及使用这些指标的理由\n需求跟踪结构（哪些属性将列入跟踪矩阵，哪些文件可追踪需求）\n\n\n\n收集需求\n为实现项目目标而确定、记录并管理相关方需要和需求。本过程只开展一次或仅在项目预定点开展\n\n需求文件：列出全部需求的清单，描述各种单一需求将如何满足项目相关的业务需求，一份记录飞机需求的文件比飞机本身更有价值\n\n收集需求的一个难点在于人们往往对需求缺乏一致性的定义\n\n\n需求跟踪矩阵\n\n\n收集需求工具与技术\n\n访谈\n问卷调查\n观察\n原型法\n标杆对照\n群体创新技术：头脑风暴法、名义小组技术、思维导图、亲和图&#x2F;分组图&#x2F;分类图（KJ法）、多标准决策分析\n群体决策技术：一致同意（德尔菲技术）、大多数原则、相对多数原则、独裁\n引导式研讨会（跨职能、跨部门专家讨论）\n焦点小组（主题专家讨论）\n系统交互图\n\n\n\n定义范围\n制定项目和产品详细描述。本过程需多次反复开展\n\n项目范围说明书包括：产品&#x2F;产出范围描述、验收标准（产出结果的验收标准、项目过程的验收标准）、项目可交付成果、项目除外责任、项目制约因素、项目假设条件\n项目范围说明书的详细程度决定着项目管理团队控制整个项目范围的有效程度\n\n\n定义范围工具与技术：\n专家判断\n产品分析：产品分解、系统分析、需求分析（质量功能展开QFD）、系统工程、价值工程（价值V&#x3D;功能F&#x2F;成本C）、价值分析\n备选方案分析：头脑风暴法、横向思维、配对比较法\n决策和人际与团队\n\n\n\n创建WBS\n将项目可交付成果和项目工作分解为较小的、更易于管理的组件。本过程只开展一次或仅在项目预定义点开展\n\n范围基准（4个基准之一）：包括范围说明书、WBS（工作包&#x2F;规划包）、WBS词典（对WBS的说明解释）\n滚动式规划（创建WBS和定义活动都需要滚动式规划）\n\n确认范围\n正式验收项目已完成的可交付成果。本过程应根据需要在整个项目期间定期开展\n\n检查：产出结果和项目过程\n由客户或发起人进行验收（正式，书面，还要有签字）\n正式验收是在监控过程组，不是在收尾过程组，在整个项目期间定期开展，可以验收阶段性产出\n\n控制范围\n监督项目和产品的范围状态，管理范围基准变更。本过程需要在整个项目期间开展\n\n在范围管理中，使用挣值分析EV来衡量实际跟基准的差距\n确保项目做且只做成功完成项目所需的全部工作，定义和控制哪些工作应包括在项目内，哪些不应包括在项目内，防止范围蔓延，范围蔓延包括镀金和范围潜变，镀金是自己造成的，讲究十全十美但得不到回报，范围潜变是由客户不断提出微小变更造成的\n提高客户的投入程度：确保项目信息（项目章程&#x2F;计划&#x2F;范围基准）在组织中很容易获得、团队中有客户参与、定期会议、定期交付一些成果、保持有效沟通\n减少不完整和不断变化的需求：遵循需求管理流程、制作原型、建立需求管理数据库、遵循变更控制流程、与干系人共同验证范围\n利用软件辅助项目范围管理：使用各种专业化软件来支持项目范围管理\n\n\n\n知识领域概要范围管理最不容易：请客户多参与项目、用变更机制进行范围管理、杜潜变、防镀金\n\n项目管理中范围管理是最重要也是最难的问题之一（重要：它描述了干系人究竟想要什么，难：干系人对究竟想要什么&#x2F;程度&#x2F;生产&#x2F;提交不易达成共识）\n\n","categories":["产品理论"],"tags":["项目管理-项目管理笔记"]},{"title":"项目进度管理","url":"/2024/07/29/%E4%BA%A7%E5%93%81%E7%90%86%E8%AE%BA/%E9%A1%B9%E7%9B%AE%E7%AE%A1%E7%90%86/%E9%A1%B9%E7%9B%AE%E7%AE%A1%E7%90%86%E7%AC%94%E8%AE%B0/5_%E9%A1%B9%E7%9B%AE%E8%BF%9B%E5%BA%A6%E7%AE%A1%E7%90%86/","content":"基本概念进度：项目的开始和结束日期\n工期：完成项目持续的时间\n进度管理&#x2F;时间管理：确保项目按时完成所需的过程\n\n制定进度表容易，按进度执行困难\n它是进度管理最大的挑战，是项目管理中灵活度最低的变量，是引发项目管理冲突的主要原因\n影响因素有：简单估算时间、个人工作作风、文化差异、死亡行军\n\n“死亡行军”项目从一开始就注定要失败，因为该项目的进度估计不符合实际，尤其是时间的约束条件，嵌入软件系统的许多进度计划都是“靠祈祷和充满希望的祝福支撑着”，拟定的工作目标不可能实现，是一个死亡行军计划。\n项目管理是以计划为核心，以进度为主线的管理\n过程和目的规划过程组：\n\n规划进度管理：制定进度管理计划（12个子计划之一），上级批准后才可执行\n定义活动：识别为完成项目所必须开展的具体活动，得到一份活动清单文件\n排列活动顺序：记录活动之间的关系&#x2F;顺序（使用单代号&#x2F;双代号网络图）\n估算活动持续时间：估算完成单个活动需要多少时间\n制定进度计划：制定出进度表（进度计划文件，未批准之前叫做项目进度计划文件，批准之后叫做项目进度基准）\n\n监控过程组：\n\n控制进度：控制和管理项目进度安排&#x2F;基准变更&#x2F;更新状态\n\n规划进度管理\n为规划、编制、管理、执行和控制项目进度而制定政策、程序和文档。本过程仅开展一次或仅在项目预定义点开展\n\n进度管理计划：为编制、监督、控制项目进度建立准则和明确活动，项目管理计划的组成部分，包括：\n\n如何定义活动\n如何排列活动顺序\n如何估算活动资源\n如何估算活动持续时间\n如何制定进度计划文件\n如何控制进度\n\n进度管理计划规定：\n\n项目进度模型制定（甘特图&#x2F;燃尽图）\n进度计划发布长度和迭代长度\n准确度、计量单位、组织程序链接、项目进度模型维护、控制临界值、报告格式、过程描述\n绩效测量规则：确定完成百分比的规则、拟用的挣值测量技术（基准法、固定公式法、完成百分比法等）、进度绩效测量指标（SV、SPI）\n\n\n\n定义活动\n识别和记录为完成项目可交付成果而需采取的具体行动，本过程需在整个项目期间开展\n\n滚动式规划（创建WBS和定义活动都需要滚动式规划）\n对近期要完成的工作进行详细规划\n中期：渐进明细，越来越清楚\n远期：对远期工作则暂时只在WBS的较高层次上进行粗略规划\n\n\n\n⭐️WBS向下进行分解就得到了活动\n排列活动顺序\n识别和记录项目活动间逻辑关系。本过程需要在整个项目期间开展\n\n项目管理信息系统PMIS\n\n使用单代号&#x2F;双代号网络图来记录活动之间的关系&#x2F;顺序\n单代号网络图：\n\n双代号网络图：只有FS一种逻辑关系，有虚活动\n\n\n\n估算活动持续时间\n估算完成单项活动所需工作时段数，需要考虑收益递减规律、资源数量、技术进步、员工激励等因素。本过程需在整个项目期间开展\n\n估算依据：\n\n\n储备分析：“已知-未知”的意思是这个风险已经预估到有，但是不知在何时发生\n\n在进行持续时间估算时，需考虑应急储备（有时称为进度储备），以应对进度方面的不确定性。应急储备是包含在进度基准中的一段持续时间，用来应对已经接受的已识别风险，应急储备与“已知-未知”风险相关，需要加以合理估算，用于完成未知的工作量。应急储备可取活动持续时间估算值的某一百分比或某一固定时间段，亦可把应急储备从各个活动中剥离出来并汇总，随着项目信息越来越明确，可以动用、减少或取消应急储备，应该在项目进度文件中清楚地列出应急储备\n也可估算管理储备，应对“未知-未知”风险，不包括在进度基准中，但属于总持续时间的一部分\n\n\n三点估算：基于三角分布的三点估算【（最悲观+最可能+最乐观）&#x2F;3】、基于贝塔分布的三点估算【（最悲观+4*最可能+最乐观）&#x2F;6】\n\n\n⭐️估算进度时一般用基于三角分布的三点估算，估算成本时一般用基于贝塔分布的三点估算\n制定进度计划\n分析活动顺序、持续时间、资源需求和进度制约因素，创建项目进度模型。本过程需要在整个项目期间开展\n\n未批准之前叫做项目进度计划文件，批准之后叫做项目进度基准\n\n进度数据\n\n\n进度压缩\n\n时间成本平衡法&#x2F;赶工：通过权衡成本与进度，确定如何以最小的成本来最大限度地压缩进度\n\n优点：不增加项目风险和管理难度\n缺点：会因加班而增加成本\n基本假设：活动历时可从正常历时缩减到要压缩历时、压缩历时与成本增加呈线性关系、有足够的资源\n\n\n快速跟进：把正常情况下按顺序执行的活动或阶段并行执行\n\n\n\n\n\n\n\n\n\n\n\n\n\n控制进度\n监督项目状态，更新项目进展，管理进度基准变更。本过程需要在整个项目期间开展\n\n进度预测（挣值计算）：\n完工估算EAC\n完工尚需估算ETC\n完工偏差VAC\n预计的完工工期EDAC\n完工尚需绩效指数TCPI\n\n\n\n知识领域概要进度管理最缺灵活性，因为花钱也买不了时间\n\n进度规划要讲实际\n将进度时间划分为阶段，每一个阶段设置一个控制的标准，未达到标准不准进行下一个阶段\n实时进行进度监控，及时发现问题及时纠正\n进度管理上要严肃纪律，不能拖延\n进度是灵活度最低的变量，无论项目进展中出现什么情况，时间依然一如既往地流逝，按时交付视为最大的挑战和引发冲突的主要原因\n\n","categories":["产品理论"],"tags":["项目管理-项目管理笔记"]},{"title":"项目成本管理","url":"/2024/08/02/%E4%BA%A7%E5%93%81%E7%90%86%E8%AE%BA/%E9%A1%B9%E7%9B%AE%E7%AE%A1%E7%90%86/%E9%A1%B9%E7%9B%AE%E7%AE%A1%E7%90%86%E7%AC%94%E8%AE%B0/6_%E9%A1%B9%E7%9B%AE%E6%88%90%E6%9C%AC%E7%AE%A1%E7%90%86/","content":"基本概念成本经常用金钱来衡量，它一定是用来获取商品和服务的\n成本管理：涉及在一个允许的预算范围内确保项目团队完成一个项目所需要开展的管理过程\n因为项目花费的钱和消费的资源可以有其他用途，所以项目经理了解项目成本管理是很重要的\n项目成本的分类：\n\n直接成本：与生产项目、产品和服务直接相关的成本，PM可以控制直接成本\n间接成本：不与项目和服务直接相关的成本，PM几乎无法控制它们，可以被分摊到项目当中（比如水电费）\n固定成本：为了进行项目而投入的，不随着项目进行变动的成本\n变动成本\n机会成本：由于我选择了这个项目，而放弃了另一个项目可能带来的收益\n沉没成本：过去花费的钱，考虑它们已经被花掉了，就像沉船永远不能再回来了，应该忘记沉没成本\n生命周期成本：长周期（典型生命周期）要考虑整个产品生命周期的成本，包括项目期间的成本和后续运维成本\n\n学习曲线，也叫做经验曲线，当重复生产物品时，在一个固定模式下，随着生产件数的增多，这些物品的单位成本会下降，学习曲线理论应能帮助估计涉及大量生产物品的项目，学习曲线理论适用于花费一定时间完成的一些任务\n\n储备可以分为：\n\n应急储备，为了应对已知的未知，它在成本基准中，PM可支配\n管理储备，为了应对未知的未知，它在成本基准外，PM无权支配，由上级或者高层管理者掌握\n\n过程和目的规划过程组：\n\n规划成本管理：制定成本管理政策，编制成本管理计划\n估算成本：近似估算完成项目活动所需资金（得到一个数或者一组数）\n制定预算：汇总，将成本分配到各个具体的工作条目，建立基准（得到一条S曲线，这就是基准）\n\n监控过程组：\n\n控制成本：监督&#x2F;更新预算、管理基准变更（重要的工具：挣值分析）\n\n规划成本管理\n确定如何估算、预算、管理、监督和控制项目进度。本过程仅开展一次或仅在项目预定义点开展\n\n成本管理计划是项目管理计划的组成部分，包括如何估算成本、如何制定预算、如何控制成本\n\n\n\n估算成本\n对完成项目工作所需资源成本进行近似估算。本过程根据需要在整个项目期间定期开展\n\n成本估算支持细节\n\n\n质量成本：分为一致性成本、不一致性成本\n一致性成本指的是我花的钱是为了避免失败\n\n不一致性成本是指由于失败而花的钱\n\n\n三点估算：基于三角分布的三点估算【（最悲观+最可能+最乐观）&#x2F;3】、基于贝塔分布的三点估算【（最悲观+4*最可能+最乐观）&#x2F;6】\n\n\n⭐️估算进度时一般用基于三角分布的三点估算，估算成本时一般用基于贝塔分布的三点估算\n制定预算\n汇总所有单个活动或工作包的估算成本，建立一个经批准的成本基准。本过程仅开展一次或仅在项目预定义点开展\n\n项目预算的组成\n控制账户CA是给WBS工作包记账用的，它会跟公司的财务部门进行对接（组织程序链接）\n\n\n成本基准是按时间段分配资金的完工预算，通常用S曲线表示（成本基准是一条S曲线，完工预算BAC是一个数）\n项目资金需求：项目资金投入通常以增量而非连续的方式进行，总资金需求&#x3D;成本基准+管理储备\n\n\n\n控制成本\n监控项目状态以更新项目成本，管理成本基准变更。本过程需要在整个项目期间开展\n\n成本基准上的任何一点都叫做计划价值pv\n挣值分析：通过五个输入（PV、EV、AC、BAC、BDAC）得到九个输出（绩效指标CV、SV、CPI、SPI，预测指标TCPI、EAC、ETC、VAC、EDAC）\n\n\n关键比值法（Critical Ratio关键比值技术）：通过计算一组指标比值的乘积（即关键比值）来进行项目状态控制的一种方法\n单独分析进度比值和成本比值，当它们大于1时，说明项目的进程状态或项目实施绩效是好的\n\n\n\n储备分析用在规划过程组也用在监控过程组，估算活动持续时间、估算成本、预算成本是规划过程组，控制成本、控制风险是监控过程组\n\n估算活动持续时间：估算时考虑应急储备（时间储备或缓冲时间），纳入项目进度计划\n估算成本：为应对成本的不确定性，成本估算中可以包括应急储备\n预算成本：可以计算项目的应急储备与管理储备\n控制成本：监督项目中的应急储备和管理储备的使用情况，判断是否还需要这些储备，是否需要增加额外的储备\n控制风险：在项目的任何时点比较剩余应急储备与剩余风险量，确定剩余储备是否仍然合理\n\n储备分析只考虑时间和成本这两个量\n\n\n知识领域概要成本管理最需规范\n\n要清楚一些主要术语\n要明确一些准则\n要精于计算\n要懂得应急储备和管理储备\n\n项目成本管理是主要三约束之一，是项目重要成功指标之一，成本超支意味着项目失败，在持续努力降低和控制成本的同时，使干系人满意是项目经理的工作\n","categories":["产品理论"],"tags":["项目管理-项目管理笔记"]},{"title":"项目沟通管理","url":"/2024/08/05/%E4%BA%A7%E5%93%81%E7%90%86%E8%AE%BA/%E9%A1%B9%E7%9B%AE%E7%AE%A1%E7%90%86/%E9%A1%B9%E7%9B%AE%E7%AE%A1%E7%90%86%E7%AC%94%E8%AE%B0/9_%E9%A1%B9%E7%9B%AE%E6%B2%9F%E9%80%9A%E7%AE%A1%E7%90%86/","content":"基本概念沟通：用各种可能的方式发送和接受信息，信息交换的方式包括书面形式、口头形式、正式或非正式形式、手势动作、媒体形式、遣词造句等\n有意或无意的信息交换，交换的信息可以是想法、指示或情绪\n沟通活动按不同维度分类：\n\n内部沟通、外部沟通\n正式沟通、非正式沟通\n层级沟通（向上、向下、横向），按照组织机构图OBS（或者叫组织分解结构）\n官方沟通、非官方沟通\n书面沟通、口头沟通\n语言沟通、非语言沟通（动作、表情、情绪、空间位置等）\n\n沟通要讲究有效，沟通重要程度中语言内容占7%、沟通方式占38%，非语言沟通占55%\n有效沟通：目的明确、监督衡量沟通效果、激励、共识、了解相关方沟通偏好和需求\n书面沟通5C原则：\n\n正确的语法和拼写\n简洁的表述和无多余字\n清晰的目的和表述\n连贯的思维逻辑\n受控的语句和想法承接\n\n沟通技巧：\n\n积极倾听\n理解文化和个人差异\n识别、设定并管理相关方期望\n强化技能（说服、指导、解决冲突）\n\n过程和目的规划过程组：\n\n规划沟通管理：根据对信息的沟通需求，定义沟通方法和计划，得到一份沟通管理计划\n\n执行过程组：\n\n管理沟通：生成&#x2F;收集&#x2F;分发&#x2F;储存&#x2F;检索&#x2F;处置项目信息（对过程进行管理）\n\n监控过程组：\n\n监督沟通：对沟通进行监督和控制，满足干系人对信息的需求（对结果进行监督）\n\n规划沟通管理\n基于每个相关方或相关方群体的信息需求、可用的组织过程资产以及具体项目的需求，为项目沟通活动指定前档的方法和机会。本过程应根据需要在整个项目期间定期开展\n\n沟通需求分析：\n\n考虑相关人员在组织机构图中的位置\n组织与干系人之间的职责关系\n涉及的学科、部门和专业\n多少人在什么地点参与项目\n开发方法\n内部信息需求\n外部信息需求\n法律要求\n\n\n影响沟通技术选择的因素：\n\n\n沟通模型：就是要保证沟通有效\n\n\n沟通方法\n\n互动沟通：双方&#x2F;多方之间进行多向信息交换（会谈、电话会议、视频会议）\n推式沟通：把信息发送给需要了解信息的特定接收方（信件、备忘录、报告、电子邮件、传真、新闻稿）\n拉式沟通：信息量大、受众多情况下使用，接收方自主自行获取信息（内网、电子在线课程、知识库）\n\n\n\n管理沟通\n确保项目信息及时且恰当地收集、生成、发布、存储、检索、管理、监督和最终处置。本过程需要在整个项目期间开展\n\n对过程进行管理\n\n监督沟通\n确保满足项目及其相关方的信息需求。本过程需要在整个项目期间开展\n\n对结果进行监督\n问题日志&#x2F;行动日志可用来记录和监督问题的解决情况，促进沟通，对问题统一认识，书面日志记录了由谁负责在目标日期前解决某特定问题\n\n知识领域概要沟通管理最讲技巧\n\n营信任\n有沟通胜任力\n用技巧\n选方法\n\n项目成功最大的威胁是沟通失败，无效的沟通常常是引起冲突的原因，采用合适的沟通方法，施展适合的沟通技巧是关键\n","categories":["产品理论"],"tags":["项目管理-项目管理笔记"]},{"title":"项目资源管理","url":"/2024/08/04/%E4%BA%A7%E5%93%81%E7%90%86%E8%AE%BA/%E9%A1%B9%E7%9B%AE%E7%AE%A1%E7%90%86/%E9%A1%B9%E7%9B%AE%E7%AE%A1%E7%90%86%E7%AC%94%E8%AE%B0/8_%E9%A1%B9%E7%9B%AE%E8%B5%84%E6%BA%90%E7%AE%A1%E7%90%86/","content":"基本概念项目资源分为实物资源和人力资源\n\n实物资源：设备、材料、设施等\n团队资源指人力资源，相对于实物资源管理，提出了不同的技能和能力要求，应在获取、管理、激励和增强项目团队方面投入适当的努力，尽管项目团队成员被分派了特定的角色和职责，但让他们全员参与项目规划和决策仍是有益的（项目经理主要进行人力资源的管理，人力资源是一种能动资源，能动性表现在两个方面：人具有分析能力、人具有主观需求）\n\n项目经理是项目团队的领导者，也是项目团队的管理者，除了项目管理活动（启动、规划、执行、监控和收尾），还负责建设高效的团队，应该关注：环境、地理位置、相关方之间沟通、组织变革、文化和组织独特性、政治氛围、其他可能改变项目绩效的因素\n项目经理对人力资源的管理和人力资源部门对人力资源的管理是有差别的，后者讲究长期性，看到的是整个企业运营所配备的资源，前者是临时性，一次性，变更驱动性，需要向企业借资源进行管理\n领导者的影响力：非权力影响力来源于下属服从的意愿，有时会比权力显得更有力量\n\n权力影响力：法定、强制、奖励\n非权力影响力：品格、才能、知识、感情\n\nX-Y理论的假设：\n\nZ理论：人的状态跟文化环境有关，跟企业氛围有关，企业氛围可能会激发人X潜能，也可能激发Y潜能\n管理风格：\n\n\n\n管理方格理论，心理学家布莱克和莫顿，以人为重，以生产为重\n\n\n\n\n\n\n领导者的激励方法：\n\n马斯洛需求层次理论：自我实现是自己给的，其余四种是外界提供的\n\n\n赫兹伯格双因素理论\n\n卫生因素（比如工资待遇、工作环境等）：良好的卫生因素基本没有激励作用，恶劣的卫生因素可能破坏激励\n激励因素（比如有挑战性的工作等）：良好的激励因素有激励作用，恶劣的激励因素可能破坏激励\n\n\n期望理论：只有当人们认为实现预定目标的可能性很大，并且实现这种目标又具有很重要的价值，这时该目标对他们的激励程度才会最大（激励程度&#x3D;期望值*效价，效价是指目标值达成以后能得到的东西）\n\n公平理论：人们的动机，不仅受其所得的绝对报酬的影响，而且更受相对报酬的影响，每个人都会不自觉的把自己所得的报酬以及自己付出的劳动，与他人所得的报酬与他人所付出的劳动进行社会比较，如果它们相等，就认为是公平的，就会成为激励力量，感觉不公平就会采取对策\n\n设法增加个人所得\n设法降低别人的所得\n减少投入，降低个人贡献\n设法增加别人的投入\n重新选择比较对象以活动公平感\n发牢骚、消极怠工、离职\n\n\n后天需要理论：大卫·麦克利兰认为个人的特定需求是通过后天培养或者长期学习，由生活经验形成的，获取需求理论包括\n\n成就需求：渴望成就，努力避开风险去做他们认为值得去做的事情\n亲和需求：渴望与他人建立和睦的关系，希望能被他人接受\n权力需求：不仅渴望得到个人权力，也想得到公共权力\n\n\n\n影响力：\n\n权力：权力是一种影响行为的潜在能力，可驱使人们去做他们不愿意去做的事，权力比影响力有更丰富的含义，它经常用来强迫人们去做他们不愿去做的事。法兰斯和瑞文著名研究《社会权力基础》列出了权力的5种主要类型：\n\n强制权力：使用处罚&#x2F;威胁方法驱使人们去做他们不愿意去做的事情\n合法权力：通过职位赋予的权力去指挥员工做事\n专家权力：使用个人知识和专业能力去改变人们的行为\n奖励权力：用奖励鼓励人们去工作\n参照权力：来自个人自身的魅力或背景\n\n项目经理通常有许多的授权，但是没有什么正式的权力，因此，他们必须利用人际关系影响来完成工作。这样的人际关系影响有5种：\n\n法定权\n奖赏权\n处罚权\n专家权\n影响力\n\n项目职权的种类：法定的权力、暗含的权力、项目章程的权力\n过程和目的规划过程组：\n\n规划资源管理：识别记录角色&#x2F;职责&#x2F;软技能&#x2F;报告关系，得到一份资源管理计划\n估算活动资源：估计为完成活动要使用多少资源（包括实物资源和人力资源）\n\n执行过程组：\n\n获取资源：获取项目所需资源（人力、设施、设备、材料、用品等）\n建设团队：提高工作能力，促进互动，改善氛围，提高项目绩效（重点关注团队整体）\n管理团队：跟踪成员表现，反馈，解决问题，管理变更，优化项目绩效（重点关注团队个人）\n\n监控过程组：\n\n控制资源：监督资源实际使用情况（控制的是实物资源，对人力资源使用控制这个词不好，一般用监督管理这个词汇）\n\n规划资源管理\n定义如何估算、获取、管理和利用团队以及实物资源。本过程仅开展一次或仅在项目预定义点开展\n\n资源管理计划要得到上级或者高层批准\n\n团队章程属于项目管理文件，资源管理计划属于项目管理计划\n\n责任分配矩阵RAM\n\n\n\n估算活动资源\n估算执行项目所需的团队资源以及材料、设备和用品的类型和数量。本过程应根据需要在整个项目期间定期开展\n\n包括实物资源和人力资源\n\n获取资源\n获取项目所需的团队成员、设施、设备、材料、用品和其他资源。本过程应根据需要在整个项目期间定期开展\n\n物质资源分配单：实物资源，项目团队派工单：人力资源\n\n资源日历表明资源在某个时段的可用性\n\n多标准决策分析：制定标准，赋予选择标准的不同权重对候选团队成员打分\n\n\n\n建设团队\n提高工作能力，促进团队互动和改善团队氛围，提高项目绩效。本过程需要在整个项目期间开展\n\n重点关注团队整体\n\n团队绩效评价指标：对团队整体的评价\n\n个人技能的改进\n团队能力的改进\n团队成员离职率的降低（组织中适当的人员流动会带来活力，但是项目团队中最好要保持人员稳定）\n团队成员凝聚力的加强\n\n\n团队建设五个阶段：塔克曼模型\n\n形成阶段，作为PM要手把手的“指导”团队成员的工作\n震荡阶段，PM要处理各种“冲突”\n规范阶段，PM开始“教练”团队里的管理成员，让他们接手一些工作，同时给他们相应的“支持”\n成熟阶段，PM更多的是“授权”，让团队成员各自完成各自的工作\n解散阶段，PM要提前做好遣散的“规划”\n\n\n\n个人和团队评估：可以使用态度调查、细节评估、结构化面谈、能力测试、焦点小组讨论等方法\n\n\n\n管理团队\n跟踪团队成员的表现，提供反馈，解决问题并管理变更，优化项目绩效。本过程需要在整个项目期间开展\n\n重点关注团队个人\n\n常用的五种冲突解决方法：\n\n撤退&#x2F;回避：一方撤出，躲开，拖延，推给别人处理\n缓解&#x2F;包容：求同存异，减轻\n妥协&#x2F;调解：双方各让一步\n强迫&#x2F;命令：推行一方观念，另一方服从，利用权力强行解决紧急问题\n合作&#x2F;解决问题：综合考虑各种意见，各方达成一致\n\n\n人际关系技能：\n\n\n\n控制资源\n确保按计划为项目分配实物资源，根据资源使用计划监督资源实际使用情况，采取必要纠正措施。本过程需要在整个项目期间开展\n\n控制的是实物资源，对人力资源使用控制这个词不好，一般用监督管理这个词汇\n实物资源一般都会有专门的技术团队去管理维护，但是对人力资源的管理就需要PM来进行了\n\n知识领域概要资源管理最靠灵活，特别是对人力资源的管理\n\n懂心理\n解人情\n施软硬\n释影响\n\n资源管理是项目管理面临的最困难的挑战之一，人是能动资源，管理好人，让人为项目产生积极的影响做贡献，是项目经理的职责，需要下功夫\n","categories":["产品理论"],"tags":["项目管理-项目管理笔记"]},{"title":"《人人都是产品经理「案例版」04》","url":"/2025/05/18/%E4%BA%A7%E5%93%81%E7%90%86%E8%AE%BA/%E4%BA%A7%E5%93%81%E7%90%86%E8%AE%BA%E4%B9%A6%E5%8D%95%F0%9F%93%9A/%E4%BA%A7%E5%93%81/%E3%80%8A%E4%BA%BA%E4%BA%BA%E9%83%BD%E6%98%AF%E4%BA%A7%E5%93%81%E7%BB%8F%E7%90%86%E3%80%8C%E6%A1%88%E4%BE%8B%E7%89%88%E3%80%8D04%E3%80%8B/","content":"从“商品”管理说起B2B：是指企业与企业之间通过专用网络或互联网，进行数据信息的交换、传递，开展交易活动的商业模式（阿里巴巴）\nB2C：是企业对消费者的电子商务模式，这种形式的电子商务一般以网络零售业为主，主要借助于互联网开展在线销售活动（天猫）\nC2C：指消费者与消费者之间的电子商务（淘宝）\nC2B：即消费者对企业（聚划算）\nCRM：客户关系管理系统\n网站的四种典型页面：\n\nDetail页面，好比新浪网的一篇新闻网页，相对静态，主要用于展示信息\nList页面，比如百度的搜索结果页，是一个引导性的过程页面\n交互页面，需要用户填各种表单、需要互动的页面，比如各大网站的注册页面\n综合页面，是指很难将其分类的其他页面，或者前三种混合的页面，比如淘宝的购物车页面，就混合了列表页面和交互页面的内容\n\n灰度发布是指在黑与白之间，能够平滑过渡的一种发布方式。AB test就是一种灰度发布方式，让一部分用户继续用A，一部分用户开始用B，如果用户对B没有什么反对意见，那么逐步扩大范围，把所有用户都迁移到B上面来。灰度发布可以保证整体系统的稳定，在初始灰度的时候就可以发现、调整问题，以保证其影响度\n在特定的场景下，一个问题不一定要用传统意义上的“开发产品功能”来解决，产品经理的责任从根本上来说是解决问题，而不是做产品\n解决问题，或者说满足需求，通常有三种方法：提高现实、降低期望、转移需求，而最常用的“开发产品”是第一种，也是最费劲的一种方法\nKPI：关键绩效指标\n商品管理的核心就是分类\n“淘宝”就是导购Doodle：指在Logo上“创意的涂鸦”，因为Google经常这么做而出名\n产品经理做事的思路：首先产品经理需要确定产品的核心用户，接着要确定这批核心用户的刚性需求，最后产品经理需要把用户需求转化为产品功能\n网络爬虫：网页蜘蛛、网络机器人、网页追逐者，是一种按照一定的规则，自动地抓取万维网信息的程序或者脚本\n用户需求和产品功能并不是一一对应的\n导购：一群买家，从某个购物需求出发，通过某个产品功能，最终到达一个商品详情页面的过程\nSPU：标准化产品单元，是商品信息聚合的最小单元，是一组可复用、易检索的标准化信息的集合，该集合描述了一个产品的特性。通俗点讲，属性值、特性相同的商品就可以称为一个SPU（一个SPU可以对应很多商品，商品与SPU的区别在于它和卖家有关）\n如果是独立的B2C，一个SPU不存在多个卖家卖的情况，直接细分为SKU就可以了\nSKU：库存保有单位，即库存进出计量的单位，可以以件、盒、托盘等为单位。SKU是物理上不可分割的最小存货单元。在使用时要根据不同业态，不同管理模式来处理\n“搜索”的启示马太效应：指强者愈强、弱者愈弱的现象，广泛应用于社会心理学、教育、金融以及科学领域\n基尼系数：是衡量一个国家或地区居民收入或财富分配不平等程度的常用指标，数值介于0到1之间，0表示绝对平等（所有人收入相同），1表示绝对不平等（所有财富集中在一个人手中）\n一个好的系统，应该是机器算法和人的思维相结合，必须要有人在里面“玩”，这个系统才会有“新”涌现出来。想用人的智慧来帮助算法进化，如果没有人的参与，机器的进化效率会低很多。系统中，一定有部分人喜欢完全靠算法，放弃选择，那就让他们生活在简单但不真实的环境里，也一定有部分人，喜欢自己挑选商品，就给他们建立一个有挑战但真实的环境\n当一个系统优化到一定程度后，必然进入帕累托最优，再要优化，则此消彼长。解决一个问题的方法太激进，必然会为整个系统带来其他问题，如果没带来其他问题，则要么是因为系统整体还不够优化，要么是因为系统边界没定义清楚\n帕累托最优，也被称为帕累托效率、帕累托改善、帕累托最佳配置，它是博弈论中的重要概念，并且在经济学、工程学和社会科学中有着广泛的应用。帕累托最优是指资源分配的一种理想状态，即假定固有的一群人和可分配的资源，从一种分配状态到另一种状态的变化中，在没有使任何人境况变坏的前提下，也不可能再使某些人的处境变好。换句话说，就是不可能再改善某些人的境况，而不使任何其他人受损\n面包屑导航：是一种显示用户在网站或网络应用中的位置的一层层指引的导航\n“电商”还是商电子商务的本质还是商务，所以绕不开广告、供应链、生产驱动或消费驱动的问题\n广告是为了某种特定的需要，通过一定形式的媒体，公开而广泛地向公众传递信息的宣传手段\n\n广告有广义和狭义之分，广义广告包括非经济广告和经济广告\n非经济广告指不以盈利为目的的广告，又称效应广告，如政府行政部门、社会事业单位乃至个人的各种公告、启事、声明等，主要目的是推广\n狭义广告仅指经济广告，又称商业广告，是指以盈利为目的的广告，通常是商品生产者、经营者和消费者之间沟通信息的重要手段，或企业占领市场、推销产品、提供劳务的重要形式，主要目的是扩大经济效益\n按时间定价付费的广告、网站Banner横幅广告（仍然是CPT以时间来计费的广告）\n按展示次数付费的CPM广告\n按点击付费的CPC广告（比如谷歌搜索、百度搜索）\n按成交付费的CPS广告（更多地适合购物类、导购类、网址导航类的网站，需要精准的流量才能带来转化）\nCPA按广告投放的实际效果计价的广告，即按回应的有效问卷或订单来计费，而不限广告投放量\nCPT和CPM较为保护网站主的利益，而CPC在所有广告模式中性价比最适中，CPA和CPS则倾向于保护广告主的利益，因为花费完全可以预测\n\n没有设计的设计就是最好的设计，用户最好感知不到产品的存在，这才是符合人性的产品设计\n随着科技的发展，信息越来越流通，各种组织的形态必然向着去中心化的2.0模式发展，而“生产驱动”这种1.0中心化的模式，也必然被“需求驱动”取代，做到极致就是自下而上的C2B\n马斯洛需求层次理论是亚伯拉罕·马斯洛于1943年提出的，其基本内容是将人的需求从低到高依次分为生理需求、安全需求、社交需求、尊重需求和自我实现需求五种需求\nCPI：居民消费价格指数，指在反映一定时期内居民所消费商品及服务项目的价格水平变动趋势和变动程度\n\n先别叹故事太短。\n我想说，是你太幸运。\n你失去的时光还不多，那些别人怀念的过去啊，\n正是你握在手里的当下和未来。\n去快活啊，别似他们等到真需要时光机的那一天。\n\n“下单”之前松耦合：指一个整体里的多个部分之间交互、依赖比较少\n做不做一个功能，除了要考虑做这个功能所需花费的资源，还需要考虑到可能激发出来的需求。很多情况下，设计出一个新的功能就像打开了一个“潘多拉魔盒”，它会激发更多的需求，投进去的资源只能不停地增加，陷入进退两难的地步\n3C是计算机、通讯和消费电子产品三类电子产品的简称\n产品经理在设计的时候，哪怕是很小的一个细节，也不要帮用户做决定，这不仅是设计之本，也是为人之本\nAjax是指一种创建交互式、快速动态网页应用的网页开发技术，在无须重新加载整个网页的情况下，能够更新部分网页的技术\n新技术会给用户的操作习惯带来改变，在使用的时候一定要慎之又慎\n新技术的出现，无非是用一个新的解决方案去解决一个老的问题，所以尊重用户习惯是必要的。体现在改版这件事情上，就需要慢慢来，多做用户测试。当然，尊重用户习惯背后有一个隐含条件，那就是市场类型。常见的市场可以分为全新市场、细分市场、旧有市场。面对旧有市场的时候，意味着用户还是那批人，所以才需要严格尊重用户习惯的规则。对于全新市场，则可以挑战，即美国苹果公司联合创始人史蒂夫·乔布斯挂在嘴边的“用户不知道自己需要什么”。而细分市场，介于两者之间，大家要灵活应对\n一个产品如果承载了太多的商业目的，必然会偏离用户需求，但在设计任何产品时也不能不考虑公司战略。如何平衡用户目标与商业目标，是产品经理们需要思考的永恒话题\n“交易”之时很多业务场景中的实际问题是两难的，并没有完美的方案，但作为产品经理，只要去用心研究，就能够有解决方案，甚至可以跳出两难的境地，在更高的层面得到更好的解决。更重要的，这个过程是产品经理对自己能力的提升\n“付款”之后理想主义不是空谈，而是在很多关键时刻，面前有两条路的时候，指引人们做出选择的价值观。正是这样的选择，让我们距离理想越来越靠近\n淘宝体的“旺旺”合久必分，分久必合。分，是为了对用户做细分，满足各种用户群的不同需求；合，是对市场的变化做反馈，希望能形成合力开拓创新。合合分分的过程是对市场变化的适应，也是一个产品发展，变得越来越优秀必须经过的过程\n有时候，问题是没法整体解决的，比如照顾了准确度，就顾不上时效性，反之亦然。与其纠结，不如针对问题找到合适的方法，将问题分解为多个子问题，然后，一个子问题专攻准确度，一个子问题专攻时效性，整个问题也迎刃而解\nSaaS：软件即服务，国内通常叫作软件运营服务模式。用户无需本地安装和维护软件，而是通过浏览器或客户端直接访问云端部署的应用，按需订阅服务\n做产品，还是得顺着用户需求，而不是顺着行业热点\n做产品要顺“势”而为，这个势，说大点是行业的浪潮，公司和产品的基因，说小点是用户群体的特性、需求的特点、场景的特质。对一类用户、需求、场景的深入定制，一方面成就了一个产品，成为对手进入的壁垒；另一方面，这堵“墙”也成了这个产品的“牢笼”，让我们走不出去。而产品经理始终要关注的，还是亘古不变的“用户、需求、场景”\n以人为本\n\n\n产品经理的典型任务\n任务说明\n\n\n\n新人入门\n公司相关的知识、技能、态度（内部转岗的容易胜任）\n\n\n熟悉领域\n特定产品的行业知识等（相关行业转来的容易胜任）\n\n\n业务规划\n更偏商业敏感度，属于战略层面（运营人员也要做）\n\n\n产品规划\n未来做什么产品才能完成业务目标\n\n\n用户研究\n用户洞察，以及研究的方法（用户研究员）\n\n\n数据分析\n数据分析相关（商业智能团队）\n\n\n需求分析\n需求的采集、开发、管理等\n\n\n产品设计\n偏狭义用户体验（用户体验设计UED：交互设计、视觉设计）\n\n\n文档撰写\n主要是PRD产品需求文档、Demo原型、MRD市场需求文档等\n\n\n沟通协作\n与各种周边角色沟通协作\n\n\n项目管理\n项目管理相关（项目经理）\n\n\n产品运营\n运营、推广、营销面（产品运营人员）\n\n\n熟悉技术\n对特性产品技术面的了解（做过技术的容易胜任）\n\n\n团队管理\n人员培养、组织进步方面（做过管理者的容易胜任）\n\n\n如果有选择，一家公司为什么不选择一名有经验的产品人员，而选择你？\n你作为产品经理的核心竞争力是什么？\n\n\n产品解决了什么用户的什么需求？\n产生需求的场合是什么？（需求的应用场景：时间、地点等，要有“故事感”）\n产品的主要功能有哪些？\n技术基础是什么？（主要考察产品功能的实现成本，从而评估性价比，是否值得做）\n没有这个产品的时候，用户是怎么解决问题的？（我们尽量不要做有很多替代方案的产品，任何一个很值得解决的问题通常已经有解决方案了，那么，这个产品的解决方案好在哪里？）\n竞争对手是什么？\n顺应了什么趋势？（好的产品是顺势而为的）\n产品的成本构成是什么？\n产品的盈利模式是什么？\n估计一下市场容量（有需求的人数、频率等），以及变化趋势？\n怎么定价？通过什么渠道卖？设计一个促销方案？\n现在你来做改进，你会增加什么功能？优先级是？为什么？需要什么资源（人、财、物、时间等）？之后会发生什么改变？\n……\n\n\n","categories":["产品理论"],"tags":["产品理论书单📚-产品"]},{"title":"《人人都是产品经理「入行版」01》","url":"/2024/12/26/%E4%BA%A7%E5%93%81%E7%90%86%E8%AE%BA/%E4%BA%A7%E5%93%81%E7%90%86%E8%AE%BA%E4%B9%A6%E5%8D%95%F0%9F%93%9A/%E4%BA%A7%E5%93%81/%E3%80%8A%E4%BA%BA%E4%BA%BA%E9%83%BD%E6%98%AF%E4%BA%A7%E5%93%81%E7%BB%8F%E7%90%86%E3%80%8C%E5%85%A5%E8%A1%8C%E7%89%88%E3%80%8D01%E3%80%8B/","content":"人人都是产品经理的真谛\n不是每个人都能以产品经理为业，但在我看来，产品经理是一类人，他们做事的思路与方法可以解决很多实际的生活问题。\n只要你能够发现问题并描述清楚，转化为一个需求，进而转化为一个任务，争取到支持，发动起一批人，将这个任务完成，并持续不断以主人翁的心态去跟踪、维护这个产物，那么，你就是产品经理。\n至少，你已经是自己的产品经理了。这才是“人人都是产品经理”的真谛。\n\n写给-1到3岁的产品经理产品就是用来解决某个问题的东西，产品可以是有形的实物，也可以是无形的服务\n并不是所有的产品都会变成商品，公益性、非营利的产品随处可见。但我们生活中所做的产品，绝大多数都需要在用户目标和公司的商业目标之间寻找平衡。只考虑用户目标，公司无法盈利；只考虑商业目标却留不住用户，公司也无法发展\n\n\n\n\n传统行业\n互联网行业\n\n\n\n行业形态不同\n成熟行业，市场已经成熟，产品基本定型，通常只能渐变式地进行创新，很难有重大突破。用户对产品也形成比较固定的使用习惯，较难改变。对于这样的市场和用户，公司会偏重营销类创新\n新兴行业，产品需要推陈出新、占领用户、主导用户习惯。偏重研发类创新，以实现“从无到有、从有到优”的不断优化\n\n\n产品形态与成本结构不同\n多为实物，有采购、仓储、物流等分工。产品研发出来后还要面对制造成本，产品经理需要考虑如何打通整个供应链、怎样销售、分销、促销等\n多为虚拟物品，公司相对较轻，团队经费和制作成本都更加集中花费在产品研发过程中，公司团队可能只有几十个人，面对的用户却可能有上百万个，这在传统行业不可想象\n\n\n生命周期不同\n产品研发周期一般是几年，需要较为复杂精细的流程来支撑\n研发周期为几个月，研发管理过程会更精简，推崇敏捷方法\n\n\n盈利模式不同\n单一卖产品赚钱，很多情况下客户只是买产品的人不是用产品的人，也许搞定几个大客户就能维持业绩\n多元盈利，比如广告等，产品大多为使用产品的终端用户所做\n\n\n用户心态不同\n花钱买，即使产品稍有缺陷也凑合着用\n免费用，只要这个产品稍有瑕疵，用户可以很方便改用别的产品\n\n\n资源充分时，正确地做事很重要；资源出现瓶颈，做正确的事很重要。管理的能力其实就是“在资源不足的情况下把事情做成”的能力，资源不足表现为几种形式：\n\n信息不足以决策\n时间不足以安排周密的计划\n人员不足以支持工作强度和难度\n资金不足以自由调配\n\n\n用户是我们的云，提供水汽。通过需求管理过程的催化，水汽凝结成雨。项目为河流，来自云层的雨水汇聚成河，流过并滋润大地。我们的团队如同各种动植物在其中促进整个过程。战略就像阳光一样驱动着整个循环，而这个生态系统的根基就是大地，产品经理的自我修养。\n\n\n\n谈需求：一个需求的奋斗史\n在一个生态系统中，水是万物生命之源，而水之源又是天上的云，它们转化为雨，滴落并滋润大地\n\n用户研究：从用户中来到用户中去从用户中来到用户中去有两层意思：\n\n需求或直接或间接都是“从用户中来”的，所以我们要“到用户中去”\n产品设计的过程是一个闭环，需求的源头是用户，而产品发布以后，在整个生命周期中，仍然要不断地“到用户中去”收集反馈，作为产品改进的依据\n\n用户是需求之源人类为什么有需求\n“食色性也”，“食”是为了生存，保证个体延续，“色”是为了繁衍，保证种族延续，这是生物（包括人）的本性，即最基本的需求\n1943年，由美国著名犹太裔人本主义心理学家亚伯拉罕·马斯洛提出了需要层次理论，此理论将人的需要划分为五个层次，由低到高，分别是：生理的需要、安全的需要、归属与爱的需要、尊重的需要、自我实现的需要\n\n生活中存在太多的问题，让人感觉不满意，而这些问题归根究底就是“理想与现实的差距”，人类会很自然地产生“减少甚至消除这个差距”的愿望，这就产生了需求\n需求的本质就是“问题”。作为产品经理，我们每天都在设法满足用户的需求，其实就是在解决各种各样的问题\n用户VS客户用户是使用产品的人，客户是购买产品、为产品付钱的人\n用户与客户可以是同一个人，也可以不是同一个人\n以用户为中心的思想UCD：以用户为中心的设计\n不要试图满足所有用户试图满足所有用户的需求是一个灾难，那会让产品变成一个臃肿不堪、谁都不满意的四不像\n谁对我们重要就先满足谁，需要和产品的商业目标结合起来考虑，简单来说就是看KPI（关键业绩指标）是什么\n你真的了解用户吗了解真正的用户想了解用户，光靠空想是不行的，他们是真实的、是五花八门的，必须得真刀真枪地去研究他们\n试着描述用户创建人物角色：是研究用户的系统化方法，它是产品经理、交互设计师了解用户目标和需求、与开发团队及相关人员交流、避免设计陷阱的重要工具\n具象化人物角色可以帮助新人在刚进团队时迅速了解用户、理解产品，同时帮助忙碌的、无法关注细节的老板迅速进入状态，保证他们也能像创建者一样，心中时刻想着正确的用户形象\n聊聊用户研究用户研究的方法：\n\n“说”表现了目标和观点，“做”反映了行为，用户“怎么说”和“怎么做”经常是不一致的。只了解“做”是没办法知道背后原因的，而不知道问题的原因也就意味着没办法从根本上解决问题。所以，我们既要看用户怎么做，也要听用户怎么说\n定性研究可以找出原因，偏向于了解，而定量研究可以发现现象，偏向于证实。只进行定量研究会导致“以表代本”，我们只能看到问题但不知道原因，只进行定性研究会导致“以偏概全”，我们很可能被部分样本的特殊情况带入歧途\n焦点小组：是由一个经过训练的主持人以一种无结构的自然形式与一个小组的被调查者交谈，可以视为一种一对多的用户访谈形式\n需求采集：产品源头的大生产运动用户研究，或者说需求采集的过程，都会有如下几步：明确目标、选择采集方法、制定采集计划、执行采集、资料整理，最后进入下一步的需求分析阶段\n定性地说：用户访谈用户访谈可以了解用户怎么说，即他们的目标和观点，用户访谈经常被用在新产品方向的预研工作中，或者通过数据分析发现现象以后，用来探索现象背后的原因\n用户访谈的常见问题与对策\n“说”和“做”不一致的问题：尽量在用户可以和产品发生交互的场合下进行用户访谈，让用户在“说”的同时也“做”，以防止被“骗”；另外也要注意区分用户说的事实与观点\n样本少，以偏概全的问题：选择样本的时候需要多加注意，尽量做到随机\n用户过于强势，把我们往沟里带：时刻牢记访谈的目的\n我们过于强势，把用户往沟里带：时刻牢记访谈的目的\n\n\n\n避免一组固定的问题：固定的问题会让被访者产生被审问的感觉，我们应该准备好问题清单，但清单只起一个引导作用，并不用照着读\n首先关注目标，任务其次：比用户行为更重要的是行为背后的原因，多问问用户为什么这么做\n避免让用户成为设计师：听用户说，但不要照着做，用户的解决方案通常短浅、片面\n避免讨论技术：特别是碰到一些略懂技术的用户，不要与其纠缠产品的实现方式\n鼓励讲故事：故事是最好的帮助设计师理解用户的方法\n避免诱导性的问题：典型的诱导问题是“如果有xx功能，你会使用吗？”一般来说用户会给出毫无意义的肯定答复\n\n\n用户大会用户大会是邀请产品的用户到某一集中地点开会，人数一般在几十人到几百人不等，可以短时间内收集大量信息，是一种特别的用户访谈形式\n\n明确目的\n资源确定\n现场执行\n结束以后：资料整理、运营、资料归档\n\n种子用户：是指对某产品忠诚度很高的用户，产品设计者与他们长期保持交流，让他们试用最新产品，可以经常从他们那里获得对产品的建议和意见\n定量地说：调查问卷调查问卷适合大量用户的信息收集，但不够深入，一般只能获得某些明确问题的答案。经常通过用户访谈的开放式问题为调查问卷收集具体的封闭式问题的素材\n\n问卷目的\n明确样本对象、调查渠道、时间计划\n问卷内容\n\n调查问卷的常见问题与对策\n样本用户与想了解的目标用户存在偏差：尽可能覆盖目标群体中各种类型的用户；要保证各种类型用户的样本比例接近全体的比例\n样本过少的问题\n问卷内容的细节问题：问题表述应无引导性；被调查者选择的答案可能与该答案的排列位置有关\n\n灰度发布：互联网产品发布上线的一种常用形式，先让少量用户看到新产品，利用他们的反馈进行修正，逐步把新产品展现给所有用户\n定性地做：可用性测试可用性测试即通过让实际用户使用产品或原型来发现界面设计中的可用性问题，它是UGC用户产生内容理念的一种很实用的实践\n\n明确目的\n招募测试用户，这些测试用户要能尽可能地代表将来真实的用户\n准备测试任务\n测试过程\n测试结束后，组织者可以询问用户对产品的主观看法或感觉\n研究和分析\n\n可用性测试的常见问题与对策\n如果可用性测试做得太晚，比如在产品马上要上线的时候，这时发现问题也于事无补了\n总觉得可用性测试很专业，所以干脆不做\n明确是测试产品，而不是测试用户\n测试过程中，组织者该做的和不该做的\n\n定量地做：数据分析数据分析最关键的步骤就是对结果的解读，通常数据分析只能发现一些现象和问题，并不能了解原因，所以分析完成后我们通常会跟进举行一些用户访谈，听听用户怎么解释\n数据分析的常见问题与对策\n过于学术，沉迷于“科学研究”\n虽然数据不会主动骗人，但我们经常无意或有意地误读数据\n平时不烧香，临时抱佛脚\n\n需求采集人人有责一手需求与二手需求\n二手需求采集工具：单项需求卡片\n尽可能多地采集需求采集，并不是产品设计之前的工作，而是一个贯穿产品生命周期的过程。它不只是产品人员的事情，而是所有人的责任，它并不怕发现什么荒谬的需求，而是怕遗漏合理的需求\n\n现场调查：和客户一起工作一段时间，深入了解需求，要特别小心被“非典型”用户带到沟里去\nAB测试：同时做方案A和方案B，并应用在不同的用户身上，然后根据反馈再做下一步决定，这个方法比较适合用户量大的产品\n日记研究：去阅读分析用户写的关于产品的文章，要注意日记的作者往往是同行，而不是主流用户\n卡片分类法：把产品的各种需求写在便利贴上，让用户一起讨论并完成分类，可以让最终的产品更加符合用户的心理模型\n自己提需求\n\n需求分析：听用户的但不要照着做明确我们存在的价值用户跟福特要一匹更快的马，福特却给了用户一辆车。这就是我们存在的价值\n用户需求VS产品需求用户需求：用户自以为的需求，并且经常被用户表达为解决方案\n产品需求：经过我们的分析，找到的真实需求，并且表达为产品的解决方案\n需求分析：从用户提出的需求出发，找到用户内心真正的渴望，再转化为产品需求的过程\n满足需求的三种方式\n提高现实：我们最常用的方法，去开发某种产品，但也是最笨的方法\n降低理想：“打预防针”、“丑话说在前头”\n转移需求：因为人类的注意力是有限的，所以引导用户去关注其他事物，他就会觉得这个差距没那么可憎了\n\n也谈创造需求我们无法创造需求，但是可以创造性地满足用户的需求\n给需求做一次“DNA检测”把用户需求转化为产品需求在这个阶段，团队经常举行头脑风暴，最终整理出一份Feature List功能列表。表格中每一行是一个产品需求，而每一列描述了产品需求的一种属性\n确定需求的基本属性\n\n\n需求属性\n属性说明\n\n\n\n编号\n需求的顺序号，唯一性标识\n\n\n提交人\n需求的录入PD，负责解释用户需求和产品需求\n\n\n提交时间\n需求的录入时间，辅助信息\n\n\n模块\n根据产品的模块划分\n\n\n名称\n用简洁的短语描述需求\n\n\n描述\n需求描述无歧义性、完整性、一致性和可测试性等，简要描述原始需求\n\n\n提出者\n即需求的原始提出者，有疑惑时便于追溯\n\n\n提出时间\n原始需求的获得时间，辅助信息\n\n\nBug编号\n将一些Bug视为需求，统一管理\n\n\n需求的种类\n\n\n需求属性\n属性说明\n\n\n\n分类\n新增功能、功能改进、体验提升、Bug修复、内部需求等\n\n\n层次\n基础、扩展（期望需求）、增值（兴奋需求），理论依据参考KANO模型\n\n\n产品需求&#x3D;产品功能需求+产品非功能需求\n产品包需求&#x3D;产品需求+市场需求+开发需求+测试需求+服务需求+…\n当一个扩展&#x2F;增值需求被普遍满足以后，它也就慢慢的变成基础需求了\n分析需求的商业价值通常在这个时候举行需求讨论会\n\n\n\n需求属性\n属性说明\n\n\n\n重要性\n重要程度，辅助确定商业价值\n\n\n紧急度\n紧急程度，辅助确定商业价值\n\n\n持续时间\n持续时间，辅助确定商业价值\n\n\n商业价值\n商业优先级，不考虑实现难度，群体决策\n\n\n初评需求的实现难度\n\n\n需求属性\n属性说明\n\n\n\n开发量\n需求的开发工作量，表征实现难度\n\n\n此时，需求往往不明确，开发人员无法评估开发量，产品人员又没那么多时间明确每个需求具体该怎么做，技术部门不评估每个需求的开发量，产品就不知道哪些值得进一步分析怎么做，而哪些又不值得。解决办法是找经验丰富的开发人员进行初评，开发量允许有误差，初评时采用三点估算法：\n\n工作量&#x3D;（最乐观+最悲观+最可能）&#x2F;3\n工作量&#x3D;（最乐观+最悲观+最可能*4）&#x2F;6\n\n在项目启动之后，制定项目计划的时候还会有一次更精确的评估，那时候已经知道需求要怎么做、由哪位开发工程师来做，所以可以推算出相对准确的工期\n判断需求的性价比\n\n\n需求属性\n属性说明\n\n\n\n性价比\n商业价值&#x2F;开发量，用于决定先做哪个需求\n\n\n需求筛选：活下来的永远是少数需求筛选，也叫需求PK\n永远忘不掉的那场战争按产品线划分团队，某个产品有自己的产品设计师、开发与测试人员，这对产品本身是有利的。产品经理权力更大，可以按照自己的想法做。不但资源有保证，产品规划也不容易被改变。此外，各种职能的员工之间沟通顺畅，开发的领导、测试的领导等都对产品经理负责\n按职能线划分团队，产品中心包括所有的产品经理和设计师，研发中心包括所有的开发工程师、架构师等，质控中心包括所有的测试工程师，这对多个产品间的资源共享有利，可以让资源流向更需要的地方，保证对核心产品的投入，但是效率不高。由于产品规划的决策需要在更高层面上敲定，单个产品的发展速度会有所降低。但是，资源战争可以把鲶鱼效应从产品内部扩大到公司层面，使产品经理和设计师们更抓狂地为产品的发展而苦苦思索，这是一件好事\n在创业期需要产品线结构，而当公司里有多个产品慢慢成熟之后，就可以用职能线来更充分地利用资源，实现资源共享\n准备出发：把需求打个包\n“需求打包”最好打包类似的功能点，打包以后通过业务逻辑图的方式可视化，可以更直观地给别人讲解\n功能互相之间有依赖关系\n需求的粒度大小问题\n\n战场：产品会议武器：商业需求文档商业需求文档简称BRD，包括以下内容：\n\n项目背景：我们在哪里？即为什么要做这个项目，这个项目解决什么问题，可以列出一些数据说明项目的必要性\n商业价值：我们去哪里？这是最关键的重点，一般还会预测一下相关数字的变化，提出这个项目的商业目标\n功能需求描述：我们怎么去？即做哪些事情来达到目标，通常用功能列表和业务逻辑图来描述，如果有简单的Demo更好\n非功能需求描述\n资源评估：这是第二个重点\n风险和对策\n\n商业价值和资源评估本质上是在追求性价比，大家都希望花费最少的资源获得最大的商业价值\n别灰心，少做就是多做最爽就是“四两拨千斤”做得少不如做得巧，内部（指偏技术）的大改动往往是外部（指偏商业）的小改动\n尽可能多地放弃需求管理：心急吃不了热豆腐一个需求的生老病死需要再加几个属性来管理需求的生命周期\n\n\n\n需求属性\n属性说明\n\n\n\n需求状态\n需求生命周期：待讨论、暂缓、拒绝、需求中、开发中、已完成、测试中、已发布\n\n\n负责PD\n状态进入“需求中”后确定\n\n\n开发工程师\n状态进入“开发中”后确定\n\n\n项目名称\n辅助信息，在需求进入“开发中”时确定，用来确定该需求属于哪个项目\n\n\n发布时间\n辅助信息，在需求状态变为“已发布”时填写，用来查看某段时间发布的需求\n\n\n备注\n其他任何信息：被拒绝的理由、被暂缓的理由和重启条件、其他相关文档\n\n\n\n需求管理的附加值\n统计每个“提交人”的需求数量，如果再加上时间段的条件，就可以从一个侧面反映出某段时间每个人的工作情况\n统计“提交信息”“发布时间”等信息，按月统计可以从需求数量的侧面看出产品发展是在增速还是在减速\n统计每个“模块”的需求数量，可以看出用户对产品的哪些模块感兴趣\n统计每个“分类”的需求数量，可以了解产品是在成长期还是成熟期\n统计需求的“商业价值”和“性价比”变化，可以看出这个产品的发展空间还有多大\n\n谈项目：项目的坎坷一生\n生态系统中，云变成雨落入河流，河流会把水运送到各地。河流中，有乱石、有浅滩，处处潜藏了危险\n\n从产品到项目项目：只进行一次且包含多项互相关联的任务，并有绩效、时间、成本和范围限制的一项工作\n产品是解决某个问题的东西，而项目是一个过程\n做产品VS做项目\n从生命周期的角度来看，“做产品”的生命周期相对较长，关注的是整个产品从规划到制造，再到最终维护和消亡的整个过程。而“做项目”有特定的目标，所以生命周期较短，通常在项目开始以前就有明确的起始和结束时间，通过验收就表示项目生命周期结束了\n从具体要做的事情来看，在“做产品”的过程中，会有更多的探索行为。而“做项目”在开始时就已经有明确的目标，更注重计划与控制\n从产出物的角度来看，产品是可以批量生产，并且提供给大量用户使用的，所以产出物最好能相对通用，通常会首先考虑用有限的资源去满足更多的、能有更多回报的需求。而项目只进行一次，意味着每次需求都是定制的、个性化的，通常为了满足这些特定的需求，产出物也比较个性化\n\n“做产品”和“做项目”也是分不开的，“做产品”的过程，正是通过做一个又一个项目实现的，但产品并不是项目的简单累加。在产品渐渐满足目标用户群体的通用需求后，我们需要细分市场，这时候产品可能升级为“产品线”，按不同的细分市场，推出不同的产品，最终通过合理地安排项目来实现产品的规划\n产品经理VS项目经理产品经理：靠想，做正确的事，思考其领导的产品是否符合市场的需求、是否能给公司带来利润\n项目经理：靠做，把事情做正确，把事情做得完美，在时间、成本和资源约束的条件下完成目标\n产品经理是内部驱动，最重要的是判断力与创造力；项目经理是外部驱动，最重要的是执行力与控制力\n为什么让产品经理管项目如果让开发人员做项目经理，会倾向于简化项目、尽量少做、做自己熟悉的功能，使得项目顺利完成，并且Bug很少，但是做出来的东西也许商业价值不足、用户体验不好\n如果让产品人员来做项目经理，会不断地给项目增加新的需求，导致项目总是无法按期完成，影响了团队的士气\n一个产品经理可能想要增加非常多的功能和特征以满足获取到的用户需求，但是项目经理却想要尽可能小地控制工作范围，以保证项目在规定时间与预算内完成。好的产品经理和好的项目经理能在冲突中找到平衡。好的项目经理明白，一个项目真正的成功并不是看它是否在规定的时间和预算内完成，而是它是否达到了拟定的目标。好的产品经理则明白，如果项目被不断延期并且从未投入市场，又或者因为大大超过预算而被结束，那么所有的产品功能特征都会变得毫无意义\n立项：一切从Kick Off开始在项目里，Kick Off指的是项目的启动大会\n团队组建如果要降低团队组建的难度，作为项目经理可以从以下几点入手：\n\n启动的项目经过产品会议并得到了大老板们的认可，项目所需的基本资源有保证\n经常合作的都是相对固定的人，沟通比较顺畅\n\n组织一个项目督导委员会很有必要\n项目计划确定确定沟通方法项目晨会、项目日报、评审会、项目变更申请、发布预告及公告\nKick Off会议会议内容：\n\n项目背景\n项目意义、目的与目标\n需求、功能点概述\n项目组织架构：项目成员互相认识\n项目计划：项目的时间点与里程碑；各个时段需要的资源，即每个人要在各个阶段做什么事情\n沟通方式\n\n任何时候都要心中有“树”项目TRQ三要素：项目时间Time、项目资源Resource、项目品质+数量Quality，通常在这几个目标中寻找平衡\n需求开发：关键的青春期，又见需求真的要写很多文档BRD：商业需求文档，这是产品生命周期中最早的文档，其内容涉及市场分析、销售策略、盈利预测等，没有产品细节，主要作用是为了获得认可、争取资源\nMRD：市场需求文档，产品进入实施阶段要写，MRD中要有更细致的市场与竞争对手分析，包括可通过哪些功能来实现商业目的，确定功能、非功能需求分哪几块，功能的优先级等内容，Feature List和业务逻辑图等都属于MRD文档，它也是从商业目标到技术实现的关键转化文档\nPRD：产品需求文档，主要包含整体说明、用例文档、产品Demo等\n\n总体说明：\n\n修订历史：每次修订的日期、版本号、说明、作者\n项目概述：项目背景、意义、目的、目标等\n功能范围：画出业务逻辑图\n用户范围\n词汇表：专有词汇、术语、缩写\n非功能需求：性能需求、数据监控需求等\n其他说明\n\n用例文档Use Case：\n\n对PRD中所有的用例进行说明，给出用例的可视化表示，说明各个用例之间的关系（类图、用例图、状态图）\n用例的正文，由一个个的用例组成\n对单个用例的一些注释\n\n\nFSD：功能详细说明，经常包含在PRD中\nUML统一建模语言&#x2F;标准建模语言：时序图、活动图、协作图时序图：也叫顺序图，描述事物变化在时间维度上的先后顺序，善于表达多个对象之间的交互，比如多个页面之间、多个角色之间\n\n活动图：比较接近流程图，描述各种动作如何引起系统变化，善于表达泳道较多、分支较多的情况\n\n协作图：表达不同对象之间是如何互相影响的\n时序图关注交互在时间上的步骤，协作图关注交互过程中各个对象间的关系\n产品Demo产品Demo，也被称作产品原型、演示版、Mockup\n手绘、线框图、高保真原型图\n需求活在项目中作为重要监控点的需求评审、设计评审、测试评审需求评审：是PRD评审、UC评审、Demo评审的统称\n设计评审在概要设计与详细设计完成之后进行，由开发工程师把对需求的理解以设计文档的形式向PD、测试人员解释说明\n测试评审：俗称TC评审，在TC编写完成后，测试开始之前进行，由测试工程师把对需求的理解以TC的形式向PD、开发人员解释说明\n再看需求的生老病死\n项目开发、测试、发布开发阶段的工作内容：概要设计&#x2F;详细设计、设计评审、编码、单元测试\n测试阶段的工作内容：TC编写、TC评审、冒烟测试、功能测试、性能测试等（在测试人员正式开始测试的同时，PD将组织一次产品的功能评审&#x2F;产品演示会，进一步确保做出来的东西就是大家想要的，之后会进行UAT用户接受度测试和验收测试）\nBug眼中的项目\n缺陷级别：一般大于等于三级的Bug被认为是严重的问题\nBug级别定义标准：\n\n\n所属产品、项目\n\nBug名称\n\nBug描述\n\n\nBug状态流转过程：\n\n发布阶段发布阶段的工作内容：发布评审、预发布、发布、线上验证\n以终为始，项目小结发送“项目发布公告”、“项目小结”（平常要有记项目日报和项目周报的习惯）\n常见的项目变化：\n\n项目范围内需求的变更，需要制定流程进行控制\n项目范围的扩展，搭车事件\n紧急事件，一般是高层自上而下推动的\n\n山寨级项目管理文档只是手段建立自己的文档规范模板作用\n让经常看同类文档的人提高效率\n让写文档的新人可以尽快上手\n让写作者不会漏考虑某些内容\n\n多人协作与版本管理流程也是手段项目VS流程项目只做一次，所以追求可行解即可；流程要反复做，所以要追求最优解\n流程的本质目的设计流程的目标，在于保证“无论谁来做这个产品的设计，都能达到80分”\n总结一些评审商业评审：决定做不做\n\n立项之前的产品会议\nKick Off会议\n功能评审\n\n技术评审：决定怎么做\n\n需求评审（PRD评审、UC评审、Demo评审）\n设计评审\n代码评审\nTC评审\n发布评审\n\n敏捷更是手段从瀑布模型发展到敏捷方法\n敏捷方法的特点：\n\n有计划，更要“拥抱变化”\n迭代周期内尽量不加任务，每次迭代其实也可以看作一个小的瀑布模型\n集中工作，小步快跑（推崇每日站立晨会）\n持续细化需求，强调测试\n不断发布，尽早交付\n\n谈团队：我的产品，我的团队\n如果生态系统里只有水汽的循环，它仍然不会有生机。有了各种各样的动植物，才能让这个系统灵动起来\n\n大产品、大设计、大团队产品之大“产品之大”可以从时间和空间两个角度来说\n时间之大：产品生命周期产品生命周期里的五种用户群体：\n\n\n创新者：新鲜感强、消费能力高，但是忠诚度不高，需要新鲜的东西不断刺激。这批人都有Geek气质，乐于探索。产品刚上市，甚至未上市的时候，主流用户往往是创新者。任何产品投放市场的第一批外部用户，基本上都是竞争对手的产品经理和业内人士，千万不要被他们带到沟里\n\n早期追随者：观念比较新，但是需求目的性很强，需要产品能够迅速解决其问题。他们可能很早就知道产品了，但不会盲目试用，而是先从其他渠道主动了解这个产品是干什么的，再反复验证，确认对自己有用以后才会尝试。这批人会比第一种人忠诚度高很多\n\n应该牢牢抓住，将来发展成种子用户\n产品上市后的早期，主流用户通常是早期追随者\n这时候产品可以偏向这类“专家用户”，因为产品的进化主要体现在功能的不断创新上\n在他们和主流用户之间，还存在一个鸿沟。因为早期采纳者有可能饥不择食，而主流用户却是实用主义者，很看重性价比（用户从早期采纳者扩展到主流用户时，产品策略需要做一些调整）\n\n\n早期主流用户：是产品大规模产生商业价值的用户群，他们是典型的实用主义者，也是生活中最常见的一批人。对他们来说，即使偶尔听说过某新产品，但只要正在使用的老产品也能解决问题，就不会轻易更换。不过，他们心中还是对新产品存在期待，希望有机会试一下\n\n这时候产品需要面向主流的“中间用户”和“新手”，所以产品需要尽量做得简单易用\n这时候开始，产品渐渐稳定\n也是真正获得商业回报的开始\n\n\n晚期主流用户：这部分主流用户和早期主流用户的区别在心态上。早期主流用户对新产品有尝试的愿望，而晚期主流用户对新产品心存抵触。直到老产品已经渐渐地出现明显的劣势，他们才会很不情愿地使用新产品\n\n这个阶段产品已经定型，用户对产品也比较了解，市场竞争也相当激烈，仅仅通过功能竞争来获得用户是不够的\n\n这个阶段是典型的市场营销发力的时刻，需要通过强大的心理攻势来赢得晚期主流用户的认可\n\n此时如果做好营销的创新，可以一招鲜吃遍天，并且这一阶段与研发阶段相比投入比较少、产出快、可预期，是收割商业回报的大好时期\n微笑曲线：\n\n\n\n\n落伍者：附加值比较低，可以在不违背道德标准的前提下偏重眼前利益\n\n此时产品渐渐退出，市场也渐渐萎缩或转移，会有新产品成长起来\n\n\n\n空间之大：商业、产品、技术商业、产品、技术的三角支撑：\n\n\n商业：在公司里主要由市场、销售、服务等部门来考虑，他们决定了产品定位、定价与促销、渠道政策等\n产品：此处指狭义的产品，由产品部门（产品设计、用户体验、产品运营等部门）来考虑，他们决定了产品的功能完成度、交互流程、视觉表现等\n技术：主要由开发、测试、运维等部门来考虑，他们决定了产品的稳定性、基本性能、Bug数量等特性\n\n设计之大产品的设计之大，体现在产品设计的多个层次上\n\n产品战略层面上的设计：做不做、做什么\n具体工作中的产品设计：做多少、怎么做\n产品实施层面上的设计：谁来做、何时做\n\n产品设计的五个层次\n\n战略层：明确商业目标和用户需求，找准方向，重点是解决两者之间的冲突，找到平衡点\n范围层：明确“做多少”\n结构层：考虑产品的各个部分互相之间是什么关系\n框架层：这一步才出现用户真正能看到的东西\n表现层：包含了视觉设计和内容的优化\n\n设计的“现实与浪漫”设计的目标有三个层次：\n\n本能水平设计：纯生理的视觉冲击\n是基础，产品要有用，能满足用户的某种需求\n\n\n行为水平设计：产品功能、用户与产品交互层面的设计\n是保证，产品要能用、好用，顺利地解决用户的问题\n\n\n反思水平设计：纯心理需求&#x2F;人性的设计\n是升华，是难以捉摸的“用得爽”\n\n\n\n团队之大常见的组织结构有职能型组织、项目型组织和矩阵型组织\n\n职能型组织是把相同职责的人划分在一个部门里，有利于同类资源共享，互相学习提高\n\n缺点是只对“上面”负责，没有人对真正的客户负责\n头儿是部门经理\n比较适合防守型业务\n\n\n项目型组织是把各种职责的人组成一个个的项目组或产品线，团队目标一致，有利于快速推进项目\n\n缺点是会浪费资源\n头儿是项目经理或产品经理\n适合进攻型业务\n\n\n矩阵型组织是上述两种组织结构的融合\n\n适合全攻全守\n\n\n缺点是“双头领导”（产品经理和部门经理可以通过兼任解决矛盾吗？不能，产品经理主要管事，有成就感，需要有攻城拔寨的能力；部门经理主要管人，有权力，有防守与后勤的感觉。如果部门经理兼任产品经理，就会用权力来寻求成就感，或者在产品KPI的重压下，主动或被动地忽视团队能力的提升。解决办法是由用人的产品经理提供建议，养人的部门经理决定对员工的考核，同时培养每个人对事负责的态度）\n\n\n\n\n游走于商业与技术之间产品团队：\n\n心思缜密的规划师包括产品经理、产品规划师、产品设计师、需求分析师等\n从概念设计到信息架构概念设计的产出物是产品概念图，本质是要用图形化的方式表达清楚这个产品是什么，比较像业务逻辑图，但比业务逻辑图更抽象。制作概念图应该在需求采集之后，需求筛选之前，它和需求分析属于同阶段的任务。在各种用户需求之中，我们需要通过概念图来理清思路，找出到底应该“做什么”，并将这些打算做的需求整合为一个合理的系统\n概念图描述的是整个产品的内外关系：\n\n产品与外界的关系：把产品整体看作一个系统，描述它与上下级系统、并列系统的关系，可能的话，勾勒出产品所处的产业链结构\n产品内部的关系：描述产品有多少模块、模块之间的关系如何，此处不用涉及数据流等细节，重点描述清楚不同的角色在系统里的身份\n\n概念设计是为内部而做的，为了让团队之间进行更好的沟通，以便于大家对产品达成共识\n信息架构是为外部用户而做的\n激情四射的设计师指的是用户体验部门UE的同事们，包括用户研究员、交互设计师、视觉设计师、前端工程师、文案设计师、信息架构师等\n规划师更多的是“结构化思维”，让产品从无到有；设计师需要更多的“形象化表达”，让产品从有到优\n“阴险狡诈”的运营师运营就是从事前“预谋”，到事中按计划执行，再到事后拿到结果并为下一次运营积累经验的过程\n事件营销：制造具有新闻价值的事件，并设法让这一事件传播，从而达到广告的效果\n病毒营销：指利用公众的积极性和人际网络，让营销信息像病毒一样传播和扩散\n在产品的日常运营工作中，我们可以对各种热点事件保持关注，并不断总结各种用户群体愿意传播的信息元素，在发现机会时一定要抓住\n商业团队，冲锋陷阵包括市场、销售、服务等\n如果说销售人员可以增加新客户，让客户对某个产品第一次付钱，那么服务人员就是要稳住老客户，让客户对某个产品不断付钱\n好产品需要市场化好的产品需要市场化，不然，产品就成了实验室里的样品\n定价与促销销售与渠道销售有两大模式：\n\n直接销售：由企业直接向最终消费者进行推销\n分销：需要借助渠道，分销的渠道分为代理和经销，代理赚取企业的佣金，代理方没有产品所有权和库存风险；经销赚取产品的差价，产品所有权发生转移\n\n渠道战术讲究“推拉并重”，所谓“推”是集中力量做渠道工作，用高额利润去刺激渠道主动推销产品，快速抢占市场；而“拉”是通过媒体关系、广告、传播等手段启动市场，刺激消费者，促使渠道来找厂商\n\n“推”适合企业规模小、技术含量高、销售过程复杂的产品，“拉”则反之\n一般新产品主要靠“推”，老产品主要靠“拉”\n\n另一种产品版本细分策略产品版本细分有两类：\n\n一种是做功能区分，分别应对每一个细分市场\n另一种是为了促进销售，利用消费者心理，纯策略性地做出“炮灰”版本，这类产品版本本质上是为产品的市场化服务的\n一种在原有版本的基础上添加一些“鸡肋”功能，做一个价格高出很多的“高价炮灰”\n另一种是删掉核心功能做一个价格稍低的“低价炮灰”\n\n\n\n开阔视界的水平营销纵向营销是进化，其特点是渐变；水平营销是革命，其特点是突变，水平营销是一种创新思维的方法\n我们还能做什么产品部门一定是先确定目标用户再设计产品，市场销售等商业部门往往是先拿到产品，再考虑主打哪些市场与用户，他们并不在意产品部门原先定义的目标用户是怎样的，只会去寻找最容易的突破口。所以，产品与市场两边的配合很重要，需要互相调整来彼此适应\n算出来的服务策略服务部门是为昨天的利润工作，给已经购买产品的客户提供承诺的价值；销售部门是为今天的利润工作，把产品变成利润，争取更多的客户；开发部门是为明天的利润工作，确保明天我们有优秀的产品可以卖；研究部门是为后天的利润工作，了解趋势、发展科技，保证产品永远处于领先位置\n维护一个老客户的成本大约是开发一个新客户成本的四分之一\n技术团队，坚强后盾技术团队：\n\n容易被遗忘的角落支撑团队：包括老板、法务、财务、行政等\n让老板做问答题、让老板做选择题、让老板做判断题\n大家好才是真的好所谓团队文化无授权领导管理VS领导\n管理更像科学，领导更像艺术\n管理靠的是权力，领导靠的是魅力\n管理者强调稳定，领导者喜欢冒险\n管理者依法治人，领导者以德服人\n管理的对象是行为，领导的对象是思维\n管理管正确地做事，领导管做正确的事\n管理是一步一个脚印，领导是不走寻常路\n管理者注重短期目标，领导者注重长期发展\n管理者是职业经理人，领导者是企业家和创业者\n管理是汽车的制动系统，领导是汽车的驱动系统\n管理是告诉团队怎么做，领导是告诉团队为什么做\n管理对人的影响由外而内，领导给人的力量由内而外\n管理让团队能完成这些事，领导让团队喜欢做这些事\n\n产品经理应该拥有管理职位吗优势：\n\n管理岗位利于拥有话语权\n管理岗位利于获取信息\n管理岗位利于争取资源\n\n劣势：\n\n管理岗位有很多行政工作\n管理岗位会让人脱离群众\n\n如何让团队更开心\n大中之小不如小中之大（比如送礼物）\n有用的不如无用的（最好的礼物应该是吃不掉、用不掉、送不掉也扔不掉的东西）\n需要的不如想要的\n有选择不如无选择（否则会让人有一种“放弃了另外一种选择”的感觉）\n小奖不如没奖（会让做事的人开始衡量投入产出的物质性价比，惩罚也是如此，小惩罚会让人心安理得）\n晚说不如早说（让人有期待感）\n一次送不如两次送（比如送两件礼物；好消息要分两次说，坏消息要一起说，大的好消息与小的坏消息一起说，小的好消息与大的坏消息分开说）\n公开不如不公开（比如工资）\n涨工资不如发奖金（从公司角度来说）\n\n跟着我，有肉吃谈战略：别让灵魂跟不上脚步\n在动植物的帮助下，水汽通过云、雨、河流形成了循环，可是，它们的原动力其实是阳光，因为“万物生长靠太阳”\n\n触及产品的灵魂：战略产品经理的三层境界：\n\n产品帮助我们\n产品与我们互相帮助、共同提高\n我们帮助产品\n\n以价值观为根基产品的灵魂或者企业的灵魂是什么，探到最深处，是由价值观决定的，而企业的价值观就是：企业决策者对企业性质、目标、经营方式的取向做出的选择，是员工所接受的共同观念，是长期积淀的产物\n有了“应该做什么、不做什么”的根本指引，就有了一切讨论的根基\n战略是怎么炼成的有价值观作为企业做事的最基本指导原则之后，我们需要思考公司或产品的使命和愿景\n\n使命是指“我们为什么而存在，要做什么事情”，它必须是一个持久的事实\n愿景是说“我们希望成为什么”，它需要由组织内部成员来制定，借由团队讨论，获得组织一致的共识，并形成大家愿意全力以赴的未来方向\n\n这些是我们做事的驱动力\n在明确了上述概念之后，一家企业才可能清晰地确定公司战略。否则，徒有战略却没有价值观、使命和愿景的公司，是无法将战略落实到位的\n之后，企业需要制定相应的流程规范、组织结构、IT系统、激励机制等保证战略的实施\n有了公司战略之后，进一步就是产品战略\n培养大局观帕累托改进：在总资源不变的情况下，如果对某种资源配置状态进行调整，使一些人的境况得到改善，而其他人的状况至少不变坏，符合这一性质的调整被称为帕累托改进\n绝大多数现实工作中的情形是“有得必有失”，如果你发现做一个改变只有好处没有坏处，那很可能是你站得低看得近，或者说你考虑到的“全部”只是更大系统里的一部分，“坏处”会在其他部分体现出来。这时候你应该找一个站得高看得远的人讨论，会比较容易发现问题\n可行性分析三部曲制订产品战略，在项目管理里叫做“可行性分析”，属于产品设计层次的“战略层”，在公司层面可能叫“战略规划”\n我们在哪儿从市场扫描开始：整个行业如何市场扫描的过程一般也是新产品的“预研”阶段\n常用的市场扫描方法：PEST分析，分别分析产品在政治法律环境、经济人口环境、社会文化环境、技术环境四个方面所面临的机会和威胁\nPEST分析的细分因素：\n\n我们只有通过宏观层面的PEST分析，发现涉足某个行业是可行的，才可以继续下去\n真实的竞争对手分析：竞争对手如何小的成功靠朋友，大的成功靠对手\n竞争对手分析也叫竞品分析，一般以经典的$APPEALS分析法作为指导方针，来开展竞争对手分析：\n\n$：产品价格\nA：可获得性\nP：包装\nP：性能\nE：易用性\nA：保证程度\nL：生命周期成本\nS：社会接受程度\n\n深刻的自我剖析：自己情况如何常用方法是SWOT分析：对企业的优势、劣势、机会和威胁进行分析\n我们去哪儿对应问题：细分市场是什么？目标用户是谁？我们要解决他们的什么问题、满足他们的什么需求？\n宏观上的用户需求：指某一个目标用户群体面临的问题是什么\n通过对某一个目标用户群体进行划分，找到有机会切入的小市场\nERP：企业资源计划，指建立在信息技术基础上，以系统化的管理思想为企业决策层及员工提供决策运行手段的管理平台\n\nHRM：人力资源管理软件\nSCM：供应链管理软件\nOA：办公自动化软件\nCRM：客户关系管理软件\n\nSEO：搜索引擎优化，为近年来较为流行的网络营销方式，主要目的是增加特定关键字的曝光率以增加网站的能见度，进而增加销售的机会\n我们怎么去对应问题：用什么产品满足需求？产品的核心竞争力是什么？\n解决我们怎么去的问题，浓缩成两个字就是：策略，各种正确的策略保证了我们是在“做正确的事”\n低头看路，抬头看天抬头看天指的是：里程碑、检查点\n我们急需靠谱的会议，大会决定小事，小会决定大事\nKPIKPI：关键业绩指标，它是在分解企业战略目标的基础上，分析各子目标与主要业务的联系之后提出的，KPI是企业目标的具体表现\nSMART原则：\n\nS代表具体，指绩效考核要切中特定的工作指标，不能笼统\nM代表可度量，指绩效指标是数量化或者行为化的，验证这些绩效指标的数据或信息是可以获得的\nA代表可实现，指绩效指标在付出努力的情况下可以实现，避免设立过高或过低的目标\nR代表现实性，指绩效指标是实实在在的，可以证明和观察\nT代表有时限，完成绩效指标有特定的期限\n\n你再怎么去客观地设计绩效体系，这个体系都无法真正地与你追求的目标画上等号，在这种情况下绩效体系越量化，越容易将团队成员带入追求绩效的数字游戏上，而忽视了真正的目标\n远视者把目的当手段，近视者把手段当目的\nKPI其实是在多个目标间做权衡\n专业产品是做给专业用户的，更倾向于“让人适应产品”，比如各种乐器；设计给新手用的产品必须是产品适应用户\n达摩克利斯之剑：用来表示时刻存在的危险\n谈修养：产品经理的自我修养\n一个生态系统，有了云和雨、河流、动植物、太阳之后，看似完整了，可我们忽略了它们的根基，那就是大地\n\n爱生活让我们充满动力，有理想让我们目标明确，会思考让我们方法得当，能沟通让我们团结前进\n爱生活，才会爱产品UGC：用户产生内容\n有理想，就不会变咸鱼会思考，活到老学到老“教”是为了“不教”，是为了激发其自我反思、自我管理的能力。当开启一个人的心智之后，他就可以自我发展，成为一个独立的人，我们所经历的教育，似乎缺少了“引出”的过程，而过多地赋予了“雕琢”的感觉。学校教育为了特定的目的，总想把一个人从石头雕刻成一件有用的工具\n学校里没教的东西：\n\n教知识不教思维\n教解题不教选题（“选择”恰恰是产品经理常做的事，工作中追求“性价比”而不是“完美”）\n教努力不教取巧\n只教“受教”不教“施教”\n\n能沟通，在什么山头唱什么歌其实产品经理很大程度上就是销售，而且比销售还要难，销售卖的是已经有的东西，而产品经理卖的是自己的想法；销售只要把产品卖给客户，而产品经理要把想法卖给老板、同事、客户等：\n\n第一卖：老板（需求、项目多得是，凭什么给你资源）\n第二卖：其他PD（大家都很有想法，凭什么听你的）\n第三卖：开发与测试（这样做很麻烦，值得吗）\n第四卖：合作公司（凭什么帮你，给个双赢的理由）\n第五卖：市场与销售（让我们振奋起来的产品，做起来才有动力）\n第六卖：服务、财务、法务（我们一直在擦屁股）\n第七卖：客户（搞清楚，钱都是我付的）\n\n沟通理念：\n\n理论上严格意义的“充分沟通”是不存在的\n沟通不是为了说服，而是为了更好地认识世界\n\n职场中的点对点沟通：\n\nIM\n\n电话\n\n面谈\n\nEmail\n\n\n\n职场中的群体沟通：\n\nIM群\n电话会议或视频会议\n线下会议\n群发邮件\n\n产品经理主义解决问题的通用思路：\n\n为了什么？\n做什么事、解决什么人的什么问题？\n何时做？谁来做？\n效果如何？\n\n甘特图：又叫横道图、条状图，它可以用图示的方式通过活动列表和时间刻度形象地表示出任何特定项目的活动顺序与持续时间\n人人都是产品经理，不是说团队里每个人都应该做产品经理的事情，而是每个人应该用产品经理式的态度和方法来做好自己相应的工作（在生活中也能用到产品经理式的态度和方法）\n一个人真正成熟的标志之一，就是心中可以容纳互相矛盾的观点而无碍行事\n产品经理的主要职责：\n\n市场调研（最终会转化成商业机会、产品战略或商业需求文档BRD）\n产品定义及设计\n项目管理\n产品宣介\n产品市场推广\n产品生命周期管理（概念化、发布、成熟、退出市场）\n\n产品经理的核心技能：\n\n沟通能力\n无授权领导能力\n学习能力\n商业敏感度\n热爱产品\n注重细节，追求完美\n日常产品管理能力\n\n","categories":["产品理论"],"tags":["产品理论书单📚-产品"]},{"title":"产品思维与技术思维的差异","url":"/2023/08/31/%E4%BA%A7%E5%93%81%E7%90%86%E8%AE%BA/%E6%8A%80%E6%9C%AF%E6%80%9D%E7%BB%B4/%E6%8A%80%E6%9C%AF%E6%80%9D%E7%BB%B4/1_%E4%BA%A7%E5%93%81%E6%80%9D%E7%BB%B4%E4%B8%8E%E6%8A%80%E6%9C%AF%E6%80%9D%E7%BB%B4%E7%9A%84%E5%B7%AE%E5%BC%82/","content":"思维及认知差异：推荐书籍：《思考，快与慢》\n人类具有两套系统：我们习惯于运用“系统1”进行思考，每个人的“系统1”结构都不同，取决于知识结构和背景经验\n\n快思考-系统1：基于情感、记忆、经验，自主运行、反应迅速\n慢思考-系统2：基于理性逻辑、分析，需要启动、非常“懒惰”\n\n个体思维及认知差异，是形成不同思维系统的原因\n产品思维与技术思维的差异是如何形成的？\n产品思维与技术思维内容的差异：\n产品思维与技术思维职能的差异：\n优秀的产品往往是扎实的技术基础和良好的用户体验相结合的产物，是产品思维和技术思维的结合体\n","categories":["产品理论"],"tags":["技术思维-技术思维"]},{"title":"《启示录-打造用户喜爱的产品》","url":"/2025/02/14/%E4%BA%A7%E5%93%81%E7%90%86%E8%AE%BA/%E4%BA%A7%E5%93%81%E7%90%86%E8%AE%BA%E4%B9%A6%E5%8D%95%F0%9F%93%9A/%E4%BA%A7%E5%93%81/%E3%80%8A%E5%90%AF%E7%A4%BA%E5%BD%95-%E6%89%93%E9%80%A0%E7%94%A8%E6%88%B7%E5%96%9C%E7%88%B1%E7%9A%84%E4%BA%A7%E5%93%81%E3%80%8B/","content":"如果开发的产品没有市场价值，那么无论开发团队多么优秀也无济于事。仅仅做出产品并不够，还要确认产品是有价值的、可用的、可行的\n作者的日常工作明确分为三块：这三个部分是探索和开发用户喜爱的产品必不可少的，项目都是由人完成的，流程则保证大家持续开发出用户喜爱的产品\n\n人员：是指负责定义和开发产品的团队成员的角色和职责\n流程：是指探索、开发富有创意的产品时，反复应用的步骤和成功的实践经验\n产品：是指富有创意的产品具有的鲜明特性\n\n好产品靠设计，从不认为富有创意的产品来自偶然，成功的产品都遵循一定的规律：\n\n产品经理的任务是探索产品的价值、可用性、可行性\n探索（定义）产品需要产品经理、交互设计师、软件架构师通力合作\n开发人员不擅长用户体验设计，因为开发人员脑子里想的是实现模型，而用户看重的是产品的概念模型\n用户体验设计就是交互设计、视觉设计（对硬件设备来说，则是工业设计）\n功能（产品需求）和用户体验设计密不可分\n产品创意必须尽早地、反复地接受目标用户的试用，以便获取有效的用户体验\n为了验证产品的价值和可用性，必须尽早地、反复地请目标用户测试产品创意\n采用高保真的产品原型是全体团队成员了解用户需求和用户体验最有效的途径\n产品经理的目标是在最短的时间内把握复杂的市场&#x2F;用户需求，确定产品的基本要求（价值、可用性、可行性）\n一旦认定产品符合以上基本要求，它就是一个完整的概念，去掉任何因素，都不可能达到预期的结果\n\n人员关键角色及其职责-现代软件产品团队这些角色都是打造成功的软件产品不可或缺的\n产品经理产品经理的主要职责分为两项：\n\n评估产品机会（许多公司借助市场需求文档MRD来完成这项工作）\n定义要开发的产品（探索产品的解决方案，包括基本的产品特征和功能、产品的用户体验、产品的发布标准，有些公司借助产品需求文档PRD来完成这项工作）\n\n用户体验设计师其中最关键的角色是交互设计师，也称为信息架构师、用户界面设计师、用户体验架构师\n\n交互设计师负责深入理解目标用户，设计有价值的、可用的功能，以及用户导航和产品使用流程\n交互设计师与产品经理密切合作，将功能与设计相结合，满足用户需求\n目标是确保产品同时具有可用性（指的是用户明白如何使用产品）和价值（指的是用户对产品的渴求程度）\n\n项目管理人员产品经理完成产品定义后，开发团队承接项目，开始开发产品。项目管理的核心任务是制订计划和跟踪进度\n开发团队软件工程师也称为产品开发人员或软件开发人员，负责开发产品。开发团队在有些公司被称为IT（信息技术）团队\n\nIT团队通常指的是为内部员工（如人力资源部门）提供技术支持的团队\n开发团队指的是为外部客户开发和维护产品的团队\n\n运维团队互联网服务产品通常运行在服务器上，用户通过web访问服务。运维团队负责保证服务正常运行\n产品营销人员产品营销团队负责对外发布信息、宣传产品、为拓展市场销售渠道、组织重点营销活动（如在线营销）、促进产品销售提供支持\n\n\n通常，每五到十位开发人员配备一位产品经理\n一位交互设计师大约可以支持两位产品经理的工作，一位视觉设计师可以支持四位交互设计师的工作\n凡超过十名开发人员参与的重大项目，就应该配备专职的项目经理。此外，如果采用火车模型发布模式（以固定的周期持续发布产品，如果某项既定功能未完成，就挪到下个周期发布的开发方法），必须为每次产品发布（通常这类产品由多个项目组成）配备专职的项目经理\n\n\n产品管理与产品营销-两者不是一回事产品经理的工作是从细节上定义开发团队开发什么产品。市场营销的职责是对外宣传产品。两项工作天差地别\n三种误区：\n\n由市场营销人员定义产品：由产品营销经理或所谓的产品经理负责收集高层产品需求，然后直接交给开发团队开发。这种方式忽略了收集详细产品需求的步骤，回避探索（定义）产品的艰难决策过程（也绕开了用户体验设计）\n\n这类产品经理或许擅长市场营销，但是对详细定义有价值的、可用的、可行的产品往往束手无策。除非他们不但具备营销技能，还掌握管理产品的方法，那么产品还有成功的机会\n\n\n两人分担定义产品的工作：定义产品的工作分给两人完成，产品营销人员负责收集高层商业需求，产品经理负责收集低层产品需求\n\n问题在于这两个人都不是真正的产品负责人，没人对最终的产品负责，而且采用这种模式是基于错误的观点，即认为可以脱离具体需求（尤其是脱离用户体验）来定义高层需求\n\n\n一人兼任两项工作：产品营销人员兼任产品经理的工作\n\n在现实中，很难找到同时具备产品管理能力与产品营销能力的人，两者的要求大相径庭。这种团队模式的扩展性很差，即便是最简单的产品，也应该由专职产品经理投入全身心进行管理。让产品营销人员兼做产品管理的工作，即便他具备两种技能，也没有精力把两边的工作都打理好\n\n\n\n出路：要解决这些问题，必须清晰界定产品经理和产品营销人员的职责。产品经理负责详细定义待开发的产品，让真实的用户测试产品。产品营销人员负责向外界宣传和推广产品，负责产品发布，为拓展市场销售渠道、组织重点营销活动（如在线营销）、促进产品销售提供支持\n产品经理和产品营销人员应该经常沟通、展开合作。一方面，营销人员是产品经理获取产品需求的重要来源；另一方面，产品经理是营销人员获取市场营销信息的重要来源\n如果产品经理定义的产品没有价值、不具备可用性和可行性，那么无论开发团队多么出色也无济于事\n产品管理与项目管理-互联网让两者变得不同多数互联网公司沿用了开发零售软件的惯例，用产品管理涵盖了项目管理。在传统的零售软件领域，产品经理常常兼任项目经理的工作。这种模式虽然适用于零售软件产品，但不太适合开发互联网服务类产品（比如旅游网站）\n\n早期的互联网公司让产品经理继续兼任项目经理的工作，但他们很快就遇到了问题。在零售软件领域，产品通常以独立安装包的形式发布，发布间隔从几个月到几年不等，产品和项目具有相同的粒度，开发频率也相同，产品经理兼任项目经理相对容易。但是在互联网产品领域，这种模式就行不通了。互联网服务类产品对网站代码的局部修改更加频繁，发布周期明显缩短（通常是每周或每月发布一次），大部分项目的开发周期明显长于发布周期。为了适应这种变化，很快出现了并行开发和火车模型发布模式。如果采用火车模型发布模式，指派项目经理来控制产品发布，就不需要产品经理兼任项目管理工作了\n\n对互联网公司而言，把这两种职责分开至关重要。必须持续不断地推动项目，否则产品发布就会延期\n对传统的零售软件而言，也有必要把这两种职责分开，这与产品管理的性质有关：\n\n产品管理的职责是探索（定义）有价值的、可用的、可行的产品\n项目管理则关注如何执行计划以按期交付产品\n\n\n怎样成为优秀的项目经理？强有力的项目管理能力是产品经理的优势，至少你可以使产品更快进入市场，甚至很可能会决定产品能否面市\n\n工作紧迫感\n善于捕捉问题\n思路清晰\n用数据说话\n果断\n判断力\n态度\n\n\n产品管理与产品设计-理解用户体验设计好产品必须提供舒适的用户体验，舒适的用户体验是产品管理和用户体验设计共同作用的结果\n与用户体验设计密切相关的分工：\n\n用户研究：专门研究、分析用户，评估产品或产品原型是否符合特定用户的使用习惯。其具体工作包括拟定恰当的测试项目，监督测试，评估测试结果，提出改进方案\n交互设计：在理解目标用户的基础上设计有价值的、可用的目标功能、用户导航和产品使用流程。交互设计师通常用线框绘制产品需求，然后交给视觉设计师\n视觉设计：根据线框设计可见的用户界面（页面），包括严格的布局、颜色和字体设置等。视觉设计能够传达并唤起产品蕴含的情感（其重要性常常被低估）\n原型制作：迅速制作融合了产品经理和设计师创意的产品原型，让用户试用，并根据反馈意见反复修正原型\n\n以上四种角色与产品经理密切合作，将功能与设计相结合，满足用户需求。目标是确保产品同时具有可用性（用户明白如何使用产品）和价值（用户对产品的渴求程度），还要确认软件设计是切实可行的，因此必须让软件架构师评估设计和产品原型\n交互设计不能外包：（如果团队中有一位称职的交互设计师，视觉设计可以外包）\n\n深入理解用户需求非常费时间，需要多个项目的经验积累。设计公司没时间深入了解客户需求，就算他们做到了，这些经验也很难保存下来，用到下一个版本里\n交互设计师必须现场深度参与项目开发，从立项直到产品发布。开发和测试过程中会出现各种细节问题，必须有一名交互设计师迅速作出决定\n产品的用户体验是公司的核心竞争力，必须在内部完成\n\n产品管理与软件开发-定义正确的产品与正确地开发产品产品经理负责定义产品方案，开发团队最了解哪些产品构思是可行的，他们负责产品的开发与实现\n产品经理负责定义正确的产品，开发团队负责正确地开发产品，双方相互依赖\n开发人员帮助产品经理完善产品定义的方式：\n\n让开发人员直接面对用户或顾客，体会用户的困惑和疑虑，了解问题的严重性，这样好点子常常会随之而来（可以邀请一名开发人员参加产品原型测试）\n向开发人员了解最新的技术发展动向，讨论哪些新技术可以用到产品里。开展头脑风暴，看看目前已实现的技术或即将实现的技术能不能解决手头的问题\n让开发人员在探索（定义）产品的初期阶段参与评估产品设计，协助策划方案。\n\n产品经理也应该配合开发人员的工作：\n\n产品经理只定义满足基本要求的产品，而不是最终产品。只有这样，产品管理与软件开发之间才能形成良好的互动\n一旦产品进入开发阶段，要尽可能避免修改产品的需求和设计\n产品开发阶段难免会产生诸多问题，比如用例丢失、用例设计考虑不周全等。产品经理应该迅速采取行动，在维持产品基本功能、尽量避免修改的原则上，拿出解决方案\n\n外包不是为了节约成本，而是为了实现合理的人员配置。选择业务外包的关键是要挑选有能力的员工，提高生产效率产生的价值可以轻易超过雇用本地员工节约的成本\n\n与开发团队合作应该遵循以下原则：在产品管理上为开发团队预留20%的自主时间，让他们自由支配。开发团队可以利用这些时间重写代码、完善架构、重构代码库中有缺陷的部分，或者更换数据库管理系统，提高系统性能，避免“需要停下来重写代码”的情形发生\n\n招聘产品经理-寻找出色的产品经理技术可以学习，素质却难以培养，有些素质是成功的产品经理必不可少的：\n\n对产品的热情（谈谈自己最喜欢的产品及喜欢的原因、聊聊不同领域的产品和讨厌的产品、如果有机会打算怎样完善自己最喜欢的产品）\n用户立场：理想的产品经理不一定来自产品的目标市场（这种情况有利也有弊），但是他必须融入目标市场。我们倾向于从自己的角度去理解用户和市场，事实上，目标用户的经验、喜好、价值观、知觉能力、忍受程度、技术理解很可能与我们的大相径庭\n智力：产品管理需要洞察力和判断力，因此必须具备敏锐的头脑\n职业操守\n正直\n信心、自信\n态度\n技能\n运用技术的能力：出色的产品经理并不需要自己发明或实现新技术，但必须有能力理解技术，发掘技术的应用潜力\n注意力：产品经理要优先解决重要问题\n时间管理\n沟通技能：口头表达、书面表达、演讲\n商业技能（学一点MBA）\n\n\n行业经验重要吗？最宝贵的经验不是行业知识或技术（这些都可能过时），而是打造优秀产品的流程、领导产品团队的能力、应对产品扩张的经验、个人对自己的认知以及自我激励的能力。高科技产品行业虽然要求快速学习新技术，但更重要的是预见如何应用技术合理地解决问题\n\n管理产品经理-建设公司从建设团队开始产品总监的关键职责有两方面：\n\n组建优秀的产品经理团队\n规划公司的全局产品战略，对产品组合负责\n\n\n怎样评估产品经理的工作？可以通过用户净推荐值NPS，它反映用户对产品的态度\n\n这个指标反映了产品的用户体验水平。当然，理论上即便拥有100%的满意用户，公司也可能因为在每个用户身上都亏损而破产。但是就单个指标而言，我认为它有利于让公司关注用户满意度。而且口碑营销是最有效、成本最低的营销方式\n这个标准还能用来区分优质收益和劣质收益。例如：赞助商或广告合伙人希望利用你的网站向你的用户群宣传他们的产品，这件事可好可坏，取决于如何达成。如果做的不好，短期收益可能很可观，但是影响了用户体验（NPS会体现出来），从长远看，业务增长会减缓。反过来，如果做得好（与广告合伙人密切合作），就会提升用户体验，会让业务增长更快。这就是为什么特例产品是危险的。客户为了低价购买产品就必须承诺接受限制条件。特例产品代表了劣质收益，它会降低用户的满意度\n\n产品管理属于哪个部门？\n\n它不应该属于市场部门或开发部门，应该把产品管理部门提升到与开发部门和市场部门相等的级别。理想的情况下，产品管理部门应该包含设计团队，因为产品管理和用户体验设计必须紧密合作\n\n\n巴顿将军的忠告-目标管理永远不要告诉别人怎么做。告诉他们做什么，他们自然会发挥天赋，给你惊喜。——乔治·史密斯·巴顿\n\n产品经理收集需求时，常听到客户建议“如何做”产品，而不是产品应该“做什么”，毕竟思考问题的解决方法是人类的本性\n产品经理习惯于告诉用户体验设计师如何设计产品，却忘了告诉他们产品要“做什么”\n\n产品副经理-办公室里最聪明的人从本质上讲，产品就是创意，产品经理的职责是想出好点子并加以实现，但是更多的灵感是受别人启发得到的\n\n公司的目标是打造卓越的产品，所有可以借用的力量都是可取的\n\n管理上司-十条经验\n为项目波动做好准备：不要企图消灭项目波动，但是可以尽量降低其负面影响\n注意沟通的方式与频率\n会前沟通\n多提建议，少谈问题\n向上司借力\n充分准备\n缩短邮件篇幅\n多用数据和事实说话\n内部宣传\n做让领导省心的员工\n\n流程评估产品机会-确定待解决的问题评估产品机会是产品经理的重要职责。评估产品机会的目的在于：淘汰馊主意，避免浪费时间和金钱；挑选合适的产品机会，团结团队，理解产品，整合资源（市场需求文档）\n\n产品要解决什么问题？（产品价值）\n为谁解决这个问题？（目标市场）\n成功的机会有多大？（市场规模）\n怎样判断产品成功与否？（度量指标或收益指标）\n有哪些同类产品？（竞争格局）\n为什么我们最适合做这个产品？（竞争优势）\n时机合适吗？（市场时机）\n如何把产品推向市场？（营销组合策略）\n成功的必要条件是什么？（解决方案要满足的条件，指的是在调研过程中发现的特殊需求）\n根据以上问题，给出评估结论（继续或放弃）\n\n机会评估只讨论待解决的问题，不应涉及具体解决方案\n\n开发新产品还是维护旧产品？\n开发新产品能为老用户提供更多选择，还能吸纳新用户；改善原有产品能提高老用户的满意度，也能吸纳新用户。两者各有千秋，关键在于比较两者的机会\n钱花在哪儿？要认识一位财务部门的同事\n\n帮助你了解产品：产品的收益模式？产品的成本？产品为公司带来了多少收益？请他们帮你评估产品，看看公司的投入是否划算，他们对产品的预测如何\n帮助你了解用户：财务部门掌握着交易记录、支付信息、客户数据和经营报表\n确认商业上的可行性\n\n\n产品探索-定义正确的产品，需求和设计软件项目可以划分为两个阶段：\n\n弄清楚要开发什么产品（定义正确的产品，强调探索，探索出兼具功能性与设计性的产品）\n开发该产品（正确地开发产品，强调执行）\n\n产品经理必须在执行阶段转换工作重心，否则，产品经理自己很可能成为产品上市的最大障碍\n\n解决方法是采用流水线方式并行开发产品，一旦前一个版本进入开发阶段，就把创造热情投入下一个版本\n\n\n探索产品的进度可控吗？\n软件产品行业存在一种根深蒂固的偏见，认为分析需求和设计产品的工作是可预测的、可控制的。这通常是产品团队最难逾越的心理障碍。定义产品本质上是创造性的工作，更像一门艺术而不是科学\n\n产品经理应该探索是否有用户需要产品，也就是说，要寻找市场，让用户验证你的构思\n产品经理要探索能够解决问题的产品方案，它必须是有价值的、可用的、可行的，也就是说，要设计解决方案，请用户和开发团队来验证\n\n\n产品原则-确定什么最重要产品原则是对团队信仰和价值观的总结，用来指导产品团队作出正确的决策和取舍。它体现了产品团队的目标和愿景，是产品战略的重要组成部分。从形式上看，它是一系列明确的、体现团队特色的产品价值准则\n仅仅罗列出产品原则还不够，还要按原则的重要性排序\n制定产品原则时容易出现两类错误：\n\n原则过于空泛，失去了指导作用\n把设计原则误当成产品原则（比如为用户提供清晰的导航路径，方便用户完成下一步操作，属于常见的设计原则，不是产品原则）\n\n\n解决意见冲突\n\n究竟要解决什么问题？\n要为哪类人物角色解决这个问题？\n产品要达到什么目标？\n每项目标的优先级是什么？\n\n\n产品评审团-制定更及时、更可靠的产品决策产品评审团让所有决策者坐到一起，为把产品推向市场共同制定决策，可以有效地加快研发产品的速度\n产品评审团的工作目标：成立产品评审团的目的是决定产品战略方向，从宏观上监督公司产品的研发流程，合理地配置资源。产品评审团不制订公司的商业战略，而是在给定商业战略的条件下，提出与之相匹配的产品战略。产品评审团的决策直接影响企业的运营\n产品评审团的成员组成：由公司各个部门的管理者组成\n产品评审团的职责：产品评审团并不是设计和开发产品的团队，它的职责是监督产品研发流程，制定关键决策。它根据研发产品的四个里程碑来评审产品，制定决策\n\n评审产品战略和产品路线图，启动评估产品机会的工作，即选择值得投入精力的产品，请产品经理开始评估产品机会\n根据评估产品机会的结果，决定是否开始定义产品的解决方案\n评审产品原型、用户测试结果、成本估算明细，决定是否开始开发产品\n评审最终产品、产品品质、发布计划、社会效应，决定是否发布产品\n\n\n何时估算项目成本？\n分两个阶段进行成本估算：\n\n在评估产品机会时做粗略估算\n根据最终的产品说明文档做详细估算\n\n\n特约用户-产品开发伙伴为了既深入洞察目标用户的需求，又赢得用户对产品的推荐，可以征集特约用户（也叫用户顾问委员会、用户评审团）协助完成产品研发\n成为特约用户的好处：\n\n参与构思产品创意，解决他们手头的问题，他们最清楚产品要解决的问题，因为这些麻烦正在困扰他们\n提前试用产品，越早使用产品意味着越早解决麻烦\n通常，提前试用产品还可以显著降低用户的各种成本\n\n产品经理的收获：\n\n聚拢一批积极的用户，他们可以为定义产品和开发产品提供建议和协助\n提供调研便利，便于产品经理去特约用户的工作场所调研。如果是平台产品的话，便于产品经理去开发人员的工作地点调研\n可以定期组织特约用户进行小组讨论\n特约用户第一时间试用、测试产品，迅速反馈意见\n如果特约用户满意产品的表现，会乐意公开推荐产品\n\n如果在寻找特约用户时遇到困难，很可能是因为产品要解决的问题不像产品经理想象的那么重要，将来也很难销售出去。这可以初步验证产品创意是否有价值。出现这种情况，产品经理应该重新考虑产品计划\n产品经理需要确保特约用户是产品的潜在目标用户。我们很容易把产品尝鲜者误当成特约用户。产品尝鲜者常常能容忍产品的不足和缺陷，根据他们的建议研发的产品，很容易只适合他们自己，无法满足大众的需求\n正式产品发布之前，一定要先请特约用户试用，确保每个人都满意，一旦发布，他们会坚定不移地向大众推荐产品\n使用特约用户是确保产品不偏离用户需求最简单有效的办法，同时也是向潜在用户宣传、推荐产品的最佳手段\n\n该不该与用户交流？\n\n产品经理应该尽可能地亲自拜访用户，与用户交流，参加每一次的可用性测试和特约用户讨论会\n与用户打交道的过程中，你会发现一些富有洞察力、善于思考的用户，应设法与他们建立长期联系，他们是特约用户的最佳候选人\n\n\n市场调研-理解市场调研的作用与局限性常用的市场调研工具和方法：\n\n用户调查（调查问卷）\n产品使用分析（通过分析工具）\n数据挖掘（新的数据分析工具）\n拜访用户\n人物角色：定义和设计产品、市场调研中都可以使用人物角色\n可用性测试\n同类产品分析\n\n合理地利用市场调研工具和方法可以回答以下几个关键问题：\n\n谁是目标用户？\n用户会怎样使用产品？\n用户能想明白怎样使用产品吗？障碍在哪里？\n用户为什么选用你的产品？\n用户喜欢产品的哪些特点？\n用户希望如何改进产品，增加哪些功能？\n\n市场调研的局限性：不直接回答最根本的产品问题（打造什么产品？）市场调研结果可以作为研发产品的依据和参考，但不能决定产品研发的方向\n成功的产品基于以下两点认识：\n\n深入理解用户需求\n明白什么样的解决方案在现阶段是可行的\n\n\n关于用户研讨会\n组织用户研讨会可以面对面了解目标用户对产品的看法，但在用户研讨会上不可能讨论出成功的产品，原因在于：\n\n用户不知道什么样的想法是可行的，多数用户对现有技术一无所知\n用户不知道自己想要什么，没见到实际产品，用户很难凭空想象自己需要什么\n\n\n产品人物角色-理解目标用户产品管理的核心在于制定决策：应该抓住哪些机会，解决什么问题，哪些功能最有价值，谁是主要用户\n人物角色又称为用户特征记录，是指通过与用户沟通交流，确定典型的目标用户类型，在理解各类目标用户的特征的基础上建立的人物原型。人物角色是合理地描述用户特征的人格化虚拟原型，重点关注用户的行为、态度、目标\n营销团队使用人物角色是为了找准目标消费者，激发消费需求；产品设计师则是为了分析用户的需求与在线行为\n作为产品管理的工具，人物角色的主要用途如下：\n\n人物角色可以用来筛选重要的产品功能：人物角色既有助于决定谁是目标用户，也有助于决定谁不是目标用户，两者同样重要。面面俱到的产品往往一无是处，使用人物角色可以避免犯这种错误\n产品团队常常把自己的需求当成用户需求，使用人物角色可以避免犯这类的错误\n许多产品的用户类型不止一种。如果只是简单地针对每种用户添加功能，结果会是一团乱麻。这主要是设计上的问题，使用人物角色有助于对用户类型的优先级进行排序，识别需要重点考虑用户体验的地方\n有了人物角色，可以方便地向团队描述产品的目标用户是谁，他们怎样使用产品，他们关心产品的哪些方面\n和产品原则一样，人物角色可以帮助团队成员达成共识\n\n与目标用户面对面交流是创建人物角色必不可少的环节\n重新定义产品说明文档-安息吧，纸质说明文档产品说明文档包含产品需求文档、市场需求文档、业务需求文档、功能规格书等\n产品经理的核心责任是确保向开发团队交付具有成功潜力的产品说明文档\n\n产品说明文档应该完整地描述用户体验：不只是用户需求，还包括交互设计和视觉设计\n产品说明文档必须准确地描述软件的行为（文字、图片表达有限）\n产品说明文档必须以某种直观的方式把产品信息和产品行为告诉所有人\n产品说明文档应该可以修改\n撰写产品说明文档的过程中会出现许多衍生物，比如按优先级排列的需求列表、线框图、实体模型，但应该有一个主体来代表产品，避免混淆不清，版本错乱\n\n高保真产品原型可以满足以上所有要求，高保真原型最突出的优点是可以用于测试（产品是有价值的、可用的、可行的），使用高保真原型还可以大大缩短产品上市时间\n用户体验设计与实现-先定义用户体验再动手开发在软件开发过程中，需求调研和产品设计（用户体验设计）可以同步展开、产品开发和测试可以交叉进行，但是用户体验设计应该在软件开发前完成（但是在此期间至少应该邀请一位软件开发人员检查设计工作，他可以协助你评估设计的可行性和成本，作出更明智的决策）\n第零次迭代：产品经理和用户体验设计师利用这段时间先完成产品设计工作，然后交由开发人员开始迭代开发\n基本产品-削减功能还是延长工期？不要试图定义最终产品，定义只满足基本要求（价值、可用性、可行性）的产品，简称基本产品。一旦基本产品定义完成，通过了用户测试，它就是一个不可分割的整体，去掉任何元素，都不可能获得预期的效果\n只设计基本功能的产品可以把复杂度降到最低，把开发时间减到最少，因而是非常重要的\n设计产品时一定要考虑哪些功能是最重要的，争取设计出只满足基本要求的、不可删减的产品\n产品验证-证明产品的价值、可用性、可行性产品验证是指在正式开发、部署产品前，验证产品说明文档描述的产品是否符合预期要求\n产品经理向产品团队提供最终的产品说明文档前，需要进行以下三项重要的验证：\n\n可行性测试：首先要明确在现有的技术条件下，能否成功开发出产品。邀请架构师和开发人员深度参与技术调研，寻找可行的方案\n可用性测试：交互设计师应该与产品经理密切合作，想方设法突出产品的功能特性，让不同类型的用户都能明白如何使用。可用性测试往往能发现没能成功实现的产品需求，如果测试得当的话，甚至能发现原本被忽略的产品需求。最好规划多次迭代测试，确保实现最佳的用户体验效果（一定要请真实的用户来试用可用性原型）\n价值测试：仅仅知道产品能够开发出来、方便使用，这还不够。同样要紧的是知道用户是否觉得你的产品有用，是否愿意购买，有多喜欢产品的设计。价值测试可以和可用性测试同时进行，使用的原型也是一样的（高保真原型）\n\n原型测试-把产品创意呈现给真实用户高保真原型可以让用户验证产品的创意，加深产品经理对产品的理解，避免开发团队浪费时间和精力开发没有把握的产品\n产品可用性测试（检验用户能否想明白如何使用产品）和产品价值测试（检验用户是否渴望使用产品）同样重要\n原型测试流程：\n\n物色测试者\n准备测试：确定可用性测试的内容，并拟出问题，就产品的价值向测试者提问\n你只有一次机会了解测试者未接触产品原型之前如何解决产品要解决的问题\n测试原型前还需要观察测试者能否从原型首页看出产品要解决什么问题，哪些地方最能吸引他们（对他们有价值）。首页的设计极大地影响着实际使用效果与用户期望之间的差距\n待测试者完成测试任务，了解产品用途后，通过聊天进一步收集信息，沟通的目的是了解测试者对产品原型的评价\n为每个问题的答案打分（比如0～10分），或者干脆让测试者用数字来回答问题，以此记录每个阶段产品原型的表现\n\n\n测试环境\n测试原型\n更新原型：测试原型的目的是找出原型中需要修改的部分，提高原型的可用性和价值（吸引力）\n\n改进现有产品-不是一味地添加功能很多情况下，添加新功能不仅不会为产品增色，反而会让产品性能变得更糟糕\n开发新产品的第一步是要明确目标\n先考虑可以从哪些方面改善用户体验，产品经理应该时刻关注这些指标，与交互设计师、用户研究人员、主程序员密切合作，分析改善产品的可能性\n改进产品不是简单地满足个别用户的要求，也不能对用户调查的结果照单全收。能提高指标的功能才是你关注的重点。你应该找准方向，分析关键指标，有针对性地改进产品\n平滑部署-避免更新产品导致用户反感毫无征兆地更新不必要的版本会令用户产生反感，不是所有用户都喜欢新版本的产品\n合理地、审慎地更新产品版本的行为称为“平滑部署”，有三种方式：\n\n发布两个并行的版本，邀请有兴趣、有时间的用户试用新版本\n区域性逐步部署，首先在某个区域内部署新版本，然后逐步扩大范围\n增量部署，将更新项分割成几个较小的部分逐步发布\n\n优秀的产品和服务可以赢得用户的好感，这是宝贵的信任，应该小心保护。不要轻易试探用户的耐心，让好感变成反感\n快速响应阶段-产品出炉后切莫虎头蛇尾发布产品不等于大获全胜，交付产品后依然需要保持高度警惕\n产品发布后的几天至一周内，所有项目成员应该留出时间作为快速响应阶段。这个阶段的主要工作是快速响应、处理产品发布后的用户反馈意见\n关键不在于是否会出现问题，而在于能多快解决问题\n评估产品表现应该使用明确的、可量化的指标，具体使用哪些指标取决于产品的商业目标。应该给指标分出轻重缓急，并保持关注\n合理运用敏捷方法-十大秘诀\n产品经理即是产品负责人，他代表了客户的需求，因而需要与产品开发团队保持密切的联系，协助督促开发进程，及时解决出现的问题\n使用敏捷方法绝不等于省略产品规划。产品经理仍然要明白产品的方向和目标，设定衡量产品成功与否的标准。只不过在敏捷环境里，规划周期应该适度缩短，反复迭代，采用轻量级的机会评估方法替代冗长的市场需求文档\n产品经理和设计师的工作进度应该比开发团队领先一两个迭代周期，确保你们有足够的时间攻克难题。始终让开发人员参与评估产品设计和产品原型，及时反馈关于可行性、成本、解决方案的建议\n尽量把产品设计工作拆分成独立的部分，分而治之，但也不能拆得太细，目标是设计出符合基本要求的产品\n产品经理的主要任务是定义有价值、可用的产品原型和用户故事，作为开发的基础。用产品原型和用户故事替代厚厚的产品需求文档和功能说明文档有三个优势：\n可以请用户测试\n强迫产品经理全面认真地思考问题\n向开发团队明确地描述每次迭代周期需要完成的任务\n\n\n让开发人员自主划分迭代周期。有的产品功能可以在一个迭代周期完成，有的却需要好几次迭代才能完成\n产品经理和交互设计师必须出席每天的晨会\n除非达到了产品经理的要求，否则不要轻易发布新版本。产品经理必须确保交给用户的产品能正常运行。过度频繁更新版本会让用户感到不安\n在每次迭代完成后，产品经理应该向团队展示产品现状，以及下次迭代的产品原型，让大家看到工作成果，同时加深大家对产品的理解，增强团队对这种开发方式的信心\n在团队内展开敏捷培训\n\n合理运用瀑布式开发方法-扬长避短瀑布式开发方法的基本原则：\n\n采用阶段式开发：软件开发过程被事先分成固定的几个阶段（撰写书面的需求说明文档、设计高层软件架构、设计低层细节、编写代码、测试、部署）\n采用阶段式评审：每个阶段结束后，对该阶段提交的成果进行评审，评审通过后才能进入下一阶段\n\n瀑布式开发方法让产品经理头痛的地方：\n\n产品验证严重滞后：产品经理必须等到软件开发的尾声，才能看到可以运行的软件\n变更计划代价不菲\n无法适应快速的市场变化\n\n在探索（定义）产品阶段，制作产品原型，请目标用户试用，确保产品设计是有价值的、可用的、可行的。只有这样才能提高产品成功的几率，同时节约开发团队的时间和成本\n创业型公司的产品管理-关键在于产品探索创业初期只设三个职位：产品经理、交互设计师和原型开发人员\n\n创建体现用户体验的高保真原型\n邀请真实的目标用户验证产品原型\n\n确定产品原型后，再招聘程序员进行开发。有了产品原型（代替产品说明文档），开发人员可以更直观、高效地领会产品设计和开发要求。这将大大缩短开发时间\n大公司如何创新-有困难，但值得一试有两大因素影响着大公司的创新氛围：企业文化和老板的观念\n帮助公司保持创新的方法：\n\n20%法则：20%的工作时间可以用来从事创新研究（人们误以为优秀的产品是战略规划的结果，或是来自公司高管的创意，其实，最好的创意大多来自于普通员工。20%法则鼓励普通员工自己尝试各种想法，发挥大家的主观能动性，让员工打心底愿意倾注更多的激情和汗水去创新）\n臭鼬工程：工程界的行话，原指秘密军事行动，现指在受限制的条件下，利用自己的时间，低调地进行创新研究\n主动观察：观察和倾听是最简单的创新途径。仔细观察用户使用公司产品或同类产品的一举一动，留心他们欣喜和失望的表情，假以时日，你肯定能想出办法更好地满足他们的需求\n创新不是发现新问题，而是用新方法解决已有的问题。观察人们对现有产品的不满，是创新的最佳途径\n\n\n改善用户体验：每款产品都有特定的实现模型，但用户脑子里装的是概念模型，他们对产品要解决的问题，以及如何解决问题有自己的想法。如果实现模型与用户的概念模型不一致，用户就会感到失望。找到用户失望的地方，就找到了创新的机会，至少是改善产品的机会\n收购小公司：创业型公司在选择收购自己的东家时，并不是只看重收购价格，他们往往会选择有过合作关系的公司\n\n公司的核心竞争力在于创新\n在大公司施展拳脚-十大秘诀大公司的现实情况：\n\n大公司都遵循一条潜规则：尽量规避风险。这并非偶然，随着业务规模变大，公司会不可避免地变得保守。因为大公司承担的风险更大，如果出现问题，损失也比小公司惨重。所以创新更容易发生在小公司里。在大公司工作，首先要面对的是公司现有的流程、规定和条条框框\n多数大公司都采取矩阵式的管理方式，核心部门（比如设计部门、开发部门、测试部门、运维部门、市场部门）是共享资源，产品经理要确保争取到足够的资源才能研发出产品。采用这种组织结构不是因为它的效率高，而是为了节约公司运营的成本\n\n在大公司施展拳脚的方法：\n\n了解公司制定决策的方式：知道决策权在谁手里，你的工作目标就更明确了，了解他制定决策的方式，他是更看重原型演示、市场数据，还是客户的承诺和评价，如果你需要公司的支持，只需要说服他就行了\n建立人脉网络\n臭鼬工程\n自己顶上\n有选择地据理力争\n会前沟通，形成默契：会议的主要作用是让与会者认识到大家取得了一致意见\n合理分配时间\n分享信息\n向上司借力\n传播你的产品理念\n\n大部分人游荡在黑暗里，他们只知道抱怨，却从不想办法寻找电灯开关\n产品苹果公司给我的启示-另类的硬件公司苹果公司有很多值得学习的经验：\n\n硬件为软件服务：这种关系不能颠倒，苹果公司明白，仅凭华丽的硬件技术和软件效果无法真正吸引用户，一旦消费者过了尝鲜的阶段，就会对产品失去兴趣。要抓住消费者的心，需要更深层的东西\n软件为用户体验服务：苹果公司明白用户体验是产品立足之本\n用户体验为情感服务：他们比谁都清楚是什么让消费者为产品疯狂，他们知道怎样抓住用户的情感需求\n产品为真正的需求服务\n\n提防有特殊要求的产品-避免陷入困境通常公司只要按客户或合作伙伴的要求生产特例产品，就会有大笔资金入账\n产品经理的任务是满足大众的需求，这是产品公司和定制软件公司的区别，如果一年之后市场需求发生变化，产品必须快速应对，签订合约后，产品就被合同绑住了，难以应变，特例产品会让公司不堪重负\n公司应该根据企业文化树立自己的产品原则，关键时刻根据产品原则决定是否接受客户提出的特殊要求（反面例子就是很多网站上有很多广告，严重影响用户体验）\n无论是企业软件还是网络服务，产品经理都要确保开发出来的产品是有价值的，尽可能满足更多用户的需求\n新瓶装老酒-新技术层出不穷许多公司认为，要想在市场上崭露头脚，必须发现新的热点，开拓新的市场\n成功的产品往往不是什么新鲜事物，只是新瓶装老酒，之所以成功，是因为这个“新瓶”做得更好、更方便、更便宜，改变了消费者对“老酒”的印象\n想在成熟的市场抢占一席之地，需要做到两点：\n\n对目标市场了如指掌，对现有产品的缺陷洞若观火。通过产品可用性测试掌握产品情况（包括自己的产品和竞争对手的产品）\n跟踪最新的技术趋势。新技术层出不穷，让之前无法实现的方案变得可能。虽然谁都没有把握永远走在技术的前列，把最新的技术融入产品设计中，但是只要做到一次，你的产品将所向披靡\n\n优秀的产品经理应该抓住现有技术与用户需求的契合点，市场机遇无处不在，你要做的是挖掘需求，运用新技术解决用户的老问题\n恐惧、贪婪、欲望-产品中情感的作用消费者购买产品大多源于情感需求，优秀的产品经理和销售人员明白其中的道理，懂得产品应该满足用户的情感需求\n只有从情感的角度重新观察市场上的产品和服务，你才能体会用户的真实感受。他们通过什么途径满足这些情感需求？哪种视觉设计更能抓住这些情感？哪些功能更能满足这些情感需求？哪些产品特性阻碍用户宣泄情感？\n不同类型的用户有着不同的情感需求\n每次开展原型测试，除了观察测试者能否顺利使用产品外，还应该趁机了解测试者的情感需求（是什么驱动他使用产品），怎样才能更好地满足他的情感需求\n用户体验设计（包括交互设计和视觉设计）、可用性测试在满足用户情感需求、打造成功产品的过程中起着至关重要的作用\n明确目标用户的情感需求后，问问你自己谁还能满足用户的这种需求。他们才是你真正的竞争对手。许多情况下，你的竞争对手不是创业型公司或大型门户网站，而是大众的线下生活方式\n\n创新结束了吗？你认为还会有好机会吗？\n现在的机会肯定比以前多，原因有三点：\n\n只要市场上还有蹩脚的产品，就有机会\n技术不断发展，今天难以置信的创意，明天也许就能实现\n现有的应用程序为将来的发展打下了基础，这是行业规律（比如Facebook，一开始只是网络社交类网站，现在它却成为了许多新应用的平台）\n\n机会永远不会消失殆尽\n\n情感接纳曲线-与雅虎前副总裁杰夫·邦弗特的对话不同类型的用户具有不同的情感需求，除了按照杰弗里·摩尔《跨越鸿沟》中提出的技术接纳曲线模型描述用户外，还应该增加一种情感接纳曲线作为补充\n为什么你喜欢关注用户的不满情绪？\n\n因为愤怒的用户决定着产品未来的发展方向。我建议产品经理关注日常生活里那些让大众烦恼不堪，又不得不应付的事情。如果产品经理能解决这些问题，一定能打造出成功的产品\n不要一味从技术角度看待产品，多从用户的角度考虑问题\n在我看来，产品经理大多只知道谈论产品功能和技术，忽略了用户的情感需求\n触及马斯洛的金字塔模型底端这类基本的安全需求，最容易让人们言听计从，相比之下，用顶端的精神需求激励大众，收效肯定不佳\n\n技术接纳曲线模型从技术角度描述了消费者对待产品的态度，但是它还不足以解释消费者的行为。仅仅借助这个模型，我们仍然不知道该设计什么样的产品。所以我提出用情感状态对技术接纳曲线的分类法进行补充，我根据消费者的情感特征，把他们分成：\n\n技术爱好者：即技术创新者购买产品，仅仅是因为产品采用了新的技术。这类消费者容易误导产品经理，因为他们的需求与普通大众的不同，他们对技术本身很痴迷\n非理性消费者：即尝鲜者的情感需求与大众的相同，但是更强烈。愤怒、恐惧、孤独这类消极情绪被放大后，会导致非理性的消费行为。在生活中，非理性消费者为了满足情感需求，会付出大大超出解决问题本身所需要的精力和成本\n理性消费者：即早期消费大众只会购买他们认为实用、成熟的产品。他们更务实，只会购买性价比合适的产品\n超理性消费者：即后期消费大众的情感需求更弱，哪怕产品有半点不合意，他们都不会掏钱\n观望者：即跟随者约占总人数的15%，他们同样有需求，但只会购买公认好用的产品\n\n在这几类人中，非理性消费者最值得产品经理注意\n传统的技术接纳曲线暗示技术爱好者和非理性消费者购买产品是有先后的，但实际上，他们可能同时购买产品。尽管他们都会在第一时间购买产品，但是对产品经理来说，技术爱好者是最没有参考价值的人群，他们会误导产品经理\n产品经理应该注意研究非理性消费者的行为，避免被技术爱好者误导\n非理性消费者夸大了产品的价值，产品经理如果深入了解他们的想法和感受，就能抓住这种情感需求，非理性消费者能帮助产品经理发现产品的内在价值\n为了让产品吸引理性消费者和超理性消费者，应该从分析非理性消费者的情感需求入手，非理性消费者的情感需求是推动产品跨越鸿沟的动力\n\n我时常问自己，是什么样的情感驱动着用户的行为？应该怎样利用这些情感？评估产品，重在分析它满足什么样的情感需求，这种需求有多迫切\n你用什么方式评估这些情感需求呢？\n我的方法叫“新生测试”。回想你踏入中学的第一天，你在小学获得的一切成绩和奖励都无效了，你得重新开始，一切对你来说都是新鲜的，这时你最敏感，最容易感受到细微的变化\n如果你带着新生的感觉去发掘每天折磨着大众的情感：孤独、恐惧、挫折、不满，你离发现新产品的日子就不远了\n\n可用性与美感-两者缺一不可设计既美观又实用的网站，交互设计师和视觉设计师缺一不可\n视觉设计可以满足用户的情感需求\n正如产品管理和产品营销作用不同，两者需要不同的技能，交互设计和视觉设计的作用也不相同，两者也需要不同的技能\n当然，设计既美观又实用的网站，产品经理和可用性测试人员的作用也不容忽视。如果网站慢得像蜗牛、充斥着广告、漏洞百出，同样会影响用户体验\n良好的用户体验是交互设计师和视觉设计师合作的结果。他们共同配合产品经理定义产品\n大众网络服务产品-十大要点与其他产品不同，大众网络服务直接面对目标用户，不需要销售团队和分销商搭建桥梁。你可以更直接地与用户互动、沟通，随时验证新产品创意，实时观察用户的反应，但这绝不是件容易的工作。最大的困难常常出现在产品受到用户的青睐和追捧之后，所谓“创业难，守业更难”\n十条管理大众网络服务产品的要点：\n\n可用性：大众网络服务产品必须具备良好的用户体验，产品性能是最重要的一条可用性指标，页面加载缓慢让用户无法忍受，也是糟糕的用户体验\n人物角色：按典型特征将用户分类，抽象出有代表性的用户类型（人物角色），加以分析。产品每增加一项新功能，都要请典型用户参与测试，根据反馈信息加以完善\n扩展性：最好利用部分开发资源和运维资源（建议分配20%）专门为系统扩展做好准备，不要到系统承受不了压力，即将崩溃才追悔莫及\n持续可用性：大众网络服务要求一刻也不能停歇，在系统设计上保证持续可用性与规划扩展性一样重要\n客户服务：要想降低客服压力，除了尽量减少系统故障和缺陷外别无他法，更重要的是维持良好的用户体验\n保护用户隐私\n口碑营销：用户如果喜欢产品，就会主动向家人、朋友、同事推荐，这是宣传产品的最佳方式\n全球化：易于本地化的产品设计可以大大节省开发成本和开发时间，避免为了语言、货币、文化差异大量改写程序\n平滑部署\n用户社区管理\n\n打造企业级产品的经验-十大要点企业级软件的销售对象，主要是企业，而不是个人消费者\n企业级软件的类型包括企业基础软件（安全软件、系统管理软件、通信软件）和企业应用软件（营销自动化软件、客户关系管理软件、企业资源计划软件）\n\n可用性：企业级软件的购买者一般不是软件的使用者\n产品正常工作：作为产品经理，确保产品按设计的方式运行是其最基本的责任\n特例产品：公司总是以为客户可以直接告诉他们需求，这种想法大错特错，他们一旦拿到产品，就会意识到这不是他们想要的。必须坚持原则才能拒绝特例产品的诱惑，开发满足广大用户需求的产品始终是你的首要任务\n特约用户：发布产品前，你至少应该保证特约用户是满意的\n销售渠道的需求：不同的渠道有不同的要求\n客户和用户的需求：客户（为产品买单的人）、用户（产品的使用者）\n产品安装\n产品的配置、自定义、集成\n产品升级\n销售策略\n\n\n关于专用解决方案\n合格的软件产品应该具备的特征：\n\n产品具有价值，用户愿意掏钱购买产品。当然用户付费不一定是为了获得使用许可，也可能是为了移除产品中的广告，或者购买售后服务\n产品能在多种环境下运行，不是定制软件\n只要提供必要的销售工具和销售培训，产品就可以通过销售渠道顺利销售出去\n产品公司能够为该产品提供支持，不断完善产品\n经销商、服务合作伙伴、客户明白如何安装、配置、使用产品\n\n软件如果不能被众多用户使用，它就称不上是一款产品\n专用解决方案还应具备以下特征：\n\n软件能帮助企业解决业务问题，通常是特定（垂直）的行业问题\n产品可能由一个或多个组件整合而成，这些组件可能是你的公司开发的，也可能是合作方开发的，但它们是预先集成好的\n必要时，产品应该获得合作方的产品认证\n\n专用解决方案直接解决企业的业务问题\n专用解决方案的客户可大可小，小到个人消费者，大到大型企业。产品形式也很灵活，可以是可安装的软件，也可以是在线服务\n以下两种形式不是专用解决方案：\n\n一组重新设计的、用于指导使用现有产品的说明，客户是不会为这样的“产品”掏钱的\n从网上搜到的或由技术支持团队提供的一套自定义的脚本\n\n优秀的产品应该直接针对客户的业务需求，做到有的放矢\n\n打造平台产品的经验-最具挑战性的工作产品管理中难度最大，也最能体现产品经理实力的是定义成功的平台产品。所谓平台产品，是指一类基础软件，应用开发者能在其基础上开发应用程序\n如果不能提供有效的应用程序接口，无法让多个应用程序在其上正常运行，这种软件就不是真正意义上的平台\n平台有三种不同的客户：\n\n应用软件供应商：选择你的平台创建解决方案的公司\n应用软件供应商关心平台开发商的生存能力，还关心平台产品的定价、认证情况、产品质量、技术支持能力，以及将产品国际化的难易程度等\n\n\n开发人员：应用软件供应商的雇员，由他们在平台上开发应用软件\n开发人员更关心平台产品是否支持自己惯用的编程语言、开发工具、基础架构，他们希望迅速、便利地开发出性能好、可靠性高的应用\n\n\n终端用户：应用软件的使用者，也是平台服务的真正使用者\n终端用户只在意最终结果\n\n\n\n这三方各自有着截然不同的需求。除非同时满足他们的需求，否则你无法打造成功的平台产品\n平台产品的产品经理忽略终端用户的需求，把开发人员摆在第一位，这是普遍存在的误区\n很多成功的平台产品都曾是开发人员的梦魇，却获得了广大终端用户和应用软件供应商的青睐，为终端用户提供优质的服务才是平台产品的目标\n总结最佳实践经验-十大要点\n产品管理的职责：许多产品经理将大把的时间浪费在与产品管理无关的工作上，比如营销管理和项目管理，这些都不是产品经理应该干的活\n用户体验：用户体验就是产品的生命\n机会评估：用方便快捷的机会评估方法取代过时的市场需求文档。动手设计产品前，先明确产品要解决什么问题，为谁解决问题，以及评估产品的标准\n特约用户：打造优秀的产品没有任何捷径，只能请用户反复试用产品，不断改进\n产品原则：产品管理工作的主要内容是制定决策。明确的产品原则可以帮助产品经理和产品团队树立清晰的价值标准，作出果断的决策\n人物角色：人物角色是协助产品经理制定决策的另一项工具。把目标用户按特征分类，逐一分析、理解其情感和行为，以此作为决策的依据\n探索（定义）产品：产品经理的主要职责是探索（定义）有价值的、可用的、可行的产品\n使用原型：使用高保真原型是探索（定义）产品的关键步骤。原因如下：\n迫使产品经理深入定义解决方案\n可以让真实的用户参与测试、验证产品创意\n可以直观地向团队展示产品的设计思路\n\n\n用户参与原型测试：有了产品原型，产品经理可以方便地请用户验证产品创意。原型测试是所有产品经理和产品设计师都必须掌握的工作技能。获得有效的用户反馈是产品经理最重要的工作\n根据数据改进产品：成功的产品经理懂得利用数据来改进现有产品。改进产品不是根据客户要求一味增加新功能，而是根据产品的实际应用情况，不断地提升产品的各项指标，逐步完善产品\n\n产品经理的反省清单-十大问题出色的产品经理会时刻关注产品的现状与未来，以下是产品经理无时无刻不在思考的问题：\n\n产品能吸引目标消费者的关注吗？\n产品的设计是否人性化，是否易于操作？\n产品能在竞争中取胜吗？即使是面对未来风云变化的市场，依旧有取胜的把握吗？\n我了解目标用户吗？产品（不是理想的产品，而是实际开发出来的产品）是否能得到他们的认可？\n产品是否有别于市面上的其他产品？我能在两分钟内向公司高管清楚地阐明这些差别吗？能在一分钟内向客户解释清楚吗？能在半分钟内向经验丰富的行业分析师解释清楚吗？\n产品能正常运行吗？\n产品是否完整？用户对产品的印象如何？销售业绩如何？销售任务能否顺利完成？\n产品的特色是否与目标用户的需求一致？产品特色是否鲜明？\n产品值钱吗？值多少钱？为什么值这么多钱？用户会选择更便宜的产品吗？\n我了解其他团队成员对产品的看法吗？他们觉得产品好在哪里？他们的看法是否与我的观点一致？\n\n为什么每天的思考时间如此重要，为什么产品经理的工作如此费时？原因就在于这十个问题等着他不断地去琢磨\n","categories":["产品理论"],"tags":["产品理论书单📚-产品"]},{"title":"产品经理对技术需要掌握到什么程度","url":"/2023/08/31/%E4%BA%A7%E5%93%81%E7%90%86%E8%AE%BA/%E6%8A%80%E6%9C%AF%E6%80%9D%E7%BB%B4/%E6%8A%80%E6%9C%AF%E6%80%9D%E7%BB%B4/2_%E4%BA%A7%E5%93%81%E7%BB%8F%E7%90%86%E5%AF%B9%E6%8A%80%E6%9C%AF%E9%9C%80%E8%A6%81%E6%8E%8C%E6%8F%A1%E5%88%B0%E4%BB%80%E4%B9%88%E7%A8%8B%E5%BA%A6/","content":"误区：深度学习某一项技术，甚至上手写代码\n技术能力与技术思维的差异：产品经理的技术思维不等于技术能力\n\n技术能力（系统技术架构、代码实施、Bug修改）：能运用某项技术写代码做系统，例如用iOS技术开发iOS客户端App\n产品经理的技术思维（理解基本技术原理、判断技术实现成本、建立技术排查问题思路）：在理解基本技术原理的基础上，能判断并解决产品问题\n\n不具备技术思维的产品经理：凭直觉、看表象、靠感觉\n具备技术思维的产品经理：理解原理、评估工作量、考虑兼容性\n","categories":["产品理论"],"tags":["技术思维-技术思维"]},{"title":"如何建立技术思维","url":"/2023/08/31/%E4%BA%A7%E5%93%81%E7%90%86%E8%AE%BA/%E6%8A%80%E6%9C%AF%E6%80%9D%E7%BB%B4/%E6%8A%80%E6%9C%AF%E6%80%9D%E7%BB%B4/3_%E5%A6%82%E4%BD%95%E5%BB%BA%E7%AB%8B%E6%8A%80%E6%9C%AF%E6%80%9D%E7%BB%B4/","content":"\n将复杂的技术概念转化为具象的理解输出，是建立技术思维的基础\n建立思维解析中间件，将复杂输入转化为可理解的输出\n学习基础技术知识，将常用技术概念系统化，形成产品经理的技术思维\n\n产品经理具备技术思维：将复杂概念解析为自身“系统1”可理解的输出\n","categories":["产品理论"],"tags":["技术思维-技术思维"]},{"title":"《人人都是产品经理「思维版」02》","url":"/2025/01/12/%E4%BA%A7%E5%93%81%E7%90%86%E8%AE%BA/%E4%BA%A7%E5%93%81%E7%90%86%E8%AE%BA%E4%B9%A6%E5%8D%95%F0%9F%93%9A/%E4%BA%A7%E5%93%81/%E3%80%8A%E4%BA%BA%E4%BA%BA%E9%83%BD%E6%98%AF%E4%BA%A7%E5%93%81%E7%BB%8F%E7%90%86%E3%80%8C%E6%80%9D%E7%BB%B4%E7%89%88%E3%80%8D02%E3%80%8B/","content":"初识：大话产品经理产品经理的“前世今生”从人类社会出现分工说起人之所以是人，至少有生物和社会两重意义，而社会意义要通过一群人构成的组织体现出来。有社会组织以来，个人的社会角色可以说经历了几个大的阶段：\n\n自给自足时期：个人和家庭，简单分工，自由人\n工场手工业时期：打破家庭，专业人，社会生产力提升，产品有了剩余，也有了更多的商品交换\n工厂制时期：机器，集中劳动，流水线工人，出现资本主义萌芽，个人只能依靠组织生存\n现代企业时期：科学管理，出现矩阵式组织和职业经理人\n新自给自足时期：科技发展和工具发达，个人能发挥的作用越来越大，对组织的依赖越来越小，诞生新自由人，“创业人”，而组织也开始为个人服务\n\n从项目经理到产品经理最核心的区别是：一个靠想，一个靠做\n\n产品经理是任务的提出者，更需要创造力，当然，产品经理也应具备一定的项目管理能力。项目经理是执行人，工作重点是把任务完成，并不充当任务的提出者，需要的是执行、计划和控制能力\n项目越做越小，越做越确定，是一个封闭式命题；而产品越做越大，是一个开放式命题\n\n千百年来，由于人类生产力的不足，传统经济都属于短缺经济。市场整体上处于供不应求的状态，做出产品就不愁卖。这种生产驱动的模式，更多地需要项目经理的能力来执行、计划和控制。而互联网带来的丰饶经济则完全改变了这一状态，在这种情况下，仅仅是把东西做出来已经没什么用了，如何让大家选择你的产品才是关键。创造力、洞察力和对客户的感知力渐渐成为核心要素，而这些就是产品经理需要掌握的核心技能\n与“传统”产品经理的区别任何一个行业，从诞生到成熟，似乎都会经历从重技术、抓生产制造，到重产品、抓创意设计，再到重运营、抓市场营销的过程。之后，再从一个成熟行业里诞生出更多新的、细分的行业，如此循环往复\n10年，产品经理逐渐成熟对于互联网行业来说，10年间产品经理岗位经历了“前产品经理时代”和“产品经理时代”，即将进入“泛产品经理时代”\n思维方式与性格特点从学生到职场一看到问题马上就想答案，这是典型的学生思维，因为我们所受的学校训练，绝大多数都是针对“经过简化的问题”：有确定的目标、完备的信息、学过的解法和标准的答案。而职场中，面对的问题通常目标不明、信息片面、闻所未闻。特别是对产品经理而言，用户提的问题一般都是扭曲或有欺骗性的，要怎么解决也没有标准答案\n先搞清问题，后选择方法，而不是直接设法解决\n只做一次的事情找可行解，反复做的事情求最优解\n从用户到产品经理要做好产品经理，就必须摆脱以自我为中心，转向以用户为中心，即具备同理心\n从现象到本质有时，技术层面的小动作能带来商业层面的大效果；反之，技术层面的大动作也可能没什么商业价值\n还有什么性格特质是加分项\n热爱生活，保持好奇心\n理想主义，完美主义\n善于沟通，团队精神\n抗压能力，自我激励，情绪调节\n\n产品经理的“日常”世上的学科，大概可以分成两大类：科学和人文。科学的认知对象是“自然世界”，人文的认知对象是“人类经验”，最厉害的产品经理要“站在科技与人文的交叉口”，这个交叉口就是广义的设计，其认知对象是“人造世界”，即用人类经验改造自然世界\n产品经理的典型任务\n\n\n产品经理的典型任务\n任务说明\n\n\n\n新人入门\n公司相关的知识、技能、态度（内部转岗的容易胜任）\n\n\n熟悉领域\n特定产品的行业知识等（相关行业转来的容易胜任）\n\n\n业务规划\n更偏商业敏感度，属于战略层面（运营人员也要做）\n\n\n产品规划\n未来做什么产品才能完成业务目标\n\n\n用户研究\n用户洞察，以及研究的方法（用户研究员）\n\n\n数据分析\n数据分析相关（商业智能团队）\n\n\n需求分析\n需求的采集、开发、管理等\n\n\n产品设计\n偏狭义用户体验（用户体验设计UED：交互设计、视觉设计）\n\n\n文档撰写\n主要是PRD产品需求文档、Demo原型、MRD市场需求文档等\n\n\n沟通协作\n与各种周边角色沟通协作\n\n\n项目管理\n项目管理相关（项目经理）\n\n\n产品运营\n运营、推广、营销面（产品运营人员）\n\n\n熟悉技术\n对特性产品技术面的了解（做过技术的容易胜任）\n\n\n团队管理\n人员培养、组织进步方面（做过管理者的容易胜任）\n\n\n\n产品架构：定义和规划产品，确定产品定位，规划和把握产品的节奏，对产品进行宏观把控，对经验要求较高\n产品设计：负责产品细节设计。2C的产品，需要和交互设计紧密配合，注重用户体验，但职业天花板相对较低；2B的产品，主要是业务逻辑、流程和规则的设计\n产品管理：狭义的管理，偏资源协调、跟进实施和团队建设\n产品运营：负责产品大运营，解决产品“有人用”的问题，建立产品与用户的通路，负责营销推广\n\n产品的周边团队产品经理在团队里的位置：\n\n\n产品：让产品有用【CEO】\n技术：让产品可用【CTO】\n设计：让产品好用【留在产品团队里、CDO首席数据官】\n大运营（包括销售、市场、客服、运营等）：让产品有人用【COO首席运营官】\nHR人力资源、行政、法务、财务等\n外部用户也是产品的一部分（如果你在免费玩一个游戏，那么你其实是这个游戏提供给付费玩家的一个功能）\n\n产品经理除了在公司内是各个角色的黏合剂，还是公司内外的接口，要负责把用户的声音带给团队，甚至把用户发展成广义团队的一部分\n产品：关键词与分类产品：解决某个问题的东西\n某个：任何一个产品都没法解决所有问题。特别是在产品早期，要有针对性地满足某些用户的某些需求，还要有明确定位。大包大揽是产品成功以后的方法，不是一开始的做法\n问题（用户、需求、场景）：理想与现实有差距，人们想缩小甚至消除这个差距，就会产生各种问题，用产品经理的话来说，就是有了用户需求场景\n东西：指有形的实物或无形的服务，一般是一个有目标的解决方案，包括常说的产品、功能、特性、服务、流程等\n\n某个：明确定位定位是用来限定“有所为有所不为”\n问题：用户、需求、场景用户：这个问题是谁的问题客户指付钱买产品的人，终端用户指最终使用产品的人\n需求：问题的核心是什么需求即“问题”的核心，它是分深浅的，最浅的一层是需求的表象，包含各种要求和欲望，反映用户需求的观点和行为；第二层是观点与行为背后的目标和动机；最深的一层是人性，虽然指向比较虚的价值观层面，但影响深远\n满足需求的三种方法：提高现实、降低期望、转移需求\n场景：用户在什么情况下，以及何时何地碰到这个问题为何移动时代更看重场景：\n\n用户：用户多样化，触达用户的渠道复杂化\n需求：更加丰富多样，也更加碎片化\n场景：随时随地，在各种环境下\n解决方案：移动特有的领域知识\n\n东西：解决方案它可以是一个有形的实物，也可以是一个无形的服务，实物很容易理解，服务相对复杂一些，通常有线下部分，包含更多人与人的交互\n常见的产品分类维度世界本为一体，我们为了便于理解，把原子及以下的层面叫作物理学；原子组成分子则进入了化学领域；有机大分子又和生物沾边；生物越来越复杂，就有了人类学；人类个体研究叫心理学；研究一群人就是社会学，从而衍生出经济、政治、文化等\n用户关系角度\n单点用户型：计算器，只要有一个用户使用就能产生完整的用户价值，虽然启动简单，但没法形成网络效应，用户的转移成本很低\n单边用户型：电话，需要有一群人同时使用，只有一个人有电话是没有意义的，使用这个产品的用户越多其价值越大，产品也就有了网络效应，可以像黑洞一样把用户都吸引过来\n多边用户型（双边、三边等）：平台级产品，需要几群不同的人一起使用才能产生价值，任何一个类似的产品，就算在功能上完全抄袭它，也很难把用户吸引过去\n\n单点启动最简单，单边可能有网络效应，多边平台相，壁垒最高。纵向上越往下的用户关系种类，其产品越难启动，但这样的产品一旦启动起来，惯性更大，壁垒也更高，更难被干掉，而且市场也更倾向于集中，更容易出现垄断巨头\n用户需求角度2C产品：\n\n工具：解决单点问题，用完即走（基本的产品逻辑是：用户要解决特定问题、需要做一个任务、使用工具、达成目标），大多数工具都是典型的单点产品，启动容易，可以快速解决流量问题，但弱点在于黏性太弱\n先把流量做起来，再解决“知道来的都是谁，抓住他们”，这是工具“从流量到用户”的转化套路。如果是盈利模式好的工具可以直接卖钱，但很容易被别的产品用“工具免费，作为引流手段”的市场策略干掉，所以，工具通常是一种比较初级的产品形态\n\n内容：价值观过滤器，内容产品和用户的关系也多是单点的，表现为单向和中心化的信息传递，由供应方生产内容提供给用户消费，是自上而下的（UGC用户产生内容的产品比较特别，它是非中心化、自下而上的，这类产品社区属性更强）\n其基本的产品逻辑是：主动（搜索、订阅等）或被动（推送、推荐等）接触内容、消费内容、消费后行为（评论、点赞、打赏等互动，以及分享、传播等扩散行为）\n单纯的内容很难独立形成商业闭环，传统的变现模式广告相对低效，只做了导流工作把用户转卖给别人，后面发生什么与你无关；后来发现了新的商业模式，通过内容筛选出一群三观接近的人之后，更容易做出用户画像，更容易了解他们的深层需求，除了“卖用户”还可以给用户“卖东西”\n\n社交：彼此互相吸引，用户与用户一起玩，彼此吸引并建立关系，最终因此而留下来。社交产品更像是去中心化的产物，社交产品常见模式是单边启动，有时候也是双边启动（比如婚恋交友类产品）\n社交产品最大的优势就是用户黏性相对高，最大的劣势是离钱比较远\n\n交易：做生意卖东西，分两种，一种是真正做交易，即自己卖货，这种相对容易启动，属于B2C模式。另一种是交易平台，自己不买卖东西，通过服务卖家和买家，让双方在平台上成交，交易平台是典型的双边启动\n\n平台：复杂的综合体，平台是一种同时满足多种角色的产品形态，也可以说是生态。平台的竞争优势不在于IT系统本身，而在于各种用户角色在平台上的沉淀\n\n游戏：打造平行世界（虚拟现实技术VR、增强现实技术AR）\n\n\n常见的产品发展路径：从一个小工具单点启动，快速获取用户，然后让这些用户彼此吸引，留下个人信息和用户关系转社交，粘住他们；或者从内容转社交，建立互动探讨的机制；接着设法转交易，给他们卖一些符合性格的东西；继而引入各种合作方，成为平台\n\n2B产品：\n\nB2D（Business to Developer），云存储、大数据等开发者服务，帮助开发者提升效率的基础设施\nSaaS1.0，通用管理型SaaS，是传统意义上的管理软件\nB2B，垂直行业交易平台，是信息撮合+在线成交\nSaaS2.0，垂直行业SaaS工具+交易，是SaaS1.0和B2B的综合，2015年左右开始成为新趋势\n\n用户类型角度2B、2C、2G面向政府、2D面向开发者\n\n企业VS个人：2C的产品是个人用，2B的产品是企业用\n群体VS个体\n工作VS生活：后台产品偏2B，前台产品偏2C，生产工具的用户量通常不大，多为熟练用户，生活工具的用户量大，多为小白。2B重商业价值，2C重用户体验\n2B像男人，在乎目的与结果，2C像女人，在乎过程与感受\n\n产品形态角度\nBS结构：Browser-Server（浏览器和服务器）结构\nCS结构：Client-Server（客户端和服务器）结构\n软硬结合：除了软件部分，还有硬件实体（比如各种智能家居）\n大实体：有软硬件更有服务（比如4S店）\n\n这4种形式的总体规律是：前面的轻，做起来快，迭代周期短，试错成本低，对质量的要求没那么高，有问题容易改正。当然，相应的进入壁垒也就比较低\n一个App的某个功能，到底是用Native（客户端模式）还是Web（浏览器模式）更好呢：\n\n偏交互的用Native，偏浏览的用Web\n已稳定的用Native，试错中的用Web\n访问硬件的用Native，信息展示的用Web\n核心功能用Native，周边辅助用Web\n变化少的用Native，经常变的用Web\n\n行业分类角度盈利模式角度盈利模式基本可以分为两大类：\n\n卖货：采用前向收费的方式，即直接向用户要钱\n卖人：采用后向收费的方式\n\n卖货的基础是货要好，卖人的基础是人要多，但人多的本质还是产品好\n关键资源角度不同的产品能不能取得成功，需要的关键资源不同：\n\n资本驱动，对应需要大笔资金做准入门槛的产品（比如补贴大战）\n技术驱动，意味着拥有核心技术能力，成为别人无法模仿的壁垒\n产品体验，产品本身要好，对于互联网行业来说，就是用户体验很爽\n运营服务，对应需要很多“人肉”参与的产品，强调运营效率、服务体验等\n垄断资源，取决于获取资源的能力（比如矿山）\n\n一个产品的成功往往需要多个因素，少了任何一个都可能掉链子，即“成功都是相似的，失败却各有不同”\n行业成熟度角度初创期、爆发期、平台期、衰退期，前者重研发，强调创新突破，后者重营销，强调复制扩张\n概念：提出与筛选产品概念的提出做产品第一步要有一个产品概念，所谓产品概念就是用什么方案解决，用一个词或一句话来概括，提出产品概念需要确定4个关键要素：\n\n核心用户：产品目标用户中最重要的用户是谁，表达为一个抽象的人群\n刚性需求：他们碰到最痛的“痛点”是什么\n典型场景：这些“痛点”最常出现在怎样的生活和工作情况下\n竞争优势：对比已有方案，新方案有什么突出优势\n\n核心用户核心用户的需求要优先满足，不能为了次要用户的需求影响核心用户\n如今的产品，用户与用户之间不再独立，而是彼此有链接。如果用户群体的价值观接近，那么，他们之间更能建立认同感，对产品的黏性也就更大\n核心用户定义得越精准，产品设计、推广等过程中的目标就越明确\n刚性需求刚性需求要满足下面3个条件：真实、刚需和高频\n\n真实：需求是真的存在，还是幻想出来的，我们要对需求的真伪做一个判断，用户说的需求可能是一些伪需求\n刚需：特指需求是否强烈，不满足能否忍受\n高频：需求发生的频次是高是低\n\n满足刚性需求要优先于满足弹性需求\n典型场景做产品就是做场景\n到底什么场景更典型？可以通过有没有“唤起点”来判断。在某种情景下，某时某刻，用户能想到，最好是能第一个想到你的产品，这个时刻就是产品的唤起点\n\n主动唤起：用户主动想到你\n被动唤起（节假日消息提醒等）\n\n产品概念竞争优势人无我有、人有我优（多快好省）\n聊聊竞品分析拓展竞品的范畴：\n\n相似的产品：用同样的产品功能解决同样的用户需求，和这样的竞品比的是产品功能的优劣，这种分析的结果，往往只能带来一些功能层面上的优化，不会给产品方向带来什么新思路\n能满足同样需求的不同产品（从表层到深层需求）：用不同的产品功能解决同样的用户需求，这叫“替代品”，这种分析，会给产品带来新思路、新方向\n所有消耗用户时间的产品\n\n聊聊用户分类的方法MECE原则：相互独立，完全穷尽，也就是对于一个重大的议题，分类要能够做到不重叠、不遗漏，而且能够借此有效把握问题的核心，并解决问题\n\n如果产品的用户是多边的，先根据不同角色分类\n新人、中间用户、专家\n根据人口统计信息（年龄、性别、职业、所在地、消费水平等）\n根据产品的业务场景\n\n\n多边先分边，新人与专家，人口统计学，业务场景化\n\n产品概念的筛选内部因素：能力分为人、财、物三个方面：\n\n人：团队是否与要做的事情相匹配\n财：各种资本和资金的支持是不是到位\n物：行业资源（任何产品都需要，往往靠的是长时间在行业和产业的积淀）与业务能力（是通过反复做某些事逐渐总结出的套路）\n\n这三个方面，最本质的还是人，财和物都可以由人带过来\n内部因素：意愿意愿就是使命、愿景和价值观\n\n使命就是我们要解决一个什么问题，要做一件什么事情\n愿景是说我们希望成为什么\n价值观就是我们认为什么是对的，什么是错的\n\n跟初心有关的事情，往往更容易成功，如果是为了追风口，为了公司的战略需要，失败的概率就会很大\n意愿不是某一天突然产生的，而是长时间思考和沉淀的产物，有了明确的意愿，做起事来才会有方向感和目标感\n外部因素：价值宏观：天花板对天花板的分析，就是对某个行业宏观价值的思考\n天花板的意思，就是我们想做的事情，扩大到一个行业，整体有多大？增速怎样？现在是高速增长期还是成熟期，甚至已经是衰退期？\n\n潜在用户（指目前还覆盖不到，但是通过产品的发展和扩张，将来可能会和你产生关系的那群人）*单用户可挖掘价值&#x3D;行业天花板\n\n微观：身边人要做一个产品，最好自己就是典型用户，然后身边再有一群受这个问题困扰很深的人\n从身边起步还有两个特殊优势：\n\n为身边人甚至为自己做产品，能降低“误以为自己懂用户”的错误概念\n找第一批精准用户更加容易，简化了项目启动过程\n\n我们把这些身边人叫作种子用户（找到你的种子用户）\n迭代的概念是和种子用户连在一起的，内部改改只能叫没想清楚就动手\n种子用户是受你要解决的那个问题困扰最深的一小群人，最早的一批用户，通常是某种意义上的熟人\n\n他们愿意配合\n可以提供很多有价值的信息（久病成良医）\n可以忍受缺陷\n可以成为义务推销员\n\nMVP：最小可行产品\n初次接触用户，验证概念\n\n种子用户：指核心用户中最早接触的那一小批用户，通常是我们认识的个体\n核心用户：指目标用户中最重要的那个群体\n目标用户：指所有现在能跟产品发生关系的用户群体\n潜在用户：指将来的想象空间与发展天花板\n\n外部因素：成本价值高的事情不一定非要做，还要看看成本与风险\n宏观：大环境宏观环境指不受企业掌控的大环境，PESTEL：\n\n政治因素：是指对组织经营活动具有实际与潜在影响的政治力量，以及有关的政策、规定等因素\n经济因素：是指组织外部的经济结构、产业布局、资源状况、经济发展水平及未来的经济走势等\n社会因素：是指组织所在社会中成员的历史发展、文化传统、价值观念、教育水平及风俗习惯等因素\n技术因素：不仅仅包括那些引起革命性变化的发明，也包括与企业生产有关的新技术、新工艺、新材料的出现，以及发展趋势和应用场景\n环境因素：一个组织的活动、产品或服务中，能与环境发生相互作用的要素\n法律因素：组织外部的法律、法规、司法状况和公民法律意识所组成的综合系统\n\n面对大环境，我们更多的是顺势而为\n微观：行业环境波特五力模型：认为行业中存在着决定竞争规模和程度的5种力量，这5种力量综合起来影响着产业的吸引力及现有企业的竞争战略决策\n\n\n同行业内现有竞争者的能力，其主要指标为市场成熟度和竞争激烈程度。对于不成熟的早期市场来说，竞争对手少，但用户教育成本高，要避免做“帮后来者教育用户”的事情；而竞争激烈时期，可以考虑的策略是往行业上游走\n潜在竞争者进入的能力，代表行业门槛高低\n替代品的替代能力\n供应商的讨价还价能力（店大欺客）\n购买者的讨价还价能力（客大欺店）\n\n竞品分析，一定程度上也在分析行业环境\n需求：采集与用户研究需求采集方法的分类采集需求只是手段，其目的是通过研究用户来更好地满足需求\n直接采集与间接采集直接采集与间接采集，获取的需求分别是一手需求与二手需求：\n\n需求的提出者是不是有需求的人，如果用户是为自己提需求，采集到的就是一手需求；如果这个需求是别人转述的，就是二手需求\n需求是原始的还是加工过的，比如直接跟用户聊，采集到的就是一手需求，而看第三方机构做的一些行业分析报告，采集到的就是加工过的二手需求\n\n直接采集的一手需求更准确，但二手需求（比如一份客户反馈周报）是经过梳理的，所以获取结论的效率更高\n实践层面，“全员参与采集，产品经理处理”是比较可行的模式\n说和做，定性与定量\n\n怎么说表达了观点，怎么做反映了行为，用户怎么说和怎么做经常是不一致的，不仅要听他如何说，还要看他怎么做（如果只看用户怎么做，我们不知道用户为什么这么做，背后的原因是什么，也就意味着没法从根本上解决问题）\n定性研究可以找出原因，偏向于了解，属于个体研究；而定量研究可以发现现象，偏向于证实，属于群体研究（定性的问题是以偏概全，定量会以表代本，只能用来发现表面的现象，却无法从中知道背后的原因）\n\n产品经理理解用户需求的过程遵循人类认知新事物的一般规律：从观点到行为，再从行为到观点，一样会从定性到定量，再从定量到定性，最后实现螺旋式上升，使了解和证实在不断迭代中得到进化\nZ字采集法：也有一个螺旋上升的循环，数据分析以后通常又会做用户访谈来证实数据分析的假设\n\n是否在真实场景里临场感是产品经理的一项基本能力，需求通常都是带场景的，只有亲身体会或者通过想象去体会，才知道你的设计有没有问题。而对体会把握的准确感，就是临场感\n为什么产品经理不能只听二手需求，因为那些需求是别人总结过的，已经没有了临场感，真实的用户不是“用户群体”，而是活生生的个体\n用户是否和产品发生交互有些需求的采集只是跟用户聊一聊，用户并没有接触这个产品，更没有真正用过这个产品，这种需求采集可能更多的是在发现新问题\n还有一种采集方法是在用户跟产品发生交互的状态下进行采集，往往用于优化现有方案\n对于很多产品来说，用户想象中的是否需要，和用过后的是否需要是完全不同的，而这正需要通过产品交互来发现\n\n电视机需求：用户以为自己要，但有了并不用的产品功能\n洗碗机需求：用户以为自己不需要，但用过就离不开的产品功能\n\n无论是电视机需求还是洗碗机需求，似乎都基于一个潜在原因：用户不靠谱，解决方法是采用低成本验证。比如先不上复杂的系统，设法简化实现，或者干脆用“人肉”跑流程来验证，同时，多让用户低成本体验产品，比如试用或租用\n用户的想法往往有些滞后和惯性，以为自己一定需要一个大家都在用的东西，或以为自己一定不需要一个很少有人用的东西\n所有的需求采集，本质上都是为了多接触用户，和用户做朋友\n用户和需求的再理解需求的3种深度\n观点和行为：表面能听到、看到的东西，一般是通过用户怎么说、怎么做直接表现出来的\n目标和动机：用户为什么这么说、这么做？\n人性和价值观：最底层最稳定的需求，人类社会诞生以来基本上没怎么变。如果能把需求挖掘到这个层次，就找到了产品最本质的用户价值\n\n马斯洛需求层次理论：本我属于生物人的范畴，和动物差别不大；自我属于社会人的范畴，人只有存在于社会中，才有这两类需求；超我属于意识人的范畴，是精神层面的需要\n\n一个产品所在的市场随着逐渐成熟和竞争日趋激烈，对用户需求的满足也遵循着类似的规律\n如何理解“战略需要”这类内部需求公司成立后，通过服务外部用户、满足外部用户价值来实现商业价值才是最终目的，而搭建团队只是达成目的的手段\n最重要的用户还是外部的，满足任何战略需要的内部需求时，心里都要时刻想着外部用户，防止本末倒置。战略需要但用户不需要的产品，往往没有好下场\n用户：从抽象到具象再到抽象\n用户是抽象群体：在产品概念阶段，用户是假想的某一类人，目标用户和核心用户\n用户是具象个体：采集需求时，我们要去接触真实的用户，见活人，听故事，找感觉，发现“用户故事”\n用户又是抽象群体：整理收集到的需求时，把真实用户再合并特征，定义出“人物角色”，并反向修正产品概念\n\n用户故事：从抽象到具体产品经理亲自去见用户，才能听到具体鲜活的需求场景，这就叫作“用户故事”\n用户故事是描述问题（需求），用户任务是描述解决方案（功能）\n人物角色：从具体到抽象人物角色是一个对整个产品生命周期都很重要的工具，也叫“用户画像”，是指根据一些具体的用户故事，对某类目标用户的汇总描述，它可以用来帮助团队内部达成共识\n有了这个工具，最直接的转变就是，很多平时对产品的讨论就可以从“我喜欢”、“你认为”转变为“王大毛会需要这个产品吗”\n人物角色会随着时间的变化而变化，我们也要与时俱进（比如在校生变成毕业生）\n两种典型用户：新手与专家新手与专家是需求差异最明显的两个用户群体，对产品尤其重要\n\n新手是一群不爱看说明书、急于直接上手、用得不爽就很懊恼、很轻易就放弃产品的用户，要的是简单易用、快速上手\n专家是一群会看说明书、会泡论坛、会查攻略、乐于接受挑战的产品用户，要的是稳定可靠、性能高\n\n核心用户是新手的典型产品，是那种用户量很大的大众产品，比如电梯（营销渠道是电视、户外灯箱等）\n任何领域的专家总是少数，所以核心用户是专家的典型产品，往往用户量很小，比如乐器（营销渠道是专业论坛、杂志和展会等）\n总体来看，2C的产品新手用户更多，2B的产品专家用户更多；前台产品的新手用户更多，后台系统的专家用户更多\n专家级产品有时候会考虑“向下兼容”，比如相机、App将更多功能隐藏在高级设置里等\n随着时间的变化，一个产品的核心用户也会变化，有从新手变为专家的（iPhone），有从专家变为新手的（自动挡汽车）\n移动互联时代，各种需求场景的碎片化，意味着用户，特别是C类用户的使用行为越来越“浅尝辄止”，成为专家的可能性越来越小。所以，各种产品对新手的友好越来越重要\n产品原则与初心制定产品原则的前提是一个产品要做过需求采集，且信息足够充分\n产品原则是整个产品团队必须达成共识的准则，依赖于团队的价值观或者是产品的初心（初心决定了团队发展空间的上限），相当于一个产品的宪法\n和很多事情一样，产品原则也需要与时俱进，定期优化调整\n往往对错都没有共识重要，有时候虽然是一条绕远的路，但只要齐心协力说不定就走完了，就怕走走停停、不断争吵\n产品原则源于初心，比如知乎的“每个人都可以在某一时刻成为某些人的老师”，豆瓣的价值观是“海量的读者或观众对图书、电影的评价可能胜过少数专家”（其实所谓的“叫好不叫座”，就是两种不同的过滤器发生冲突的结果，专家过滤器过滤出来的，我们称之为“叫好”，大众过滤器过滤出来的，我们称之为“叫座”）\n转化：需求分析与Y模型从问题到解决方案方法是手段，问题是目的\n问题中心是“手里拿着钉子，看什么都是锤子”，思考更多与“问题”相关的事情。方法中心是“手里拿着锤子，看什么都是钉子”，思考更多与“解决方案”相关的事情\n在一个团队中，技术人员的思维侧重方法中心，业务人员的思维侧重问题中心，而产品人员则要融合这两种思维：先侧重问题中心，尽快找到用户需求，回答Why（为什么）和What（什么），然后侧重方法中心，最终设计出产品功能来回答How（怎么样）\nY模型的基本概念需求分析就是指从问题到方法（解决方案）的转化，或者说从用户需求到产品功能的转化\n\n\n“1”是用户需求场景，经常简单说成用户需求。这是起点，也是表象，还是需求的第一种深度：观点和行为\n“2”是用户需求背后的目标和动机，是需求的第二种深度。产品经理在思考用户目标时，也要综合考虑公司和产品的目标\n“3”是产品功能，是解决方案，是实施人员能看懂的描述\n“4”是人性，或者说价值观，是需求的第三种深度，是需求的本质\n\n用心听，但不要照着做遵循1、2、3的路径相比于直接从1到3的好处：\n\n不被伪需求欺骗，不被用户自以为是的解决方案绕进去\n解决需求冲突，产品用户是多种多样的，所以彼此之间的需求经常不一致，产品经理只有站在更高的位置来统一规划，才可以避免出现需求冲突，所以要从1到2再转到3\n发现更多用户目标，在2上下功夫，把用户没有说出来的东西挖出来\n抓住恒定的人性，表象无常，人性更持久\n在成熟市场中找到机会（如果仅仅满足了用户提出的需求，他们不会感到惊喜，因为这些需求用户事先已经知道，只有满足用户人性层面的需求，让用户觉得自己没有想到的问题被你想到了，他们才会对你产生正向情感，甚至主动帮你传播产品）\n\n我们没法创造需求，只能创造出用户没见过的解决方案，从而更好地满足需求\n增长黑客：简单地讲就是利用产品技术的手段，帮助产品某方面数据增长\n实战中如何深入浅出需求分析可以分为两大步骤：\n\n1、2、4要深入，尽可能洞察透彻\n如何深挖人性，主要依赖“定性地说”这种需求采集方法\n攀梯术主要出现在一对一深度访谈的场合，用来探究用户对产品功能&#x2F;特性的态度背后的原因\n情境唤起：通过让用户假想、回忆使用产品的情境，引起他的思考\n假设某物或某状态的缺失：让用户思考，某物&#x2F;状态如果缺失了会怎样\n反面攀梯：用户无法说出做某事或想要某种感觉的原因时，可询问他不做某些事情或不想产生某种感觉的原因\n时间倒流对比：让用户反思过去，并与现状对比\n重定向-沉默或重述确认：用沉默或再次询问确认的方式来鼓励用户继续讲\n\n\n\n\n4、2、3要浅出，力争给出最可能简单的方案\n如何设计功能，浅出的意思是解决方案要尽量简单（完美不是无一分可增，而是无一分可减）\n向糗事百科学借力用户\n向知乎与知乎日报学冷启动\n向各种游戏学引人入胜\n\n\n\nY模型的更多理解用户视角与公司视角\n用户需求就是产品机会\n用户目标就是产品目标（只满足用户目标而没有产品目标，就不是一个商业行为，也不可能得到持续发展；只有产品目标而不去满足用户目标，用户就会渐渐离你而去）（2是对用户和公司都有价值的交叉点，是内外交叉点）\n用户任务就是产品功能（往往用户任务越简单，产品功能背后的实现就越复杂，而产品经理应该做的是把简单留给用户，把复杂留给自己）\n\n新手思维与专家思维在Y模型的前半段面对问题时要像新手，这也是常说的“一秒钟变傻瓜”，要快速进入一个没有任何专业知识的用户视角。而在Y模型的后半段，设计解决方案时必须成为专家才能发现需求的本质，找到最具性价比的解决方法\n\n拥有新手心态\n拥有专家能力（面对问题时表现出来的能力层次：制造问题、忽视问题、发现问题、解决问题）\n\n普通青年、文艺青年与产品经理\n\n普通青年：采用方法中心的思维方式，拥有典型的学生式解题思维，对应着Y里面的2-3，需要有人告诉他们明确的任务\n文艺青年：采用问题中心的思维方式，对应着Y里面的1-2，整天只会思考为什么，却不行动\n产品经理：习惯先问题后方法，思维方式是“用心听，但不要照着做”，对应着Y里面的1-2-3，或是更好地从1-2-4-3\n\n一些概念如何理解竞品：不仅与“3”相似的东西是竞品，与“3”不同但与“1”相似的产品也是竞品，甚至更要关注\n如何理解创新：创新不只是做一个新东西出来，而是要同时满足“1”（有用户需求，背后靠的是市场洞察）和“3”（有方法突破，背后靠的是科学发明）\n产品如何扩张：通常而言，早期先要扩张用户规模。因为“3”的变化不大，所以要围绕核心功能不断优化，等用户增长出现瓶颈以后，再去设法满足用户群体更多“1”对应的需求场景，这时候就要在“3”上做较大改动\n产品发展早期为什么会有鸿沟：产品用户数增长的鸿沟存在于种子用户与主流目标用户之间，主要是因为这两个人群的“1”对应的需求场景不同。种子用户是“饥不择食”的，主流目标用户是在乎性价比的\n何谓生产驱动和需求驱动：Y模型里，从1-3叫需求驱动，是从问题出发推导解决方案；也可以从3-1，这叫生产驱动，是用现有的技术方案去解决合适的问题（比如为公司滞销的一批货找到了新的用户），产品经理的价值体现，是找到“1”用户需求&#x2F;问题与“3”产品功能&#x2F;解决方案的匹配\n如何理解目的与手段：Y模型的前半段是目的，后半段是手段。随着技术发展和市场变化，手段会不断更新升级。所以，我们应该花更多的时间和精力在目的的研究上\n功能：细化与打包一个功能的DNA具体参考《人人都是产品经理「入行版」01》\n本章主要扩展：商业价值、开发量、层次\n\n价值由产品功能背后的用户需求&#x2F;问题决定\n成本由产品功能&#x2F;解决方案决定\n\n性价比&#x3D;价值&#x2F;成本\n理论上，性价比高的功能优先级也就高，应该先做，不过在实际操作中，还需要考虑功能的分类\n功能的价值判断对某个功能进行价值判断的流程：\n\n参照产品原则里对目标部分的定义，明确当前产品最看重的指标是什么，如果有多个指标，则需要对这些指标加权合并\n考察每个功能点实现后，就看对上述指标的帮助大不大，如果大，则这个功能的价值就大\n\n广度：潜在用户数*单用户价值广度对应着潜在用户数，即一个产品将来可能覆盖的用户群体有多大，不同产品、不同功能的定位，直接决定其可能覆盖的潜在用户数的差异，这种差异有时甚至会达到一个或多个量级（也就是之前提到的“天花板”）\n具体操作时，我们经常先从某些细分用户切入，再逐步扩大到所有潜在用户\n频度：需求频次*单次复杂度频度是指需求频次的高低，不同的需求频次差异会非常大\n通常，频次很高的需求不可能有太高的单次价值\n不同价位、不同频次需求的处理策略：先利用高频低单价的需求抓用户，因为高频场景和用户互动的机会多，而低单价的轻决策场景可以降低用户进入门槛，容易引流；再用低频高单价的需求做利润，因为单价高了，可以切分利润的蛋糕才大；之所以采取这样的先后次序，是因为必须有海量的用户做基础，低频需求的总量才足够大\n\n需求频次*单次复杂度，让我们可以从频度的视角再一次对市场容量进行验证\n强度：刚需（可替代性、紧急程度、持续时间）强度背后说的就是真实刚需，一个需求是不是真的，是不是刚性，有一个简单的判断原则，就是问自己这样一个问题：“当你没有做这个产品功能时，用户是不是在设法解决，甚至已经在用某种低效的方式来解决这个问题？”如果答案是肯定的，那么说明需求真的很强烈\n\n可替代性：用来说明一个功能是不是很容易被其他功能替代\n紧急程度\n持续时间：指一个功能做好之后，用户有效使用的周期是多久\n\n不同阶段的产品看重什么\n产品早期的验证阶段，更重视强度。通常在产品上线前后，要设法验证用户是否认可产品，用户愿意用且愿意反复用，即测验留存率高低\n验证完毕后，产品进入到大面积“拉新”（获取新用户）的阶段，这时更重视广度。这个阶段的产品需要快速增长，希望通过各种推广来占领更多的市场份额，以尽快与对手拉开差距\n当用户增长出现瓶颈时，就需要对产品的用户进行激活，这时更重视频度\n\n一个产品要大成，靠的就是用户与你产生复杂的积极性情感\nKOL：关键意见领袖\n成本评估与性价比成本评估互联网、IT行业常常把开发量的高低视为成本的高低（团队估算、计划扑克）\n评估的目的：确定功能的相对成本高低，从而确定性价比\n确定性价比性价比&#x3D;价值&#x2F;成本\n功能分类：KANO模型KANO模型是一种对用户需求进行分类和优先排序的实用工具，以分析用户需求对用户满意度的影响为基础，体现了产品性能和用户满意度之间的非线性关系\n基础功能\n当这类功能没有实现时，用户对产品是“极其不满”的。但是，这个功能做得再好，用户也认为“理所应当”。基础功能是必须要实现的功能点，但无法给用户带来满意，只会消除用户的不满\n亮点功能\n当这个功能没有做时，用户并不会不满意或觉得有问题，因为已经“习以为常”。但是一旦有了这个功能，用户就会大为惊喜，甚至“赞不绝口”\n亮点是忠诚度和口碑传播的基础，要想低成本引流，让老用户带来新用户，产品就必须找到自己的亮点\n怎么做出亮点？主要靠对用户人性的理解，因为亮点是用户想不到、说不出的，必须领先一步，深刻洞察\n期望功能这类功能对产品而言往往是“多多益善”，选择起来也比较简单：先做性价比高的\n\n产品具备了期望功能，用户当然会继续使用，但因为缺乏惊喜，用户不大可能主动传播。如果产品方只是通过简单地和用户交流来采集需求，最终实现的大多只能是期望功能\n\n用户不会提基础功能，因为他觉得你的产品肯定会有；用户也不会说亮点功能，因为他想不到\n前三类功能的与时俱进：随着时间的推移，一个功能的类型是会变化的，往往会经历从亮点功能到期望功能再到基础功能这样的一个完整变迁\n随着时间的推移，也是一个市场逐渐成熟、由俭入奢的过程。越来越多的功能成为基础功能，行业门槛也就随之提升。因此，基础功能常用来满足已有的存量市场，而亮点功能则更有可能创造一个全新的增量市场\n无差别功能做不做用户对产品的感受是没有变化的\n\n这类功能不要做，但是不做又不知道它是无差别功能，所以要采用低成本验证方法\n低成本验证：采取一些低投入的方案来验证用户需求和市场，进而决定要不要做这个功能\nIT系统作为狭义的产品，本来就是用于提高效率的。所以，先通过“人肉”跑流程来验证模式，使用量上来后再用IT系统来提升效率、实现规模化效益，这是常见的操作方式。在效益可接受时，一个流程不一定非要做成产品。千万不要因为我们是产品经理，为了刷存在感，就要把所有东西都做成IT系统。产品只是一种解决方案，人工服务也是，核心考量是投入产出比\n反向功能做得越多，用户越讨厌（比如广告）\n\n注意用户的多边性\n注意用户的多样性\n\n\n一个KANO模型，往往只针对核心用户\n反向功能很考验产品经理，我们需要在多种用户利益之间寻找平衡\n功能打包，确定MVP功能打包就是从整个功能列表里，把下个版本打算做的功能点挑选出来，理清逻辑，安排实施\n尽可能多地放弃少做就是多做\n完美不是无一分可增，而是无一分可减\nMVP的功能就是用它接触客户，尽早根据客户的回馈来改进你的产品，用户需要的东西有时候并不难实现，但很容易被忽略\n\n发布的频次并非越频繁越好\n越轻量级的产品，越容易打包出一个小的MVP\n不完美的产品先让种子用户去用\n\n优雅降级：在思考这种“一大堆功能中选哪几个先做”的问题时，也可以用逆向思维。假设产品已经完全具备这些功能，但是因为流量太大，服务器撑不住了，必须要关掉某些功能以保证基础产品的可用性，你会留下哪些功能？\nMVP的限制因素基础功能必做，要留足资源；在产品初创期，先实现个别低成本的亮点；对期望功能，先做性价比高的；无差别功能不用做，低成本验证出来即可；对反向功能，权衡各方利益后再决定\n\n考虑功能依赖关系\n考虑功能相似性\n考虑非功能需求（性能需求、培训需求、维护需求、可扩展需求、数据分析需求等）\n\nMVP的表达：产品架构图根据表达的需要，产品架构图可以画成流程图、实体关系图、用例图等\n功能分分合合的本质不同的功能，到底应该做在一起，还是分开？（比如顺风车模块，乘客和车主的功能在同一个客户端里；出租车模块，乘客和司机的功能分布于两个客户端）\n看不同用户角色背后的自然人重合度高不高，如果高，则倾向于在同一个客户端里，如果不高，则倾向于分布在不同客户端\n如果把外部用户和公司员工视为广义上的双边用户，那么通常，外部用户用的前台产品和员工用的后台系统，就是两个独立的产品，所以，MVP阶段很可能需要做一个独立的后台\n把需求和功能管起来把已经做的、正在做的和还没做的需求与功能都管理起来\n空间维度：功能列表它表达了在某个时间切片，所有功能的状态\n时间维度：需求流程其实是从需求到功能的状态流转图，需求流程实际上是在管理某个需求到功能的完整生命周期\n\n执行：立项组队与研发生产从“想清楚”到“做出来”原型验证与NPS确保有的放矢，不要努力地做错误的事，这是产品立项前要做出的最重要的判断。因为立项就意味着研发资源的正式投入。在这个节点的验证，叫原型验证。之前的验证，主要目的是验证用户需求抓得准不准，而本次验证则是为了考察用户是否认可解决方案\n有的公司把这个环节叫作POC，意为产品概念测试。在这一环节，需要用尽量低的成本，做出某种形式的产品原型或demo来让用户试用\nNPS指净推荐值，是一种计量用户向其他人推荐某产品可能性的指数。作为一种流行的用户忠诚度分析指标，它专注于用户口碑，在产品早期验证用户价值时尤为重要\nNPS&#x3D;（推荐者数-批评者数）&#x2F;总样本数*100%\n确定净推荐值时，可以直截了当地问用户一个问题：“您是否愿意将某产品推荐给您的朋友或者同事？”然后让用户根据愿意推荐的程度，在0到10分之间打分，最后根据打分情况把用户分为推荐者、被动者和批评者\n\n推荐者：打分在9-10分之间，是具有狂热忠诚度的人，他们会继续使用产品并将其引荐给其他人，可以帮助产品成长\n被动者：打分在7-8分之间，总体满意但并不狂热，会用但不会传播，可能考虑其他竞争对手的产品\n批评者：打分在0-6分之间，使用后不满意，或者对产品没有忠诚度，可能有负面口碑，会阻碍产品成长\n\nNPS的得分值在50%以上就已经比较理想，如果达到70%-80%，则说明产品拥有一批忠实拥护者\n产品委员会与关键节点从“想清楚”到“做出来”，再到“推出去”，每逢关键节点，都需要产品委员会判断接下来对此产品是应该加大投入、保持投入，还是减少投入\n4个关键节点：\n\n概念筛选\n立项组队\n上线发布：产品完成开发后，千万不要仓促上线。这时要先用真实产品找种子用户验证，如果没有通过验证就不要上线，以免浪费更多的客服、销售和运营维护资源\n营销推广：为提升用户量，上线之后马上就开始推广，这也是常见的错误。应该先花一段时间考察用户是否活跃，是否会再次使用产品。当这些指标达到预期后才可以大力推广，否则就是浪费资源\n\n在大公司里，这4个节点是申请资源的关键节点；在创业公司里，这4个节点是引入外部投资和关键岗位人才的重要节点\n立项：搞定各种资源关于人：团队、组织组织形成的3种原始动力：\n\n权力：强力组织，比如国家政府，用“铁腕子”保证“绳之以法”\n利益：商业组织，比如公司企业，用“钱袋子”支撑“诱之以利”\n共识：松散组织，比如公益社团，用“笔杆子”达成“动之以情，晓之以理”\n\n关于物：政策、流程、资金等MRD：市场需求文档，除了描述问题，解释为什么要做这个产品，还要给出解决方案。这个文档比较像产品规划和商业计划书BP，是写给资源拥有方看的，包含的内容：\n\nWhy：为什么要做这个产品（ROI投资回报率）\nWhat：产品MVP包含哪些功能及要做什么\nHow：项目计划及风险对策等\n\nPRD：产品需求文档，是在项目过程中写给开发、测试和设计师看的，仔细描述产品功能要怎么做\n组队：聊聊初创团队如何快速地知己知彼小团队的沟通协作奥卡姆剃刀原理：如无必要，勿增实体，即简单有效原理\n沟通协作方式：\n\n\n\n\n\n个体：一对一\n群体：多人\n\n\n\n线上\n实时\n电话、IM\n电话&#x2F;视频会议、各种群\n\n\n线上\n延时\nIM、邮件\n各种群、群邮件、协作工具\n\n\n线下\n实时\n面谈\n会议、看板\n\n\n线下\n延时\n留纸条\n看板\n\n\n小团队与大公司的区别借助第三方力量做产品\n\n\n\n旧模式\n新模式\n\n\n\n缺钱\n募资\n众筹\n\n\n缺人\n招人\n众包、外包、顾问\n\n\n做产品要不断进行低成本试错，其实用人也是\n众包分为两类：\n\n帮助现有的人节省时间，通常是借助工具\n借助外面的人力（知识经验领域共享经济）\n分享：我说你听，借的力只是一个想法和做法，我并没有帮你做事，而且针对性也不是很强\n座谈：可以有针对性地进行讨论，给出一些有针对性的建议\n咨询：给你指导，带着你做\n外包：直接上手，帮你搞定\n\n\n\n研发生产时，我们做什么原型验证完成、产品委员会评审通过以后，要经历立项、需求、设计、开发、测试、发布几大环节，然后再拿着做出来的产品找用户验证，最后做项目总结\n单元测试：是指对软件中的最小可测试单元进行检查和验证，一般由开发人员自己完成\n冒烟测试：是对新电路板基本功能检查的形象类比。任何新电路板焊好后，先要通电检查，如果板子不冒烟，则冒烟测试通过。软件研发领域借用这个词来描述对新功能是否可用的初步测试\n回归测试：是指修改了旧代码后，对相关功能重新测试，以确认修改没有引入新的错误或导致其他代码产生错误\n产品经理要不要懂技术\n可以和技术人员无障碍沟通，并不要求产品经理会写代码\n多向技术伙伴请教，自学一些技术知识\n根据所负责的产品，产品经理决定要懂哪些技术，懂到什么程度\n要特别关注技术方案与业务场景的关联\n\n设计师的分工：\n\n交互设计：关注的是产品与用户互动的过程，具体的输出为产品线框图、低保真原型等\n视觉设计：更加注重用户界面的美观、好用、具体的输出为视觉稿、高保真原型等\n工业设计：主要对应产品里的硬件、实物、包装等的设计\n服务设计：更加关注线上、线下的服务流程，以及如何提升用户体验等\n\n产品经理负责结构化思维，设计师负责形象化表达\n如何做一个让他们“讨厌”的人成长：规划与迭代好产品步步为营成功的产品都是相似的，因为每个环节、每一步都要做对，而失败的产品各有各的不同，因为任何一环出问题都会垮掉\n规划和迭代，表面上看说的都是“一步步来”，它们的区别在于一个是发射火箭、一个是开车出门\n在做产品，特别是互联网产品时，很难做到像发射火箭那样，在点火前收集到足够充分、完备的信息，准备好一切后再发布，也就是说无法事先规划。我们面对的局面往往是信息很难收集、市场在快速变化，所以做产品更像是开车出门，有一个明确的目的地，然后走一步看一步，这就叫作迭代\n规划的一步步来，是以自我为中心、以公司为中心的，是生产驱动的；而迭代的一步步来，是需求驱动的，是对用户反馈的不断响应，需要根据市场信息的变化来一步步调整\n规划是战略布局，是定方向，做正确的事；迭代是战术实施，是定走法，正确地做事，二者各有短长\n规划：只看最短和最长只做最短和最长的规划，短的规划是指最近1-3个月、最多6个月的时间段里，要做什么，这其实更像是一个项目计划。长的规划是要预判产业终局，比如3-5年甚至10年以后会是什么样子，要思考那个时候我们处在产业链的什么位置\n规划通常会有业务规划和产品规划两种。产品规划只需要讲清楚产品要做什么就行，而业务规划更完整，涉及不少商业上的话题，因此业务规划要大于产品规划。业务规划可以包含MRD里的所有内容，但它更加强调“未来几步怎么走”，它和MRD相比，还应该说清楚以下3点：\n\n一句话的业务定位：这句话通常也会表现为产品的slogan标语\n一个业务模型：包括这个业务内部分为哪些模块，彼此之间有什么关系，与产业链中的各个角色怎么配合，如何平衡各方的利益，自己如何赚钱等。为了更加清晰，可以画几张图来表达\n三、五个业务关键点：接下来的一段时间，主攻的几个业务难点是什么\n\n作为一个产品经理，如果规划做得好，就有可能再进一步，如参与到公司的战略讨论\n从规划向上看战略长期的规划即战略，它是一种从全局考虑、谋划实现全局目标的规划。一个战略就是设计用来发展核心竞争力、获取竞争优势的一系列综合的约定和行动。选择了一种战略，即公司在多种竞争方式中做出了选择。从这个意义上来说，战略选择表明了这家公司打算做什么，以及不打算做什么\n战略上接企业的使命、愿景和价值观，下接具体的战术实施步骤，包括产品规划\n通过提问把别人“干翻”“干翻”别人不是目的，防止自己被“干翻”才是目的。更终极的目的是把各种问题都想清楚，使做出的规划更靠谱，团队资源的分配更合理\n通过问答的方式，可以提升思考的深度\n提升规划能力的实践可以通过演练的方式来提升规划的实战技能\n迭代：再理解敏捷敏捷指以用户的需求变化为核心，采用循序渐进的方式进行软件开发。敏捷最重要的不是那些具体的方法论，而是底层的价值观、宣言和原则\n价值观、宣言与原则价值观：\n\n沟通\n简单：less is more\n反馈\n勇气：所有的创新都是从冒险开始的\n谦逊：UGC用户生产内容，典型的向用户求援的例子\n\n敏捷宣言：\n\n人与人的交互，重于过程和工具\n可用的软件，重于详细的文档\n与客户协作，重于合作谈判\n随时应对变化，重于循规蹈矩\n\n敏捷12条原则：\n\n我们最重要的目标，是通过及早和持续不断地交付有价值的软件使客户满意\n欣然面对需求变化，即使在开发后期也一样。为了客户的竞争优势，敏捷过程掌控变化\n经常地交付可工作的软件，相隔几星期或一两个月，倾向于采取较短的周期\n业务人员和开发人员必须相互合作，项目中的每一天都不例外\n激发个体的斗志，以他们为核心搭建项目。提供所需的环境和支援，辅以信任，从而达成目标\n不论团队内外，传递信息效果最好效率也最高的方式是面对面的交谈\n可工作的软件是进度的首要度量标准\n敏捷过程倡导可持续开发。责任人、开发人员和用户要能够共同维持其步调稳定延续\n坚持不懈地追求技术卓越和良好设计，敏捷能力由此增强\n以简洁为本，它是极力减少不必要工作量的艺术\n最好的架构、需求和设计出自自我组织的团队\n团队定期地反思如何能提高成效，并依此调整自身的行为表现\n\n敏捷项目管理的实践天下武功，唯快不破每个产品都要通过不断的规划和迭代一步步成长，而互联网产品的特殊之处就在于成长得格外快\n做产品，成功当然最好，但最差的不是失败，而是“半死不活”地一直拖着，因为其间的机会成本大到公司负担不起。互联网产品追求快速，首先要强调研发周期的缩短和迭代频率的加快。因为迭代周期越短，同样时间段内获得的尝试次数越多，用来纠正和改进的机会也就越多\n互联网产品的迭代速度有多快“烧钱”是为了抢时间计算一款产品的单用户成本时，要纳入整个公司的运营成本（含人员等成本），而不是只计算该产品的推广费用\n省时间的低成本验证低成本验证的理念，本质上和迭代的思路完全一致：在一个快速变化的环境中，不断地用最少的时间和成本获取市场反馈，不断地修正前进方向\n\n不轻易做系统还有一个现实意义：上线容易下线难\n用一个简单的产品雏形把业务逻辑先跑通，然后再考虑是否做客户端，是很值得推荐的产品策略\n利用公关手段也可以做低成本验证：大机构想推出新政策的时候，往往先借助合适之人如专家，或其他渠道如非官方媒体、小道消息等来透露给社会大众，试探他们的反应，得到相应的结果后，或顺水推舟地证实，或矢口否认地辟谣。不用担心最终没做会辜负期待，因为用户总是很健忘。其优势在于成本非常低，验证非常高效\n\n低成本验证的核心，就是看谁能用更少的资源、时间等成本，拿到证明一些假设是否成立的结论；而更深层次的目的，还是为了更好地服务用户，更好地达成公司的商业目标\n与用户一起成长产品除了要通过规划和迭代，面对快速成长的问题，还需要在更大的时间尺度上-比如5-10年，考虑用户的成长。经过这么长的时间跨度，产品的用户往往已经不再是最初那批人，产品将面临这样一个选择：是跟着原有用户走，还是服务一批新用户？\n产品往哪里走，并不是由产品经理决定的，而是由产品团队和用户共同决定的。产品与用户在几年时间内已经形成共生的关系，产品影响着用户，用户也影响着产品\n产品和用户是一起成长的，只有把用户当作产品的一部分，形成一个大的生态系统，才是正道\n一个产品完整的生命周期，是为时间大局观；大运营，是为空间大局观\n运营：先验证再扩张产品与运营的关系自古以来，运营就是产品不可分割的一部分\n产品经理的职责是将产品做出来，保证其“有用”；而运营的职责是将产品推出去，保证其“有人用”\n在公司里运营和产品谁说了算？谁懂用户谁说了算\n从需求、功能到卖点如果说产品经理的核心能力体现在从需求到功能这个阶段，那么运营的核心能力就体现在从功能到卖点的阶段：让一个“有用”的东西“有人用”。就算我们都能很好地找到用户需求场景，做出正确的产品功能，不同产品的市场表现仍然会千差万别。而造成差距的核心原因，就是讲故事的能力，也就是面对用户时应该说什么？要以用户为中心\n\n目标用户：人物\n场景：时间、地点\n碰到的问题：事情的起因-需求产生\n产品&#x2F;功能：事情的经过-我们如何解决了问题\n用户收益：事情的结果-使用产品以后，用户的工作和生活如何变得美好\n\n如果在产品的早期阶段就能对用户需求场景理解得很透彻，那么卖点的提炼往往可以水到渠成。由此可见，产品和运营这两个角色的确应该紧密合作\n多相爱，少相杀在实际工作中，产品人员和运营人员经常发生冲突。产品人员总觉得运营人员想到一出是一出，毫无逻辑，乱提需求；运营人员却总是觉得产品人员不给力，不理解KPI的压力，这么简单的功能也不帮忙实现\n给运营人员提需求的模板\n运营工作的分类内容运营内容的定义很广泛，文章、图片、视频、商品等都属于内容。内容运营人员要做的事情是打造“内容供应链”，从内容来源的挖掘、筛选，到内容本身的生产加工、包装呈现和传播\n内容运营的目的是通过连接用户与其匹配的内容，促进用户的下一步行动\n从广义而言，所有媒体从业者，包括互联网环境下的网络编辑和新媒体运营等的工作，都属于内容运营范畴\n活动运营活动只是手段，策划活动是为达成背后的运营目的\n办活动存在通用的框架性思路，包括确定目的、策划方案、执行方案和复盘等，如果是一次有效的活动，做完以后应该能看到关注指标的明显提升\n\n用户运营根据产品的不同，用户运营的对象也会有所不同\n对于产品来说，用户运营是最本质的命题，用户在哪里、产品当前的主要目标是获取新用户还是维护老用户、怎么高效触达用户等问题，务必要及早找出答案\n渠道运营广义用户运营的一种，其运营的对象是渠道商，在2B的产品中比较常见\n数据运营主要职能是用数据来辅助决策，运营对象是数据，隶属于BI部门\n运营工作主要分为拉新、激活、留存这3个阶段，转化是每个阶段都要做的工作。运营目标体现为特定事件的“事后用户数&#x2F;事前用户数”比率，只不过特定事件的定义不同\n不同阶段的运营目标互联网产品随时间变化的用户数曲线：\n\n\n90%的产品，这里的数字是虚指，意味着绝大多数产品从来没红过，用户量始终没起来\n9%的产品，这类产品肯定有它的过人之处，但“过把瘾就死”，只能成为现象级产品。它们的硬伤在于是好奇心驱动的，无法提供持续的用户价值，用户新鲜劲一过就难以为继。所以，这类产品更适合作为一个大产品里的功能，出现在一次有计划的推广活动中，这样能起到很好的拉新作用，然后用产品的其他功能做留存\n1%的产品，作为极少数，它们可以拉出一根真正漂亮的S型曲线，成为大家眼中成功的产品\n\n幂次法则：80-20法则，在任何一组事物中，最重要的只占其中一小部分，约20%，其余80%尽管是多数，却是次要的（凡有的，还要加给他，叫他有余。没有的，连他所有的也要夺过来，这就是商业的理性）\n成功产品的用户数曲线：理想状态的2.0产品，会在1.0版期间获得一定规模用户的基础上，再拉出一根漂亮的S型曲线\n\n\n验证期：也就是产品发布前的筹备阶段加上发布之后到推广之前的预备阶段。这个阶段的主要目标是验证产品是否与市场匹配，即PMF（产品-市场匹配）。产品在这个期间要不断修正主打功能，运营人员主要关注的指标是用户留存，典型的良性表现就是用户用了还想用，成为回头客\n爆发期：产品验证完成后开始大面积推广，即进入爆发期。此阶段，产品依然在围绕核心功能进行强化，但用户数会迅速增加，运营人员工作的主要目标是拉新\n平台期：拉新一段时间后，产品会进入平台期。一旦容易搞定的用户都搞定了，单用户的获取成本就越来越高，这时候要想继续放大产品的整体价值，就只能依托于提升单用户的价值。于是，产品功能开始扩展，升级2.0版逐渐提上日程。运营人员工作的主要目标是激活用户，也就是常说的“促活”，让用户使用产品的时间尽可能增加\n衰退期：1.0版的产品终归要退出历史舞台。进入衰退期以后，产品仅需要维护，而运营人员能做的事情就是想方设法榨取产品的剩余价值。比如，在敬畏用户、不伤产品口碑的前提下，从用户身上赚到最后一点钱；把用户平稳无知觉地导入到2.0；让团队去做更有价值的事情等\n\n上面提到的拉新、激活、留存在产品的每个时期都要做，只是不同时期各有侧重\nAARRR模型：A获取用户、A提高活跃度、R提高留存率、R获取收入、R自传播，是产品运营工作的5个重要部分，是一个获取业务增长的方法论集合，俗称“海盗模型”\n产品和运营对每个阶段的贡献是不同的：\n\n拉新阶段特别依赖推广能力，明显运营的作用更大一些\n激活阶段，二者的贡献则不相伯仲\n留存阶段，产品的因素会更多一些，因为只有产品好，用户才会持续使用（第一次不来是运营的错，第二次不来就是产品的错）\n\n验证期：艰难的冷启动真正满足用户需求的产品有两个特征：\n\n用户数自然增长：在无主动拉新的情况下，依靠产品的自身价值，而非不可持续的利益刺激，每天的新增用户数持续攀升。这意味着已有相当多的用户愿意把产品推荐给亲朋好友，也就是说产品在净推荐值这项指标上表现出色\n用户的激活与留存稳定：如果把所有运营动作停掉，用户激活率、留存率等相关指标依然可以保持稳定，则说明产品能持续提供用户价值\n激活率等于单位时间内的“已激活用户&#x2F;新用户”，表征的是新用户使用后，觉得有用的人数比例。激活行为像是完成新人转化的漏斗\n留存率等于特定事件段内的“回访用户&#x2F;已激活用户”，表征的是第一次走了之后仍念念不忘、还会再次使用产品的用户比例\n\n\n\n很多产品经理的梦想：做一个不需要运营的产品，完全通过产品逻辑实现运营。由此可见，推广行为真的不是产品上线后马上应该做的，其本质只是加速产品的成长，说白了就是为了抢时间，和市场抢、和友商抢。不幸的是，如果方向不对，抢跑越成功，距离目标只会越远\n这个阶段，需要对大量用户的涌入慎之又慎，甚至还要故意设置一些门槛，因为大量的主流用户只会给产品一次机会，如果他们看到了早期不完美的产品，就算今后产品成熟了，他们也不会再来了\n第一批种子用户如何获取，产品的验证就是从种子用户开始的，如果产品可以匹配到这几个人群，那不失为一个好的开局：\n\n学生党：年轻有好奇心，愿意尝试各种新产品，有大把的时间但没有钱，容易用小额利益撬动。而且人群密集，获客与社会化传播的成本都较低\n美女：不管在何种产品里，美女用户都是焦点，满足她们的优越感、存在感之后，其他用户就会源源不断地被美女吸引过来\n羊毛党：这群人是最容易用补贴撬动的，但风险也大，要好好思考他们到底是不是目标用户\n竞品用户：在竞争对手那里，产品目标用户的密度自然也最高，而且竞争对手已经帮我们筛选过的，往往是真正的优质用户\n\n有了种子用户，服务好他们非常重要\n爆发期：脱离种子阶段经过验证期，对产品优化效果满意后，运营就要开始发力，迅速扩散产品信息。市场留给产品的时间窗口往往不大，容不得慢慢打磨\n爆发期的主要运营工作是拉新，目的是尽快把目标用户吸引过来。在这个阶段，要迅速把产品从第一级的种子用户手里至少推到第三级的目标用户手里（种子用户、核心用户、目标用户、潜在用户）\n产品有了对目标用户的覆盖之后，就可以达成一个价值闭环\n产品生命周期里的五种用户群体参考《人人都是产品经理「入行版」01》\n平台期：深耕更多价值当拉新进行到一定程度，容易搞定的、便宜的新用户人员越来越少，这说明产品已进入平台期。在这个阶段，要想继续提升产品的价值，只能通过提升单用户贡献来实现，而其主要的手段就是“促活”。在“促活”这件事情上，产品和运营都能起到很大的作用\n\n在爆发期主要做的是市场开发，这意味着产品并不会有太大的变化，但要设法让产品满足更多的人。对应Y模型来看，就是在“3”的产品功能层面的改动相对不大，但在“1”的方向上，要解决更多用户相似场景的需求\n在平台期主要做的是产品开发，对应“1”中面对的用户群体变化不大，只是要设法满足他们更多的场景需求。所以，需要开发更多的“3”-产品功能（这里说的产品开发，除了IT系统的开发，可能还包括一些线下服务的设计或改善）\n\n就产品的4个阶段而言，主攻“市场开发”的策略与增长期和衰退期更匹配，而主攻“产品开发”的策略与平台期和验证期更匹配\n社交的需要也叫归属与爱的需要，是指个人渴望得到家人、朋友和同事的关怀、爱护和理解，是对亲情、友情、爱情、信任和温暖的需要\n大运营的其他职责产品与销售的关系做产品通常是一个发现问题并提出解决方案的过程。但对于销售人员来说，往往是先拿到已有的解决方案，再去想到底用它去解决什么问题，相当于反向去找用户需求\n对于销售来说，不同价位的产品，销售策略应该是不同的：\n\n典型的几元、几十元的产品，比如QQ会员、游戏道具，这些只适合纯网络销售\n几百几千元的产品，用户的决策成本会高一些，此时需要引入电话销售\n几千几万元的产品，就能担负得起直销的成本了，也可以寻找渠道或代理，通过合作伙伴来售卖\n几十万元以上的产品，需要用大客户顾问的方式，有些甚至需要动用一个团队服务一个客户\n\n销售人员是公司里和用户接触最密切的一群人，所以，他们也是非常好的需求收集渠道\n服务是广义的用户运营当早期产品不完美时，优质的服务可以挣回很多分\n\n售前服务与销售、技术支持的工作都有些许重叠，目的都是帮助用户了解产品、解决疑虑\n提供售后服务相当于在维护老客户。让一位老客户续约的成本，最多是开发一个新用户的1&#x2F;4到1&#x2F;3（服务人员赚昨天的钱，运营人员、销售人员赚今天的钱，市场人员、品牌推广人员赚明天的钱，产品研发人员赚后天的钱）\n\n市场的几种分类维度一种分类是将市场分为：\n\n旧有市场：也叫存量市场。要有突出的产品优势，比如更便宜、质量更好、获取更便捷等。这是种子用户和主流用户区别最小的市场，跨越鸿沟最简单，但竞争激烈，后进者营销成本巨大。在旧有市场里，产品和用户都很成熟，用户对产品非常熟悉，因此要尊重用户习惯\n细分市场：也叫小众市场。介于现有与全新之间，要突出小众特色，找到差异化定位\n全新市场：也叫增量市场。要突出产品能解决的问题，此时做品牌推广意义不大，而是要有一个较长的客户培养期。可以通过小众市场切入，寻找巧妙的“引爆点”，做全新市场最担心的问题是帮别人教育用户\n\n还有一种分类的维度，将市场分为卖方市场与买方市场。如果我们想做“卖家”，那显然要挑选一个供不应求的市场，如果我们想做平台，那就应该努力维持市场里的供需平衡（卖家、买家、商品）\n市场人员要做的，就是在各种市场环境下，努力拉近产品与用户的心理距离\n品牌到底是什么品牌是一个公司所有经营活动的最终沉淀，需要很多年的积累。所以，它也是产品发展到相对成熟的后期，才需要投入重心做的事情。公司发展到最后，沉淀下来的不会是资金、产品、运营这些东西，甚至不是人才，而是品牌\n品牌建设，其本质是一种心智的占领\n公关是企业的戾气与利器公关又叫PR。说公关是企业的戾气，是指他们会表现出杀气很重的一面，做出控制言论、操纵认知的事情；而说公关是企业的利器，是指他们又有可能成为厉害的制胜武器\n\n公关的实践方法就是断言、重复、传染，也可称之为“洗脑”。先断言，让大众产生某一种想法，再利用各种渠道不断重发，然后再持续地传播\n公关执行的四要素包括：对谁说、说什么、谁来说、怎么说\n\n产品的生命周期从验证期到衰退期验证期、爆发期、平台期、衰退期\n从定位、需求到品牌从企业发展的层面来看，依次要经历定位、需求、产品、流量、用户、收入、盈利、品牌这些阶段。对应要做的事情有：给产品定位、采集需求回来分析、做产品功能、产品上市以后要获取流量、把流量转化成有价值的用户、从用户身上获取收入、实现盈利、沉淀为品牌\n想清楚CEO、做出来CTO、推出去COO\n创意设计：问题正确，解决方案靠谱，用户还没用上产品\n研发生产：做得出来，不断优化，极少量种子用户用上了内测版本\n运营销售：卖得出去，赚得到钱，尝鲜者、早期采纳者使用产品\n市场品牌：铺得开，叫得响，主流用户使用产品\n\n案例：商业模式、创新与行业聊聊商业模式商业模式画布：\n\n\n客户细分：我们的目标用户是谁，其中最重要的又是谁\n价值主张：我们可以帮用户创造什么额外的价值。这里所说的价值，必须是现有产品服务没有的，比如更高的性能、更低的价格、更小的风险\n客户关系：用户与我们、用户与用户之间的互动模式是什么，比如专人一对一服务、用户自助使用、用户共建社区等\n渠道通路：如何与用户建立起高效的联系，拉近现实与心理的距离\n关键业务：我们需要做什么产品来解决用户问题，创造价值\n核心资源：我们做这件事和别人相比，有什么特别的优势因素\n重要合作：我们需要和哪些上下游及周边伙伴协作，以及如何协作\n收入来源：如何从用户那里获得收入，以维持业务的可持续发展\n成本结构：做这件事，在哪些环节需要花钱\n\n对比：商业模式、业务模式和盈利模式\n商业模式：完整讲述了我们创造了什么价值，为什么有存在的意义，对应以上9个因素\n业务模式：在解决方案层面做的是什么事，对应关键业务、核心资源、重要合作\n盈利模式：怎么赚钱，怎么养活自己的团队，对应成本结构、收入来源\n\n整个商业模式画布，描述的是从定位、需求、产品到运营、销售的全过程，反映的是从用户愿意用到愿意买的变化。商业模式还需要找到将用户价值转化为商业价值的业务模式，才能最终落地到盈利模式\n产品经理需要有商业意识\n2VC指to Venture Capital（风险投资），业内对一些不赚钱公司的盈利模式的戏称，对比2B和2C的赚钱方式，说他们是赚投资人的钱。投资人看重的是公司未来的发展，愿意用钱来换取公司股权\n任何一个成熟的行业，其实都很难有暴利的空间，市场的力量会调动各种角色一起把暴利消化掉\n互联网可以把传统行业的多级渠道打薄，这体现出了供应链重构和新零售创造的巨大价值\n资本就是通过钱在行业中不停的流动创造了价值\n既然成熟行业难有暴利，那么我们之所以觉得它暴利，是因为容易忽略这样一个事实：在完整的生态系统里，社会化大分工中不可或缺的每一个参与角色的人力成本、日常运营成本及承担的风险等，都是有偿的。而对资金去向进行研究，可以了解到：行业里有哪些类型的公司、组织和玩家，他们彼此之间是怎么协作的，是被什么样的利益、规则或潜规则驱动的，各自的核心价值是什么，应得的合理回报是多少等\n传统商业的简化逻辑：\n\n将商业逻辑研究透了，如果还能发现可以优化和挤压的空间，那就可以迎来真的机会，也就是创新\n创新那点事儿发明仅仅是创造出新技术、新产品，而创新应该是科学发明和市场洞识的交集\n创新需要满足两个条件：市场有需求，技术能实现。如果不能满足实际的市场需求，只是发明了一个新奇的玩具，虽然有趣最终却只能被束之高阁。同样的道理，如果不能与科学发明相结合，纯粹的市场洞识带来的最好结果也不过是模仿别人的生意\n创新必须克服两个风险：一是市场风险，即能否找到用户；二是技术风险，即能否做出来\n“活着”就是为了创新前喻文化是指用以前的文化和思维来影响今天，用过去的经验来决策现在，这在变化很慢的社会里很有效，是一种“儿子”向“老子”学习的文化。后喻文化是指向年轻人学习，向新科学、新技术和新生事物学习，是一种“老子”向“儿子”学习的文化。基于农耕文明的中国传统思想是典型的前喻文化，这对创新非常不利\n创新分两种，“更快的马”是渐进式创新，“汽车”是颠覆式创新。用户只能提出渐进式创新，而颠覆式创新则要靠产品经理来进行。前者好比个体生命的生长，后者好比群体生命的繁衍。如今的创新，虽然并不排斥自上而下，但是自下而上的可能性却越来越大\n创业公司的创新“坑”\n这个idea不能跟别人说（事情是做出来的，只有“想到”毫无意义，在做的过程中发现的“秘密”更有价值）\n我们就差程序员了（没找到真的用户需求之前要谨记：不要开始）\n别急，我们要憋个大招（市场和用户都在不停变化，会不断碰到新的问题，获得新的信息）\n我觉得用户一定喜欢\n给我盯着XXX，先抄后超（最终都很难“超”，最多只能跟在后面，这反映的是竞品分析的思路，我们不能仅仅盯着别人的产品功能来研究，而是要思考同类产品到底是在解决用户的什么需求，有没有更好的解决方案，或者还有什么新的产品形态没有出现）\n不怕，我们有资源（传统行业习惯了短缺经济-供给驱动，互联网行业是丰饶经济-需求驱动，创业者必须有强烈的用户意识，因此认识到懂用户、了解需求，才是我们取之不尽、用之不竭的“资源”）\n找到风口，找对赛道（要根据初心）\n\n大型公司的创新“坑”\n高层管理者与基层管理者的矛盾（高层很看重创新，但基层管理者身上还背着沉重的KPI）\n主流业务与非主流业务的纠结\n我们高估了“内部创业”的成功率\n赛马选手和团队自身水平的问题\n\n两个尝试：\n\n承载“新型组织形态探索”的任务\n“创新文化”的宣导\n\n传统企业的创新“坑”\n设立的新部门成为众矢之的\n成立子母公司控股的子公司（母公司出钱占大股，团队出人占小股，还是抱着打工心态）\n内部投资模式：内部投资后不知怎么导入资源\n更好的办法：不强求公司转型而只需让钱转型\n\n再谈创新者的窘境为什么过去的成功反而会成为创新的阻力？所谓的“窘境”，就是说管理良好的企业，由于它的管理良好，使得它对于一个特定的“价值网”（生态系统）来说很成功，也正是由于它的管理良好，或者说，是对某生态系统的过度优化，使得它遇到另一个新的“生态系统”时，会遭遇失败\n这里不同生态系统的此消彼长，也就是《浪潮之巅》里说的“浪潮”\n成功公司的常规管理方法是：\n\n听取消费者的意见，大力投资他们希望进一步改善的技术\n争取更高的利润率，以更大的市场，而不是更小的市场为目标\n\n在碰到新兴生态系统时，现在的成功企业无法进入的原因如下：\n\n企业的资源分布取决于固有的消费者、投资者与合作伙伴，而不只是内部员工，更不是几个高层管理者。整个产业链的既得利益，阻碍了企业对资源进行重新分配\n新兴生态系统刚出现时规模太小，无法满足成功大企业的增长需求。新兴生态系统利润率相对较低，这很容易理解，正因为利润率低，所以才会后出现，这是大企业不愿意进入的重要原因之一。所以，大企业总倾向于向利润率更高的高端市场发展，这样就给新兴生态系统留下了一个低端切入的口子。而新兴生态系统又会不断进化，直到足以挤占旧有生态系统的部分生存空间\n技术的发展，通常会快于市场需求，所以新技术在不成熟时的“指标落后”，往往是暂时的，而当一个产品的“功能”基本完备，消费者的需求重点会逐步转移-从可靠性到便捷性，再到价格。而越往后的需求，往往越是新技术擅长的。等到开始拼价格的时候，这个产品就彻底沦为一般商品。大公司在技术上不会落后，只是被旧有生态系统捆住了\n新兴生态系统，也体现在消费者是新的。成功企业若只执着于现有的客户，是找不到这个市场的\n现有的市场分析方法，无法应对变幻莫测的新兴生态系统。新市场里没办法提前规划和计划，因此试错是常态，这是大企业不擅长的。大企业面对的竞争，不只是一家新公司，而是冲入新兴生态系统的无数个小公司。从概率上讲，小公司必然有一家会成功\n\n如何应对这种局面：从大企业中独立出一个机构，让其试水新兴生态系统。这个机构可以去找新的消费者与市场，可以满足于较少收益，可以有独立的流程和价值观，并且可以获得大企业源源不断地资源支持\n在大势上，胜利者总是那些冲进各种潜在新兴生态系统的海量小公司，最终只有极少数新兴生态系统存活了下来，其中又有极少数小公司存活并成长为大公司，开始面对被新的小公司打败的危险。这就是整个商界生生不息的内在机制\n古代称开店营业的商人为坐商，与走街串巷的行商相对。坐商与行商的根本区别在于，一个是被动式的销售，一个是主动式的销售，通常来说，坐商适合卖方市场，行商适合买方市场\n不少行业，都有从“行商”到“坐商”再到市场出现细分，变为混合模式的发展轨迹\n一个行业有互联网化的改造余地-狭隘地说就是从“到店”向“上门”倾斜，本质是因为随着互联网工具的使用及各种技术的发展，信息更加通畅，生产效率得以提升，导致生产关系发生变化，供应链需要优化。市场逐步从卖方强势变为买方强势，各种服务资源整体上从供不应求走向供过于求，很多行业过渡到从“坐商”向“混合模式”发展的阶段。这种改变在哪些行业的细分市场中先发生，主要看这些行业是否能提高各种参与角色和要素的综合效率\n蜕变：从产品助理到CEO产品经理的7层修炼\n\n\n层级\n典型任务\n相关能力的关键词举例\n\n\n\n0\n职场新手上路\n学习能力、执行力、沟通能力、逻辑思维、时间管理、团队精神、会议管理、办公软件使用\n\n\n1\n需求细化与研发跟进\n文档与原型、领域知识、懂技术、懂设计、项目跟进\n\n\n2\n主动挖掘与项目管理\n用户研究、项目管理、心理学、社会学、数据分析、竞品分析、协调资源、优化流程\n\n\n3\n完整产品与大局观\n做取舍、需求管理、产品规划、懂市场、懂运营、商业感觉、行业分析\n\n\n4\n产品线与带团队\n前瞻性、产品分解、产品生命周期管理、培养新人、团队管理、定目标、追过程、拿结果\n\n\n5\n成功案例与影响力\n创新、输出方法论、知识传承、心态修炼、成就他人\n\n\n6\n商业闭环与全职能管理\n开宗立派、领导力、企业文化传承、战略制定、组织发展\n\n\n7\n自己成功到助人成功\n理想与信念、情怀、引领时代\n\n\n第1层：需求细化与研发跟进\n做客服：熟悉用户，为了真正了解，目标用户是谁，他们的需求场景是什么\n写TC：熟悉产品，写TC需要真正了解产品的各种细节及每一条逻辑规则，顺带着了解技术。TC可以理解成是从测试的视角写的产品描述，测试人员与产品经理的逻辑不同，产品经理要抓大放小，测试人员要想清楚各种边边角角\n请吃饭：熟悉团队，请吃饭是为了真正了解要合作的人都是什么性格，有什么喜好，甚至最近开心不开心\n\n第2层：主动挖掘与项目管理第2层的产品经理与第1层相比，最大的区别就是开始从被动变到主动，对需求从被动接收到主动获取，在项目中更主动，从跟进到把控，对文档也是从遵循模板到提出优化建议\n第1层的产品经理是被动的，前期的工作已经由老板想清楚了，要做的是“2”到“3”的How部分。而进入第2层后，就开始做完整的“1”到“2”再到“3”流程，甚至可以尝试挖一挖“4”\n从能力角度看，第1层的产品经理只要有理性就能做好，而第2层需要增加一些感性方面的能力。做好Y模型的前半段，需要洞察用户，有人文情怀；做好后半段，需要有逻辑能力和科学素养\n第3层：完整产品与大局观前两层的产品经理，都还在做加法。而到了第3层，产品经理会碰到“完美，不是无一分可增，而是无一分可减”。这时就要开始做取舍、砍需求，大到产品概念的筛选，小到具体功能的权衡，都要有这个意识\n第2层的产品经理，可能只负责产品里的一个模块或者功能，到了第3层，就要负责完整的产品了，这叫从局部到整体。意味着你负责的产品是一个可以提供用户价值的整体了\n\n时间大局观：指规划与迭代\n空间大局观：要借力周边团队（一方面意识到产品不仅仅只是一个IT系统，还包括了线上线下的服务体验、与上下游的利益分配机制等；另一方面明白产品的成功不是只靠产品经理，还有很多职能部门非常重要，比如市场、运营、服务等，甚至包括外部的合作伙伴）\n\n到了第3层，产品经理要对最终的用户价值和商业结果负责，而不能仅仅满足于把一些功能做出来或按时上线\n第4层：产品线与带团队与第3层的主要区别是要负责足够复杂的产品，要拥有洞察行业走势、提前布局的能力。这时，光靠自己肯定忙不过来，要从单干到“打群架”。于是，开始负责产品线，带团队，养新人。这个阶段，要把一个大产品解构为几个子产品，交给几位产品经理分而治之，而这些产品的集合，常常被叫作产品线\n之后，产品经理需要提升团队管理的能力，要带着一群前3层的产品经理定目标、追过程、拿结果。在这一层，你从对“物”，即事情的关注，上升到对“人+物”的关注\n第5层：成功案例与影响力这一层需要具备天时、地利、人和\n第5层与第4层最大的差异是从维护到创新，从能Hold住一条产品线，到开创一条产品线、一个业务，体现的是“打江山”与“守江山”的区别\n这里的成功案例，是指操盘过一个众所周知的产品，甚至是“无中生有”地做出颠覆性的创新产品，而不只是作为一名产品经理参与其中\n在这一层，对培养新人的要求也会提高，要能输出方法论，做好知识传承，建立团队的人才梯度，并形成影响力\n第6层：商业闭环与全职能管理与第5层的产品经理相比，这一层的产品经理开始从产品到业务。你负责的领域从“产品的方方面面”发展为“商业闭环”，即在某个行业里践行甚至开创某种商业模式，给行业带来惊喜，影响浪潮。负责商业闭环，意味着你要开始考虑赚钱的事情，考虑如何养活几百几千人的团队。这时候，你已经是一个独立公司或者大集团子公司的总负责人，即我们常说的CEO。除了战略，还要思考企业文化的事情。你需要极强的领导力和组织建设能力，要带领一个全职能团队冲锋陷阵\n在第6层，你的关注领域会从“人+物”，上升到“人+财+物”，这时候，你也需要开始考虑产品和公司的国际化，影响更大范围的人群\n第7层：自己成功到助人成功第7层的产品经理，需要从自己成功发展到助人成功，从商业过渡到人性，关注点从自己到社会。要加入一点情怀，力争能对社会甚至人类文明有贡献，能开创一个时代。从商业上看，这样的事情几乎也是开创了一个全新的行业，引领浪潮并站在了浪潮之巅\n做这种广义上的产品，需要强大的理想和信念做支撑，因为它是一辈子都做不完的事情。它不只是一个产品实体，而是一种理念，可以让世界更美好。这种产品会以平台的形态出现，不仅仅可以赚钱、养活团队，还可以帮助到社会上的很多人，这是比商业价值更高的社会价值\n想达到第7层，需要彻底想清楚自己做各种事情的初心，拥有关注全人类命运的人文情怀，这样，才有可能找到自己改变世界的方式\n7层里的3个阶段\n\n第3层对应着大公司的高级产品经理或者创业公司的产品负责人\n第4层对应着大公司的产品总监或者中小公司的产品负责人\n第5层对应着大公司的产品负责人或优秀的创业者\n第6层对应着大公司的总负责人、CEO\n第7层对应着伟大的企业家\n\n第1阶段叫理性决定下限，要面对的是目标、逻辑和解法，术的层面，可以通过训练达到\n第2阶段叫感性决定上限，要做到“向内看，独一无二”\n第3阶段叫人性空间无限，讲求“通过内心看到宇宙”\n10年后，再无产品经理关于一个功能的实现：硅谷的方式，因少了一个环节而减少了沟通与损耗，最终，国内模式很可能也会向这个方向进化\n\n国内：高层级产品经理定方向&#x2F;框架、低层级产品经理写文档跟进、工程师写代码实现\n硅谷：高层级产品经理定方向&#x2F;框架&#x2F;部分设计、工程师细化设计&#x2F;实现\n\n也许“产品经理”作为一个词和岗位，10年以后很少还会有人提及，但“产品经理”作为一种思维方式和做事方法，在未来10年必然产生越来越广的影响。到那时，所有人都在做“产品经理”的部分工作，人人都是产品经理的“泛产品经理”时代真的到来了，产品经理这个岗位也就不一定必须存在了\n归宿：无非广义创业从产品经理到创业者很多大家熟知的“做产品”的过程，是过去几百上千年，由于长期物质缺乏而推导出的“供给驱动”模式。近几年，“需求驱动”的模式日渐上风，而我们还不习惯。供给驱动模式，在现今只适合成熟的产品，属于执行过程，而创业是探索过程，需要的是试错和迭代\n消费者是否愿意购买产品，并不取决于创业者是否勤勉，技术是否先进，或者销售人员是否有魅力。这也是大部分创业者失败的原因。并不是他们没能力开发产品，而是开发的产品用户不需要\n体验创业的3种选择\n在创业公司当员工\n当合伙人：所谓合伙人，是你愿意也敢于把所有坏消息都告诉他的人，通常，这种人是认识多年的老朋友。要成为合伙人，一是要具备对公司长期发展不可替代的能力。如果只是短期内公司需要的关键能力，比如某种人脉或用户资源，完全可以用兼职顾问的方式来实现，说直白一点，用更少的股份或者现金做利益交换即可。二是个人职业路径要和公司做的事情吻合。这可以基于其过去多年做过的事情加以判断。而且，合伙人必须非常认可公司的愿景，并且曾经为此愿景努力过\n当老大：必须有强烈的使命感-不做这件事，这辈子就白活了；做过这件事，就算失败了也是给自己一个交代。有了这种心态，团队在碰到各种问题时，才能坚持下去\n\n互联网创业的5个启动步骤\n再次判断自己适不适合创业，主要考虑以下这些前提条件：\n同窗：多年来，你已经积累了一群兄弟，不管你干什么都愿意跟着你。这群人组成的整体能力是否完整，与要做的事情匹配度是否高？\n无根：是不是没什么牵挂，可以全身心投入到创业中？比如可以说走就走地换城市居住\n无畏：创业过程中必定会碰到无数巨大的困难，面对困难时，你是否有坚韧不拔的态度，能屡败屡战？\n激情：你对做的事情是否有使命感，是否不做就觉得这辈子白活了？\n\n\n组队和选择合伙人，主要基于以下的要素进行选择\n共同愿景：你们对做的事情要真心认可。所以，对靠谱的合伙人，既不能强拉说服，也不能用不合理的股份比例吸引\n背靠背的信任+包容：可以分享所有消息，尤其是坏消息，因为这建立在对双方的信任之上\n互补：性格和能力都要互补。而这要求创始人对要做的事情需要什么能力，应该有一个清晰的认识，与合伙人也要有明确分工\n\n\n找到精准的商业模式：好的模式通常都是一句话就能说清楚的\n确定各自的权责利与股权结构：根据商业模式和切入点，可以推导出各自要做什么事，以及需要哪些能力。然后分析初创团队里每个人的重要性，综合考虑短期与长期价值，据此推导出股权结构。通常，团队一定有暂时空缺的能力。对此，可以把部分股权做成期权池，留给将来加入团队的能人\n打磨业务和产品，在产品早期要注意以下几点：\n产品心态：尽快做出一款丑陋的产品，不要追求完美，而要追求尽快验证\n产品迭代：每周树立一个里程碑，其本质是保持快速改进的节奏\n能否外包：创始人应该自己做第一任产品经理。产品设计层面绝对不能外包，技术实现在短期内可以外包应急，但要做好找到技术合伙人之后重做的准备\n\n\n\n互联网创业的地域鄙视链一个城市能够成为创业之都，要具备多个要素：\n\n有足够多、足够好的创业公司来提供文化氛围、社会认同和流动资源\n有具备示范作用的龙头企业，可以提供高素质的“熟练工”，比如创业公司的合伙人\n有投资公司与天使投资人，可以提供资金及衍生资源\n有优质高校能提供潜力新人和技术研发能力\n当地政府能提供政策支持和优质的大环境\n\n以上要素形成了一个生态，一个互为因果的正循环，缺了任何一个都会对正反馈产生很大影响\n下一个硅谷在哪里非决定性因素：\n\n自然条件\n优质高校\n风险投资\n行业巨头\n知识产权\n政策支持\n\n决定性因素：\n\n叛逆精神\n拒绝平庸\n宽容失败\n多元文化\n\n随着时空尺度的变化，因素的利害通常会发生变化。比如，你为负责的项目争取到资源，对于部门来说是好事，但因资源有限而导致更重要的项目延期，对于公司来说就是坏事\n整体上看，在一个国家和地区是否能持续强大这个问题上，“大陆性”不如“海洋性”（这里的大陆和海洋不只是地理上的概念，更是文化上的概念）。海洋性开放、多样，与外部有更多的交流和交易，能获得更多的“新”；大陆性自给自足，倾向于封闭，而一个封闭系统，在物理学上是熵增的，会走向混乱\n从生活态度到社会推动力“人人都是产品经理”，对于个人来说是一种生活态度，对于社会来说更可能成为进步的推动力\n先说生活态度生活中，处处皆产品，处处可用心\n再说社会推动力\n只会照做：照着做，最大的问题是没有创新，一代不如一代，最后创新精神就彻底死掉了\n不用心听：多保持一点好奇心，对自己不了解的事物保持敬畏，再培养一点多样性，让自己可以听得懂更多不同的观点\n\n用心听，但不要照着做：用心听，是充分地接触广义用户，以了解问题及其背后的动机和人性。不照着做，要求拥有多个领域的专业知识，能做出一些新的东西。而这些，一定会成为社会发展的推动力\n","categories":["产品理论"],"tags":["产品理论书单📚-产品"]},{"title":"《幕后产品-打造突破式产品思维》","url":"/2025/06/12/%E4%BA%A7%E5%93%81%E7%90%86%E8%AE%BA/%E4%BA%A7%E5%93%81%E7%90%86%E8%AE%BA%E4%B9%A6%E5%8D%95%F0%9F%93%9A/%E4%BA%A7%E5%93%81/%E3%80%8A%E5%B9%95%E5%90%8E%E4%BA%A7%E5%93%81-%E6%89%93%E9%80%A0%E7%AA%81%E7%A0%B4%E5%BC%8F%E4%BA%A7%E5%93%81%E6%80%9D%E7%BB%B4%E3%80%8B/","content":"产品经理技能树：\n\n\n修身、齐家、治国、平天下\n正心、修身、齐家、治业、助天下\n\n产品经理的四个素质创业精神面试问题：当时你负责的项目有这么多问题你都知道，你有做任何的哪怕微小的努力去改变它们吗？\n终身学习（求知）产品经理知识矩阵：\n\n面试题：最近三个月或半年，你有没有遇到觉得很好玩的产品？\n善于联想产品经理的工作本质是解决问题，不停地解决问题，创造性地解决问题\n产品经理的工作需要有很多创新的地方。这种创新并不一定是发明某项新技术，抑或完全颠覆某项技术，更多的还是站在无数巨人的肩膀上更进一步，即联想。善于联想能够让产品经理更具创造性地设计产品、满足用户需求\n\n洞察能力\n归纳能力：归纳与演绎是逻辑思维的两种方法\n联想能力：我们通过洞察和归纳获得灵感，通过联想产生产品创意\n\n善于决断对于产品经理而言，联想能力是出谋划策，而善断能力则是要在复杂变化的互联网环境中做出最有利于产品目标的决策\n\n要抓住重点（对于宏观的用户体验而言，产品功能的影响大于交互设计的，而交互设计的影响又大于视觉设计的，在决定一个按钮摆放的位置时，应最优先考虑产品功能层面，最后考虑美感层面）\n不追求完美（在互联网环境中，速度常常是很重要的因素，而且不应该被忽略）\n需要有实验意识（在无法抉择要不要做一个功能时，可以用最低的产品成本，通常是一个“简陋”的产品原型实验自己的想法，然后观察用户反馈和数据来做后续的判断、A&#x2F;B测试）\n\n创业和求知是态度，决定了产品经理职业天花板的高度；而联想和善断则帮助产品经理向上发展，在产品工作中不仅是一个执行者，而且能独当一面\n如何全面深入地了解用户产品经理将对用户需求的理解与大脑中的商业创意连接起来，创造出具有用户价值和商业价值的产品，因此了解用户是重中之重\n亲力亲为地研究用户最忌讳的是，产品经理只了解自己熟悉领域的用户，而对其他用户群视而不见，如果不亲力亲为，很难体会到大众用户的需求\n用户研究的旧瓶装新酒\nUCD：以用户为中心的设计\nUX&#x2F;UE：用户体验\nIXD：交互设计\nUI：界面设计\n\n常见的用户研究方法分为定性研究和定量研究两类，主要包含以下几种：\n\n深入访谈：做访谈需要与用户交流，最重要的就是要有共情、共鸣、共话题\n焦点小组：由一名主持人和一组用户（通常不超过八人）在一个主题下进行的访谈，通常会持续两三个小时\n问卷调查\n可用性测试\n留置研究：留置研究和可用性测试的区别在于，可用性测试是在现场时间段内进行的，而留置研究则是用户在实际场景里长时间使用中得出的，用户在这一过程中记录自己的使用感受、回答调研问题等，对产品的反馈会更加完善与真实\n\n以上这些方法都是为了形成用户画像，让产品经理脑海里对目标用户有非常具象和清晰的认识：有哪些用户群？他们各自是什么样的人？在各种产品功能面前会有什么样的反应？\n理解用户、挖掘用户需求是产品设计过程中最难的事情。其中的难点就在于，怎样才能尽可能地接近用户真实的想法？在用户研究时有以下三个关键因素需要考虑：\n\n用户是否是典型的目标用户？（要研究的目标用户群分类越细、定义越清晰，就越要注意鉴别调研对象的真伪，一旦源头出现偏差，整个调研会的心血都将付诸东流）\n挖掘到的信息是否真实？\n怎么将用户研究的结论应用到产品设计中？（所有用户研究的根本目的，都是希望能将结论应用于产品设计。也只有实践，才能检验研究结论是否正确。但通常来说，越是概念性的研究，越难以直接形成产品设计方案；而如果是可用性测试、留置研究等直接反映产品设计问题的，则可以很快形成解决方案）\n\n快速划分用户群用户群细分是最常见的用户研究手段\n划分用户群直接产生的作用就是能更好地理解产品的目标用户和市场竞争情况，包括：\n\n有哪几类用户群？\n这些用户群的特点是什么？用户群数量大致是多少？\n竞争对手们覆盖了哪些用户群？\n哪个细分领域是市场空白？而哪个细分领域又是长期目标的必争之地？\n\n产品从起步到成熟的竞争策略是什么？先做哪个用户群，再做哪个用户群？\n快速划分用户群的方法：\n\n通过定性访谈，分析出划分用户群的因子（总的来说，因子可以分为两类：基本的人口属性，如年龄、性别、教育程度、职业等；和垂直领域属性，在音乐方面就是音乐喜好程度。用一个二维坐标系划分用户群，使用两个因子就足够了）\n利用因子划分用户群，每个用户群做一下用户画像\n通过问卷调查来验证，问卷的目标用户和投放渠道、问卷的大纲、问卷题目的设计（通过问卷调查的定量研究来验证之前定性研究分析的结果，从而以较低的成本鉴别判断的正确性）\n\nUGC：用户原创内容，内容贡献者和内容消费者\n洞察心理和人性理解用户的更高一层境界是什么呢？具备同理心，洞察心理和人性\n在互联网产品的世界中，最关键的就是懂用户，而懂用户中最关键的就是洞察心理\n洞察用户的心理为何如此重要？\n\n可以满足用户深层次的需求\n满足深层次的需求能够带来更好的用户黏性，因为用户会感觉产品懂他，会有情绪上的波动，用户与产品的关系就会超越一般的App，成为朋友，甚至知己，用户对产品的依赖就会变强\n还与品牌相关，好的品牌会直达用户心灵，让用户觉得其与自己的身份相符、价值观相符、世界观相符，如果产品能够尽可能地洞察用户心理、满足用户深层次的需求，那么用户对品牌就会有如信仰一样的感觉\n\n在分析爱现心理时，需要考虑以下几个方面：\n\n每个人都有爱现心理，但为此付出的努力程度不同（为了让产品尽可能多地覆盖用户群，需要让产品功能的门槛尽可能低，让尽可能多的人能感受到爱现心理被满足的快感。因此在考虑产品设计的时候，甚至需要更关注轻度爱现的用户）\n求之而不得，则会贪嗔痴（在产品设计的过程中需要额外关注这个问题，一方面需要尽可能地避免资源集中在少数地方，应让爱现心理尽可能地被分散满足；另一方面需要延长用户爱现心理的满足时间，不要在短时间内进行很强烈的刺激，而是长时间、绵绵地引导）\n人总会有疲惫的那一天（爱现是人的基本心理，而每个人都会有兴趣，兴趣本身的魅力则是最原始的内驱力。兴趣与爱现心理是相辅相成的，如果没有兴趣，爱现心理只是镜中花、水中月；爱现心理获得满足会刺激兴趣，但是也有限度）\n\n群体用户心理\n群体极化，会更加认同观点（群体因彼此价值观、观点或兴趣等相同而聚集在一起。在群体中的个人面临选择、需要决策的时候，往往会选择和群体中其他人一致的做法；在我们运营起一个群体之后，群体表现出来的支持或反对态度，都会比个人力量汇总强大得多）\n向心力越强，群体越紧密，同时与外界也更加界限分明（越是性格分明还带点极端的品牌越容易和外界划清界限，也就是说喜欢的人会很喜欢，讨厌的人会很讨厌。这样的选择无可厚非，但需要想清楚这样做是否会限制品牌的长远发展。因为品牌形象一旦形成，改变的难度将非常大。在花费很大的力气营销、影响品牌，给品牌定下了某种价值观后，就必须做好如何应对攻击的准备）\n适当允许不同群体间发生矛盾和竞争，这样群体内部会变得更加团结，适当的矛盾能让群体更加活跃，从而提高整个产品的活跃度（不能让矛盾过激，即不要让矛盾超出两个群体间的范围，不要影响社区中的其他用户，长远来看，一个充满了争斗、负能量的社区的天花板会比较低；每个群体的需求与动机才是产生矛盾背后的根本原因，设计社区运营的规则，让群体的动机和行为不超越规则，就会避免爆发严重的群体矛盾）\n留住群体中的意见领袖（永远不要让任何一个群体的意见领袖的影响力超出或接近社区本身）\n\n从一个产品的用户到一片产品的用户产品经理更多的是“做一行，爱一行”\n如何才能尽可能多地了解不同产品领域的用户？\n\n培养同理心\n设身处地地想（我们通过平常积累的对用户的感知，在具体的产品设计需求判断过程中运用对场景的预设和提问，来体察用户在这些场景下可能会有的反应）\n发展多方面的兴趣，多出门食人间烟火（要想真实地了解不同的用户，就要走出家门）\n玩RPG（角色扮演类游戏）网游，短时间内体验人生（人生的经历越丰富，对不同用户的理解程度就越高，这些经历可以帮助更好地理解人性，而人性则是无数不同用户之间最高的共通点）\n从理解某一方面用户群体的需求和心理到理解普罗大众的需求和心理，这是一个非常漫长的过程，但几乎没有捷径（其实对用户心理的洞察起到了一种润物细无声般的作用，会内化成产品经理的思维方式，即在做产品的过程中每时每刻都会产生效用）\n\n做产品正如体验人生\n需求分析方法论\n信息收集阶段（收集需求、分类梳理）：对需求的收集、分类梳理是一个尽可能获取足够多信息的过程。信息越多，对产品面临的局面掌握得就越全面，做决策时就越清晰\n评估阶段（深入、全面、真伪、优先级）：需求有真伪，也有轻重缓急之分，做什么需求能给产品带来最大的价值？需要用多种方式进行评估\n精炼阶段（挖掘产品利益最大的需求）：需求堆砌不出好产品，就算满足了每个用户反馈的需求，也会遭遇用户量涨不上去的情况，我们需要挖掘一些真正重要的需求\n\n尽可能多地收集需求坚持日复一日地看用户反馈\n\n不要拒绝来自任何人的需求，不管这个人是用户、同事、老板、朋友或毫不相干的人\n要从各个渠道获取需求，包括但不限于产品内的反馈系统、新浪微博、百度贴吧、知乎、微信群等（每个渠道的用户特点不同；用户反馈的渠道同时也是用户接触产品、品牌的渠道，我们认真对待用户声音就等同于在宣传我们的产品、打造品牌忠诚度）\n需求需要有逻辑地进行组织，一方面，应保证可以方便地记录、检索、避免遗忘；另一方面，应能通过组织良好的需求池宏观地观察产品发展阶段的状态，结合当前和长远目标，更好地做优先级决策\n需求也是符合二八原则的，80%的人提出的都是20%的需求\n除了要关注集中的占比80%的主流需求外，剩余的20%长尾需求其实需要产品经理投入更多的精力，因为在一个充分竞争的市场环境中，越是主流的需求，越是被充分挖掘，也就越显得竞争力不够，而那些尚未被发掘的需求，才是可能创新的所在（这并不意味着只需要关注长尾、小众需求，而不需要关注主流、大众需求）\n\n长尾效应：在数字化和网络化的环境下，非热门的小众产品（长尾部分）通过低成本存储和分销，能够共同占据与热门产品相当甚至更大的市场份额\n需求背后的动机沟通技巧与分析需求背后的动机在逻辑上是一致的。假设老板提了一个不靠谱的需求，如何说服他呢？\n\n分析需求背后的动机，比如，老板是不是想通过这个功能获取更多的新用户？\n从当下的局面考虑、从产品长远发展考虑，在获取新用户的目标上是否能达成一致？是不是当下重要的事情？\n采用老板的方法获取新用户，会有什么问题吗？有哪些积极的作用，有哪些负面的影响？性价比如何？\n有没有别的更好的方法获取新用户？有没有办法作用更大、实现更简单、负面影响更小？\n\n任何可能不在一个频道上的沟通，都需要先将沟通的双方调整到一个频道上\n评估实现需求的影响\n分析一个需求的影响范围\n分析一个需求的利弊\n\n产品的世界里不是每个问题都有对错，但都会有选择，产品经理为自己的选择负责\n角色、场景、流程如何分辨伪需求？除了分析需求背后的动机外，还可以用角色、场景、流程进行需求分析\n\n角色：对同一个功能，不同角色的需求不一致\n场景：分析需求真实发生的场景，考虑实际情况\n流程：分析满足需求的关键路径，判断能否满足\n\n角色、场景、流程是一套经典的需求分析方法，其中的关键在于通过三个角度拆解一个需求，细细地品味隐藏在一个看似正确的需求背后的真实的用户心理、使用场景、使用流程，从而判断需求的真伪、有效性，决策我们是否应该实现它\n符合产品目标不管做什么产品，不管这个产品做到什么阶段，用户需求总是无穷无尽的。需要考虑需求与产品本身目标、定位的匹配程度，在不同的产品阶段，产品的目标和定位会有差别\n实现需求需要对产品也有利，不能光满足用户，还需要满足产品的利益，这就是产品经理在其中所做的权衡与抉择\n产品的目标通常可以分为短期目标和长期目标。短期目标即为眼下产品需要达成的目标，如果需求能满足短期目标，就会立即产生效果。而长期目标则是产品战略和定位，通常是需要一年甚至两三年实现的目标，如果需求能满足长期目标，则一般会逐渐积累、最终满足\n通常来说，我们应该着眼长远，去实现那些符合产品长期目标的需求。长期目标与产品定位和战略挂钩，如果打算做一个志存高远的产品，产品经理应当在日常工作中多多思考，思考眼前的短期目标需求与长期目标需求之间的精力投入占比至少应该达到1:1，这样才能最终让产品实现战略目标\n在长期实践之后，产品经理可以获得关于产品长期目标的一些经验总结。需求总是非常多，但其中只有一部分对长期目标有巨大的帮助，它们通常具备以下特点：\n\n创造新的超越以往的体验，而非过时的\n有数据积累，并且数据越多能量越大\n长远来看，能和数据分析、挖掘、算法、社交社区、UGC等结合起来，产生巨大的作用\n通常其他竞争对手并不会这么做\n\n机会都是探索出来的，很少是规划出来的\n四两拨千斤如何能低成本地快速获得大量目标用户，而不是与竞争对手打持久战呢？\n\n用户的需求重点：通常是用户选择产品时的需求痛点，或者用户迁移时的主要成本所在\n竞争对手真正薄弱的地方：竞争对手可能在某些地方有优势，但不要放过竞品的每一个弱点，并且要放大这些弱点\n自己能发挥巨大优势的地方：结合上面两个考虑，将它们转化成自己产品的优势，就可以拨动千斤之重的竞争对手的用户群\n\n目标-问题-解决方案的逻辑思维过程：\n\n目标定义清晰，确保这个目标就是产品战略上的重要目标，并且用一句话就能描述清楚\n目标到问题的分解，推导路径要严谨，逻辑要严密，比如，最终分解出来的问题互斥、整个问题的集合是完整的等\n明确了要解决的问题，之后设计解决方案就是产品经理最基础的工作\n\n为了口碑满足需求在用户群中拥有很好口碑的产品是怎样炼成的？口碑带给产品的品牌和传播效应是一款产品实现爆发式增长的基础（满足用户需求绝不是将用户反馈的需求一一满足来达成的，甚至有些反馈的需求就算被实现了，也产生不了哪怕一丁点儿的口碑，因此对于需求的理解和判断，是把握用户口碑的关键）\n用户口碑有三个特点：\n\n超出预期：口碑的产生源自超出预期地满足了用户，带给了用户惊喜感（当产品经理打磨产品体验、揣摩用户需求时，不能把所有注意力都放在用户的基本需求上。这些需求通常表现得理所当然、四平八稳，实现它们带来的效果也比较波澜不惊。好口碑的产生一定是超出用户预期的，那么也就一定伴随着风险，团队内部可能对此会有争论，优秀的产品经理需要有一些冒险精神）\n快：在某项激动人心的新事物出现的时候，你的产品是第一时间跟进的，甚至这个新事物就是你们创造的，那么感兴趣的用户会产生惊喜感\n深：只要功夫深，铁杵磨成针（比如说非常重视用户反馈，团队成员每天都会查看并回复）\n不同维度：在用户的预期与产品带来的感知处于同一维度的时候，想要用户产生惊喜感是难度很大的（比如音效与听音乐是同一维度，而音乐评论与听音乐是不同维度）\n\n\n乐意传播：用户口碑最明显的特征就是用户会在自己的圈子里传播（产品经理需要有一定的市场思维，这样才能更好地捕捉用户乐意传播的点，在分析需求的时候，需要提前考虑传播，这样才能更好地打造口碑）\n感同身受（用户共鸣）\n打开眼界（用户都有好奇心，未知而有趣的东西容易引发传播）\n展示自己（用户爱现心理）\n\n\n大体量的用户：产品经理在面对用户需求时，需要甄别哪些是大体量的用户需求，满足这样的需求产生的口碑会具有巨大的能量\n\n产品经理的基本功\n基本功（用户研究、需求分析、数据分析、交互设计、信息架构、UI设计、编程能力、审美能力、竞品&#x2F;市场&#x2F;行业分析判断等）\n天赋（洞察能力、商业嗅觉）\n\n数据分析ROI投资回报率、UV独立访客、PV访问量、跳出率、停留时长、留存率、DAU日活跃用户数量、漏斗、路径转化\n\n不能只看大数据，需要精细化分析（精细化地分析数据是非常重要的意识，从一个宏观数据上往下细分更多的数据维度，能让我们真正了解一个业务的真实状态，而不是表面上的情况）\n需要看数据的变化、趋势（产品经理需要有敏锐的发现数据趋势的能力）\n需要对比数据，做到心中有谱（这里最普遍的问题是，是否知道某项数据的天花板在哪里，有时候我们觉得一个数据表现得不错，但其放在大盘里可能不突出）\n找到关键数据\n数据约等于效率的意识（数据分析帮助产品经理做决策，甚至A&#x2F;B测试可以替代产品经理做部分决策，这些都是为了降低决策的失误率和风险，将人的脑力用在更合适、更有深度、更有价值的地方：洞察）\n\n马太效应：指强者愈强、弱者愈弱的现象\n交互设计和信息架构产品经理要求同时具备出色的抽象和具象能力：抽象运用在系统级别的思考上，而具象运用在用户体验级别的思考上。交互设计和信息架构是锻炼这两种能力很好的基础与实践方式。在具象层面，交互设计不仅是画出页面功能的线框图，更本质的是将满足用户需求的想法具象化；在抽象层面，信息架构不仅是产品导航的设计，更本质的是产品元信息&#x2F;数据的梳理、功能的划分与组织、产品与用户之间的交互关系，这些抽象逻辑将在之后更进一步地发展成业务架构\n\n具象层面，交互设计最关键的是考虑用户认知（就是在用户使用产品的时候，不要让他有任何思考）、使用场景\n具象层面，不断地积累自己熟悉的设计模式\n抽象层面，思考用户与信息&#x2F;内容&#x2F;服务…的关系\n抽象层面，考虑复杂的多路径，设计整体的信息架构\n\nUI设计和编程能力大量地观摩设计作品，是产品经理培养自己对UI的感觉、审美意识的最佳实践\n写代码能提高产品经理的产品架构能力、锻炼产品经理的逻辑思维能力\n审美能力\n提高审美能力是为了让我们在美的理解上提高自己的上限、拓宽自己的认知幅度，见得足够多，我们才能有针对性地根据具体的人群选择具体的设计\n美是不断变化和发展的，我们提高审美能力也是为了让产品经理对美的感知和体验能领先大众半个身位，能感受到今后流行的设计趋势，同时也能感受到大众对美的接受边界在哪里\n\n由表及里，审美能力对产品的影响范围分为三层：视觉&#x2F;体验层、用户行为&#x2F;产品层、价值观&#x2F;世界观层\n\n视觉&#x2F;体验层：这是最快、最直接让用户感受到的地方，美好的视觉体验能让用户产生愉悦感，精巧的细节设计能够给用户留下深刻的印象\n用户行为&#x2F;产品层：从这一层开始，就涉及“真善美”中美的部分了，即会包含更多人文素养的内容\n价值观&#x2F;世界观层：一个产品需要有自己的价值观&#x2F;世界观\n\n在激烈的竞争中寻找产品定位产品如何才能形成差异化竞争？\n在竞争市场中确定产品定位至关重要，因为它决定了：\n\n产品能否在开始阶段活下来\n产品今后发展的天花板\n\n产品经理对产品定位的把握需要大量的经验积累，这些经验来自用户需求洞察的实践、产品架构的设计，以及行业市场的分析等。其中行业市场的分析是源头的部分，也是最关键的部分，源头如果模糊、偏移，那么自然会造成结果的偏差\n产品定位的方法论：\n\n分析行业、市场、竞争对手，从抽象到具象一步步地剖析你的产品所处的环境\n寻找产品的切入点，结合外部的分析和自身用户群、优势的分析，找到产品打开市场的切口\n在切入点的基础上，对产品定位和长期发展做出阶段性的规划，并设计扩张的接口\n整套方法论中最关键的当属“变化”二字，机会往往处于变化之中\n\n看清楚一个行业机会往往出现在未来会发生巨大变化的行业中\n作为产品经理，思考产品定位的第一步就是要弄清楚自己产品所在行业的情况，这是发现机会的开始（产品经理要掌握全方位的逻辑思考、推理能力）\n\n这个行业有哪些玩家？他们之间的关系是怎样的？\n未来几年，这个行业会发生什么变化？在这些变化中会产生什么机会？\n行业里的玩家会如何抓住变化中的机会？\n\n眼界是一个产品经理从执行层面迈向决策层面最关键的素质之一\n移动互联网的特点：资源极多、时间碎片化、传播极广\n分析市场的竞争局面SWOT市场分析方法对于初步分析产品所处的市场环境是很有用的，但随着互联网的发展，市场的变化速度非常快，往往看似不相关的两个市场也会产生竞争，因此，在移动互联网时代，分析市场的方法是放在更大的环境中去思考，不仅要寻找突破口，也要寻找防御点\n\n这个市场的相关市场是什么？它的上下游有哪些？谁是平台，谁是应用？\n这是一个零和市场吗？有没有办法做非零和市场？\n这个市场未来的变化是怎样的？应该如何抓住机会？\n\n零和市场：指市场中参与者的总收益与总损失相抵消，一方获利必然导致另一方受损，整体利益没有净增长\n互联网对行业的很多影响和渗透都是从下游开始逐渐往上游走的，从应用开始逐渐发展成平台。这是因为越依赖互联网的部分，越容易在前期就受到互联网的影响，只需要一部手机和一个App就能连接千万用户。但这并不意味着这个市场就没机会了，这时需要分析市场的上下游，以及平台和垂直应用的关系\n\n分析市场的上下游：上游和下游同时有着竞争与合作的关系，下游市场在用户基数变大之后，势必会向上发展，从而更多地影响整个行业；上游市场在掌握了资源后，也势必会向下发展，去拓展更多的渠道，它们在充分竞争后达到一个平衡。当市场的下游已经被占据时，可以看它的中游、上游是否还有新机会，尤其是那些尚未完全爆发的市场\n分析平台和垂直应用：平台可以支撑垂直应用的发展，垂直应用发展壮大后也可以成为平台。在没有平台的时候，在市场中要开拓一个垂直应用是很艰难的，平台需要用户频繁使用，不断提升用户黏性，它承担了教育用户、培养市场的责任。在用户的需求逐渐成熟、发散出来后，平台就可以带动周围的垂直应用，让整个市场更快地向前发展。当研究市场中的平台和垂直应用时，我们需要思考两个问题：市场中有没有平台？如果没有的话，我们要做的应用是不是高频应用，能否发展成平台？\n探寻非零和市场\n分析市场中的变化机会：市场中的变化机会往往因用户需求发生变化，需求的变化主要来自需求越来越丰富、出现新的消费形式等\n\n所有的研究与分析最后都应服务于产品经理对用户需求和产品自身的判断和策略，在具体做决策时，市场分析只是众多考虑因素中的一环\n比竞争对手还了解竞争对手Web产品包含战略层、范围层、结构层、框架层、表现层的产品设计要素，这五层是宏观思路，而竞品分析除了宏观的战略方面外，更重要的是落在实处地对竞争对手了如指掌\n\n竞品分析是贯穿产品经理工作始终的，对一个产品的深入了解不会是一次性的，而需要日积月累地加深，最终达到了若指掌的程度，这意味着产品经理随时都会进入分析一个竞品的状态中\n竞品的不断发展、变化也要求产品经理持续地跟踪、了解。我们可以通过竞品的变化，揣摩它业务方向的调整、发展，它的财务情况，它团队的变化，这些对产品经理来说都是很重要的信息，有利于把握竞争局面\n\n可以从数据、用户、产品三个角度去分析竞品：（其中最关键的就是对数据和用户行为、反馈的挖掘）\n\n数据方面（QuestMobile、联通沃指数、百度指数、微指数、应用商店排名&#x2F;下载量等）\n竞品整体数据，了解竞品在市场中的体量和位置（不仅要看一个产品的总用户量，还需要查看产品的日活跃用户数、周活跃用户数或者月活跃用户数，以及使用时长、使用频次等；也可以从用户对一个产品的搜索频次、社交讨论频次来侧面揣摩产品的用户体量）\n竞品数据趋势，了解竞品整体数据的变化趋势（如产品在过去一年中活跃用户的增长情况、使用时长的变化情况、各个重要产品迭代时间点前后的数据变化、重要的市场营销行为对产品知名度的影响等；只要结合数据和趋势一起看，可以挤掉大部分水分，例如，可以观察出在应用市场上刷榜的行为，同时也能知道一个产品的发展状态，一个产品是在快速向上，还是在走下坡路，这无疑是很重要的信息）\n当下国内互联网上比较健康的产品（较大体量以上）的平均数据：日活跃用户数&#x2F;总用户数&#x3D;5%，周活跃用户数&#x2F;总用户数&#x3D;10%，月活跃用户数&#x2F;总用户数&#x3D;20%，次日留存率&#x3D;40%，7日留存率&#x3D;20%，30日留存率&#x3D;10%\n\n\n\n\n用户方面\n竞品核心用户，熟悉竞品最忠实的、黏性最高的用户群（一个产品有很多功能，但大部分用户只用到其中20%左右的功能，而核心用户可能会用到一个产品80%左右的功能；不同产品的核心用户情况不一样，有些产品功能很简单，其实就没有核心用户，绝大部分用户的使用体验都差不多；运用用户研究方法，给核心用户做一个用户画像）\n竞品主流用户，熟悉竞品占比最大的主流用户群\n用户构成，熟悉竞品各类用户群的构成比例\n\n\n产品方面\n竞品核心竞争力，分析核心功能的特点、详细数据情况、用户的行为和反馈\n竞品主要功能，分析竞品的主要功能特点、详细数据情况、用户的行为和反馈\n竞品发展趋势，了解竞品过去、现在、未来的功能发展走向\n\n\n\n寻找切入点产品最难的地方就在于从0到1，而从0到1最难的地方就在于寻找产品切入点\n市场形势和用户需求始终处于变化之中，不同市场之间的差异也很大，任何一个产品寻找切入点都不容易\n在强大竞争对手可能忽视的地方，寻找未来的发展机会点：\n\n细分：足够尖锐，切开一道口子\n新兴：足够前瞻，未来改变现在\n\n内容社区型的产品通常会考虑将某个领域的资深用户作为细分市场切入点，这主要是因为如下原因：\n\n资深用户可以产生高质量的内容，高质量的内容才有好的消费价值\n聚集资深用户有利于做格调较高的品牌，品牌从高往低辐射比较容易发展，从低往高则困难得多\n\n广义上的产品形态，在选择细分市场时，需要重点考虑如下因素：\n\n细分用户的的关键需求是否没有被很好地满足，而且他们的需求也是大众市场的需求，只是市场上目前没有很好的解决方案\n细分市场是否有足够的影响力，在之后产品扩张时能影响别的群体\n我们的产品能否在细分市场上占据前三，甚至第一的位置（通常我们的目标是希望达到第一）。要么这个细分市场上没有竞争者，要么竞争者还比较弱小，完全有机会赶超。如果是前者，那么其实需要很小心，为啥没有人看到这个机会呢？需要谨慎思考上面的第一点。如果是后者，我们可以根据前面竞品分析的方法来判断。产品需要在细分市场上占据领先位置、占据用户的心智模型\n\n很多创业产品最容易忽视的一点是，寻找的细分市场缺乏与大众之间的连接。除非可以在一个细分市场中赢利、自给自足，（即便如此）绝大部分产品面临的永恒问题都是如何进一步扩大市场（高科技企业的早期市场和主流市场之间存在着一条巨大的“鸿沟”，能否顺利跨越鸿沟并进入主流市场，成功赢得实用主义者的支持，决定了一项高科技产品的成败）\n以切入点考虑产品架构产品如何通过最初的几个版本迭代做好从0到1？\n在整个设计过程中，产品经理对于其核心-产品架构的把控，是至关重要的，它就像是骨架，支撑起整个产品的发展\n我们从产品切入点出发，在设计最初的产品架构时，需要考虑以下方面：\n\n产品瞄准的细分市场\n产品的发展方向\n产品的核心功能：产品经理应该思考核心功能点有哪些待选项，即研究能实现产品成功切入市场的可能路径有哪些，然后权衡利弊\n信息架构：在设计的过程，需要考虑下面这些重点\n核心功能突出，用户上手简单，使用户马上能感受到产品的优点，对于一款新产品，用户对它的认知越清晰越好，因此产品也就不能有过多的功能\n核心功能与整体产品的架构布局。很重要的一点是，产品架构上没有断层，而且重要模块间是可以互相借力、协同发展的\n产品架构逐步完善的顺序和节奏\n\n\n\n需要注意的是，产品架构并不只是用一张脑图画出的产品导航结构图，产品导航结构图只是产品架构的一部分。产品经理很容易忽略的是，用户在产品上的主要行为路径，这一点往往决定了我们头脑中设想的产品亮点能否真正成为产品的发力点\n为未来发展设计接口在产品发展的过程中，到底该不该坚持最初的产品定位？\n用户量的增长时常会带来产品定位的改变\n产品定位并不是一成不变的，完全可以期待它有变化：从陷入困境变化为进入发展轨道，或者百尺竿头更进一步，找到新的增长点\n产品定位的改变会放大具体产品设计和运营策略的变化，这些变化会带来高昂的团队资源成本\n新产品在设计产品定位时，如何考虑未来发展而设计接口，避免中后期因变化太多，导致团队成本大幅增加，从而影响产品的发展速度？\n\n首先，我们应当思考产品的未来发展，这可能是设计接口时最难的问题，在产品定位都无法保证100%准确的情况下，思考定位上的产品发展就更难做到准确了（要思考清楚大方向，大方向上的事情一定是和未来三至五年发展相关的事情，并且具有模糊性，大方向并不能确定我们接下来的每一步需要做哪些具体的事情，但从实际的观点来看，定出这些方向只是一小步，设定这些方向的产品成千上万，但最终成长起来的屈指可数，因此，在大方向上产品如何规划、如何执行，才是真正决定性的要素）\n其次，所有的产品都是从最初的一点点架子逐步搭建完成的。设计接口的理念就是在最基础的产品架构上能与未来产品要做的功能、系统更好地衔接上。这其中有如下几个重要思路：\n考虑占位，即在大方向上需要占位，以做积累，从而为以后的发展提供资源、数据、能力，这就是所谓的厚积薄发\n考虑高概率，即在大方向上，从多种可能性中选择高概率确定的策略，留足充分的空间以及试错机会\n考虑低成本，即思考接口的成本，如果成本低，则可以大胆尝试\n考虑扩展，就如程序架构一样，要考虑代码的可扩展性、模块的可复用性等，对于产品架构而言，也需要考虑如何支撑产品的未来发展-功能会越来越丰富，系统会越来越复杂。优秀产品架构的主干会相对少而统一，分支围绕主干发展，这是最理想的状态，因此产品经理要充分考虑可扩展的接口\n\n\n\n需要说明的是，接口的设计很依赖产品经理的经验，因为只有见得多、做得多，才可以清楚、准确地理解每种产品的设计方法和思路，才可以为未来可能用到的策略提供接口。这方面的能力是在实践中不断增长的。在做产品设计时，不需要刻意追求为未来发展而设计接口，因为它有可能导致产品经理对产品定位、架构设计本身产生偏差、关注不足，从而带来更大的影响，毕竟如果产品定位和架构出了问题，产品可能在还没有到要考虑进一步发展的时候就遇到很大的困境，此即所谓的舍本逐末\n好的思维方式为什么有的产品经理的思路很清晰？\n思维方式很重要，好的思维方式能让人快速抓住重点、抓住问题的本质、抓住做大&#x2F;做强的思路\n产品经理在往更高的层面发展时，需要能够做到深度思考\n往重点思考产品经理要考虑的事情很多，如何才能抓住重点？\n\n思考关键目标（先发散，后收敛）\n思考实现关键目标的关键行动\n思考关键行动的关键依赖（思考我们所需的资源、我们的团队、我们的合作伙伴等）\n然后加以权衡（有时候关键目标比较多，需要权衡，放弃很重要）\n\n往本质思考为什么有人总能透过现象看到事物的本质？\n\n跳出思维惯性\n一层一层往下多提问题\n日常实践并与人交流\n\n产品经理最核心的能力是深度思考和用户洞察。方法论有时候其实没那么重要，重要的是我们不管在什么领域都能有很好的用户洞察，敏锐地捕捉到用户需求和商业机会，同时进行深度思考，能在这个领域内找到解决思路。所以对于一个产品经理来说，最重要的不是学习别人的方法论，而是通过自己的深度思考与用户洞察，不断地总结和迭代自己的方法论并形成闭环，这才是真正重要的事情\n往上层思考产品经理需要登高望远（不要好高骛远）\n\n一方面，在我们面对的问题越来越复杂的时候，在与问题相同的层面上可能很难梳理清楚，这时我们往上一层，会看到这些表面问题背后的问题，针对这些背后的问题进行思考和解决，就可以更有针对性地梳理复杂问题\n另一方面，往上层思考是让我们的战略眼光更好，能看到更大的机会。从一个局部功能，到一个系统，再到整个产品，是一层一层向上、一脉相承的\n\n往上层思考分为几个部分：\n\n看上层的格局和眼界\n思考上层与本层之间的逻辑关系\n想象未来的可能性\n\n往不同思考往不同思考是一个人非常难能可贵的思维方式\n\n客观地思考不同：当我们在思考不同时，要想一想背后的逻辑是否站得住脚，是否是客观存在的，而不只是自己想象臆断的\n逆向思维\n捕捉创新\n形成自己独特的思维框架\n\n产品架构能力所有产品经理都应当追求优雅的产品架构，这不是为了自我欣赏，而是实实在在地能让用户用得爽，同时也给未来的业务发展提供了很好的架构基础，不至于让业务、团队越来越臃肿和复杂\n产品架构的能力不是单一的能力，它与基础的交互设计、信息架构息息相关，同时也与上层的业务架构、战略架构一脉相承，因此产品架构能力是产品经理成长发展所必需的\n产品架构的要点我们应当追求什么样的产品架构呢？\n产品架构自然是架构产品，对象是从用户需求、商业需求中产生的各种产品功能，一个产品是由各种各样的功能组成的，产品架构则是将这些不同的功能围绕目标进行分类、整合\n这里有一个很重要的系统思维，即产品功能之间是有关系的，而非孤立存在的。如果是一些没有关系的功能组成的东西，则不能称之为系统。这是我们思考产品架构的基础，即不会单独思考产品系统中的功能，而是在整体系统层面上思考\n对于产品功能之间的关系，我们通常会思考分类聚合、用户流程、相互配合这几个因素：\n\n分类聚合：即从目标出发，将满足同个或同类用户需求、商业需求的产品功能聚合在一起\n用户流程：适用于用户流程较长的情况，单一的用户流程比较简单，多种用户流程须同时考虑时则比较复杂\n相互配合：在产品架构的系统中，我们还需要考虑不同功能（组）之间的配合\n\n重要的架构要点：\n\n用户易理解：即需要产品架构符合用户的认知和预期\n高效、易用\n尽量简练\n扩展性强：优秀的产品架构能低成本、快捷地支持功能扩展。扩展性强一部分与架构简练有关，功能模块通用性强，因而能支撑更多的功能。另一部分，则是我们在设计产品架构的时候，需要深入地思考和布局未来产品可能增加的功能，预留好接口\n\n最美的架构应是能够用非常简单的话语就阐释清楚的，而不是只有专家才能理解的复杂局面\n格式塔心理学：强调人类对事物的感知具有整体性，认为“整体大于部分之和”\n信息架构、产品架构与业务架构互联网产品架构的终极场景是架构公司的战略和业务，这需要很好的商业意识、业务洞察、战略规划和架构能力来相互配合\n信息架构、产品架构与业务架构的关系可以认为是递进式的：信息架构是最前端的表现层架构，产品架构是连接业务与用户表现层的产品功能、系统的架构，业务架构则是包含商业逻辑在内的业务运转机制的架构。如果反过来看，其实是从业务架构一步步推导出信息架构的，从而以前端的表现层呈现在用户面前。因此可以说，业务架构是内核、产品架构是骨架、信息架构是肌理脉络\n\n当我们面对一个复杂产品时，可以从三个层面入手分析：从界面层看信息架构、从功能层推敲产品架构、从商业和增长层梳理业务架构\n懂运营和营销现在的互联网时代早已不是产品完全主导的时代了，在产品从1到100的过程中，运营和营销至关重要\n系统思维与经营思维产品经理职位有其自身的思维特点，可以用系统思维来形容，其通常用系统性的办法解决问题；而运营则不一样，可以用经营思维来形容，在长久发展过程中一点一滴不断地深挖用户价值和商业价值\n具体到业务的表现上，产品经理的系统思维给业务提供了长远发展的方向和底层的动力；运营的经营思维则给业务提供一波又一波的高峰，带动业务快速发展，尽快聚集量变以达到产品预设的质变，每个业务阶段以此循环反复\n我们在做产品之初，就需要用经营思维来思考业务商业模式的本质是什么，究竟为用户、客户、行业等提供了什么新商业价值，我们如何从中获取利润\n产品结合运营在实践中的应用：\n\n经营用户流量\n思考用户是谁、研究他们在哪里：往往我们想要的用户很多，但需要选取一个当下最合适的用户群体来拓展；只要弄清楚目标用户是谁以及找到他们，剩下的就是用合适的利益点和方法吸引他们了，这样就能够长久、持续地经营用户流量\n寻找热点机遇、赚取流量红利\n裂变传播\n\n\n经营资源\n识别资源：在经营资源的过程中，“空手套白狼”可能是产生最大效用的方法之一。这里所说的“空手套白狼”并不是什么都没有去忽悠，而是指灵活、聪明地看待、运用自己所拥有的资源（我们需要培养自己识别资源的能力，不是那些明显摆在桌面上的才是资源。在互联网上，除了流量、资金外，我们的股东、品牌、团队、能力、时间、预期、合作伙伴、竞争对手等都是资源，在经营过程中我们需要有意识地识别它们）\n整合运用资源：整合运用资源的本质其实是思考各个资源之间如何配合并产生1+1大于或等于2的效果，其前提就是弄明白各资源的接口（所需要的输入以及能提供的输出）\n资源的投入&#x2F;产出：\n评估资源投入的ROI投资回报率（需要补充商业和财务方面的知识，明确定义投入的资源和产生的收益价值几何）\n产品经理要培养资源投入的意识，明确产品功能只是搭建了一个框架，需要资源不断注入才能生长、发芽\n产品经理要有多条腿走路的经营意识，避免将资源鸡蛋只装在一个篮子里。当然这并不意味着我们做产品时要做很多业务（业务复杂度越高，成本越高，经营越困难）\n\n\n\n\n经营价值链：经营资源的上一级就是经营价值链。一门生意一般来说脱离不了供应链、研发、生产、营销、销售、服务等环节，产品、研发部门生产出产品，经过运营部门培育壮大或变成服务，再经过营销部门宣传，最终产生营收。经营价值链就是使这个过程最大限度地实现营收。具体来说，就是低成本获取资源，然后增加附加价值，变成可营收的产品或服务，最后高价值地卖出去（在价值链的多个环节中，不断地寻找降低成本的思路，提高整体价值链的效能，创造更大的收益）\n\n品牌的用户心智与洞察在用户眼中，互联网公司里持续最久的是什么？是品牌，更具体地说是品牌所传递的用户心智，其能更久远地存在，比一个产品或服务要久得多\n\n产品时刻都需要思考差异化定位：对于一个新品牌的诞生来说，定位最重要，它是用户心智最初对品牌形成的认知。在互联网行业中，大部分领域最终可能只有两个品牌能较好地存活，当领先品牌占据大部分市场时，其他品牌必须做差异化定位，否则将无法存活下来\n在产品发展的全过程中，要持续不断地思考差异化，因为差异化的效果会随着时间和竞争对手的努力而减弱，我们必须在原有差异化的定位上不断加强及持续创新，做更多相关的差异化，形成一个更强大的合力\n我们选择的差异化一定要在一定程度上超出用户的预期，而不能选择用户认为理所当然应该有的特性\n\n\n聚焦并让用户热爱品牌：10个人爱你，好过100个人有点喜欢你（千万不要从我们自己所拥有的技术和资源出发去构思我们的发展方向，而是问自己如果要让用户爱上我们的品牌，我们应当做什么）\n运营人员持续地与核心用户沟通（最好公司全民是客服，时刻回复用户的反馈）\n营销的自我思考与传播：如果说产品经理设计产品品牌定位，运营建立核心用户的品牌用户心智，那么营销则在大众层面上更广泛地建立起品牌用户心智，最终实现量变引起质变的效果（没有大量用户作为基础的品牌用户心智是很脆弱的，达不到存续久远的效果）。在做品牌营销传播之前，我们需要对品牌做一个自我价值的探索，这个过程会存在两个鸿沟，产品经理设计的品牌定位与核心用户心智之间的鸿沟、核心用户心智与大众用户心智之间的鸿沟（品牌用户心智必须直击用户，它必须用一句话就能说清楚，必须是用户马上能明白并传播的语言，要么让用户产生精神上的共鸣，要么让用户觉得有利）\n品牌的边界思考：越是性格分明还带点极端的品牌，越容易与外界划清界限，也就是说喜欢的人很喜欢、讨厌的人很讨厌\n\n人对自我的探索和表达是无限的，是永不停止的，如果让用户在玩的过程中能沉浸到探索和表达中，那么就会引发用户的共鸣，用户就会很乐意自发地分享\n产品负责人的三个能力要具备什么能力，才能全局地把控一个产品？\n\n商业嗅觉及推理能力：对产品扩张、商业化的敏锐感觉，以及推导出为何能获得更大的发展、如何能发展壮大\n业务架构及创新能力：规划、实施复杂的业务架构，通过产品、运营、市场的多维度布局来打通用户对产品特性的认知\n善于沟通及领导能力：鼓舞、带领团队向战略方向前进，克服非常之困难，完成非常之突破\n\n商业嗅觉及推理能力什么是商业嗅觉？对商业机会的嗅探、把握。互联网的一个重要特性在于规模化，商业嗅觉是一种对扩张和赢利的敏锐直觉，如果按照一般的营收业务和用户规模业务来区分，那么扩张应该是包含了这两者，无论是做用户规模业务，还是营收业务，都应该拥有对扩张的敏锐直觉，能够谋求更大的发展\n关于扩张，需要回答如下两个问题：\n\n为何我能获得更大的发展？（可以拆解为我们的产品核心是什么、产品的边界在哪里两个问题）\n关于扩张最重要的就是要明确产品的核心和边界，在回答如何能获得更大的发展时，就是在核心之上设计用户与营收增长的发展策略，也就是知道起点和终点（可能是模糊的终点）并逐渐明确中间路径的过程\n\n\n我如何能发展壮大？\n要在发现问题之上的层面来解决问题\n如何在复杂的业务架构上打造新的增长引擎？\n\n\n\n现金牛：来自于波士顿矩阵模型，指那些在成熟市场上已经取得可观市场份额、利润丰厚且稳定的公司\n一个东西原本没有用户愿意为之买单，但如果越来越多的用户把注意力时间花在上面，就会产生让用户付费的可能，这和群体心理有关，看的人多了，大家就会觉得它挺有价值的，而羡慕、攀比等心理也会让它升值\n我们在运用用户注意力时间来形成商业模式的时候，有以下几点需要考虑：\n\n注意力时间的价值：这个模式让不愿意付费的用户花时间，让愿意付费的用户花钱，核心在于让用户付出的时间产生价值，并且这个价值能获得花时间和花钱用户的认可\n价值货币化：货币化可以大大提高用户对价值的认知，降低未来真正付费的门槛\n消费场景：货币需要有消费场景\n二八原则：80%的用户贡献时间，20%的用户为时间价值付费并贡献80%的收入\n\n业务架构及创新能力有一个宏大的想法，但不知道从何处下手该怎么办？\n产品发展到中期，业务开始变得复杂，同时关注的目标会多起来（当然仍可以归纳为一个大的产品目标），业务架构就是梳理清楚各个业务之间驱动轮和从动轮分别是什么、如何协同、如何输入&#x2F;输出、如何将各自的目标完成并且共同服务于大目标。清晰而合理的业务架构能让业务1+1大于2，而不合理的业务架构则会各自为政、无法形成合力，反而不断内耗。总体来讲，业务架构大致包含如下两方面：\n\n目标的拆解与分析：目标之间的依赖关系是什么样的，是如何协同的，哪个目标是重中之重\n各业务是如何服务各目标的，业务之间的依赖关系是什么样的，输入&#x2F;输出是什么，哪个是驱动轮业务，哪个是从动轮业务，如何构建一个清晰合理的业务架构\n\n互联网的产品创新：\n\n联想、借鉴、举一反三，善用他山之石形成自己产品的创新\n让用户形成对产品新特性的认知（只有真正能让用户买单，我们的创新才有价值，我们要在实际场景中通过体会用户的感受去思考创新能否击中用户，而非我们自己造出来的概念）\n\n用户的认知是会受影响的，当有大量意见领袖都传播这个认知时，大众也会产生这样的认知\n我们在思考让用户形成新的认知的时候，不能只从产品层面考虑，而应该结合产品、运营、营销多维度一起考虑\n创新是基于深刻的用户洞察和行业洞察而产生的\n善于沟通及领导能力领导力与一个人的管理职位、管理级别是没有关系的。在组织中仅依靠自己做事情，这是个人能力；而团结大家向一个目标努力，完成一项任务，则需要领导力。如果在一个组织中，依赖管理者发号施令才能让团队协同作战，那么这个团队的能力会大打折扣\n产品负责人的领导力所要达到的目标：\n\n产品负责人要规划业务发展，设定业务目标，需要团队认可目标、行动一致。因而，需要发挥领导力，让目标统一\n互联网产品是很强调想法碰撞的，一个互相信任、充分交流的团队是成功的基石。因而，需要发挥领导力，让各个角色都能在大目标下充分地交流与碰撞想法\n产品负责人为结果负责，光有想法不行，必须要有好的团队执行力。因而，需要发挥领导力，让团队保持一个高昂的状态，加满油全力以赴\n\n在和团队沟通的过程中要注意的关键点：\n\n每种职能的驱动力不一样，甚至每个人的驱动力也不一样。如何找到每个人的驱动力并激励大家，是领导团队发展中的重点\n一个互相信任的团队能形成合力、减少内耗\n很少有业务的发展是一帆风顺的，团队总会遇到大的挫折和困难，而此时需要向团队传递正能量（演讲能力）\n\n产品负责人自身的业务能力是保证实现业务目标的基础，而领导力则是除团队整体的管理体系外保证业务执行力的重要方式\n如何提升我们的沟通与领导力？\n\n聆听、复述\n\n提问\n\n赋能：以往的放权指的是将业务中的决策等权力进行不同程度的下放，让团队有更多自主的权力；而赋能，不仅包含了放权，而且把视角放在了如何为团队提供能力上\n\n能力：也就是团队的专业能力培养、梯队建设\n\n清晰的能力模型和标杆能够帮助我们打造学习型组织，给团队专业能力赋能\n标杆的作用就是让这些抽象的能力模型更加具象，更容易学习、模仿\n团队能力互补与梯队建设能让整个产品团队的能力没有明显短板，彼此之间能形成高效的协同，并且突出的能力能有效传递（因材施教）\n\n\n环境氛围：我们如何在压力大的结果导向的整体条件下，创造一个同样利于深度思考和创新的环境氛围，赋能团队？这个问题包含两个方面：\n\n一方面是产品负责人自身如何既能扛住来自业务KPI和公司高层的压力，同时也能将这些压力转化为团队的动力（产品负责人除了自身责任心强、勇于承担外，还需要适度地将压力传递给团队，形成动力，完全感受不到压力的团队的执行力肯定很差，压力太大的团队也不容易出成绩，与团队成员一起对战略和KPI进行层层分解）\n另一方面是产品负责人在团队内部打造合适的环境氛围（需要想想深度思考、创新和联想需要什么样的环境氛围？同时，我们应该有意识地引导团队共同创造氛围）\n\n\n机制：机制是产品负责人应当花最多的时间思考的事情，因为它是团队赋能的底层框架\n\n赋能的目的：它是为了赋予团队能力&#x2F;能量来解决团队本层遇到的问题，甚至上层的问题，是为了适应未来越来越不确定的环境，让组织能更敏捷、灵活地解决问题。在以往传统的管理模式下，团队更专注于解决本层的问题，上层的问题必须得到上层管理者的批准。而现在及未来，本层的问题与上层的问题的关联将越来越紧密，难以流程化地解耦。这就是赋能的初衷\n\n赋能的机制：\n\n业务：通常我们将业务划分为战略、战术、执行三个环节\n团队：战略团队、战术团队、执行团队\n信息：我们需要在整个产品组织内共享信息，即便是那些关键信息，我们也要比以往更多地共享，因为信息是赋能生效的基础之一，信息不对称经常会导致决策失误\n能力\n氛围：赋能组织非常需要相匹配的文化氛围\n\n\n\n\n\n\n互联网产品越来越依赖多个角色的协作，并且这些角色会更多地并行工作，而非串行\n下面是我们提倡和坚持的：\n\n热爱自己从事的工作并发展成兴趣\n大局观\n脚踏实地：大胆假设、小心求证\n心胸宽广\n喜欢学习\n无私分享\n\n下面是我们不提倡和禁止的：\n\n强烈的等级观念：组织内平等有利于创新\n故步自封\n害怕失败\n过于看重个人利益\n缺乏雄心\n\n产品之路时学时新产品的学习之路有终点吗？\n学习上的两个难处：\n\n缺少镜子，看不见自己应该学习的地方\n瓶颈难破，需要跑马拉松那般长久的耐力\n\n我们的镜子夫以铜为镜，可以正衣冠；以史为镜，可以知兴替；以人为镜，可以明得失\n学习最怕不知道自己应该学什么，所谓的不知道自己不知道\n在我们如今所处的时代，想要以人为镜，更多地需要我们自己打开自己，辩证地看待自己：\n\n打开自己：首先要有一个积极开放的心态\n多人之镜：一个人过往的成功越耀眼，光环下的阴影面积就越大，固有认知通道就越顽固，认知盲区就越多。一旦环境发生变化，这些在大量的经验中习得的思维习惯反而更有可能让人深陷泥沼。面对这个不确定世界的风云变迁，我们如何在认知大战中弯道超车？人镜就是让我们认知升级，一个产品负责人自己的边界才是产品真正的边界\n辩证地看待自己\n\n我们的瓶颈探求内心就是一场马拉松，需要相当大的耐力和精力\n遇到瓶颈、观察当前现实、感知其他信息、放下纠结、内心的自然流现、接纳自己的改变、创造新的想法、形成新的行动、突破瓶颈\nU型理论：\n\n知止而后有定，定而后能静，静而后能安，安而后能虑，虑而后能得\n在如今快速变化的互联网时代，当我们遇到瓶颈时，既往的经验与方法、内心的焦虑与急切都有可能会蒙蔽我们的双眼。我们通常会在瓶颈面前感到害怕，越是害怕、放不下，就越容易依赖既往的经验与方法。而现如今市场、环境变化极快，在瓶颈面前我们很难从过去、经验中获得突破（并不是说经验总结与方法沉淀不重要，而是各有用处），这时候我们更多地需要从未来、从未知中寻找机会。人的天性就是会对未知感到害怕，突破瓶颈实际上是在与我们的天性做对抗，让自己从害怕失败和未知的心理中跳脱出来，放下既往的经验和认知，重新感知周围的环境并思考未来会如何。当这样的心流涌现时，我们就会有新的想法和新的行动，而突破瓶颈就成为顺其自然的事了\n我们的自省我们如何才能持续不断地成长，乃至终身成长？\n吾日三省吾身\n学习从入门到精通的四个递进状态：\n\n杂乱：在刚开始接触一个学习对象不久，它呈现在我们面前的状态是杂乱的，有很多的信息，彼此之间的脉络关系不清楚，不知道应该从哪里入手\n有序（树状结构）：将知识分门别类，理清主干和枝叶\n焦点：从有序到焦点是境界的提升，需要浸淫其中，大量的经验积累能够帮助我们悟到一个学习对象的本质，也就是说我们在这个领域内所掌握的知识能最后汇聚成一个点，这个点代表它的本质（比如互联网产品领域的焦点可以是洞察与架构）\n混沌（网状结构）：焦点是聚焦的最终形态，但它缺少了发散。初看起来，杂乱和混沌比较像，没有明显的秩序感，但混沌之中充满了连接，孕育着创新。在混沌状态下，除了对知识的脉络了然于心，能够用本质去理解诸多的知识外，还能够保持非常开放的心态，连接更多乃至无穷尽的知识，产生新的理解和感悟\n\n我们的学习和成长从何而来？\n\n向外界的一部分学习：有明确的学习方向和目标，然后向外界寻找合适的部分来学习\n向外界的全部学习\n自省（由内而发的学习）：如果能依靠自己的内心流现而非外界输入来驱动自己的学习成长，这无疑是让人怡然自得而终身学习的状态，而不是被迫的。自省状态的前提条件是通透的自知之明，如果没有自知之明，即便我们进行自省，也会省不出什么来，那样只是形式主义\n有意识地做：吾日三省吾身\n方法和工具：U型理论\n愉悦的状态：我们的焦虑状态是终身成长中最好&#x2F;最终的状态吗？不是。适当的愉悦感和焦虑感组合在一起则是好状态，自身成长带给自己更多的愉悦而非焦虑，这样形成正循环，而适当的焦虑则会让我们紧一紧，保持动力，避免过分愉悦而自我膨胀\n\n\n\n终身成长是每个人都可以追求并达到的\n","categories":["产品理论"],"tags":["产品理论书单📚-产品"]},{"title":"如何区分现象和问题","url":"/2023/08/31/%E4%BA%A7%E5%93%81%E7%90%86%E8%AE%BA/%E6%8A%80%E6%9C%AF%E6%80%9D%E7%BB%B4/%E6%8A%80%E6%9C%AF%E6%80%9D%E7%BB%B4/5_%E5%A6%82%E4%BD%95%E5%8C%BA%E5%88%86%E7%8E%B0%E8%B1%A1%E5%92%8C%E9%97%AE%E9%A2%98/","content":"如何高效沟通？沟通的本质是取得共识和解决问题，高效沟通的目的是寻找最短路径去取得共识和解决问题\n现象 vs 问题我们花了太多的时间去讨论和重复讨论现象，却恰恰忽略了定义关键问题，现象是影响，问题是原因\n瞄准问题打方案定义清楚问题，就已经解决了一半\n","categories":["产品理论"],"tags":["技术思维-技术思维"]},{"title":"如何正确提需求","url":"/2023/08/31/%E4%BA%A7%E5%93%81%E7%90%86%E8%AE%BA/%E6%8A%80%E6%9C%AF%E6%80%9D%E7%BB%B4/%E6%8A%80%E6%9C%AF%E6%80%9D%E7%BB%B4/6_%E5%A6%82%E4%BD%95%E6%AD%A3%E7%A1%AE%E6%8F%90%E9%9C%80%E6%B1%82/","content":"提需求的时机：根据工程师的工作习惯，不是每个时候都适合提需求，找准时机，让需求更容易被接受\n提需求的顺序：用一个上下文完整的信息并结合问题给工程师提需求，避免干瘪的功能性需求\n顺序：\n\n背景（现状、问题、原因）\n方案（如何做、可行性）\n执行（何时做）\n\n提需求的内容：避免凭感觉式的需求描述，需求内容要具体、可行\n不要迷信文档模版，一份好的需求内容只需要满足把背景、方案、素材定清楚就行\n","categories":["产品理论"],"tags":["技术思维-技术思维"]},{"title":"如何评估技术工作量","url":"/2023/08/31/%E4%BA%A7%E5%93%81%E7%90%86%E8%AE%BA/%E6%8A%80%E6%9C%AF%E6%80%9D%E7%BB%B4/%E6%8A%80%E6%9C%AF%E6%80%9D%E7%BB%B4/7_%E5%A6%82%E4%BD%95%E8%AF%84%E4%BC%B0%E6%8A%80%E6%9C%AF%E5%B7%A5%E4%BD%9C%E9%87%8F/","content":"技术工作包括哪些？技术工作的细节远比我们看到的要多，实施过程中的不确定性极强，任何一个环节都可能延期\n\n数据库设计\n接口设计\n界面代码\n逻辑代码\n组件复用\n代码注释\n单元测试\n接口联调\nbug修改\n部署上线\n\n按需求拆分产品经理无需精确评估技术工作量，也评估不准，但可以把需求进行拆分评估大概周期\n拆分维度：\n\n系统：按不同系统拆分，例如按电商优惠券系统、促销系统、运营后台进行拆分\n模块：按功能模块拆分，例如按电商交易流程中的购物车、结算页、收银台进行拆分\n页面：按独立页面拆分，例如按电商商品详情页、订单列表页、用户评价页进行拆分\n\n根据拆分后的需求，根据复杂度、改动量、过往经验进行工作量预估\n技术组件化不重复发明轮子是技术组件化的目标，不是所有的功能都需要重复开发，例如：\n\n定位组件\nIM组件\n列表数据加载组件尽可能在实现过程中进行技术组件化，降低评估工作量难度\n\n","categories":["产品理论"],"tags":["技术思维-技术思维"]},{"title":"工程师思维","url":"/2023/08/31/%E4%BA%A7%E5%93%81%E7%90%86%E8%AE%BA/%E6%8A%80%E6%9C%AF%E6%80%9D%E7%BB%B4/%E6%8A%80%E6%9C%AF%E6%80%9D%E7%BB%B4/4_%E5%B7%A5%E7%A8%8B%E5%B8%88%E6%80%9D%E7%BB%B4/","content":"个体思维差异每个人的成长背景、经历、个人认知导致了思维差异的形成，尊重并接受这种差异性是形成有效沟通的前提\n工程师思维\n与工程师沟通\n","categories":["产品理论"],"tags":["技术思维-技术思维"]},{"title":"技术思维在产品设计中的运用","url":"/2023/08/31/%E4%BA%A7%E5%93%81%E7%90%86%E8%AE%BA/%E6%8A%80%E6%9C%AF%E6%80%9D%E7%BB%B4/%E6%8A%80%E6%9C%AF%E6%80%9D%E7%BB%B4/8_%E6%8A%80%E6%9C%AF%E6%80%9D%E7%BB%B4%E5%9C%A8%E4%BA%A7%E5%93%81%E8%AE%BE%E8%AE%A1%E4%B8%AD%E7%9A%84%E8%BF%90%E7%94%A8/","content":"运用技术思维进行产品设计产品是感性思考和理性设计的结合体，在设计环节，加入技术思维的考虑，会更有利于落地\n考虑方案的实现原理，主要涉及：\n\n数据结构调整（数据库、接口）\n页面调整\n逻辑兼容（新老版本兼容）\n\n在需求阶段，除了功能层面的设计，多关注技术细节的设计，把握全流程的来龙去脉\n","categories":["产品理论"],"tags":["技术思维-技术思维"]},{"title":"如何持续提升技术思维","url":"/2023/08/31/%E4%BA%A7%E5%93%81%E7%90%86%E8%AE%BA/%E6%8A%80%E6%9C%AF%E6%80%9D%E7%BB%B4/%E6%8A%80%E6%9C%AF%E6%80%9D%E7%BB%B4/9_%E5%A6%82%E4%BD%95%E6%8C%81%E7%BB%AD%E6%8F%90%E5%8D%87%E6%8A%80%E6%9C%AF%E6%80%9D%E7%BB%B4/","content":"技术思维不等于技术能力产品经理要掌握的是技术思维，而不是技术能力，切记别顾此失彼\n\n技术思维：理解程序和代码逻辑、设计低复杂度的界面布局、判断数据是如何在功能间流转\n技术能力：能够编写代码实现功能、实现前端界面、从数据库查询或修改数据\n\n学习技术思维的主要途径：\n\n需求评审会上，对工程师的问题重点记录，反复思考，翻译成通俗的理解\n阅读数据库设计文档以及接口文档，建立数据结构的基本认知\n产品升级和设计调整时，是了解其中的技术细节的最好时机，包括数据流转、接口分布等\n进一步系统化的学习可以参照一些大学教材进行基础知识补充，但不建议太深入\n\n建立自己的技术知识库：将复杂的技术概念，转化为自己可理解的常识性概念，持续丰富自己的技术知识库\n","categories":["产品理论"],"tags":["技术思维-技术思维"]},{"title":"数据库是如何工作的","url":"/2023/08/31/%E4%BA%A7%E5%93%81%E7%90%86%E8%AE%BA/%E6%8A%80%E6%9C%AF%E6%80%9D%E7%BB%B4/%E6%95%B0%E6%8D%AE%E5%BA%93%E6%8A%80%E6%9C%AF/1_%E6%95%B0%E6%8D%AE%E5%BA%93%E6%98%AF%E5%A6%82%E4%BD%95%E5%B7%A5%E4%BD%9C%E7%9A%84/","content":"什么是数据库？数据库是用来进行数据存储和管理的容器，产品在使用过程中发生的行为和业务数据都会存储在数据库中\n数据库在哪？数据库运行在服务器上，属于后端的一部分\n数据库与服务端有什么关系和区别？服务端程序处理业务逻辑，然后调用数据库进行数据操作\n数据库分类：不同的数据库厂商提供的数据库基础能力类似，但使用场景和处理能力略有差别，好比不同的空调厂商，都能提供制冷和制热空调，但品牌、能耗、价格不一样\n数据库的工作原理：\n被服务端调用，进行数据增删改查\n服务端程序通过SQL语句操作数据库，SQL语句需要工程师通过写代码的方式实现\n数据库运行在服务器上，数据存储在服务器硬盘中\n\n","categories":["产品理论"],"tags":["技术思维-数据库技术"]},{"title":"数据库“字段”和“字段类型”","url":"/2023/08/31/%E4%BA%A7%E5%93%81%E7%90%86%E8%AE%BA/%E6%8A%80%E6%9C%AF%E6%80%9D%E7%BB%B4/%E6%95%B0%E6%8D%AE%E5%BA%93%E6%8A%80%E6%9C%AF/3_%E6%95%B0%E6%8D%AE%E5%BA%93%E2%80%9C%E5%AD%97%E6%AE%B5%E2%80%9D%E5%92%8C%E2%80%9C%E5%AD%97%E6%AE%B5%E7%B1%BB%E5%9E%8B%E2%80%9D/","content":"数据表“字段”字段对应实体对象中的属性，在数据库表结构中，字段是基本组成要素\n数据表“字段类型”每一个字段都对应一种字段类型，字段类型用来表示该字段存储的值属于哪种类型，常用字段类型：整数型、字符型、日期类型\n字段和字段类型的使用：\n字段映射的是客观世界中实体的属性，每个属性都需要对应的数据类型\n字段和字段类型是数据结构的基础，接口里的参数和值对应的都是数据库里的字段和字段类型，工程师都是基于字段和字段类型来定义接口API\n产品经理对数据库表、字段、字段类型有了解后，可以更好的理解接口的设计和功能的逻辑\n\n","categories":["产品理论"],"tags":["技术思维-数据库技术"]},{"title":"数据库操作语言SQL","url":"/2023/08/31/%E4%BA%A7%E5%93%81%E7%90%86%E8%AE%BA/%E6%8A%80%E6%9C%AF%E6%80%9D%E7%BB%B4/%E6%95%B0%E6%8D%AE%E5%BA%93%E6%8A%80%E6%9C%AF/4_%E6%95%B0%E6%8D%AE%E5%BA%93%E6%93%8D%E4%BD%9C%E8%AF%AD%E8%A8%80SQL/","content":"SQL（Structured Query Language）全称叫做结构化查询语言，是一种用来操作关系型数据库的编程语言，可以理解为对数据库的操作命令，SQL语句被嵌入在服务端程序中，后端工程师除了编写业务逻辑代码外，还需要对数据库进行操作\n数据是如何被呈现到客户端界面的？客户端发起请求，服务端处理，调用数据库进行查询，通过接口将数据返回给客户端并显示\n常用SQL语句：\n","categories":["产品理论"],"tags":["技术思维-数据库技术"]},{"title":"数据库表索引是什么","url":"/2023/08/31/%E4%BA%A7%E5%93%81%E7%90%86%E8%AE%BA/%E6%8A%80%E6%9C%AF%E6%80%9D%E7%BB%B4/%E6%95%B0%E6%8D%AE%E5%BA%93%E6%8A%80%E6%9C%AF/5_%E6%95%B0%E6%8D%AE%E5%BA%93%E8%A1%A8%E7%B4%A2%E5%BC%95%E6%98%AF%E4%BB%80%E4%B9%88/","content":"什么是数据库索引？索引是基于数据库表某一列或几列建立的目录结构，通过索引能极大提高数据的查询效率\n数据库索引的缺点：\n索引需要耗费一定的物理存储空间，索引单独维护\n每次对数据表更新的同时需要更新维护索引表\n需要花费较多的时间去建立和维护索引，随着数据总量的增加，花费的时间也将增加\n\n","categories":["产品理论"],"tags":["技术思维-数据库技术"]},{"title":"互联网是如何提供服务的","url":"/2023/08/31/%E4%BA%A7%E5%93%81%E7%90%86%E8%AE%BA/%E6%8A%80%E6%9C%AF%E6%80%9D%E7%BB%B4/%E6%9C%8D%E5%8A%A1%E7%AB%AF%E6%8A%80%E6%9C%AF/1_%E4%BA%92%E8%81%94%E7%BD%91%E6%98%AF%E5%A6%82%E4%BD%95%E6%8F%90%E4%BE%9B%E6%9C%8D%E5%8A%A1%E7%9A%84/","content":"我们是如何获取互联网资源的？我们通过手机或者电脑访问互联网上的资源，包括图片、文字、视频等，都是在获取互联网资源。客户端作为接入载体，访问服务端的数据，服务端提供计算逻辑和内容服务，以数据流的方式进行内容传递\n如何检测网络是否连通？互联网服务依赖于网络连接，客户端与服务器的通信也依赖于通顺的网络，这是一切互联网服务的基础。通过ping命令可以检测某个服务器地址的连接是否可用（Packet Internet Groper：互联网包探测器），工程师经常说的“ping一下”，就是检测一下目标服务器是否连通\n通过“端口”访问对应的服务同一台服务器的服务可能有多个，通过“端口”可以唯一确定具体对应的服务，通过netstat -an可查看本地服务对应的ip地址和端口号，工程师所说的“8080”端口号就是某一服务对应的具体端口\n代理服务器\nCDN服务\n","categories":["产品理论"],"tags":["技术思维-服务端技术"]},{"title":"服务端基础技术架构","url":"/2023/08/31/%E4%BA%A7%E5%93%81%E7%90%86%E8%AE%BA/%E6%8A%80%E6%9C%AF%E6%80%9D%E7%BB%B4/%E6%9C%8D%E5%8A%A1%E7%AB%AF%E6%8A%80%E6%9C%AF/2_%E6%9C%8D%E5%8A%A1%E7%AB%AF%E5%9F%BA%E7%A1%80%E6%8A%80%E6%9C%AF%E6%9E%B6%E6%9E%84/","content":"服务端介绍：服务端也被称为“后端”，在产品对应的技术体系中，负责业务逻辑处理和数据处理，是“大后方”\n服务端处理逻辑：\n\n客户端通过互联网将数据以接口的形式发送给服务端\n服务端由服务器承载，接收客户端请求\n服务端处理业务逻辑并做数据存储管理\n服务端将请求结果返回给客户端\n\n服务端放在哪里？\n服务端开发技术：服务端开发语言有很多，例如Java、PHP、Python等，不同的开发语言都可以用来构建服务端，服务端程序运行在服务器中，服务器的部署有两种方式：\n\n自建服务器机房\n使用云服务（例如阿里云、亚马逊AWS等）\n\n","categories":["产品理论"],"tags":["技术思维-服务端技术"]},{"title":"数据库“表”、“关系结构”和“主键”","url":"/2023/08/31/%E4%BA%A7%E5%93%81%E7%90%86%E8%AE%BA/%E6%8A%80%E6%9C%AF%E6%80%9D%E7%BB%B4/%E6%95%B0%E6%8D%AE%E5%BA%93%E6%8A%80%E6%9C%AF/2_%E6%95%B0%E6%8D%AE%E5%BA%93%E2%80%9C%E8%A1%A8%E2%80%9D%E3%80%81%E2%80%9C%E5%85%B3%E7%B3%BB%E7%BB%93%E6%9E%84%E2%80%9D%E5%92%8C%E2%80%9C%E4%B8%BB%E9%94%AE%E2%80%9D/","content":"实体关系结构反映客观世界中实体本身和相互之间的关系结构，实体间关系可以是1对1、1对多、多对多\n数据库反映的也是客观世界中的实体关系\n数据库“表”数据库由数据库表组成，数据库“表”对应客观世界中的一个实体，“表”的名就是实体名，“表”的字段就是实体属性\n数据库“关系结构”反映客观世界中实体本身和相互之间的关系结构，实体间关系可以是1对1、1对多、多对多，“表”与“表”之间可以建立关联关系，对应不同实体之间的关系\n表与表之间通过“主键”相互关联主键：每个表中，唯一标识一条数据的字段\n","categories":["产品理论"],"tags":["技术思维-数据库技术"]},{"title":"接口API、JSON、XML","url":"/2023/08/31/%E4%BA%A7%E5%93%81%E7%90%86%E8%AE%BA/%E6%8A%80%E6%9C%AF%E6%80%9D%E7%BB%B4/%E6%9C%8D%E5%8A%A1%E7%AB%AF%E6%8A%80%E6%9C%AF/3_%E6%8E%A5%E5%8F%A3API%E3%80%81JSON%E3%80%81XML/","content":"如何实现数据通信？客户端之间的通信、客户端与服务端之间的通信都通过“接口”来实现，应用程序编程接口（API：Application Programming Interface）是一个通讯协议，约定客户端和服务端之间数据传输格式和访问地址\n接口定义：接口（API）由两部分组成：url地址、数据参数\nurl地址：确定所访问的服务器地址以及对应的端口和服务数据参数：以某一种格式来定义和携带数据，将数据从客户端发送至服务端\nJSON&#x2F;XMLJSON&#x2F;XML都是用来承载数据参数的格式，就像写信用的信纸，可以用横格纸，也可以用方格纸，目前主流的是JSON：\n","categories":["产品理论"],"tags":["技术思维-服务端技术"]},{"title":"API和SDK的区别是什么","url":"/2023/08/31/%E4%BA%A7%E5%93%81%E7%90%86%E8%AE%BA/%E6%8A%80%E6%9C%AF%E6%80%9D%E7%BB%B4/%E6%9C%8D%E5%8A%A1%E7%AB%AF%E6%8A%80%E6%9C%AF/4_API%E5%92%8CSDK%E7%9A%84%E5%8C%BA%E5%88%AB%E6%98%AF%E4%BB%80%E4%B9%88/","content":"什么是SDK？SDK：软件开发包（Software Development Kit），是一系列开发工具（API）的集合，比如定位SDK、推送SDK、数据统计SDK等\n每一个平台或者技术语言，都有对应的SDK版本，例如Android SDK、iOS SDK、Python版SDK\nAPI和SDK的关系？API是一项单独能力，通常一个API对应一个能力接口，例如定位API、登录API、授权API，SDK则是将一系列的API集合封装起来，以软件包的形式对外提供服务\n应用程序是如何集成并使用SDK的？根据对应的版本集成SDK包，按接口文档的要求调用SDK里的API，使用SDK前，通常需要专门申请对应的key，进行授权使用\n集成SDK时，应用程序通过调用不同SDK的接口来实现多样化的服务\n","categories":["产品理论"],"tags":["技术思维-服务端技术"]},{"title":"生产环境与测试环境","url":"/2023/08/31/%E4%BA%A7%E5%93%81%E7%90%86%E8%AE%BA/%E6%8A%80%E6%9C%AF%E6%80%9D%E7%BB%B4/%E6%9C%8D%E5%8A%A1%E7%AB%AF%E6%8A%80%E6%9C%AF/6_%E7%94%9F%E4%BA%A7%E7%8E%AF%E5%A2%83%E4%B8%8E%E6%B5%8B%E8%AF%95%E7%8E%AF%E5%A2%83/","content":"服务端运行环境：服务端程序运行在服务器中，可分别配置生产环境和测试环境\n测试环境是用来给工程师开发测试用的，对应的功能和数据与生产环境会有一定区别：\n\n在发布新版本前，尽可能用生产环境数据同步到测试环境进行测试\n在做一些例如数据推送测试、数据库修改测试时，仔细检查当前环境，避免出现误操作\n在测试环境和生产环境都需要做新老版本兼容性测试\n\n","categories":["产品理论"],"tags":["技术思维-服务端技术"]},{"title":"服务端与客户端数据交互模型","url":"/2023/08/31/%E4%BA%A7%E5%93%81%E7%90%86%E8%AE%BA/%E6%8A%80%E6%9C%AF%E6%80%9D%E7%BB%B4/%E6%9C%8D%E5%8A%A1%E7%AB%AF%E6%8A%80%E6%9C%AF/5_%E6%9C%8D%E5%8A%A1%E7%AB%AF%E4%B8%8E%E5%AE%A2%E6%88%B7%E7%AB%AF%E6%95%B0%E6%8D%AE%E4%BA%A4%E4%BA%92%E6%A8%A1%E5%9E%8B/","content":"接口请求与响应：客户端程序通过发送HTTP请求访问对应的API（URL），并携带参数（JSON&#x2F;XML）传递给服务端\n\n一个功能可能只调用一个API，也可能同时调用多个API\n一次功能操作，API可以顺序执行调用，也可以异步处理调用\n\n服务端接收API调用后，处理业务逻辑，并将处理结果以数据参数的形式返回给客户端\n\n客户端操作某一功能后，等待服务端返回结果\n等待服务端响应功能结果，可以是同步的，也可以是异步的\n\n基于请求-响应的数据交互模型服务端与客户端之间都是基于这种数据交互模型来进行通信，每一次请求都由客户端发起，服务端接收请求并完成业务逻辑处理和数据处理后，将结果返回给客户端\n","categories":["产品理论"],"tags":["技术思维-服务端技术"]},{"title":"什么是token","url":"/2023/08/31/%E4%BA%A7%E5%93%81%E7%90%86%E8%AE%BA/%E6%8A%80%E6%9C%AF%E6%80%9D%E7%BB%B4/%E6%9C%8D%E5%8A%A1%E7%AB%AF%E6%8A%80%E6%9C%AF/7_%E4%BB%80%E4%B9%88%E6%98%AFtoken/","content":"token是在客户端频繁向服务端请求数据，服务端频繁的去数据库查询用户名和密码并进行对比，判断用户名和密码正确与否，并作出相应提示，在这样的背景下，token便应运而生。\ntoken是服务端生成的一串字符串，以作客户端进行请求的一个令牌，当第一次登录后，服务器生成一个token便将此token返回给客户端，以后客户端只需带上这个token前来请求数据即可，无需再次带上用户名和密码。\ntoken的目的是为了减轻服务器的压力，减少频繁的查询数据库，使服务器更加健壮。\n","categories":["产品理论"],"tags":["技术思维-服务端技术"]},{"title":"什么是功能测试","url":"/2023/08/31/%E4%BA%A7%E5%93%81%E7%90%86%E8%AE%BA/%E6%8A%80%E6%9C%AF%E6%80%9D%E7%BB%B4/%E6%B5%8B%E8%AF%95%E5%B8%B8%E8%AF%86/2_%E4%BB%80%E4%B9%88%E6%98%AF%E5%8A%9F%E8%83%BD%E6%B5%8B%E8%AF%95/","content":"功能测试就是对产品的各功能进行验证，根据功能测试用例逐项测试，检查产品是否达到用户要求的功能。\n","categories":["产品理论"],"tags":["技术思维-测试常识"]},{"title":"什么是自动化测试","url":"/2023/08/31/%E4%BA%A7%E5%93%81%E7%90%86%E8%AE%BA/%E6%8A%80%E6%9C%AF%E6%80%9D%E7%BB%B4/%E6%B5%8B%E8%AF%95%E5%B8%B8%E8%AF%86/3_%E4%BB%80%E4%B9%88%E6%98%AF%E8%87%AA%E5%8A%A8%E5%8C%96%E6%B5%8B%E8%AF%95/","content":"自动化测试是把以人为驱动的测试行为转化为机器执行的一种过程。通常，在设计了测试用例并通过评审之后，由测试人员根据测试用例中描述的规程一步步执行测试，得到实际结果与期望结果的比较。在此过程中，为了节省人力、时间或硬件资源，提高测试效率，便引入了自动化测试的概念。\n","categories":["产品理论"],"tags":["技术思维-测试常识"]},{"title":"什么是提测","url":"/2023/08/31/%E4%BA%A7%E5%93%81%E7%90%86%E8%AE%BA/%E6%8A%80%E6%9C%AF%E6%80%9D%E7%BB%B4/%E6%B5%8B%E8%AF%95%E5%B8%B8%E8%AF%86/1_%E4%BB%80%E4%B9%88%E6%98%AF%E6%8F%90%E6%B5%8B/","content":"就是提交给专业的QA去测试，开发人员在dev开发环境进行开发和联调，结束后提交给测试人员。测试人员在test测试环境来验证本次迭代的功能是否正确。\n","categories":["产品理论"],"tags":["技术思维-测试常识"]},{"title":"什么是白盒、灰盒、黑盒测试","url":"/2023/08/31/%E4%BA%A7%E5%93%81%E7%90%86%E8%AE%BA/%E6%8A%80%E6%9C%AF%E6%80%9D%E7%BB%B4/%E6%B5%8B%E8%AF%95%E5%B8%B8%E8%AF%86/5_%E4%BB%80%E4%B9%88%E6%98%AF%E7%99%BD%E7%9B%92%E3%80%81%E7%81%B0%E7%9B%92%E3%80%81%E9%BB%91%E7%9B%92%E6%B5%8B%E8%AF%95/","content":"黑盒测试：也可叫功能测试，是一种从用户角度出发的测试。把被测程序当作一个黑盒子，测试人员完全不用考虑盒子里面的逻辑结构和具体运作，只依据程序的需求规格说明书，检查程序的功能是否符合它的功能说明。主要的测试方法有等价划分类，错误推测法等。\n灰盒测试：是介于白盒测试与黑盒测试之间的一种测试，灰盒测试多用于集成测试阶段，不仅关注输出、输入的正确性，同时也关注程序内部的情况。灰盒测试不像白盒那样详细、完整，但又比黑盒测试更关注程序的内部逻辑。\n白盒测试：也称为结构测试。它根据程序的控制结构设计测试用例，测试人员会利用程序内部的逻辑结构及有关信息，通过在不同点检查程序状态，检验程序中的每条通路是否都能按预定要求进行正确工作。\n\n从测试目标和依据来说：黑盒面对的是产品设计，白盒针对的是程序功能的实现，灰盒针对兼而有之，既要考虑产品设计要求，又考虑到功能实现的效果。\n从实现者而言：黑盒在意的是客户的角度，白盒测试针对的研发人员。\n从测试模块颗粒度而言：白盒在意的是代码实现层面，而灰盒更加侧重模块之间，而黑盒更在于用户层面。\n\n","categories":["产品理论"],"tags":["技术思维-测试常识"]},{"title":"什么是Alpha测试？什么是Beta测试","url":"/2023/08/31/%E4%BA%A7%E5%93%81%E7%90%86%E8%AE%BA/%E6%8A%80%E6%9C%AF%E6%80%9D%E7%BB%B4/%E6%B5%8B%E8%AF%95%E5%B8%B8%E8%AF%86/6_%E4%BB%80%E4%B9%88%E6%98%AFAlpha%E6%B5%8B%E8%AF%95%EF%BC%9F%E4%BB%80%E4%B9%88%E6%98%AFBeta%E6%B5%8B%E8%AF%95/","content":"α测试是由一个用户在开发环境下进行的测试，也可以是公司内部的用户在模拟实际操作环境下进行的测试。α测试的目的是评价软件产品的功能、局域化、可使用性、可靠性、性能和支持，尤其注重产品的界面和特色。α测试可以从软件产品编码结束之时开始，或在模块（子系统）测试完成之后开始，也可以在确认测试过程中产品达到一定的稳定和可靠程度之后再开始。\nβ测试是由软件的多个用户在实际使用环境下进行的测试，这些用户返回有关错误信息给开发者。测试时，开发者通常不在测试现场。因而，β测试是在开发者无法控制的环境下进行的软件现场应用。在β测试中，由用户记下遇到的所有问题，包括真实的以及主观认定的，定期向开发者报告。β测试主要衡量产品的功能、局域化、可使用性、可靠性、性能和支持，着重于产品的支持性，包括文档，客户培训和支持产品生产能力。\n区别：\n\nAlpha测试是软件开发公司组织内部人员模拟各类用户对即将面市软件产品进行测试，试图发现错误并修正。Beta测试是一种验收测试，一般根据产品说明书严格检查产品，确保所开发的软件产品符合用户的各项要求。\nAlpha测试是由一个用户在开发环境下进行的测试，也可以是公司内部的用户在模拟实际操作环境下进行的测试。Beta测试是由软件的多个用户在实际使用环境下进行的测试，这些用户返回有关错误信息给开发者。Beta测试是在开发者无法控制的环境下进行的软件现场应用。\n\n","categories":["产品理论"],"tags":["技术思维-测试常识"]},{"title":"什么是灰度测试","url":"/2023/08/31/%E4%BA%A7%E5%93%81%E7%90%86%E8%AE%BA/%E6%8A%80%E6%9C%AF%E6%80%9D%E7%BB%B4/%E6%B5%8B%E8%AF%95%E5%B8%B8%E8%AF%86/8_%E4%BB%80%E4%B9%88%E6%98%AF%E7%81%B0%E5%BA%A6%E6%B5%8B%E8%AF%95/","content":"灰度测试，就是在某项产品或应用正式发布前，选择特定人群试用，逐步扩大其试用者数量，以便及时发现和纠正其中的问题，由“灰”到“黑”。\n","categories":["产品理论"],"tags":["技术思维-测试常识"]},{"title":"什么是A、B测试","url":"/2023/08/31/%E4%BA%A7%E5%93%81%E7%90%86%E8%AE%BA/%E6%8A%80%E6%9C%AF%E6%80%9D%E7%BB%B4/%E6%B5%8B%E8%AF%95%E5%B8%B8%E8%AF%86/7_%E4%BB%80%E4%B9%88%E6%98%AFA%E3%80%81B%E6%B5%8B%E8%AF%95/","content":"A&#x2F;B测试（也称为分割测试或桶测试），是一种将网页或应用程序的两个版本相互比较以确定哪个版本的性能更好的方法。AB测试本质上是一个实验，其中页面的两个或多个变体随机显示给用户，统计分析确定哪个变体对于给定的转换目标（指标如CTR）效果更好。\n","categories":["产品理论"],"tags":["技术思维-测试常识"]},{"title":"Android和iOS技术特点","url":"/2023/08/31/%E4%BA%A7%E5%93%81%E7%90%86%E8%AE%BA/%E6%8A%80%E6%9C%AF%E6%80%9D%E7%BB%B4/%E7%A7%BB%E5%8A%A8%E7%AB%AF%E6%8A%80%E6%9C%AF/1_Android%E5%92%8CiOS%E6%8A%80%E6%9C%AF%E7%89%B9%E7%82%B9/","content":"Android和iOS技术差异对比：\n移动端的基本三要素：页面、控件、操作Android及iOS基础控件：UI控件是指构成产品界面的基本元素，根据作用及操作的不同，区分为不同种类\n页面控件规则：\n\n大小\n位置\n外观（内容）\n\n页面布局：各种UI控件按照一定的布局规则组合在一起，构成一个独立的产品界面\n页面操作的实现原理：\n","categories":["产品理论"],"tags":["技术思维-移动端技术"]},{"title":"客户端数据缓存机制","url":"/2023/08/31/%E4%BA%A7%E5%93%81%E7%90%86%E8%AE%BA/%E6%8A%80%E6%9C%AF%E6%80%9D%E7%BB%B4/%E7%A7%BB%E5%8A%A8%E7%AB%AF%E6%8A%80%E6%9C%AF/4_%E5%AE%A2%E6%88%B7%E7%AB%AF%E6%95%B0%E6%8D%AE%E7%BC%93%E5%AD%98%E6%9C%BA%E5%88%B6/","content":"什么是缓存？缓存是一种临时存储机制，目的是用来提升数据加载过程中的速度和使用体验\n缓存级别缓存通常分为一级缓存和二级缓存，一级缓存指手机中的内存，空间较小；二级缓存是指硬盘存储，空间较大\n\n内存读取速度快，空间共享，数据临时性存储\n硬盘空间独享，数据可永久性存储\n\n设计合理的缓存机制，能极大提升产品的使用体验\n","categories":["产品理论"],"tags":["技术思维-移动端技术"]},{"title":"什么是性能测试","url":"/2023/08/31/%E4%BA%A7%E5%93%81%E7%90%86%E8%AE%BA/%E6%8A%80%E6%9C%AF%E6%80%9D%E7%BB%B4/%E6%B5%8B%E8%AF%95%E5%B8%B8%E8%AF%86/4_%E4%BB%80%E4%B9%88%E6%98%AF%E6%80%A7%E8%83%BD%E6%B5%8B%E8%AF%95/","content":"性能测试是通过自动化的测试工具模拟多种正常、峰值以及异常负载条件来对系统的各项性能指标进行测试。负载测试和压力测试都属于性能测试，两者可以结合进行。\n\n通过负载测试，确定在各种工作负载下系统的性能，目标是测试当负载逐渐增加时，系统各项性能指标的变化情况。\n压力测试是通过确定一个系统的瓶颈或者不能接受的性能点，来获得系统能提供的最大服务级别的测试。\n\n","categories":["产品理论"],"tags":["技术思维-测试常识"]},{"title":"原生开发、Web开发和混合开发","url":"/2023/08/31/%E4%BA%A7%E5%93%81%E7%90%86%E8%AE%BA/%E6%8A%80%E6%9C%AF%E6%80%9D%E7%BB%B4/%E7%A7%BB%E5%8A%A8%E7%AB%AF%E6%8A%80%E6%9C%AF/2_%E5%8E%9F%E7%94%9F%E5%BC%80%E5%8F%91%E3%80%81Web%E5%BC%80%E5%8F%91%E5%92%8C%E6%B7%B7%E5%90%88%E5%BC%80%E5%8F%91/","content":"原生开发原生开发（Native App开发），是在Android、iOS等移动平台上利用官方提供的开发语言、开发类库、开发工具进行App开发。比如Android是利用Java、Eclipse、Android studio；iOS是利用Objective-C和Xcode进行开发。\n优点：\n\n可访问手机所有功能（如GPS、摄像头等）、可实现功能最齐全\n运行速度快、性能高，绝佳的用户体验\n支持大量图形和动画，不卡顿，反应快\n兼容性高，每个代码都经过程序员精心设计，一般不会出现闪退的情况，还能防止病毒和漏洞的出现\n比较快捷地使用设备端提供的接口，处理速度上有优势\n\n缺点：\n\n开发时间长，快则3个月左右完成，慢则五个月左右\n制作费用高昂，成本较高\n可移植性比较差，一款原生的App，Android和IOS都要各自开发，同样的逻辑、界面要写两套\n内容限制（App Store限制）\n必须等下载完毕用户才可以打开，获得新版本时需重新下载应用更新\n新需求迭代，上线慢\n\nWeb开发（HTML5）HTML5应用开发，是利用Web技术进行的App开发，可以在手机端浏览器里面打开的网站就称之为webapp。Web技术本身需要浏览器的支持才能进行展示和用户交互，因此主要用到的技术是HTML、CSS、Javascript以及jQuery、Vue、React等JS框架。\n优点：\n\n支持设备范围广，可以跨平台，编写的代码可以同时在Android、IOS、Windows上运行\n开发成本低、周期短\n无内容限制\n适合展示有大段文字（如新闻、攻略等），且格式比较丰富（如加粗，字体多样）的页面\n用户可以直接使用最新版本（自动更新，不需用户手动更新）\n\n缺点：\n\n由于Web技术本身的限制，H5移动应用不能直接访问设备硬件和离线存储，所以在体验和性能上有很大的局限性\n对联网要求高，离线不能做任何操作\n功能有限\nAPP反应速度慢，页面切换流畅性较差\n图片和动画支持性不高\n用户体验感较差\n无法调用手机硬件（摄像头、麦克风等）\n\n混合开发（还有flutter等）混合开发（Hybrid App开发），是指在开发一款App产品的时候，为了提高效率、节省成本而利用原生与H5的开发技术的混合应用。通俗点来说，这就是网页的模式，通常由“HTML5云网站+APP应用客户端”两部份构成。 混合开发是一种取长补短的开发模式，原生代码部分利用WebView插件或者其它框架为H5提供容器，程序主要的业务实现、界面展示都是利用与H5相关的Web技术进行实现的。比如京东、淘宝、今日头条等APP都是利用混合开发模式而成的。\nFlutter是一款移动应用程序SDK，一份代码可以同时生成iOS和Android两个高性能、高保真的应用程序。 目前不少中小型企业已经开始大量使用。\n优点：\n\n开发效率高，节约时间。同一套代码Android和IOS基本上都可使用\n更新和部署比较方便，每次升级版本只需要在服务器端升级即可，不再需要上传到App Store进行审核\n代码维护方便、版本更新快，节省产品成本\n比web版实现功能多\n可离线运行\n\n缺点：\n\n功能&#x2F;界面无法自定：所有内容都是固定的，不能换界面或增加功能\n加载缓慢&#x2F;网络要求高：混合APP数据需要全部从服务器调取，每个页面都需要重新下载，因此打开速度慢，网络占用高，缓冲时间长，容易让用户反感\n安全性比较低：代码都是以前的老代码，不能很好地兼容最新手机系统，且安全性较低，网络发展这么快，病毒这么多，如果不实时更新，定期检查，容易产生漏洞，造成直接经济损失\n\n混合开发App中如何辨别原生和H5\n看加载的方式：如果在打开新页面导航栏下面有一条加载的线的话，这个页面就是H5页面，如果没有就是原生的。 微信里面打开我们的H5页面常见的有个绿色的加载线条。\n看App顶部导航栏是否会有关闭的操作：如果APP顶部导航栏当中出现了关闭按钮或者有关闭的图标，那么当前的页面肯定的H5，原生的不会出现（除非设计开发者故意弄的），美团的、大众点评的APP、微信APP当加载h5过多的时候，左上角会出现关闭二字。\n\n","categories":["产品理论"],"tags":["技术思维-移动端技术"]},{"title":"手机传感器的应用","url":"/2023/08/31/%E4%BA%A7%E5%93%81%E7%90%86%E8%AE%BA/%E6%8A%80%E6%9C%AF%E6%80%9D%E7%BB%B4/%E7%A7%BB%E5%8A%A8%E7%AB%AF%E6%8A%80%E6%9C%AF/3_%E6%89%8B%E6%9C%BA%E4%BC%A0%E6%84%9F%E5%99%A8%E7%9A%84%E5%BA%94%E7%94%A8/","content":"传感器是内置在手机中的一些具备感知能力的硬件设备，可用来实现软件功能（例如计步器、摇一摇）\n传感器分类：\n手机是如何定位的？手机可通过GPS、基站、Wi-Fi实现定位功能\n\nGPS通过连接卫星获取参照位置具体经纬度，通常会做一些位移\n基站都是固定的，手机获取基站信号时可以定位位置\nWi-Fi通过获取无线路由器的MAC地址实现位置经纬度获取\n\n","categories":["产品理论"],"tags":["技术思维-移动端技术"]},{"title":"客户端消息推送","url":"/2023/08/31/%E4%BA%A7%E5%93%81%E7%90%86%E8%AE%BA/%E6%8A%80%E6%9C%AF%E6%80%9D%E7%BB%B4/%E7%A7%BB%E5%8A%A8%E7%AB%AF%E6%8A%80%E6%9C%AF/7_%E5%AE%A2%E6%88%B7%E7%AB%AF%E6%B6%88%E6%81%AF%E6%8E%A8%E9%80%81/","content":"客户端获取服务端消息的方式：\n\n客户端发起请求访问服务端，服务端返回消息\n服务端向客户端推送消息\n\n消息推送：服务端主动向客户端发送消息的机制\n推送原理：实现消息推送的三种方式（主动轮询、建立长连接、心跳消息）\n消息推送服务器：\n","categories":["产品理论"],"tags":["技术思维-移动端技术"]},{"title":"微信小程序的技术特点及应用","url":"/2023/08/31/%E4%BA%A7%E5%93%81%E7%90%86%E8%AE%BA/%E6%8A%80%E6%9C%AF%E6%80%9D%E7%BB%B4/%E7%A7%BB%E5%8A%A8%E7%AB%AF%E6%8A%80%E6%9C%AF/6_%E5%BE%AE%E4%BF%A1%E5%B0%8F%E7%A8%8B%E5%BA%8F%E7%9A%84%E6%8A%80%E6%9C%AF%E7%89%B9%E7%82%B9%E5%8F%8A%E5%BA%94%E7%94%A8/","content":"微信小程序介绍和特点：小程序是一种新的开放能力，开发者可以快速的开发一个小程序，小程序可以在微信内被便捷的获取和传播，同时具有出色的使用体验\n小程序是基于微信生态的一种应用程序开放平台，基于微信环境，跨平台支持\n\n依托于微信运行，无法单独在手机操作系统环境内运行\n可基于微信的关系链进行传播，例如微信好友和微信群\n有自己的开发环境和发布机制，并且有小程序独特的开发语言\n可调用微信原生基础组件，例如地图和多媒体支持等\n小程序无法主动向用户推送消息\n\n微信小程序使用的开发语言：基于HTML、CSS、JavaScript技术，衍生出WXML、WXSS、WXS\n\nWXML（WeiXin Markup Language）：是小程序框架设计的一套标签语言，可用来构建小程序页面结构\nWXSS（WeiXin Style Sheets）：是一套样式语言，用于描述WXML的组件样式\nWXS（WeiXin Script）：是小程序的一套脚本语言，结合WXML，可以构建出页面的结构，并处理页面交互\n\n微信小程序与APP对比：\n","categories":["产品理论"],"tags":["技术思维-移动端技术"]},{"title":"什么是React Native技术","url":"/2023/08/31/%E4%BA%A7%E5%93%81%E7%90%86%E8%AE%BA/%E6%8A%80%E6%9C%AF%E6%80%9D%E7%BB%B4/%E7%A7%BB%E5%8A%A8%E7%AB%AF%E6%8A%80%E6%9C%AF/5_%E4%BB%80%E4%B9%88%E6%98%AFReact%20Native%E6%8A%80%E6%9C%AF/","content":"什么是React Native？React Native是一种轻量级的前端技术，适合快速开发、快速上线，无需重复发版\nReact Native的优势？\nReact Native的应用场景？适合的场景：\n\n资讯类产品，例如信息流和瀑布流\n动态运营类模块较多的产品，例如电商\n\n不太适合的场景：\n\n对首次加载速度要求较高的产品\n工具类产品，对效率体验要求较高的产品\n\n","categories":["产品理论"],"tags":["技术思维-移动端技术"]},{"title":"冷更新、热更新","url":"/2023/08/31/%E4%BA%A7%E5%93%81%E7%90%86%E8%AE%BA/%E6%8A%80%E6%9C%AF%E6%80%9D%E7%BB%B4/%E7%A7%BB%E5%8A%A8%E7%AB%AF%E6%8A%80%E6%9C%AF/8_%E5%86%B7%E6%9B%B4%E6%96%B0%E3%80%81%E7%83%AD%E6%9B%B4%E6%96%B0/","content":"冷更新指在用户关闭App后再进行更新。冷更新相对简单一些，因为没有运行时的问题需要考虑，但是也要考虑如何管理版本，以及如何处理不同版本之间的兼容性问题。\n热更新指的是在App运行时进行更新。对于热更新，需要考虑如何在不影响用户体验的情况下进行更新，因此要涉及到一些复杂的逻辑，以及如何处理代码冲突和兼容性问题。\n","categories":["产品理论"],"tags":["技术思维-移动端技术"]},{"title":"区块链技术原理及应用","url":"/2023/08/31/%E4%BA%A7%E5%93%81%E7%90%86%E8%AE%BA/%E6%8A%80%E6%9C%AF%E6%80%9D%E7%BB%B4/%E6%96%B0%E6%8A%80%E6%9C%AF/3_%E5%8C%BA%E5%9D%97%E9%93%BE%E6%8A%80%E6%9C%AF%E5%8E%9F%E7%90%86%E5%8F%8A%E5%BA%94%E7%94%A8/","content":"什么是区块链？区块链是一个去中心化的分布式数据库技术，运用到了密码学、点对点传输、共识机制，区块链的一个具体应用就是比特币，每隔一段时间后全网会统计一次交易信息并打包在一个“区块中”，然后这些不同时间点的区块首尾相连形成链条，所以叫区块链\n去中心化去中心化是指没有唯一的中心化节点，形成“多中心化”的布局，支付宝是中心化、比特币是去中心化、银行是分布式\n共识机制在比特币交易中，一笔交易完成后会通知全网，不同的节点开始记账，当一定的节点都完成记账后，网络共识完成，这笔记账就成功，给成功记账的人发一笔奖励，记账的过程就叫做“挖矿”，或者“工作量证明”（POW），奖励就是“比特币”\n区块、链、比特币\n区块链技术应用区块链技术特点：本质上解决的是“信任问题”\n\n不可篡改\n全程可追溯\n去中心化存储\n\n应用领域：\n\n商品溯源\n信用存证\n金融交易\n\n","categories":["产品理论"],"tags":["技术思维-新技术"]},{"title":"AR、VR技术原理及应用","url":"/2023/08/31/%E4%BA%A7%E5%93%81%E7%90%86%E8%AE%BA/%E6%8A%80%E6%9C%AF%E6%80%9D%E7%BB%B4/%E6%96%B0%E6%8A%80%E6%9C%AF/2_AR%E3%80%81VR%E6%8A%80%E6%9C%AF%E5%8E%9F%E7%90%86%E5%8F%8A%E5%BA%94%E7%94%A8/","content":"增强现实ARAR（Augmented Reality）全称叫增强现实技术，是指通过实时计算物理空间和角度，通过视频、动画、3D模型技术呈现现实中不存在的虚拟场景\nAR应用场景游戏、医疗、场景营销，AR产品化主要是寻找应用场景，将技术融合到现实场景中去\n虚拟现实VRVR（Virtual Reality）虚拟现实技术是一种能创造虚拟环境的仿真技术，通过3D立体图像、声音和触觉等多感官互动的方式，为用户营造身临其境的感觉\n体验虚拟现实通常需要借助外部设备，例如头盔眼镜，以及一些手持设备\nAR与VR的区别：\n","categories":["产品理论"],"tags":["技术思维-新技术"]},{"title":"AI技术原理及应用","url":"/2023/08/31/%E4%BA%A7%E5%93%81%E7%90%86%E8%AE%BA/%E6%8A%80%E6%9C%AF%E6%80%9D%E7%BB%B4/%E6%96%B0%E6%8A%80%E6%9C%AF/1_AI%E6%8A%80%E6%9C%AF%E5%8E%9F%E7%90%86%E5%8F%8A%E5%BA%94%E7%94%A8/","content":"人工智能人工智能（Artificial Intelligence）是计算机科学的一个分支，主要用来为机器赋予一定的自主判断能力，最早在上世纪四五十年代就被提出，近几年随着技术的发展、尤其是计算能力的提高，AI再次得到巨大发展和应用\nAI技术可运用的领域非常多，包括了人脸识别、自动驾驶、智能机器人等\nAI包含的技术：人工智能技术包括了常用的机器学习、模式识别、深度学习等\n人类学习 vs 机器学习人类学习是通过外界的知识和实践获取从而转化为经验的过程，机器学习是通过大量数据的输入并通过算法构建模型，并形成机器判断的过程\n程序执行与机器学习的区别：\nAI的应用AI的关键在于数据、算法、应用场景\nAI未来应用的领域非常多，需要产品经理懂业务、懂数据、能设计应用方案\n","categories":["产品理论"],"tags":["技术思维-新技术"]},{"title":"5G技术原理及应用","url":"/2023/08/31/%E4%BA%A7%E5%93%81%E7%90%86%E8%AE%BA/%E6%8A%80%E6%9C%AF%E6%80%9D%E7%BB%B4/%E6%96%B0%E6%8A%80%E6%9C%AF/4_5G%E6%8A%80%E6%9C%AF%E5%8E%9F%E7%90%86%E5%8F%8A%E5%BA%94%E7%94%A8/","content":"什么是5G？5G（5th-Generation）：第五代通讯网络，对应3G、4G，是通讯技术的一次整体升级，速度更快是直观感受\n5G技术带来的产品变革使得原本受制于网速的技术应用有大规模使用的可能，例如自动驾驶、人工智能、物联网\n技术变革对产品经理的启示社会的发展源于技术的发展，每一次技术的发展都会带来行业发展和风口性机会，3G和4G技术的发展，催生了移动互联网的出现，带动了各个领域的产品升级，下一次技术升级势必也会带来产品形态的升级\n对产品经理而言：\n\n对技术发展保持敏感\n探索新技术下新的应用场景\n创新产品解决方案\n\n","categories":["产品理论"],"tags":["技术思维-新技术"]},{"title":"macOS终端ssh远程连接Ubuntu server","url":"/2021/05/31/%E8%AE%A1%E7%AE%97%E6%9C%BA%E7%90%86%E8%AE%BA/Apple+Linux/macOS/4_macOS%E7%BB%88%E7%AB%AFssh%E8%BF%9C%E7%A8%8B%E8%BF%9E%E6%8E%A5Ubuntu%20server/","content":"原因：\n\nUbuntu server虚拟机界面实在是不如Mac终端好操作\nLinux下的命令与UNIX很多不一样，无法直接在macOS下学习Linux\n\n步骤：\n\nUbuntu系统默认安装了openssh-client，但没有安装openssh-server，先检查一下(ps -e | grep ssh)\n\n安装openssh-server：sudo apt-get install openssh-server\n\n如果出现sshd，代表安装成功【sudo &#x2F;etc&#x2F;init.d&#x2F;ssh start启动服务】\n\nifconfig -a查看IP地址\n\nssh 用户名@IP地址\n\n\n","categories":["计算机理论"],"tags":["Apple+Linux-macOS"]},{"title":"廖家龙的博客网站更新、搭建步骤","url":"/2024/03/06/%E8%AE%A1%E7%AE%97%E6%9C%BA%E7%90%86%E8%AE%BA/Apple+Linux/macOS/1_%E5%BB%96%E5%AE%B6%E9%BE%99%E7%9A%84%E5%8D%9A%E5%AE%A2%E7%BD%91%E7%AB%99%E6%9B%B4%E6%96%B0%E3%80%81%E6%90%AD%E5%BB%BA%E6%AD%A5%E9%AA%A4/","content":"更新步骤：复制终端代理命令将hexo-theme-keep文件夹移动到别处cd /Users/liaojialong/Desktop/廖家龙的博客网站/themesgit clone https://github.com/XPoet/hexo-theme-keep.git更新_config.yml、footer.ejs文件//安装必备插件cd /Users/liaojialong/Desktop/廖家龙的博客网站npm install hexo-wordcount //文章字数统计、计算阅读时长npm install hexo-generator-searchdb //站内搜索npm install hexo-generator-feed //rsshexo cleanhexo ghexo d\n\n崩溃后快速搭建步骤：复制终端代理命令cd /Users/liaojialong/Desktophexo init 廖家龙的博客网站cd /Users/liaojialong/Desktop/廖家龙的博客网站npm installhexo server可查看初始化效果替换_config.yml文件和source文件夹，粘贴hexo-theme-keep文件夹npm install hexo-deployer-git --save //安装git部署插件//安装必备插件cd /Users/liaojialong/Desktop/廖家龙的博客网站npm install hexo-wordcount //文章字数统计、计算阅读时长npm install hexo-generator-searchdb //站内搜索npm install hexo-generator-feed //rsshexo cleanhexo ghexo d\n\n完整搭建步骤：","categories":["计算机理论"],"tags":["Apple+Linux-macOS"]},{"title":"iPhone各型号逻辑分辨率和物理分辨率","url":"/2024/01/01/%E8%AE%A1%E7%AE%97%E6%9C%BA%E7%90%86%E8%AE%BA/Apple+Linux/iPadOS+iOS+watchOS/2.1_iPhone%E5%90%84%E5%9E%8B%E5%8F%B7%E9%80%BB%E8%BE%91%E5%88%86%E8%BE%A8%E7%8E%87%E5%92%8C%E7%89%A9%E7%90%86%E5%88%86%E8%BE%A8%E7%8E%87/","content":"\n状态栏高度、导航栏高度、安全区域、tabBar高度、底部小横条区域、底部安全距离\n\n逻辑分辨率和物理分辨率的区别？\n\n我们以Mac的发展史来说明什么是物理分辨率？以及为什么需要衍生出逻辑分辨率？\n我们的主人公是乔帮主和比尔盖茨，此时乔帮主面前有一台Mac，屏幕的分辨率是1280x720，这就是物理分辨率。乔帮主对比尔盖茨说，给我的Mac开发一个Word软件吧。盖茨说OK，于是写了一个软件，这个软件显示的时候长度是1280像素，宽度是720像素，正好能够盖满整个Mac屏幕，乔帮主看了之后很满意。有一天，乔帮主看自己的Mac屏幕觉得很粗糙，一点都不清晰锐利，于是聪明的乔帮主想到，同样是15寸的屏幕，我把像素点翻倍不就可以更清晰了吗？于是他把Mac的物理分辨率改成了2560x1440的分辨率，相当于每个像素点的尺寸减少了4倍，这下再也看不出颗粒感了，乔帮主很满意。但是当乔帮主打开盖茨给他写的Word的时候，傻眼了，原本全屏的Word现在只占屏幕的四分之一，而且文字非常的小，乔帮主打电话给盖茨说，你的软件怎么出问题了？盖茨回答说，我开发的时候你的Mac分辨率就是1280x720，你自己改了硬件尺寸怪我咯，我很忙没空给你改软件代码，你就凑合着用吧。乔帮主稍作思考，马上想出了一个非常聪明的主意！他在软件和硬件之间的系统层加了一层逻辑分辨率。虽然屏幕横向有2560个像素点，但是告诉软件我只有1280个像素点！当word的宽度要占1280个像素的时候，实际上已经占了2560个像素。于是我们的Word又占满屏幕了！于是乔帮主把这个机智的想法命名为逻辑分辨率，不管我的显示器的硬件有多少个像素点，我只会告诉软件我的逻辑分辨率，这样软件的代码就不用修改也能在不同的屏幕上显示效果一致。在多年后，Mac的物理分辨率已经达到了5120x2880，但是告诉软件的时候还是说我的分辨率是1280x720，相当在盖茨看来的一个逻辑像素点，背后实际上已经有16个物理像素点为其工作了！\n\n\n\n\n\n\niPhone型号\n逻辑分辨率\n物理分辨率\n\n\n\niPhone 3Gs\n320*480\n\n\n\niPhone 4\n320*480\n\n\n\niPhone 4s\n320*480\n\n\n\niPhone 5\n320*568\n\n\n\niPhone 5c\n320*568\n\n\n\niPhone 5s\n320*568\n\n\n\niPhone SE一代\n320*568\n\n\n\niPhone 6\n375*667\n\n\n\niPhone 6s\n375*667\n\n\n\niPhone 6 Plus\n414*736\n\n\n\niPhone 6s Plus\n414*736\n\n\n\niPhone 7\n375*667\n\n\n\niPhone 7 Plus\n414*736\n\n\n\niPhone 8\n375*667\n\n\n\niPhone 8 Plus\n414*736\n\n\n\niPhone X\n375*812\n\n\n\niPhone XR\n414*896\n\n\n\niPhone XS\n375*812\n\n\n\niPhone XS Max\n414*896\n\n\n\niPhone 11\n414*896\n\n\n\niPhone 11 Pro\n375*812\n\n\n\niPhone 11 Pro Max\n414*896\n\n\n\niPhone SE二代\n375*667\n\n\n\niPhone 12 mini\n375*812\n\n\n\niPhone 12\n390*844\n\n\n\niPhone 12 Pro\n390*844\n\n\n\niPhone 12 Pro Max\n428*926\n\n\n\niPhone 13 mini\n375*812\n\n\n\niPhone 13\n390*844\n\n\n\niPhone 13 Pro\n390*844\n\n\n\niPhone 13 Pro Max\n428*926\n\n\n\niPhone 14\n390*844\n\n\n\niPhone 14 Plus\n428*926\n\n\n\niPhone 14 Pro\n393*852\n\n\n\niPhone 14 Pro Max\n430*932\n\n\n\n","categories":["计算机理论"],"tags":["Apple+Linux-iPadOS+iOS+watchOS"]},{"title":"macOS的一些使用小技巧","url":"/2021/05/31/%E8%AE%A1%E7%AE%97%E6%9C%BA%E7%90%86%E8%AE%BA/Apple+Linux/macOS/3_macOS%E7%9A%84%E4%B8%80%E4%BA%9B%E4%BD%BF%E7%94%A8%E5%B0%8F%E6%8A%80%E5%B7%A7/","content":"\n在任意输入框中按option+shift+K组合键会显示苹果logo\n文本编辑中按Fn+Delete键可向后删除内容\nFinder+菜单栏中的前往+一直按住option，打开资源库\n终端输入sudo spctl —master-disable命令打开【安全性与隐私】中的【任何来源】\n隐藏和恢复桌面文件：\n\n\n隐藏桌面文件：defaults write com.apple.finder CreateDesktop -bool false;killall Finder \n恢复显示桌面文件：defaults write com.apple.finder CreateDesktop -bool true;killall Finder\n\n\n快速调用emoji表情：control+command+空格\nCheatSheet:长按command键可显示当前应用所有的快捷键\n调整launchpad图标大小： \n改行数：defaults write com.apple.dock springboard-rows -int 10 \n改列数：defaults write com.apple.dock springboard-columns int 7 \nkillall Dock\n\n\n\n恢复系统默认： \n\ndefaults write com.apple.dock springboard-rows Default \ndefaults write com.apple.dock springboard-columns Default \nkillall Dock\n\n\n移动文件：打开源文件夹和目标文件夹，拖拽源文件到目标文件夹拷贝文件：按住option，拖拽源文件到目标文件夹 \n全屏截图：command+shift+3截取部分屏幕：command+shift+4\n回到桌面：command+F3\n\n","categories":["计算机理论"],"tags":["Apple+Linux-macOS"]},{"title":"Markdown教程","url":"/2021/05/31/%E8%AE%A1%E7%AE%97%E6%9C%BA%E7%90%86%E8%AE%BA/Apple+Linux/macOS/6_Markdown%E6%95%99%E7%A8%8B/","content":"Markdown介绍Markdown是一种轻量级标记语言，它允许人们使用易读易写的纯文本格式编写文档\nMarkdown编写的文档可以导出HTML、Word、图像、PDF、Epub等多种格式的文档\nMarkdown编写的文档后缀为.md、.markdown\nmacOS系统推荐使用Typora编辑器\nMarkdown标题使用#号可表示1～6级标题，一级标题对应一个#号，二级标题对应两个#号，以此类推\n# 一级标题\n## 二级标题\n### 三级标题\n#### 四级标题\n##### 五级标题\n###### 六级标题\nMarkdown段落格式字体Markdown可以使用以下几种字体：\n斜体文本斜体文本粗体文本粗体文本粗斜体文本粗斜体文本\n分隔线可以在一行中用三个以上的星号、减号来建立一个分隔线，行内不能有其他东西\n删除线如果段落上的文字要添加删除线，只需要在文字的两端加上两个波浪线~~即可：删除的文本\n下划线下划线可以通过HTML的&lt;u&gt;标签来实现：带下划线文本\n脚注脚注是对文本的补充说明\n王者荣耀^ 注释\nMarkdown列表Markdown支持有序列表和无序列表无序列表使用星号*、加号+或者减号-作为列表标记，这些标记后面要添加一个空格，然后再填写内容\n\n第一项\n第二项\n\n\n第一项\n第二项\n\n\n第一项\n第二项\n\n有序列表使用数字并加上.号来表示\n\n第一项\n第二项\n\n列表嵌套列表嵌套只需在子列表中的选项前面添加四个空格即可\n\n第一项\n第一项嵌套的第一个元素\n第一项嵌套的第二个元素\n\n\n第二项\n第二项嵌套的第一个元素\n第二项嵌套的第二个元素\n\n\n\nMarkdown区块区块引用Markdown区块引用是在段落开头使用&gt;符号，然后后面紧跟一个空格符号\n\n区块引用一\n区块引用二\n\n区块嵌套另外区块也是可以嵌套的，一个&gt;符号是最外层，两个&gt;符号是第一层嵌套，以此类推\n\n最外层\n\n第一层嵌套\n\n第二层嵌套\n\n\n\n区块中使用列表\n区块中使用列表\n\n第一项\n第二项\n\n\n第一项\n第二项\n\n\n列表中使用区块如果要在列表项目内放进区块，那么就需要在&gt;前添加四个空格的缩进\n\n第一项\n\n区块一\n区块二\n\n\n第二项\n\n\nMarkdown代码如果是段落上的一个函数或片段的代码可以用反引号把它包起来\nprint(&#39;hello&#39;)\n代码区块可以指定一种语言\n#include&lt;stdio.h&gt;int main() &#123;  printf(&quot;hello&quot;);&#125;\n\nMarkdown链接[链接名称](链接地址)\n&lt;链接地址&gt;\n百度\nhttps://www.baidu.com\n高级链接我们可以通过变量来设置一个链接，变量赋值在文档末尾进行\n这个链接用 1 作为网址变量 [Google][1]这个链接用 runoob 作为网址变量 [Runoob][runoob]然后在文档的结尾为变量赋值（网址）  [1]: http://www.google.com/  [runoob]: http://www.runoob.com/\n\n这个链接用 1 作为网址变量 Google这个链接用 runoob 作为网址变量 Runoob然后在文档的结尾为变量赋值（网址）\nMarkdown图片![alt 属性文本](图片地址)![alt 属性文本](图片地址 &quot;可选标题&quot;)\n\n\nMarkdown还没办法指定图片的高度和宽度，如果需要的话，可以使用普通的标签\n\n\nMarkdown表格Markdown制作表格使用|来分隔不同的单元格\n| 表头 | 表头 |\n\n\n\n表头\n表头\n\n\n\n单元格\n单元格\n\n\n单元格\n单元格\n\n\nMarkdown高级技巧支持的HTML元素不在Markdown涵盖范围之内的标签，都可以直接在文档里面用HTML撰写，目前支持的HTML元素有&lt;kbd&gt;、&lt;b&gt;、&lt;i&gt;、&lt;em&gt;、&lt;sup&gt;、&lt;sub&gt;、&lt;br&gt;等\n使用Ctrl + Alt + Del 重启电脑\n转义Markdown使用了很多特殊符号来表示特定的意义，如果需要显示特定的符号则需要使用转义字符，Markdown使用反斜杠转义特殊字符\n文本加粗\n** 正常显示星号 **\nMarkdown支持以下这些符号前面加上反斜杠来帮助插入普通的符号：\n\\   反斜线`   反引号*   星号_   下划线&#123;&#125;  花括号[]  方括号()  小括号#   井字号+   加号-   减号.   英文句点!   感叹号\n\n公式当你需要在编辑器中插入数学公式时，可以使用两个美元符$$包裹TeX或LaTeX格式的数学公式来实现，提交后，问答和文章页会根据需要加载Mathjax对数学公式进行渲染\n$$\\mathbf&#123;V&#125;_1 \\times \\mathbf&#123;V&#125;_2 =  \\begin&#123;vmatrix&#125; \\mathbf&#123;i&#125; &amp; \\mathbf&#123;j&#125; &amp; \\mathbf&#123;k&#125; \\\\\\frac&#123;\\partial X&#125;&#123;\\partial u&#125; &amp;  \\frac&#123;\\partial Y&#125;&#123;\\partial u&#125; &amp; 0 \\\\\\frac&#123;\\partial X&#125;&#123;\\partial v&#125; &amp;  \\frac&#123;\\partial Y&#125;&#123;\\partial v&#125; &amp; 0 \\\\\\end&#123;vmatrix&#125;$&#123;$tep1&#125;&#123;\\style&#123;visibility:hidden&#125;&#123;(x+1)(x+1)&#125;&#125;$$\n\n$$\\mathbf{V}_1 \\times \\mathbf{V}_2 &#x3D;  \\begin{vmatrix}\\mathbf{i} &amp; \\mathbf{j} &amp; \\mathbf{k} \\\\frac{\\partial X}{\\partial u} &amp;  \\frac{\\partial Y}{\\partial u} &amp; 0 \\\\frac{\\partial X}{\\partial v} &amp;  \\frac{\\partial Y}{\\partial v} &amp; 0 \\\\end{vmatrix}${$tep1}{\\style{visibility:hidden}{(x+1)(x+1)}}$$\n","categories":["计算机理论"],"tags":["Apple+Linux-macOS"]},{"title":"本地项目上传至GitHub","url":"/2021/05/31/%E8%AE%A1%E7%AE%97%E6%9C%BA%E7%90%86%E8%AE%BA/Apple+Linux/macOS/5_%E6%9C%AC%E5%9C%B0%E9%A1%B9%E7%9B%AE%E4%B8%8A%E4%BC%A0%E8%87%B3GitHub/","content":"首次使用1. 配置SSH   cd 项目文件夹   git init   ssh-keygen -t rsa -C &quot;2668802570@qq.com&quot;   pbcopy &lt; ~/.ssh/id_rsa.pub  #将ssh代码复制到剪贴板   回到GitHub界面，将刚才生成的ssh配置到GitHub里   ssh -T git@github.com  #验证是否添加ssh成功了2. 开始上传代码   git clone 仓库地址   cd 仓库   git add --all   git commit -m &quot;第1次上传&quot;   git push\n\n以后使用cd 项目文件夹执行步骤2\n","categories":["计算机理论"],"tags":["Apple+Linux-macOS"]},{"title":"Xcode无响应解决方法","url":"/2021/05/31/%E8%AE%A1%E7%AE%97%E6%9C%BA%E7%90%86%E8%AE%BA/Apple+Linux/macOS/7_Xcode%E6%97%A0%E5%93%8D%E5%BA%94%E8%A7%A3%E5%86%B3%E6%96%B9%E6%B3%95/","content":"\n关闭Xcode\n前往/Users/liaojialong/Library/Developer/Xcode/DerivedData路径，将文件夹中的内容全部删除\n将/Users/liaojialong/Library/Saved Application State/com.apple.dt.Xcode.savedState文件夹删除\n清理垃圾，重新启动，打开Xcode\n\n","categories":["计算机理论"],"tags":["Apple+Linux-macOS"]},{"title":"解决Mac安装软件后提示“已损坏，无法打开”问题","url":"/2023/03/09/%E8%AE%A1%E7%AE%97%E6%9C%BA%E7%90%86%E8%AE%BA/Apple+Linux/macOS/2_%E8%A7%A3%E5%86%B3Mac%E5%AE%89%E8%A3%85%E8%BD%AF%E4%BB%B6%E5%90%8E%E6%8F%90%E7%A4%BA%E2%80%9C%E5%B7%B2%E6%8D%9F%E5%9D%8F%EF%BC%8C%E6%97%A0%E6%B3%95%E6%89%93%E5%BC%80%E2%80%9D%E9%97%AE%E9%A2%98/","content":"\n开启“允许任何来源”选项\nsudo spctl --master-disable\n\n如果发现还是显示“已损坏，无法打开”，在终端输入以下命令：\nsudo xattr -r -d com.apple.quarantine /Applications/PicGo.app\n\n\n","categories":["计算机理论"],"tags":["Apple+Linux-macOS"]},{"title":"编写第一个shell脚本","url":"/2021/04/30/%E8%AE%A1%E7%AE%97%E6%9C%BA%E7%90%86%E8%AE%BA/Apple+Linux/Ubuntu%20Server/13_%E7%BC%96%E5%86%99%E7%AC%AC%E4%B8%80%E4%B8%AAshell%E8%84%9A%E6%9C%AC/","content":"shell脚本是一个包含一系列命令的文件，shell读取这个文件，然后执行这些命令，就好像这些命令是直接输入到命令行中一样；shell既是一个强大的命令行接口，也是一个脚本语言解释器，大多数能够在命令行中完成的工作都可以在脚本中完成，反之亦然。\n为了成功创建和运行一个shell脚本，我们需要做三件事：1）编写脚本：shell脚本是普通的文本文件，所以我们需要一个文本编辑器来编辑它，最好文本编辑器可以提供“语法高亮”功能，从而能够看到脚本元素彩色代码视图，“语法高亮”可以定位一些常见的错误2）使脚本可执行：系统相当严格，它不会将任何老式的文本文件当作程序，所以我们需要将脚本文件的权限设置为允许执行3）将脚本放置在shell能够发现的位置：当没有显式指定路径名时，shell会自动的寻找某些目录，来查找可执行文件，为了最大程度的方便，我们将脚本放置在这些目录下\n文本行中，在“#”符号后面的所有内容会被忽略“#!”字符序列是一种特殊的结构，称之为shebang，用来告知操作系统，执行后面的脚本应该使用的解释器的名字，每一个shell脚本都应该将其作为第一行\n可执行权限：对于脚本，有两种常见的权限设置，权限为755的脚本，每个人都可以执行；权限为700的脚本，只有脚本的所有人才能执行，注意，为了能够执行脚本，它必须是可读的\n脚本文件的位置：为了使脚本运行，我们必须显式指定脚本文件的路径\n如果没有显式指定路径，则系统在查找一个可执行程序时，需要搜索一系列目录，这就是当我们在命令行中输入ls时，系统知道要执行&#x2F;bin&#x2F;ls的原因。&#x2F;bin目录是系统会自动搜索的一个目录。\n目录列表存放在名为PATH的环境变量中，这个PATH变量包含一个由冒号分隔开的待搜索目录的列表：\n如果脚本位于该列表中的任何一个目录中，问题就解决了\n这两个命令一样，为了减少输入，当在命令行中输入选项时，短选项更可取，但是在编写脚本时，长选项名可以提高可读性\n缩进和行连接：\n脚本和命令行的一个区别是，脚本可以使用制表符来实现缩进，但在命令行中，Tab键用来激活自动补齐功能\n","categories":["计算机理论"],"tags":["Apple+Linux-Ubuntu Server"]},{"title":"shell是什么","url":"/2021/04/30/%E8%AE%A1%E7%AE%97%E6%9C%BA%E7%90%86%E8%AE%BA/Apple+Linux/Ubuntu%20Server/1_shell%E6%98%AF%E4%BB%80%E4%B9%88/","content":"《Linux命令行大全》\n\ndate：显示当前系统的时间和日期 \n\ncal ：默认情况下显示当月的日历 \n\ndf ：查看磁盘驱动器当前的可用空间 \n\nfree ：显示可用内存 \n\nexit ：结束终端会话（或直接关闭终端窗口）\n\n\n\n（1）shell是一个接收由键盘输入的命令，并将其传递给操作系统来执行的程序 \n（2）当使用图形用户界面时，需要另一种叫做终端仿真器的程序与shell进行交互（KDE环境下使用的是konsole,GNOME环境下使用的是gnome-terminal,但是在桌面菜单上很可能将它们简单的统称为终端） \n（3）shell提示符：username@machinename,其后是当前工作目录(长度更长一些)和一个$符号；如果shell提示符的最后一个字符是#，而不是一个$符号，那么终端会话将享有超级用户特权\n（4）命令历史记录：在默认情况下，大部分Linux发行版本能够存储最近输入的500个命令 \n","categories":["计算机理论"],"tags":["Apple+Linux-Ubuntu Server"]},{"title":"vi的基本使用","url":"/2021/04/30/%E8%AE%A1%E7%AE%97%E6%9C%BA%E7%90%86%E8%AE%BA/Apple+Linux/Ubuntu%20Server/10_vi%E7%9A%84%E5%9F%BA%E6%9C%AC%E4%BD%BF%E7%94%A8/","content":"本文目录\n使用vi的原因\n启动、退出、保存vi\nvi的三种工作模式\n移动光标\n基本编辑 a.撤销命令 b.删除文本 c.剪切、复制和粘贴文本 d.合并行\n查找和替换 a.行内搜索 b.搜索整个文件 c.全局搜索和替换\n编辑多个文件 a.切换文件 b.载入更多的文件 c.文件之间的内容复制 d.插入整个文件\n\n\n使用vi的原因：\nvi总是可用的，如果用户面前的系统没有图形界面，例如是远程服务器或者是本地系统的X配置不可用，那么vi就会成为救命的稻草。POSIX（一种UNIX系统的程序兼容标准）要求系统必须配备有vi\nvi是轻量级的软件，运行速度快。对很多任务来说，启动vi比在菜单中找到一个图形界面编辑器并等待几兆大小的编辑器载入要容易的多。另外，vi的设计还非常利于打字\n用户不想被其他Linux和UNIX用户蔑视\n\n\n启动、退出、保存vi：启动vi：vi 新文件名\n退出、保存vi：\nesc   :w 保存文件但不退出vi   :w file 将修改另外保存到file中，不退出vi（另存为）【此命令在以新名称保存文件的同时，并不更改编辑中的原文件的名称，当用户继续编辑时，编辑的还是原文件而不是新文件】   :w! 强制保存，不退出vi   :wq 保存文件并退出vi   :wq! 强制保存文件，并退出vi   :q 不保存文件，退出vi   :q! 不保存文件，强制退出vi   :e! 放弃所有修改，从上次保存文件开始再编辑   命令模式下输入ZZ 保存当前文档并退出vi\n\n\nvi的三种工作模式：\n如果用户阅读vi的说明文档，会困惑的发现命令模式被称为普通模式，而使用ex命令则被称为命令模式\n\n移动光标（命令模式下）：\nl或右方向键：右移一位\nh或左方向键：左移一位\nj或下方向键：下移一行\nk或上方向键：上移一行\n数字0：至本文开头\n\n\n\n基本编辑：在命令模式下按u键可以撤销用户多步操作\n删除文本（命令模式下）：\nx：当前字符3x：当前字符和之后2个字符\n\n剪切(d)、复制(y)和粘贴(p)文本：\n命令d不只是删除文本，而是在剪切文本，用户每次使用d命令之后，都会复制删除的内容进缓存（类似剪贴板），然后用户就可以使用p命令将缓存中的内容粘贴到光标之后或使用P命令将内容粘贴到光标之前dd：当前行5dd：当前行和之后4行dW：当前字符到下一单词的起始d$：当前字符到当前行的末尾d0：当前字符到当前行的起始d^：当前字符到当前行下一个非空字符dG：当前行到文件末尾d20G：当前行到文件第20行yy：当前行5yy：当前行和之后4行yW：当前字符到下一单词的起始y$：当前字符到当前行的末尾Y0：当前字符到当前行的起始y^：当前字符到当前行下一个非空字符yG：当前行到文件末尾y20G：当前行到文件第20行\n\n合并行(J)：vi在行的概念上非常严格，通常来说，将光标移动到行的末端并删除行的末尾字符并不能将此行与下一行合并\n\n查找和替换:行内搜索：命令f在行内进行搜索，并将光标移至搜索到的下一个指定字符。比如命令fa就会将光标移动到本行下一处出现字符a的地方，在执行过一次行内搜索之后，输入分号可以使vi重复上一次搜索\n搜索整个文件：命令“&#x2F;”可以完成对单词或短语的搜索，当用户使用“&#x2F;”命令后，一个“&#x2F;”符号会出现在屏幕的底部。接下来，输入需要搜索的单词或短语，以Enter结束，光标就会移动到下一处包含被搜索字符串的地方，使用n命令可以重复此搜索\n全局搜素和替换：vi使用ex命令来执行几行之内或者整个文件中的搜索和替换操作\n:%s/Line/line/g    :冒号用于启动一条ex命令    %确定了操作作用的范围，%简洁的代表了从文件的第一行到最后一行（还可以用1,2表示从第一行到第二行），如果不明确指出命令的作用范围，那么命令只会在当前行生效    s指定了具体的操作：替换    /Line/line搜索和替换的文本    g代指global（全局），也就是说对搜索到的每一行的每一个实例进行替换，如果g缺失，那么只替换每一行第一个符合条件的实例          在命令末尾添加c，则命令在每次替换之前都会请求用户确认::%s/Line/line/gc    y：执行替换    n：跳过此次替换    a：执行此次替换和之后的所有替换    q或者ESC：停止替换    l：执行此次替换并退出替换，是last的缩写    Ctrl-E，Ctrl-Y：分别是向下滚动和向上滚动，能用于查看替换处的上下文\n\n\n编辑多个文件:vi file1 file2 file3… 打开多个文件\n\n切换文件： \n:n下一个文件 :N上一个文件\n\n当用户从一个文件切换到另一个的时候，vi要求用户必须先保存对当前文件做出的修改才能切换到其他文件。若要放弃对文件的修改并使vi强制切换到另一个文件，可在命令后添加感叹号！\n:buffers   查看正在编辑的文件列表:buffer 2  切换到文件2\n\n载入更多的文件：\n:e 文件名【使用此命令载入的文件不会响应:n或:N命令，而需要使用:buffer加文件编号来切换文件】  \n\n文件之间的内容复制：使用之前的复制粘贴命令即可\n插入整个文件：\n:r text1  将text1文件内容插入到当前文件光标处","categories":["计算机理论"],"tags":["Apple+Linux-Ubuntu Server"]},{"title":"定制提示符","url":"/2021/04/30/%E8%AE%A1%E7%AE%97%E6%9C%BA%E7%90%86%E8%AE%BA/Apple+Linux/Ubuntu%20Server/11_%E5%AE%9A%E5%88%B6%E6%8F%90%E7%A4%BA%E7%AC%A6/","content":"系统的默认提示符：提示符中包含了用户名、主机名和当前的工作目录\n提示符是由名为PS1（提示符字符串1）的环境变量定义的，echo命令可以帮助用户看到PS1的值\n\n尝试设计提示符：\n备份：在终端会话中，用户随时可以通过这个过程的逆操作来复原最初的提示符\n如果提示符为空：那么用户不会得到任何提示\n将提示符设置成最简略的内容：\n在提示符中添加了一个铃声，每当系统显示提示符的时候，用户都会听到哔哔声，这在一些情况下可能会很有帮助，比如可以在一个耗时比较长的命令执行完毕时通知用户：\n包括主机名和当天的时间信息：\n\n添加颜色：字符颜色是由发送到终端仿真器的一个ANSI转义代码来控制的，该转义代码嵌入到了要显示的字符流中，控制代码不会打印到屏幕上，而是被终端解释为一条指令：\n创造红色的提示符：但是此时用户输入的所有文字也变成红色了\n修复这个问题：\n设置文本的背景颜色，背景颜色不支持粗体属性：\n文本除了正常(0)和粗体(1)属性外，还可以设置为下划线(4)、闪烁(5)和斜体(7)，为了维持好的品味，许多终端仿真器拒绝使用闪烁属性\n\n","categories":["计算机理论"],"tags":["Apple+Linux-Ubuntu Server"]},{"title":"命令的使用","url":"/2021/04/30/%E8%AE%A1%E7%AE%97%E6%9C%BA%E7%90%86%E8%AE%BA/Apple+Linux/Ubuntu%20Server/3_%E5%91%BD%E4%BB%A4%E7%9A%84%E4%BD%BF%E7%94%A8/","content":"\ntype命令是一个shell内置命令，可根据指定的命令名显示shell将要执行的命令类型：type command \n\n which命令可以确定一个给定可执行文件的准确位置 \n\n\nwhich命令只适用于可执行程序，而不适用于内置命令和命令别名（真正可执行程序的替代物），试图在shell内置命令（例如cd）中使用which命令时，要么没响应，要么得到一条错误信息\n3.bash为每一个shell内置命令提供了一个内置的帮助工具，输入help，然后输入shell内置命令的名称即可使用该帮助工具\n注意：出现在命令语法描述中的方括号表示一个可选的选项，竖线符号代表的是两个互斥的选项，这种表示法说明，cd命令后可能有一个-L参数，也可能是-P参数，甚至可以跟参数dir\n4.–help选项描述了命令支持的语法和选项\n5.大多数供命令行使用的可执行文件，提供一个称之为manual或者是man page的正式文档，该文档可以用一种称为man的特殊分页程序来查看：man program(这里的program是需要查看的命令名称)\nman ls:\n在大多数Linux系统中，man命令调用less命令来显示手册文档\n\napropos:\n\nwhatis程序显示匹配具体关键字的手册页的名字和一行描述\n\n\n\nGNU项目提供了info页面来代替手册文档，info页面可通过info阅读器来显示，info页面使用超链接，这与网页结构很相似\ninfo ls:\n\n\n\n通过alias命令将以上命令整合成一条新的命令【给这条命令起了一个名字foo，现在foo就代表这条命令了】\n\nunalias foo:删除别名\n要查看在环境中定义的所有别名，可以使用不带参数的alias命令\n在命令行定义别名还有一个小问题：当shell会话结束时，这些别名也随之消失了\n\n1.\n\n命令行小技巧：通过使用分号来分隔多条命令，就可以将多条命令输入在一行之中\n\n","categories":["计算机理论"],"tags":["Apple+Linux-Ubuntu Server"]},{"title":"导航、Linux系统、操作文件与目录","url":"/2021/04/30/%E8%AE%A1%E7%AE%97%E6%9C%BA%E7%90%86%E8%AE%BA/Apple+Linux/Ubuntu%20Server/2_%E5%AF%BC%E8%88%AA%E3%80%81Linux%E7%B3%BB%E7%BB%9F%E3%80%81%E6%93%8D%E4%BD%9C%E6%96%87%E4%BB%B6%E4%B8%8E%E7%9B%AE%E5%BD%95/","content":"\npwd(打印工作目录)：显示当前工作目录（第一次登录系统时或是启动终端仿真器会话时，当前工作目录被设置成主目录，每个用户账号都有一个主目录，作为普通用户操作时，这是唯一一个允许用户写文件的地方） \n\nls：列出当前工作目录的文件和目录   \n\n\n通过ls命令可以查看目录内容，确定各种重要文件和目录的属性\nls 指定目录：列出指定要显示的目录\nls ~ &#x2F;usr：列出用户主目录（由符号波浪线表示）和&#x2F;usr目录的内容\nls -l：将输出以长格式显示\n选项和参数：通常，命令后面跟有一个或多个选项，带有不同选项的命令其功能也不一样；此外，命令后面还会跟有一个或多个参数，这些参数是命令作用的对象【command -options arguments】\n大部分命令使用的选项是在单个字符前加上连字符，如-l，但是很多命令，包括GNU项目里的命令，也支持在单字前加两个连字符的长选项，而且很多命令也允许多个短选项串在一起使用\nls命令包含了两个选项，l选项产生长格式输出，而t选项则表示以文件修改时间的先后将结果进行排序，加上长选项—reverse，则结果会以相反的顺序输出\nls命令的常用选项\n下面的例子来自于Ubuntu系统：ls长列表字段：\n3.cd 目标工作目录的路径名：改变工作目录（即在文件系统树的位置）\n路径名指的是沿着分枝到达目标目录的路由，路径名分为两种：绝对路径名和相对路径名\n绝对路径名：从根目录开始，其后紧接着一个又一个文件树分支，直到到达目标目录或文件\n&#x2F;usr&#x2F;bin:大多数系统程序都安装在这个目录里【根目录(在路径名中用前导斜杠来表示)中有一个目录是usr,该目录包含一个bin目录】\n相对路径名：从工作目录开始，通常使用一些特殊符号来表示文件系统树中的相对位置（“.” ”..”）“.”代表当前工作目录“..”代表当前工作目录的父目录\n我们希望把工作目录改变成&#x2F;usr&#x2F;bin的父目录&#x2F;usr1）绝对路径名2）相对路径名\n也可以把工作目录从&#x2F;usr变到&#x2F;usr&#x2F;bin1）绝对路径名2）相对路径名\n几乎在所有的情况下都可以省略“.&#x2F;”，因为它是隐含的，一般而言，如果没有指定路径名，则默认为工作目录\ncd的一些快捷方式：1）cd：将当前工作目录改变为主目录2）cd -:将工作目录改变成先前的工作目录3）cd ~username：将工作目录改变为username的主目录\n\nfile filename：确定文件的类型\n\n\n\nless filename：查看文本文件的内容，Q键退出less程序\nless程序最常使用的键盘命令：\n\n符号链接：\n\n在浏览过程中，我们可能会看到带有如下条目的目录信息\n该条目信息的第一个字母是l，而且看起来像是有两个文件名，这种特殊的文件叫做符号链接（又叫软链接或symlink）\n假设，一个程序需要使用包含foo文件中的一个共享资源，但foo版本变化很频繁，这样，在文件名中包含版本号会是一个好主意，因此管理员或其他相关方就能够看到安装了foo的哪个版本，这就出现了一个问题，如果改变了共享资源的名称，就必须跟踪每个可能使用了该共享资源的程序，并且当安装了该资源新的版本后，都要让使用它的程序去寻找新的资源名\n假设foo的安装版本是2.6，他的文件名是foo-2.6，然后创建一个符号链接foo指向foo-2.6，这意味着，当一个程序打开foo文件时，它实际上打开的是文件foo-2.6.这样一来皆大欢喜，依赖foo文件的程序能够找到它，并且也能看到实际安装的版本。当需要升级到foo-2.7时，只需将该文件添加到系统里，删除符号链接文件foo，创建一个指向新版本的符号链接即可，这不仅解决了版本升级的问题，也可以将两种版本都保存在机器里。假如foo-2.7存在一个程序错误需要切换到旧的版本，同样，只需要删除指向新版本的符号链接，重新创建指向旧版本的符号链接即可\n硬链接：默认情况下，每个文件有一个硬链接，该硬链接会给文件起名字。当创建一个硬链接的时候，也为这个文件创建了一个额外的目录条目\n硬链接和文件本身没有什么区别，与包含符号链接的目录列表不同，包含硬链接的目录列表没有特别的链接指示说明。当硬链接被删除时，只是删除了这个链接，但是文件本身的内容依然存在（也就是说，该空间没有释放），除非该文件的所有链接都被删除了\nln file link：创建硬链接\nln -s item link:创建符号链接，这里的item可以是文件也可以是目录\n符号链接是通过创建一个特殊类型的文件来起作用的，该文件包含了指向引用文件或目录的文本指针\n\n由于shell需要经常使用文件名，因此它提供了一些特殊字符来帮助你快速指定一组文件名，这些特殊字符称为通配符，通配符（也叫文件名替换）允许用户依据字符模式选择文件名通配符的使用使得为文件名构建复杂的筛选标准成为可能：\n\n\n\nmkdir dir1：创建单个dir1目录\nmkdir dir1 dir2 dir3：创建3个目录\n9.cp：复制文件和目录cp item1 item2：将单个文件或目录item1复制到文件或目录item2中cp item1 . :将item1复制到当前目录cp item… directory：将多个项目（文件或目录）复制进一个目录中\n需要注意的是，在没有任何警告的情况下，cp命令会覆盖第一次的复制内容（命令一样的情况下）\n10.mv：文件移动和文件重命名（在这两种情况下，完成操作后，原来的文件名将不存在）\nmv item1 item2:将文件（或目录）item1移动（或重命名）为item2mv item… directory：将一个或多个条目从一个目录移动到另一个目录下\n11.rm item… ：移除（删除）文件和目录\n\n\n（1）与Windows相同，类UNIX操作系统（Linux）也是以称之为分层目录结构的方式来组织文件的，文件系统的第一个目录叫做根目录，它包含了文件和子目录，子目录里包含了更多的文件和子目录，依此类推\n（2）在Windows系统中，每个存储设备都有一个独立的文件系统树。而在类UNIX系统中，无论多少驱动器或存储设备与计算机相连，通常只有一个文件系统树。根据系统管理员的设置，存储设备将会连接（挂载）到文件系统树的不同位置，系统管理员要负责系统的维护 \n（3）树通常是倒立显示的，顶部是根目录，依次向下排列的是子目录\n（4）以“.”字符开头的文件名是隐藏的，这仅说明ls不会列出这些文件，除非输入ls -a,在创建用户账号时，主目录里会放置一些隐藏文件，用来配置账号信息，此外，一些应用程序也会将它们的配置文件和设置文件以隐藏文件的形式放在主目录下面\n（5）与UNIX一样，在Linux中，文件名与命令是区分大小写的 \n（6）Linux没有文件扩展名的概念，我们可以按照自己的喜好随意给文件命名，文件的内容或用途由其他方式来决定 \n（7）Linux支持长文件名，但是在创建文件名的过程中，仅句号、连字符和下划线是可以使用的，文件名中不要嵌入空格，可以使用下划线 \n（8）在Linux系统中找到的目录：\n\n实战演练：\n","categories":["计算机理论"],"tags":["Apple+Linux-Ubuntu Server"]},{"title":"高级键盘技巧","url":"/2021/04/30/%E8%AE%A1%E7%AE%97%E6%9C%BA%E7%90%86%E8%AE%BA/Apple+Linux/Ubuntu%20Server/6_%E9%AB%98%E7%BA%A7%E9%94%AE%E7%9B%98%E6%8A%80%E5%B7%A7/","content":"光标移动：\n修改文本：\n剪切和粘贴文本：\n自动补齐功能：在输入命令时，按Tab键将触发自动补齐功能\n使用历史命令：bash会保存使用过命令的历史记录，这些命令的历史记录列表保存在用户主目录的.bash_history文件中\n搜索历史命令：\nhistory | less：查看历史记录的内容列表\nbash默认会保存用户最近使用过的500个命令，其中500是个默认值\n找到用来列出&#x2F;usr&#x2F;bin目录下内容的命令：\n\n历史记录扩展：\n","categories":["计算机理论"],"tags":["Apple+Linux-Ubuntu Server"]},{"title":"重定向和管道","url":"/2021/04/30/%E8%AE%A1%E7%AE%97%E6%9C%BA%E7%90%86%E8%AE%BA/Apple+Linux/Ubuntu%20Server/4_%E9%87%8D%E5%AE%9A%E5%90%91%E5%92%8C%E7%AE%A1%E9%81%93/","content":"I&#x2F;O是输入&#x2F;输出(input&#x2F;output)的缩写，I&#x2F;O重定向可以把命令行的输入重定向为从文件中获取内容，也可以把命令行的输出结果重定向到文件中，如果我们将多个命令行关联起来，将形成非常强大的命令：管道\n\n标准输出重定向：I&#x2F;O重定向功能可以重新定义标准输出内容发送到哪里，使用重定向操作符“&gt;”，后面接文件名，就可以把标准输出重定向到另一个文件中，而不是显示在屏幕上，主要用于把命令的输出内容保存到一个文件中\n\n标准错误重定向：\n将标准输出和标准错误重定向到同一个文件:1）传统的方法，在旧版本的shell中使用2）在这个例子中，只使用一个标记符“&amp;&gt;”就把标准输出和标准错误都重定向到了文件中\n处理不想要的输出：有时候沉默是金，命令执行后我们并不希望得到输出，而是想把这个输出丢弃，尤其是在输出错误和状态信息的情况下更为需要。系统提供了一种方法，即通过把输出重定向到一个称为&#x2F;dev&#x2F;null的特殊文件中来实现它，这个文件是一个称为位桶(bit bucket)的系统设备，它接受输入但是不对输入进行任何处理\n标准输入重定向：\ncat file..：合并文件，读取一个或多个文件，并把它们复制到标准输出文件中\n\n\n管道:命令从标准输入到读取数据，并将数据发送到标准输出的能力是使用了名为管道的shell特性，使用管道操作符“｜”可以把一个命令的标准输出传送到另一个命令的标准输入中\ncommand | command【标准输出—&gt;标准输入】\n通过使用该技术，可以很方便的检查任意一条生成标准输出的命令的运行结果\n过滤器：管道功能经常用来对数据执行复杂的操作，也可以把多条命令合在一起构成一个管道，这种方式中用到的命令通常被称为过滤器(filter)，过滤器接受输入，按照某种方式对输入进行改变，然后再输出它\nsort：假设要把&#x2F;bin和&#x2F;usr&#x2F;bin目录下的所有可执行程序合并成一个列表，并且按照顺序排列，最后再查看这个列表\nuniq：经常和sort命令结合使用，uniq可以接受来自于标准输入或者一个单一文件名参数对应的已排好序的数据列表，默认情况下，该命令删除列表中的所有重复行\nwc(字数统计，word count)：用来显示文件中包含的行数、字数和字节数\ngrep：在文件中查找匹配文本\nhead&#x2F;tail：打印文件的开头部分&#x2F;结尾部分：head命令将输出文件的前10行，tail命令则输出文件的最后10行，可以通过-n选项来调整输出的行数\n这些命令选项也可以应用在管道中：\n\ntee：读取标准输入，再把读到的内容复制到标准输出（允许数据可以继续向下传输到管道中）和一个或更多的文件中去【标准输入—&gt;标准输出】\n在使用grep命令过滤管道内容之前，先使用tee命令来获取整个目录列表并输出到ls.txt文件中：\n","categories":["计算机理论"],"tags":["Apple+Linux-Ubuntu Server"]},{"title":"权限","url":"/2021/04/30/%E8%AE%A1%E7%AE%97%E6%9C%BA%E7%90%86%E8%AE%BA/Apple+Linux/Ubuntu%20Server/7_%E6%9D%83%E9%99%90/","content":"传统的UNIX操作系统与那些传统的MS-DOS操作系统不同，区别在于它们不仅是多重任务处理系统，而且还是多用户系统,这意味着同一时间内可以有多个用户使用同一台计算机\nid命令可以获得用户身份标识的相关信息\n1）用户账户定义在文件&#x2F;etc&#x2F;passwd中，对于每一个用户账户，文件&#x2F;etc&#x2F;passwd中都定义了对应用户的用户（登录）名、uid、gid、账户的真实姓名、主目录以及登录shell信息2）用户组定义在文件&#x2F;etc&#x2F;group中，如果查看文件&#x2F;etc&#x2F;passwd和文件&#x2F;etc&#x2F;group的内容，可以发现除了普通用户账户信息之外，文件中还有对应于超级用户（uid为0）和其他不同种类的系统用户的账户信息3）在创建用户账户和群组时，这些文件随着文件&#x2F;etc&#x2F;shadow的变动而修改，文件&#x2F;etc&#x2F;shadow中保存了用户的密码信息\n对文件和目录的访问权限是按照读访问、写访问以及执行访问来定义的：\nchmod：更改文件或者目录的模式（权限），只有文件所有者和超级用户才可以更改文件或者目录的模式1）八进制数字表示法：使用八进制数字来设置所期望的权限模式\n通过使用3位八进制数字，我们可以分别设置文件所有者、组成员和其他所有用户的文件模式\n2）符号表示法：分为三部分：更改会影响谁、要执行哪个操作、要设置哪种权限\numask命令控制着创建文件时指定给文件的默认权限，它使用八进制表示法来表示从文件模式属性中删除一个位掩码\n有三种方法用来转换身份：1）注销系统并以其他用户的身份重新登录系统2）使用su命令3）使用sudo命令\n在shell会话状态下，使用su命令将允许你假定为另一个用户的身份，既可以以这个用户的ID来启动一个新的shell会话，也可以以这个用户的身份来发布一个命令使用sudo命令将允许管理者创建一个称为&#x2F;etc&#x2F;sudoer的配置文件，并且定义一些特定的命令，这些命令只有被赋予为假定身份的特定用户才允许执行\nsu：以其他用户和组ID的身份来运行shell\nsudo：以另一个用户的身份执行命令\nchown：更改文件或者目录的所有者和所属群组，需要超级用户的权限\nchgrp：在更早的UNIX版本中，chown命令只能更改文件的所有者，而不能改变文件所属群组，为了达到这个目的，可以使用chgrp\n实例：\npasswd：设置或者更改密码\n","categories":["计算机理论"],"tags":["Apple+Linux-Ubuntu Server"]},{"title":"扩展和引用","url":"/2021/04/30/%E8%AE%A1%E7%AE%97%E6%9C%BA%E7%90%86%E8%AE%BA/Apple+Linux/Ubuntu%20Server/5_%E6%89%A9%E5%B1%95%E5%92%8C%E5%BC%95%E7%94%A8/","content":"扩展：每次输入命令行按下Enter键时，bash都会在执行命令之前对文本进行多重处理，产生这个结果的处理过程称为扩展，有了扩展功能，在输入内容后，这些内容将在shell对其执行之前被扩展成其他内容\necho:shell内置命令，把文本参数内容打印到标准输出\n路径名扩展：通过使用通配符来实现扩展的机制\n波浪线扩展：如果把～用在一个单词的开头，那么它将被扩展为指定用户的主目录名，如果没有指定用户命名，则扩展为当前用户的主目录\n算术扩展：shell支持通过扩展来运行算术表达式，这允许我们把shell提示符当作计算器来使用：\n花括号扩展：可以按照花括号里面的模式创建多种文本字符串\n参数扩展：命名为USER的变量包含你的用户名，为了触发参数扩展，并显示出USER的内容：\n命令替换：可以把一个命令的输出作为一个扩展模式使用\n\n引用：\n在第一个例子中，shell会对echo命令的参数列表进行单词分割，去除多余的空白；在第二个例子中，因为$1是一个未定义的变量，所以参数扩展将把$1的值替换为空字符串\nshell提供了一种称为引用（quoting）的机制，用来有选择性的避免不想要的扩展\n双引号：在第一个例子中，没有加上引号的命令替换将导致命令行被识别为命令后面跟着38个参数；而在第二个例子中加了双引号，使得命令行被识别为命令后面只跟着一个参数，这个参数包含着嵌入空格和换行字符\n单引号：\n转义字符：\n有时候我们只是想要引用单个字符，这种情况可以通过在该字符前加上反斜杠来实现，这里的反斜杠称为转义字符，转义字符经常在双引号中用来有选择性的阻止扩展：\n转义字符也常用来消除文件名中某个字符的特殊含义，比如文件名中可以使用在shell中通常具有特殊含义的字符，这些字符包括“$”、“!”、“&amp;”、空格等\n如果想要显示反斜杠字符，可以通过使用两个反斜杠“\\”来实现，需要注意的是，单引号中的反斜杠将失去它的特殊含义，而只被当成一个普通字符\n\n","categories":["计算机理论"],"tags":["Apple+Linux-Ubuntu Server"]},{"title":"进程","url":"/2021/04/30/%E8%AE%A1%E7%AE%97%E6%9C%BA%E7%90%86%E8%AE%BA/Apple+Linux/Ubuntu%20Server/8_%E8%BF%9B%E7%A8%8B/","content":"现代操作系统通常都支持多重任务处理，多重任务处理是指系统通过快速切换运行中的程序来实现多任务的同时执行，Linux内核通过使用进程来管理多重任务，进程是Linux用来安排不同程序等待CPU调度的一种组织方式\n进程如何工作：系统启动时，内核先把它的一些程序初始化为进程，然后运行一个称为init的程序，init程序将依次运行一系列称为脚本初始化的shell脚本(放在&#x2F;etc目录下)，这些脚本将会启动所有的系统服务，其中的很多服务都是通过守护程序来实现的，而后台程序只是呆在后台做它们自己的事情，并且没有用户界面，因此，即使没有用户登录，系统也在忙于执行一些例行程序\n一个程序的运行可以触发其他程序的运行，在进程系统中这种情况被表述为父进程创建子进程\n内核会保存每个进程的信息以便确保任务有序进行，比如，每个进程将被分配一个称为进程ID(PID，process ID)的号码。进程ID是按递增的顺序来分配的，init进程的PID始终为1.内核也记录分配给每个进程的内存信息以及用来恢复运行的进程就绪信息。和文件系统类似，进程系统中也存在所有者、用户ID、有效用户ID等\nps命令：查看进程信息（默认情况下，ps命令输出的信息并不是很多，只是输出和当前终端会话相关的进程信息）1）TTY是teletype(电传打字机)的缩写，代表了进程的控制终端2)UNIX在这里也显示了进程的运行时间，TIME字段表示了进程消耗的CPU时间总和\n添加x选项(注意这里没有前置的连字符)将告知ps命令显示所有的进程，而不需要关注它们是由哪个终端（如果有其他的情况）所控制的。TTY列中出现的“？”表示没有控制终端\n这些进程状态的后面可以带其他的字符来表示不同的特殊进程特性\nps aux：将会显示属于每个用户的进程信息，使用这些选项时不带前置连字符将使得命令以“BSD模式(BSD-style)”运行。ps命令的Linux版本可以模拟多种UNIX版本中ps程序的运行方式：\n虽然ps命令可以显示有关机器运行情况的很多信息，但是它提供的只是在ps命令被执行时刻机器状态的一个快照。要查看机器运行情况的动态视图，可以使用top命令\ntop程序将按照进程活动的顺序，以列表的形式持续更新显示系统进程的当前信息（默认每3秒更新一次），它主要用于查看系统“最高（top）”进程的运行情况，top命令显示的内容包含两个部分，顶部显示的是系统总体状态信息，下面显示的是一张按CPU活动时间排序的进程情况表\ntop程序可以接受许多键盘指令，其中最常用的有两个：一个是h，输入后将显示程序的帮助界面；另一个是q，用来退出top命令\n主流的桌面环境都提供了用来显示类似top命令的输出信息的图形化应用程序，但是top命令优于图形化版本，这是因为top命令运行的更快，而且消耗的系统资源要少得多，毕竟，系统监控程序不应该减缓正在被监控的系统的处理速度\n控制进程：\n1）中断进程：在终端里按下Ctrl-C键将会中断一个程序，它意味着我们委婉的请求程序结束，许多（但不是所有）命令行程序都可以使用这种方法来实现中断\n2）使进程在后台运行：\n3）使进程回到前台运行：\n4）停止（暂停）进程：\n信号：\nkill命令通常用来“杀死”（终止）进程，它可以用来终止运行不正常的程序或者反过来拒绝终止的程序\n","categories":["计算机理论"],"tags":["Apple+Linux-Ubuntu Server"]},{"title":"环境","url":"/2021/04/30/%E8%AE%A1%E7%AE%97%E6%9C%BA%E7%90%86%E8%AE%BA/Apple+Linux/Ubuntu%20Server/9_%E7%8E%AF%E5%A2%83/","content":"在shell会话调用环境期间，shell会存储大量的信息，程序使用存储在环境中的数据来确定我们的配置，尽管大多数系统程序使用配置文件来存储程序设置，但是也有一些程序会查找环境中存储的变量来调整自己的行为，用户可以使用环境来自定义shell\n尽管shell在环境中存储了两种基本类型的数据，但是在bash中，这两种类型基本上没有区别。这两种数据类型分别是环境变量和shell变量。shell变量是由bash存放的少量数据，环境变量就是除此之外的所有其他变量。除变量之外，shell还存储了一些编程数据，也就是别名和shell函数\nset命令会同时显示shell变量和环境变量，而printenv只会显示环境变量printenv | less:\n命令printenv也能够列出特定变量的值：\n在使用set命令时，如果不带选项或参数，那么只会显示shell变量、环境变量以及任何已定义的shell函数，与printenv命令不同的是，set命令的输出结果是按照字母顺序排列的set | less:\n如需要查看单个变量的值，也可以使用echo命令\nset命令和printenv命令都不能显示的一个环境元素是别名，要查看别名，需使用不带任何参数的alias命令\n一些有趣的变量：\n环境是如何建立的：用户登录系统后，bash程序就会启动并读取一系列称为启动文件的配置脚本，这些脚本定义了所有用户共享的默认环境。接下来，bash会读取更多存储在主目录下的用于定义个人环境的启动文件。这些步骤的确切顺序是由启动的shell会话类型决定的\n\n修改环境：\n文本编辑器：\n使用文本编辑器配置文件：所有的文本编辑器都可以通过在命令行输入编辑器名称和需编辑的文件名称的方式启动，如果输入的文件不存在，编辑器会认为用户想要创建一个新的文件\n扩展名.bak、.sav、.old和.orig是常用的标示备份文件的方法\n激活修改：因为只有在启动shell会话时才会读取.bashrc，所以对.bashrc做出的修改只有在关闭shell终端会话并重启的时候才会生效。也可以使用命令强制命令bash重新读取.bashrc文件\n在shell脚本和bash启动文件中，注释是以“#”开头的\n","categories":["计算机理论"],"tags":["Apple+Linux-Ubuntu Server"]},{"title":"软件包管理","url":"/2021/04/30/%E8%AE%A1%E7%AE%97%E6%9C%BA%E7%90%86%E8%AE%BA/Apple+Linux/Ubuntu%20Server/12_%E8%BD%AF%E4%BB%B6%E5%8C%85%E7%AE%A1%E7%90%86/","content":"决定Linux发行版本质量最重要的因素是软件包系统和支持该发行版本社区的活力软件包管理是一种在系统上安装、维护软件的方法不同的Linux发行版用的是不同的软件包系统，并且原则上适用于一种发行版的软件包与其他版本是不兼容的。多数Linux发行版采用的不外乎两种软件包技术阵营，即Debian的.deb技术和Red Hat的.rpm技术，当然也有一些特例。比如Gentoo，Slackware和Foresight等软件包系统工作方式：Linux系统所有软件均可在网上找到，并且多数是以软件包文件的形式由发行商提供，其余则以可手动安装的源代码形式存在1）软件包文件2）库3）依赖关系4）高级和低级软件包工具：软件包管理系统通常包含两类工具—执行如安装、删除软件包文件等任务的低级工具和进行元数据搜索及提供依赖性解决的高级工具尽管所有Red-Hat系列版本都使用相同的低级工具（rpm），但使用的高级工具却不尽相同常见软件包管理任务：1）在库里面查找软件包2）安装库中的软件包3）安装软件包文件中的软件包4）删除软件包5）更新库中的软件包6）更新软件包文件中的软件包7）列出已安装的软件包列表8）判断软件包是否安装9）显示已安装软件包的相关信息10）查看某具体文件由哪个软件包安装得到\n","categories":["计算机理论"],"tags":["Apple+Linux-Ubuntu Server"]},{"title":"LeetCode_15_三数之和","url":"/2019/06/30/%E8%AE%A1%E7%AE%97%E6%9C%BA%E7%90%86%E8%AE%BA/LeetCode%E7%AE%97%E6%B3%95/%E5%8F%8C%E6%8C%87%E9%92%88/2.2_LeetCode_15_%E4%B8%89%E6%95%B0%E4%B9%8B%E5%92%8C/","content":"题目描述：给你一个包含 n 个整数的数组 nums，判断 nums 中是否存在三个元素 a，b，c ，使得 a + b + c = 0 ？请你找出所有和为 0 且不重复的三元组。注意：答案中不可以包含重复的三元组。示例：输入：nums = [-1,0,1,2,-1,-4]输出：[[-1,-1,2],[-1,0,1]]输入：nums = []输出：[]输入：nums = [0]输出：[]提示：1. 0 &lt;= nums.length &lt;= 30002. -10^5 &lt;= nums[i] &lt;= 10^5\n\n解法1：双指针class Solution &#123;public:    vector&lt;vector&lt;int&gt;&gt; threeSum(vector&lt;int&gt;&amp; nums) &#123;        vector&lt;vector&lt;int&gt;&gt; result;  //返回的结果        sort(nums.begin(), nums.end());              if (nums.size() &lt; 3) return result;        for (int i = 0; i &lt; nums.size(); i++) &#123;            //排序之后如果第一个元素已经大于零，那么无论如何组合都不可能凑成三元组，直接返回结果就可以了            if (nums[i] &gt; 0) return result;                        //错误去重方法            //输入：[-1,0,1,2,-1,-4]            //输出：[[-1,0,1]]            //预期结果：[[-1,-1,2],[-1,0,1]]            //if (nums[i] == nums[i + 1]) continue;            //正确去重方法            if (i &gt; 0 &amp;&amp; nums[i] == nums[i - 1]) continue;            //a = nums[i], b = nums[left], c = nums[right]            int left = i + 1, right = nums.size() - 1;            while (right &gt; left) &#123;                //去重不可以放在这里                //输入：[-4,-2,1,-5,-4,-4,4,-2,0,4,0,-2,3,1,-5,0]                //输出：[[-5,1,4],[-4,0,4],[-4,1,3],[-2,-2,4]]                //预期结果：[[-5,1,4],[-4,0,4],[-4,1,3],[-2,-2,4],[-2,1,1],[0,0,0]]                if (nums[i] + nums[left] + nums[right] &gt; 0) right--;                else if (nums[i] + nums[left] + nums[right] &lt; 0) left++;                else &#123;                    result.push_back(vector&lt;int&gt;&#123;nums[i], nums[left], nums[right]&#125;);                    //去重应该放在找到一个三元组之后                    while (right &gt; left &amp;&amp; nums[right] == nums[right - 1]) right--;                    while (right &gt; left &amp;&amp; nums[left] == nums[left + 1]) left++;                    //找到答案时，双指针同时收缩                    left++;                    right--;                &#125;            &#125;        &#125;        return result;    &#125;&#125;;\n\n","categories":["计算机理论"],"tags":["LeetCode算法-双指针"]},{"title":"LeetCode_167_两数之和2-输入有序数组","url":"/2019/06/30/%E8%AE%A1%E7%AE%97%E6%9C%BA%E7%90%86%E8%AE%BA/LeetCode%E7%AE%97%E6%B3%95/%E5%8F%8C%E6%8C%87%E9%92%88/2.1_LeetCode_167_%E4%B8%A4%E6%95%B0%E4%B9%8B%E5%92%8C2-%E8%BE%93%E5%85%A5%E6%9C%89%E5%BA%8F%E6%95%B0%E7%BB%84/","content":"❗️剑指Offer_57_和为s的两个数字\n题目描述：若两个指针指向同一数组，遍历方向相同且不会相交，则称为滑动窗口（两个指针包围的区域即为当前的窗口），经常用于区间搜索若两个指针指向同一数组，但是遍历方向相反，则可以用来进行搜索，待搜索的数组往往是排好序的指针函数：返回类型是指针的函数函数指针：指向函数的指针给定一个已按照 升序排列  的整数数组 numbers ，请你从数组中找出两个数满足相加之和等于目标数 target 。函数应该以长度为 2 的整数数组的形式返回这两个数的下标值。numbers 的下标 从 1 开始计数 ，所以答案数组应当满足 1 &lt;= answer[0] &lt; answer[1] &lt;= numbers.length 。你可以假设每个输入只对应唯一的答案，而且你不可以重复使用相同的元素。示例：输入：numbers = [2,7,11,15], target = 9输出：[1,2]解释：2 与 7 之和等于目标数 9 。因此 index1 = 1, index2 = 2 。输入：numbers = [2,3,4], target = 6输出：[1,3]输入：numbers = [-1,0], target = -1输出：[1,2]提示：1. 2 &lt;= numbers.length &lt;= 3 * 10^42. -1000 &lt;= numbers[i] &lt;= 10003. numbers 按 递增顺序 排列4. -1000 &lt;= target &lt;= 10005. 仅存在一个有效答案\n\n解法1：双指针class Solution &#123;public:    vector&lt;int&gt; twoSum(vector&lt;int&gt;&amp; numbers, int target) &#123;        int l = 0,r = numbers.size() - 1;  //定义一个左指针，一个右指针        int sum;        //如果两个指针指向元素的和等于给定值，那么它们就是我们要的结果。        //如果两个指针指向元素的和小于给定值，我们就把左指针向右移一位        //如果两个指针指向元素的和大于给定值，我们就把右指针向左移一位        while (l &lt; r) &#123;            sum = numbers[l] + numbers[r];            //对于排好序且有解的数组，双指针一定能遍历到最优解            if (sum == target) break;            if (sum &lt; target) ++l;            else --r;        &#125;        return vector&lt;int&gt;&#123;l + 1,r + 1&#125;;    &#125;&#125;;\n\n","categories":["计算机理论"],"tags":["LeetCode算法-双指针"]},{"title":"LeetCode_680_验证回文字符串2","url":"/2019/06/30/%E8%AE%A1%E7%AE%97%E6%9C%BA%E7%90%86%E8%AE%BA/LeetCode%E7%AE%97%E6%B3%95/%E5%8F%8C%E6%8C%87%E9%92%88/2.6_LeetCode_680_%E9%AA%8C%E8%AF%81%E5%9B%9E%E6%96%87%E5%AD%97%E7%AC%A6%E4%B8%B22/","content":"题目描述：给定一个非空字符串 s，最多删除一个字符。判断是否能成为回文字符串。示例：输入: &quot;aba&quot;输出: True输入: &quot;abca&quot;输出: True解释: 你可以删除c字符。注意：字符串只包含从 a-z 的小写字母。字符串的最大长度是50000。\n\n解法1：双指针class Solution &#123;public:    bool validPalindrome(string s) &#123;        //双指针遍历        for (int i = 0, j = s.length() - 1; i &lt; j; i++, j--) &#123;            //遇到要删除的情况，分成两部分进行判断            if (s[i] != s[j]) &#123;                return isPalindrome(s, i + 1, j) || isPalindrome(s, i, j - 1);            &#125;        &#125;        return true;    &#125;    //判断子字符串是否是回文串    bool isPalindrome(string s, int i, int j) &#123;        while (i &lt; j) &#123;            if (s[i++] != s[j--]) return false;        &#125;        return true;    &#125;&#125;;\n\n","categories":["计算机理论"],"tags":["LeetCode算法-双指针"]},{"title":"LeetCode_581_最短无序连续子数组","url":"/2019/06/30/%E8%AE%A1%E7%AE%97%E6%9C%BA%E7%90%86%E8%AE%BA/LeetCode%E7%AE%97%E6%B3%95/%E5%8F%8C%E6%8C%87%E9%92%88/2.7_LeetCode_581_%E6%9C%80%E7%9F%AD%E6%97%A0%E5%BA%8F%E8%BF%9E%E7%BB%AD%E5%AD%90%E6%95%B0%E7%BB%84/","content":"题目描述：给你一个整数数组 nums ，你需要找出一个 连续子数组 ，如果对这个子数组进行升序排序，那么整个数组都会变为升序排序。请你找出符合题意的 最短 子数组，并输出它的长度。示例：输入：nums = [2,6,4,8,10,9,15]输出：5解释：你只需要对 [6, 4, 8, 10, 9] 进行升序排序，那么整个表都会变为升序排序。输入：nums = [1,2,3,4]输出：0输入：nums = [1]输出：0提示：1. 1 &lt;= nums.length &lt;= 10^42. -10^5 &lt;= nums[i] &lt;= 10^5\n\n解法1：双指针class Solution &#123;public:    int findUnsortedSubarray(vector&lt;int&gt;&amp; nums) &#123;        vector&lt;int&gt; sorted_nums(nums);                //对数组的副本排序，得到升序数组        sort(sorted_nums.begin(), sorted_nums.end());        //双指针分别找到不同段落的边界        int l = -1, r = -1;        for (int i = 0; i &lt; nums.size(); i++) &#123;            if (nums[i] != sorted_nums[i]) &#123;                l = i;                break;            &#125;        &#125;        for (int i = nums.size() - 1; i &gt;= 0; i--) &#123;            if (nums[i] != sorted_nums[i]) &#123;                r = i;                break;            &#125;        &#125;                if (l == -1) return 0;                return r - l + 1;    &#125;&#125;;\n\n","categories":["计算机理论"],"tags":["LeetCode算法-双指针"]},{"title":"LeetCode_18_四数之和","url":"/2019/06/30/%E8%AE%A1%E7%AE%97%E6%9C%BA%E7%90%86%E8%AE%BA/LeetCode%E7%AE%97%E6%B3%95/%E5%8F%8C%E6%8C%87%E9%92%88/2.3_LeetCode_18_%E5%9B%9B%E6%95%B0%E4%B9%8B%E5%92%8C/","content":"题目描述：给定一个包含 n 个整数的数组 nums 和一个目标值 target，判断 nums 中是否存在四个元素 a，b，c 和 d ，使得 a + b + c + d 的值与 target 相等？找出所有满足条件且不重复的四元组。注意：答案中不可以包含重复的四元组。示例：输入：nums = [1,0,-1,0,-2,2], target = 0输出：[[-2,-1,1,2],[-2,0,0,2],[-1,0,0,1]]输入：nums = [], target = 0输出：[]提示：1. 0 &lt;= nums.length &lt;= 2002. -10^9 &lt;= nums[i] &lt;= 10^93. -10^9 &lt;= target &lt;= 10^9\n\n解法1：双指针class Solution &#123;public:    vector&lt;vector&lt;int&gt;&gt; fourSum(vector&lt;int&gt;&amp; nums, int target) &#123;        vector&lt;vector&lt;int&gt;&gt; result;        sort(nums.begin(), nums.end());        if (nums.size() &lt; 4) return result;        for (int k = 0; k &lt; nums.size(); k++) &#123;            //错误写法：这道题目target可能为负数            //if (nums[k] &gt; target) return result;            //去重            if (k &gt; 0 &amp;&amp; nums[k] == nums[k - 1]) continue;            for (int i = k + 1; i &lt; nums.size(); i++) &#123;                //去重                if (i &gt; k + 1 &amp;&amp; nums[i] == nums[i - 1]) continue;                int left = i + 1, right = nums.size() - 1;                while (right &gt; left) &#123;                    //⭐️注意必须强转成long int，因为-10^9 &lt;= nums[i] &lt;= 10^9                    //输入：[1000000000, 1000000000, 1000000000, 1000000000] 0                    //输出：[]                    //三数之和那道题不需要强转是因为它前面有判断条件：if (nums[i] &gt; 0) return result;                    if ((long int)nums[k] + (long int)nums[i] + (long int)nums[left] + (long int)nums[right] &gt; target) right--;                    else if ((long int)nums[k] + (long int)nums[i] + (long int)nums[left] + (long int)nums[right] &lt; target) left++;                                        else &#123;                        result.push_back(vector&lt;int&gt;&#123;nums[k],nums[i],nums[left],nums[right]&#125;);                        //去重应该放在找到一个四元组之后                        while (right &gt; left &amp;&amp; nums[right] == nums[right - 1]) right--;                        while (right &gt; left &amp;&amp; nums[left] == nums[left + 1]) left++;                        //找到答案时，双指针同时收缩                        left++;                        right--;                    &#125;                &#125;            &#125;        &#125;        return result;    &#125;&#125;;\n\n","categories":["计算机理论"],"tags":["LeetCode算法-双指针"]},{"title":"LeetCode_88_合并两个有序数组","url":"/2019/06/30/%E8%AE%A1%E7%AE%97%E6%9C%BA%E7%90%86%E8%AE%BA/LeetCode%E7%AE%97%E6%B3%95/%E5%8F%8C%E6%8C%87%E9%92%88/2.4_LeetCode_88_%E5%90%88%E5%B9%B6%E4%B8%A4%E4%B8%AA%E6%9C%89%E5%BA%8F%E6%95%B0%E7%BB%84/","content":"题目描述：给你两个有序整数数组 nums1 和 nums2，请你将 nums2 合并到 nums1 中，使 nums1 成为一个有序数组。初始化 nums1 和 nums2 的元素数量分别为 m 和 n 。你可以假设 nums1 的空间大小等于 m + n，这样它就有足够的空间保存来自 nums2 的元素。示例：输入：nums1 = [1,2,3,0,0,0], m = 3, nums2 = [2,5,6], n = 3输出：[1,2,2,3,5,6]输入：nums1 = [1], m = 1, nums2 = [], n = 0输出：[1]提示：1. nums1.length == m + n2. nums2.length == n3. 0 &lt;= m, n &lt;= 2004. 1 &lt;= m + n &lt;= 2005. -10^9 &lt;= nums1[i], nums2[i] &lt;= 10^9\n\n解法1：三指针class Solution &#123;public:    //a++和++a都是将a加1，但是a++返回值a，++a返回值为a+1    //⭐️如果只是希望增加a的值，而不需要返回值，则推荐使用++a，其运行速度会略快一些    void merge(vector&lt;int&gt;&amp; nums1, int m, vector&lt;int&gt;&amp; nums2, int n) &#123;        //因为这两个数组已经排好序，我们可以把两个指针分别放在两个数组的末尾，即nums1的m-1位和nums2的n-1位        //每次将较大的那个数字复制到nums1的后边，然后向前移动一位。因为我们也要定位nums1的末尾，所以我们还需要第三个指针，以便复制        int pos = m-- + n-- -1;        while (m &gt;= 0 &amp;&amp; n &gt;= 0) &#123;            nums1[pos--] = nums1[m] &gt; nums2[n] ? nums1[m--] : nums2[n--];        &#125;        //[0] 0 [1] 1        while (n &gt;= 0) &#123;            nums1[pos--] = nums2[n--];        &#125;    &#125;&#125;;\n\n","categories":["计算机理论"],"tags":["LeetCode算法-双指针"]},{"title":"LeetCode_633_平方数之和","url":"/2019/06/30/%E8%AE%A1%E7%AE%97%E6%9C%BA%E7%90%86%E8%AE%BA/LeetCode%E7%AE%97%E6%B3%95/%E5%8F%8C%E6%8C%87%E9%92%88/2.5_LeetCode_633_%E5%B9%B3%E6%96%B9%E6%95%B0%E4%B9%8B%E5%92%8C/","content":"题目描述：给定一个非负整数 c ，你要判断是否存在两个整数 a 和 b，使得 a^2 + b^2 = c 。示例：输入：c = 5输出：true解释：1 * 1 + 2 * 2 = 5输入：c = 3输出：false输入：c = 4输出：true输入：c = 2输出：true输入：c = 1输出：true提示：0 &lt;= c &lt;= 2^31 - 1\n\n解法1：双指针class Solution &#123;public:    bool judgeSquareSum(int c) &#123;        //双指针        long left = 0;        long right = (int)sqrt(c);        while (left &lt;= right) &#123;            long sum = left * left + right * right;            if (sum == c) return true;            else if (sum &gt; c) right--;            else left++;        &#125;        return false;    &#125;&#125;;\n\n","categories":["计算机理论"],"tags":["LeetCode算法-双指针"]},{"title":"字符串转换","url":"/2019/06/30/%E8%AE%A1%E7%AE%97%E6%9C%BA%E7%90%86%E8%AE%BA/LeetCode%E7%AE%97%E6%B3%95/%E5%AD%97%E7%AC%A6%E4%B8%B2/0.1_%E5%AD%97%E7%AC%A6%E4%B8%B2%E8%BD%AC%E6%8D%A2/","content":"题目描述：写一个字符串转换函数，输入以驼峰命名法为格式的字符串，输出相应的以下划线命名法为格式的字符串要求：1. 只遍历输入字符串一遍2. 注意合理处理连续的大写字母如 HTTP3. 请提供单元测试，不局限于下面的例子4. 语言不限输入：myFirstName输出：my_first_name输入：OnlineUsers输出：online_users输入：Address输出：address输入：validHTTPRequest输出：valid_http_request\n\n解法1：#include &lt;iostream&gt;#include &lt;string&gt;using namespace std;//字符串转换函数string conversionString(string s) &#123;        string res;  //res是返回的最终结果        if (s.size() == 0) return 0;  //判断输入值为空的情况        for (int i = 0 ; i &lt; s.size() ; ++i) &#123;                //第一种情况：输入 validHTTPRequest        //如果该字符是大写并且左右两边都是大写的话，只需要把该字符转换成小写就可以了        if (s[i - 1] &gt;= &#x27;A&#x27; &amp;&amp; s[i - 1] &lt;= &#x27;Z&#x27; &amp;&amp;            s[i] &gt;= &#x27;A&#x27; &amp;&amp; s[i] &lt;= &#x27;Z&#x27; &amp;&amp;            s[i + 1] &gt;= &#x27;A&#x27; &amp;&amp; s[i + 1] &lt;= &#x27;Z&#x27;) &#123;                            res.push_back(s[i] - &#x27;A&#x27; + &#x27;a&#x27;);                      //第二种情况：输入 HTTPNameHTTP 或 HTTP          //字符串开头和结尾都是大写的情况下，也只需要把该字符转换成小写就可以了        &#125; else if ((i == 0 || i == s.size() - 1) &amp;&amp; s[i] &gt;= &#x27;A&#x27; &amp;&amp; s[i] &lt;= &#x27;Z&#x27;) &#123;                        res.push_back(s[i] - &#x27;A&#x27; + &#x27;a&#x27;);                      //第三种情况：除了以上两种特殊情况，其他字符为大写的时候        &#125; else if (s[i] &gt;= &#x27;A&#x27; &amp;&amp; s[i] &lt;= &#x27;Z&#x27;) &#123;                        res.push_back(&#x27;_&#x27;);            res.push_back(s[i] - &#x27;A&#x27; + &#x27;a&#x27;);                      //第四种情况：字符为小写的时候        &#125; else res.push_back(s[i]);    &#125;        return res;  //for循环结束后，返回res结果&#125;//以下是测试代码：void test1() &#123;        string s, res;        s = &quot;HTTP&quot;;        res = conversionString(s);    cout &lt;&lt; &quot;输入：HTTP，输出：&quot; &lt;&lt; res &lt;&lt; endl;&#125;void test2() &#123;        string s, res;        s = &quot;HTTPNameHTTP&quot;;        res = conversionString(s);    cout &lt;&lt; &quot;输入：HTTPNameHTTP，输出：&quot; &lt;&lt; res &lt;&lt; endl;&#125;void test3() &#123;        string s, res;        s = &quot;myFirstName&quot;;        res = conversionString(s);    cout &lt;&lt; &quot;输入：myFirstName，输出：&quot; &lt;&lt; res &lt;&lt; endl;&#125;void test4() &#123;        string s, res;        s = &quot;OnlineUsers&quot;;        res = conversionString(s);    cout &lt;&lt; &quot;输入：OnlineUsers，输出：&quot; &lt;&lt; res &lt;&lt; endl;&#125;void test5() &#123;        string s, res;        s = &quot;Address&quot;;        res = conversionString(s);    cout &lt;&lt; &quot;输入：Address，输出：&quot; &lt;&lt; res &lt;&lt; endl;&#125;void test6() &#123;        string s, res;        s = &quot;validHTTPRequest&quot;;        res = conversionString(s);    cout &lt;&lt; &quot;输入：validHTTPRequest，输出：&quot; &lt;&lt; res &lt;&lt; endl;&#125;int main(int argc, char *argv[]) &#123;        test1();    test2();    test3();    test4();    test5();    test6();&#125;\n\n\n","categories":["计算机理论"],"tags":["LeetCode算法-字符串"]},{"title":"剑指Offer_50_第一个只出现一次的字符","url":"/2019/06/30/%E8%AE%A1%E7%AE%97%E6%9C%BA%E7%90%86%E8%AE%BA/LeetCode%E7%AE%97%E6%B3%95/%E5%AD%97%E7%AC%A6%E4%B8%B2/1.2_%E5%89%91%E6%8C%87Offer_50_%E7%AC%AC%E4%B8%80%E4%B8%AA%E5%8F%AA%E5%87%BA%E7%8E%B0%E4%B8%80%E6%AC%A1%E7%9A%84%E5%AD%97%E7%AC%A6/","content":"题目描述：在字符串 s 中找出第一个只出现一次的字符。如果没有，返回一个单空格。 s 只包含小写字母。示例：s = &quot;abaccdeff&quot;返回 &quot;b&quot;s = &quot;&quot; 返回 &quot; &quot;限制：0 &lt;= s 的长度 &lt;= 50000\n\n解法1：哈希表class Solution &#123;public:    char firstUniqChar(string s) &#123;        unordered_map&lt;int, int&gt; map;        for (auto ch : s) ++map[ch];                for (int i = 0; i &lt; s.size(); ++i) &#123;            if (map[s[i]] == 1) return s[i];                    &#125;        return &#x27; &#x27;;    &#125;&#125;;\n\n","categories":["计算机理论"],"tags":["LeetCode算法-字符串"]},{"title":"剑指Offer_05_替换空格","url":"/2019/06/30/%E8%AE%A1%E7%AE%97%E6%9C%BA%E7%90%86%E8%AE%BA/LeetCode%E7%AE%97%E6%B3%95/%E5%AD%97%E7%AC%A6%E4%B8%B2/1.1_%E5%89%91%E6%8C%87Offer_05_%E6%9B%BF%E6%8D%A2%E7%A9%BA%E6%A0%BC/","content":"题目描述：请实现一个函数，把字符串 s 中的每个空格替换成&quot;%20&quot;。示例：输入：s = &quot;We are happy.&quot;输出：&quot;We%20are%20happy.&quot;限制：0 &lt;= s 的长度 &lt;= 10000\n\n解法1：class Solution &#123;public:\tstring replaceSpace(string s) &#123;\t\tstring res;  //重新定义一个字符串\t\tfor (auto x : s) &#123;\t\t\tif (x == &#x27; &#x27;) res += &quot;%20&quot;;\t\t\telse res += x;\t\t&#125;        \t\treturn res;\t&#125;&#125;;\n\n","categories":["计算机理论"],"tags":["LeetCode算法-字符串"]},{"title":"剑指Offer_58_翻转字符串","url":"/2019/06/30/%E8%AE%A1%E7%AE%97%E6%9C%BA%E7%90%86%E8%AE%BA/LeetCode%E7%AE%97%E6%B3%95/%E5%AD%97%E7%AC%A6%E4%B8%B2/1.3_%E5%89%91%E6%8C%87Offer_58_%E7%BF%BB%E8%BD%AC%E5%AD%97%E7%AC%A6%E4%B8%B2/","content":"❗️LeetCode_151_翻转字符串里的单词\n题目1描述：翻转单词顺序输入一个英文句子，翻转句子中单词的顺序，但单词内字符的顺序不变。为简单起见，标点符号和普通字母一样处理。例如输入字符串&quot;I am a student. &quot;，则输出&quot;student. a am I&quot;。示例：输入: &quot;the sky is blue&quot;输出: &quot;blue is sky the&quot;输入: &quot;  hello world!  &quot;输出: &quot;world! hello&quot;解释: 输入字符串可以在前面或者后面包含多余的空格，但是反转后的字符不能包括。输入: &quot;a good   example&quot;输出: &quot;example good a&quot;解释: 如果两个单词间有多余的空格，将反转后单词间的空格减少到只含一个。说明：1. 无空格字符构成一个单词。2. 输入字符串可以在前面或者后面包含多余的空格，但是反转后的字符不能包括。3. 如果两个单词间有多余的空格，将反转后单词间的空格减少到只含一个。\n\n解法1：栈//从最后一个字符开始，遇到单词则入栈，遇到空格或第一个字符都要检查一下栈中是否有单词可以弹出，若有则全部弹出并拼接，每弹出一个完整的单词就添加一个空格class Solution &#123;public:    string reverseWords(string s) &#123;        stack&lt;char&gt; word;  //定义一个栈        string result = &quot;&quot;;        for (int i = s.size() - 1; i &gt;= 0; --i) &#123;            //遇到单词则入栈            if (s[i] != &#x27; &#x27;) word.push(s[i]);            //遇到空格或第一个字符都要检查一下栈中是否有单词可以弹出            if (s[i] == &#x27; &#x27; || i == 0) &#123;                  //bool flag = false; 这一行不能去掉                //输入：&quot;  hello world!  &quot;                //输出：&quot;  world! hello &quot;                //预期结果：&quot;world! hello&quot;                bool flag = false;  //标记是否发生出栈                while (!word.empty()) &#123;                //因为word栈存储的元素为char型，而result为string型，故不能相加，只能使用push_back()                    result.push_back(word.top());                     word.pop();                    flag = true;                &#125;                //每弹出一个完整的单词就添加一个空格                if (flag == true) result += &quot; &quot;;              &#125;        &#125;        //最后一个单词后面会多加一个空格，所以只需要截取前面的部分就行        return result.substr(0, result.size() - 1);      &#125;&#125;;\n\n题目2描述：左旋转字符串字符串的左旋转操作是把字符串前面的若干个字符转移到字符串的尾部。请定义一个函数实现字符串左旋转操作的功能。比如，输入字符串&quot;abcdefg&quot;和数字2，该函数将返回左旋转两位得到的结果&quot;cdefgab&quot;。示例：输入: s = &quot;abcdefg&quot;, k = 2输出: &quot;cdefgab&quot;输入: s = &quot;lrloseumgh&quot;, k = 6输出: &quot;umghlrlose&quot;限制：1 &lt;= k &lt; s.length &lt;= 10000\n\n解法1：//将字符串倍增成为两个同样的字符串拼接的长字符串class Solution &#123;public:    string reverseLeftWords(string s, int n) &#123;                int len = s.size();        s += s;        return s.substr(n,len);    &#125;&#125;;\n\n解法2：class Solution &#123;public:    string reverseLeftWords(string s, int n) &#123;        //左闭右开        reverse(s.begin(),s.begin()+n);        reverse(s.begin()+n,s.begin()+s.size());        reverse(s.begin(),s.end());            return s;    &#125;&#125;;\n\n","categories":["计算机理论"],"tags":["LeetCode算法-字符串"]},{"title":"摩尔投票法的普遍写法","url":"/2019/06/30/%E8%AE%A1%E7%AE%97%E6%9C%BA%E7%90%86%E8%AE%BA/LeetCode%E7%AE%97%E6%B3%95/%E6%95%B0%E7%BB%84/0.1_%E6%91%A9%E5%B0%94%E6%8A%95%E7%A5%A8%E6%B3%95%E7%9A%84%E6%99%AE%E9%81%8D%E5%86%99%E6%B3%95/","content":"\n","categories":["计算机理论"],"tags":["LeetCode算法-数组"]},{"title":"剑指Offer_39_数组中出现次数超过一半的数字","url":"/2019/06/30/%E8%AE%A1%E7%AE%97%E6%9C%BA%E7%90%86%E8%AE%BA/LeetCode%E7%AE%97%E6%B3%95/%E6%95%B0%E7%BB%84/1.3_%E5%89%91%E6%8C%87Offer_39_%E6%95%B0%E7%BB%84%E4%B8%AD%E5%87%BA%E7%8E%B0%E6%AC%A1%E6%95%B0%E8%B6%85%E8%BF%87%E4%B8%80%E5%8D%8A%E7%9A%84%E6%95%B0%E5%AD%97/","content":"❗️LeetCode_169_多数元素\n题目描述：数组中有一个数字出现的次数超过数组长度的一半，请找出这个数字。你可以假设数组是非空的，并且给定的数组总是存在多数元素。示例：输入: [1, 2, 3, 2, 2, 2, 5, 4, 2]输出: 2限制：1 &lt;= 数组长度 &lt;= 50000\n\n解法1：哈希表class Solution &#123;public:    int majorityElement(vector&lt;int&gt;&amp; nums) &#123;        unordered_map&lt;int,int&gt; map;  //定义一个哈希表        int k = nums.size() / 2;        for (int i = 0;i &lt; nums.size();++i) &#123;            ++map[nums[i]];            if (map[nums[i]] &gt; k) return nums[i];        &#125;        return NULL;    &#125;&#125;;\n\n解法2：摩尔投票法class Solution &#123;public:    int majorityElement(vector&lt;int&gt;&amp; nums) &#123;        if (nums.empty()) return &#123;&#125;;        int m = 0,msize = 0,n = 0,nsize = 0;        for (auto num : nums) &#123;            if (m == num) msize++;            else if (n == num) nsize++;            else if (msize == 0) m = num,msize++;            else if (nsize == 0) n = num,nsize++;            else msize--,nsize--;        &#125;        msize = nsize = 0;        for (auto num : nums) &#123;            if (num == m) msize++;            else if (num == n) nsize++;        &#125;        if (msize &gt; nums.size() / 2) return m;        if (nsize &gt; nums.size() / 2) return n;                return NULL;    &#125;&#125;;\n\n","categories":["计算机理论"],"tags":["LeetCode算法-数组"]},{"title":"剑指Offer_04_二维数组中的查找","url":"/2019/06/30/%E8%AE%A1%E7%AE%97%E6%9C%BA%E7%90%86%E8%AE%BA/LeetCode%E7%AE%97%E6%B3%95/%E6%95%B0%E7%BB%84/1.2_%E5%89%91%E6%8C%87Offer_04_%E4%BA%8C%E7%BB%B4%E6%95%B0%E7%BB%84%E4%B8%AD%E7%9A%84%E6%9F%A5%E6%89%BE/","content":"❗️LeetCode_240_搜索二维矩阵2\n题目描述：在一个 n * m 的二维数组中，每一行都按照从左到右递增的顺序排序，每一列都按照从上到下递增的顺序排序。请完成一个高效的函数，输入这样的一个二维数组和一个整数，判断数组中是否含有该整数。示例：现有矩阵 matrix 如下：[  [1,   4,  7, 11, 15],  [2,   5,  8, 12, 19],  [3,   6,  9, 16, 22],  [10, 13, 14, 17, 24],  [18, 21, 23, 26, 30]]给定 target = 5，返回 true。给定 target = 20，返回 false。限制：1. 0 &lt;= n &lt;= 10002. 0 &lt;= m &lt;= 1000\n\n解法1：从右上角遍历class Solution &#123;public:    bool findNumberIn2DArray(vector&lt;vector&lt;int&gt;&gt;&amp; matrix, int target) &#123;        int nums = matrix.size();  //矩阵的数量        //这行代码不能写在下面那行代码的后面，因为如果矩阵为空，下面那行代码会报错        if (nums == 0) return false;          int cols = matrix[0].size();  //一行的数量\t\tint i = 0;        int j = cols - 1;\t\t        //首先选取数组中右上角的数字，如果该数字等于要查找的数字，则查找过程结束；        //如果该数字大于要查找的数字，则剔除这个数字所在的列        //如果该数字小于要查找的数字，则剔除这个数字所在的行        //同样我们也可以选取左下角的数字，但我们不能选取左上角或右下角的数字        while (i &lt; nums &amp;&amp; j &gt;= 0) &#123;            //从右上角开始遍历            if (matrix[i][j] == target)\treturn true;            else if (matrix[i][j] &lt; target)\ti++;            else j--;        &#125;        return false;    &#125;&#125;;\n\n","categories":["计算机理论"],"tags":["LeetCode算法-数组"]},{"title":"LeetCode_229_求众数2","url":"/2019/06/30/%E8%AE%A1%E7%AE%97%E6%9C%BA%E7%90%86%E8%AE%BA/LeetCode%E7%AE%97%E6%B3%95/%E6%95%B0%E7%BB%84/2.2_LeetCode_229_%E6%B1%82%E4%BC%97%E6%95%B02/","content":"题目描述：给定一个大小为 n 的整数数组，找出其中所有出现超过 ⌊ n/3 ⌋ 次的元素。示例：输入：[3,2,3]输出：[3]输入：nums = [1]输出：[1]输入：[1,1,1,3,3,2,2,2]输出：[1,2]提示：1. 1 &lt;= nums.length &lt;= 5 * 10^42. -10^9 &lt;= nums[i] &lt;= 10^9\n\n解法1：哈希表class Solution &#123;public:    vector&lt;int&gt; majorityElement(vector&lt;int&gt;&amp; nums) &#123;        vector&lt;int&gt; ans;  //定义一个容器，返回最终结果        unordered_map&lt;int,int&gt; mp;  //定义一个哈希表        int k = nums.size() / 3;        for (int i = 0; i &lt; nums.size();++i) &#123;            ++mp[nums[i]];            if (mp[nums[i]] &gt; k) &#123;                ans.push_back(nums[i]);                mp[nums[i]] = -1;  //让它永远卡在-1            &#125;            if (mp[nums[i]] == 0) mp[nums[i]] = -1;        &#125;        return ans;    &#125;&#125;;\n\nclass Solution &#123;public:    vector&lt;int&gt; majorityElement(vector&lt;int&gt;&amp; nums) &#123;        vector&lt;int&gt; ans;  //定义一个容器，返回最终结果        unordered_map&lt;int,int&gt; mp;  //定义一个哈希表，键存储数值，值存储数值出现的次数        int k = nums.size() / 3;        for (int i = 0; i &lt; nums.size();++i) &#123;            ++mp[nums[i]];        &#125;        for (auto &amp;a : mp) &#123;                        //a.first表示键，a.second表示值            if (a.second &gt; k) ans.push_back(a.first);        &#125;        return ans;    &#125;&#125;;\n\n解法2：摩尔投票法class Solution &#123;public:    vector&lt;int&gt; majorityElement(vector&lt;int&gt;&amp; nums) &#123;        vector&lt;int&gt; res;        if (nums.empty()) return &#123;&#125;;        int m = 0,msize = 0,n = 0,nsize = 0;        for (auto num : nums) &#123;            if (m == num) msize++;            else if (n == num) nsize++;            else if (msize == 0) m = num,msize++;            else if (nsize == 0) n = num,nsize++;            else msize--,nsize--;        &#125;        msize = nsize = 0;        for (auto num : nums) &#123;            if (num == m) msize++;            else if (num == n) nsize++;        &#125;        if (msize &gt; nums.size() / 3) res.push_back(m);        if (nsize &gt; nums.size() / 3) res.push_back(n);                return res;    &#125;&#125;;\n","categories":["计算机理论"],"tags":["LeetCode算法-数组"]},{"title":"剑指Offer_53-2_0～n-1中缺失的数字","url":"/2019/06/30/%E8%AE%A1%E7%AE%97%E6%9C%BA%E7%90%86%E8%AE%BA/LeetCode%E7%AE%97%E6%B3%95/%E6%9F%A5%E6%89%BE%E7%AE%97%E6%B3%95/1.1_%E5%89%91%E6%8C%87Offer_53-2_0%EF%BD%9En-1%E4%B8%AD%E7%BC%BA%E5%A4%B1%E7%9A%84%E6%95%B0%E5%AD%97/","content":"题目描述：一个长度为n-1的递增排序数组中的所有数字都是唯一的，并且每个数字都在范围0～n-1之内。在范围0～n-1内的n个数字中有且只有一个数字不在该数组中，请找出这个数字。示例：输入: [0,1,3]输出: 2输入: [0,1,2,3,4,5,6,7,9]输出: 8限制：1 &lt;= 数组长度 &lt;= 10000\n\n解法1：class Solution &#123;public:    int missingNumber(vector&lt;int&gt;&amp; nums) &#123;        for (int i = 0;i &lt; nums.size();++i) &#123;            if (nums[i] != i) return i;        &#125;        return nums.size();    &#125;&#125;;\n\n解法2：二分查找class Solution &#123;public:    int missingNumber(vector&lt;int&gt;&amp; nums) &#123;        if (nums.empty()) return NULL;        int l = 0, r = nums.size() - 1;        while (l &lt;= r) &#123;            int mid = (l + r) / 2;            if (nums[mid] != mid) r = mid - 1;            else l = mid + 1;        &#125;        //输入：[1,2] 输出：0        //输入：[0,1,2] 输出：3        if (r == -1 || nums[r] == r) ++r;          return r;    &#125;&#125;;\n\n","categories":["计算机理论"],"tags":["LeetCode算法-查找算法"]},{"title":"LeetCode_01_两数之和","url":"/2019/06/30/%E8%AE%A1%E7%AE%97%E6%9C%BA%E7%90%86%E8%AE%BA/LeetCode%E7%AE%97%E6%B3%95/%E6%95%B0%E7%BB%84/2.1_LeetCode_01_%E4%B8%A4%E6%95%B0%E4%B9%8B%E5%92%8C/","content":"题目描述：给定一个整数数组 nums 和一个整数目标值 target，请你在该数组中找出 和为目标值 target  的那 两个 整数，并返回它们的数组下标。你可以假设每种输入只会对应一个答案。但是，数组中同一个元素在答案里不能重复出现。你可以按任意顺序返回答案。示例：输入：nums = [2,7,11,15], target = 9输出：[0,1]解释：因为 nums[0] + nums[1] == 9 ，返回 [0, 1] 。输入：nums = [3,2,4], target = 6输出：[1,2]输入：nums = [3,3], target = 6输出：[0,1]提示：1. 2 &lt;= nums.length &lt;= 10^42. -10^9 &lt;= nums[i] &lt;= 10^93. -10^9 &lt;= target &lt;= 10^94. 只会存在一个有效答案⭐️注意与LeetCode_167题的区别：本题数组是乱序的并且题目要求返回的是数组的下标，所以不可以使用双指针；167题可以\n\n解法1：暴力枚举//方法1：暴力枚举class Solution &#123;public:    vector&lt;int&gt; twoSum(vector&lt;int&gt;&amp; nums, int target) &#123;        int n = nums.size();        for (int i = 0; i &lt; n; ++i) &#123;            for (int j = i + 1; j &lt; n; ++j) &#123;                if (nums[i] + nums[j] == target) &#123;                    return &#123;i, j&#125;;                &#125;            &#125;        &#125;        return &#123;&#125;;    &#125;&#125;;\n\n解法2：哈希表class Solution &#123;public:    vector&lt;int&gt; twoSum(vector&lt;int&gt;&amp; nums, int target) &#123;\t    unordered_map&lt;int,int&gt; mp;  //定义一个哈希表：将数组数字作为键，数组下标作为值\t    vector&lt;int&gt; ans;\t    for (int i = 0;i &lt; nums.size();i++) &#123;            //count返回值为1或者0，1返回存在，0返回不存在，返回的是布尔类型的值，            //因为在map类型中所有的数据的Key值都是不同的，所以被count的数要么存在1次，要么不存在\t\t    if (mp.count(target - nums[i])) &#123;\t\t\t    ans.push_back(i);\t\t\t    ans.push_back(mp[target - nums[i]]); \t\t    &#125; \t\t            //将数组的数字和下标作为键和值存到map中\t\t    mp[nums[i]] = i;     \t    &#125;\t    return ans;    &#125;&#125;;\n\n","categories":["计算机理论"],"tags":["LeetCode算法-数组"]},{"title":"剑指Offer_03_数组中重复的数字","url":"/2019/06/30/%E8%AE%A1%E7%AE%97%E6%9C%BA%E7%90%86%E8%AE%BA/LeetCode%E7%AE%97%E6%B3%95/%E6%95%B0%E7%BB%84/1.1_%E5%89%91%E6%8C%87Offer_03_%E6%95%B0%E7%BB%84%E4%B8%AD%E9%87%8D%E5%A4%8D%E7%9A%84%E6%95%B0%E5%AD%97/","content":"题目描述：找出数组中重复的数字。在一个长度为 n 的数组 nums 里的所有数字都在 0～n-1 的范围内。数组中某些数字是重复的，但不知道有几个数字重复了，也不知道每个数字重复了几次。请找出数组中任意一个重复的数字。示例：输入：[2, 3, 1, 0, 2, 5, 3]输出：2 或 3 限制：2 &lt;= n &lt;= 100000\n\n解法1：修改数组//代码中尽管有一个两重循环，但每个数字最多只要交换两次就能找到属于它自己的位置，因此总的时间复杂度是O(n)，另外，所有的操作步骤都是在输入数组上进行的，不需要额外分配内存，因此空间复杂度为O(1)class Solution &#123;public:    int findRepeatNumber(vector&lt;int&gt;&amp; nums) &#123;        int temp;        //我们注意到数组中的数字都在0～n-1的范围内，如果这个数组中没有重复的数字，那么当数组排序之后数字i将出现在下标为i的位置。由于数组中有重复的数字，有些位置可能存在多个数字，同时有些位置可能没有数字        for (int i = 0;i &lt; nums.size();i++) &#123;            while (nums[i] != i) &#123;                if (nums[i] == nums[nums[i]]) return nums[i];                temp = nums[i];                nums[i] = nums[temp];                nums[temp] = temp;            &#125;        &#125;        return -1;    &#125;&#125;;\n\n解法2：哈希表class Solution &#123;public:    int findRepeatNumber(vector&lt;int&gt;&amp; nums) &#123;        unordered_map&lt;int, int&gt; hash;  //定义一个哈希表        for(int i = 0; i &lt; nums.size(); ++i) &#123;            hash[nums[i]]++;  //遇到重复的数字，就将它的索引+1            if (hash[nums[i]] != 1) return nums[i];        &#125;        return -1;    &#125;&#125;;\n\n","categories":["计算机理论"],"tags":["LeetCode算法-数组"]},{"title":"LeetCode_34_在排序数组中查找元素的第一个和最后一个位置","url":"/2019/06/30/%E8%AE%A1%E7%AE%97%E6%9C%BA%E7%90%86%E8%AE%BA/LeetCode%E7%AE%97%E6%B3%95/%E6%9F%A5%E6%89%BE%E7%AE%97%E6%B3%95/2.2_LeetCode_34_%E5%9C%A8%E6%8E%92%E5%BA%8F%E6%95%B0%E7%BB%84%E4%B8%AD%E6%9F%A5%E6%89%BE%E5%85%83%E7%B4%A0%E7%9A%84%E7%AC%AC%E4%B8%80%E4%B8%AA%E5%92%8C%E6%9C%80%E5%90%8E%E4%B8%80%E4%B8%AA%E4%BD%8D%E7%BD%AE/","content":"❗️剑指Offer_53-1_在排序数组中查找数字1\n题目描述：给定一个按照升序排列的整数数组 nums，和一个目标值 target。找出给定目标值在数组中的开始位置和结束位置。如果数组中不存在目标值 target，返回 [-1, -1]。示例：输入：nums = [5,7,7,8,8,10], target = 8输出：[3,4]输入：nums = [5,7,7,8,8,10], target = 6输出：[-1,-1]输入：nums = [], target = 0输出：[-1,-1]提示：1. 0 &lt;= nums.length &lt;= 10^52. -10^9 &lt;= nums[i] &lt;= 10^93. nums 是一个非递减数组4. -10^9 &lt;= target &lt;= 10^9\n\n解法1：二分查找//这道题可以看作是自己实现C++里的lower_bound和upper_bound函数class Solution &#123;public:    vector&lt;int&gt; searchRange(vector&lt;int&gt;&amp; nums, int target) &#123;        if (nums.empty()) return vector&lt;int&gt; &#123;-1,-1&#125;;        //二分查找尤其要注意边界值，尽量使用左闭右闭的写法        int lower = lower_bound(nums,target);        int upper = upper_bound(nums,target) - 1;  //注意这里需要减1        //[5,7,7,8,8,10] 6        //[2,2] 3        if (lower == nums.size() || nums[lower] != target) &#123;            return vector&lt;int&gt; &#123;-1,-1&#125;;        &#125;        return vector&lt;int&gt; &#123;lower,upper&#125;;    &#125;    //查找元素的第一个位置    int lower_bound(vector&lt;int&gt; &amp;nums,int target) &#123;        int l = 0,r = nums.size() - 1,mid;        while (l &lt;= r) &#123;            mid = (l + r) / 2;            if (nums[mid] &gt;= target) r = mid - 1;            else l = mid + 1;        &#125;        return l;    &#125;    //查找元素的最后一个位置    int upper_bound(vector&lt;int&gt; &amp;nums,int target) &#123;        int l = 0,r = nums.size() - 1,mid;        while (l &lt;= r) &#123;            mid = (l + r) / 2;            if (nums[mid] &gt; target) r = mid - 1;            else l = mid + 1;        &#125;        return l;    &#125;&#125;;\n\n//剑指Offer_53-1_在排序数组中查找数字1//解法2：哈希表class Solution &#123;public:    int search(vector&lt;int&gt;&amp; nums, int target) &#123;        unordered_map&lt;int,int&gt; map;        for (auto num : nums) ++map[num];        for (auto a : map) &#123;            if (a.first == target) return a.second;        &#125;        return 0;    &#125;&#125;;\n\n","categories":["计算机理论"],"tags":["LeetCode算法-查找算法"]},{"title":"常用的查找算法","url":"/2019/06/30/%E8%AE%A1%E7%AE%97%E6%9C%BA%E7%90%86%E8%AE%BA/LeetCode%E7%AE%97%E6%B3%95/%E6%9F%A5%E6%89%BE%E7%AE%97%E6%B3%95/0.1_%E5%B8%B8%E7%94%A8%E7%9A%84%E6%9F%A5%E6%89%BE%E7%AE%97%E6%B3%95/","content":"","categories":["计算机理论"],"tags":["LeetCode算法-查找算法"]},{"title":"剑指Offer_11_旋转数组的最小数字","url":"/2019/06/30/%E8%AE%A1%E7%AE%97%E6%9C%BA%E7%90%86%E8%AE%BA/LeetCode%E7%AE%97%E6%B3%95/%E6%9F%A5%E6%89%BE%E7%AE%97%E6%B3%95/1.2_%E5%89%91%E6%8C%87Offer_11_%E6%97%8B%E8%BD%AC%E6%95%B0%E7%BB%84%E7%9A%84%E6%9C%80%E5%B0%8F%E6%95%B0%E5%AD%97/","content":"❗️LeetCode_154_寻找旋转排序数组中的最小值2\n❗️LeetCode_153_寻找旋转排序数组中的最小值\n题目描述：把一个数组最开始的若干个元素搬到数组的末尾，我们称之为数组的旋转。输入一个递增排序的数组的一个旋转，输出旋转数组的最小元素。例如，数组 [3,4,5,1,2] 为 [1,2,3,4,5] 的一个旋转，该数组的最小值为1。  示例：输入：[3,4,5,1,2]输出：1输入：[2,2,2,0,1]输出：0\n\n解法1：二分查找class Solution &#123;public:    int minArray(vector&lt;int&gt;&amp; numbers) &#123;        int low = 0, high = numbers.size() - 1;        while (low &lt;= high) &#123;  //条件都是&lt;=            int pivot = low + (high - low) / 2;  //取中点            //表示右边是递增的            if (numbers[pivot] &lt; numbers[high]) high = pivot;                        //表示左边是递增的            else if (numbers[pivot] &gt; numbers[high]) low = pivot + 1;                        //如果本题数组中元素各不相同，这个条件也要带上            else high -= 1;  //特殊情况：[1,1,1,1,2,1,1,1]        &#125;        return numbers[low];    &#125;&#125;;\n\n","categories":["计算机理论"],"tags":["LeetCode算法-查找算法"]},{"title":"LeetCode_33_搜索旋转排序数组","url":"/2019/06/30/%E8%AE%A1%E7%AE%97%E6%9C%BA%E7%90%86%E8%AE%BA/LeetCode%E7%AE%97%E6%B3%95/%E6%9F%A5%E6%89%BE%E7%AE%97%E6%B3%95/2.3_LeetCode_33_%E6%90%9C%E7%B4%A2%E6%97%8B%E8%BD%AC%E6%8E%92%E5%BA%8F%E6%95%B0%E7%BB%84/","content":"题目描述：整数数组 nums 按升序排列，数组中的值 互不相同 。在传递给函数之前，nums 在预先未知的某个下标 k（0 &lt;= k &lt; nums.length）上进行了 旋转，使数组变为 [nums[k], nums[k+1], ..., nums[n-1], nums[0], nums[1], ..., nums[k-1]]（下标 从 0 开始 计数）。例如， [0,1,2,4,5,6,7] 在下标 3 处经旋转后可能变为 [4,5,6,7,0,1,2] 。给你 旋转后 的数组 nums 和一个整数 target ，如果 nums 中存在这个目标值 target ，则返回它的下标，否则返回 -1 。示例：输入：nums = [4,5,6,7,0,1,2], target = 0输出：4输入：nums = [4,5,6,7,0,1,2], target = 3输出：-1输入：nums = [1], target = 0输出：-1提示：1. 1 &lt;= nums.length &lt;= 50002. -10^4 &lt;= nums[i] &lt;= 10^43. nums 中的每个值都 独一无二4. 题目数据保证 nums 在预先未知的某个下标上进行了旋转5. -10^4 &lt;= target &lt;= 10^4\n\n解法1：二分查找class Solution &#123;public:    int search(vector&lt;int&gt;&amp; nums, int target) &#123;        int start = 0,end = nums.size() - 1;        while (start &lt;= end) &#123;  //条件都是&lt;=            int mid = (start + end) / 2;  //取中点                        if (nums[mid] == target) return mid;  //先判断条件            if (nums[mid] &lt; nums[end]) &#123;  //右区间是递增的                if (target &gt; nums[mid] &amp;&amp; target &lt;= nums[end]) start = mid + 1;                else end = mid - 1;            &#125; else if (nums[mid] &gt; nums[end])&#123;  //左区间是递增的                if (target &gt;= nums[start] &amp;&amp; target &lt; nums[mid]) end = mid - 1;                else start = mid + 1;                            &#125; else end -= 1;  //即使本题数组中元素各不相同，这个条件也要带上        &#125;        return -1;    &#125;&#125;;\n\nclass Solution &#123;public:    int search(vector&lt;int&gt;&amp; nums, int target) &#123;        int start = 0,end = nums.size() - 1;        while (start &lt;= end) &#123;  //条件都是&lt;=            int mid = (start + end) / 2;  //取中点                        if (nums[mid] == target) return mid;  //先判断条件            if (nums[mid] &lt; nums[end]) &#123;  //右区间是递增的                if (target &gt; nums[mid] &amp;&amp; target &lt;= nums[end]) start = mid + 1;                else end = mid - 1;            &#125; else &#123;  //左区间是递增的                if (target &gt;= nums[start] &amp;&amp; target &lt; nums[mid]) end = mid - 1;                else start = mid + 1;                            &#125;        &#125;        return -1;    &#125;&#125;;\n\n","categories":["计算机理论"],"tags":["LeetCode算法-查找算法"]},{"title":"剑指Offer_42_连续子数组的最大和","url":"/2019/06/30/%E8%AE%A1%E7%AE%97%E6%9C%BA%E7%90%86%E8%AE%BA/LeetCode%E7%AE%97%E6%B3%95/%E5%8A%A8%E6%80%81%E8%A7%84%E5%88%92/1.1_%E5%89%91%E6%8C%87Offer_42_%E8%BF%9E%E7%BB%AD%E5%AD%90%E6%95%B0%E7%BB%84%E7%9A%84%E6%9C%80%E5%A4%A7%E5%92%8C/","content":"❗️LeetCode_53_最大子序和\n题目描述：输入一个整型数组，数组中的一个或连续多个整数组成一个子数组。求所有子数组的和的最大值。要求时间复杂度为O(n)。示例：输入: nums = [-2,1,-3,4,-1,2,1,-5,4]输出: 6解释: 连续子数组 [4,-1,2,1] 的和最大，为 6。提示：1. 1 &lt;= arr.length &lt;= 10^52. -100 &lt;= arr[i] &lt;= 100\n\n解法1：动态规划class Solution &#123;public:    int maxSubArray(vector&lt;int&gt;&amp; nums) &#123;        //先默认第一个数为最大值        int sum = 0, maxsum = nums[0];        for (auto &amp;num : nums) &#123;            if (sum &lt;= 0) sum = num;  //如果当前sum为负数时，舍弃            else sum += num;                        maxsum = (sum &gt; maxsum) ? sum : maxsum;  //不停比较更新maxsum        &#125;        return maxsum;    &#125;&#125;;\n\n","categories":["计算机理论"],"tags":["LeetCode算法-动态规划"]},{"title":"LeetCode_81_搜索旋转排序数组2","url":"/2019/06/30/%E8%AE%A1%E7%AE%97%E6%9C%BA%E7%90%86%E8%AE%BA/LeetCode%E7%AE%97%E6%B3%95/%E6%9F%A5%E6%89%BE%E7%AE%97%E6%B3%95/2.4_LeetCode_81_%E6%90%9C%E7%B4%A2%E6%97%8B%E8%BD%AC%E6%8E%92%E5%BA%8F%E6%95%B0%E7%BB%842/","content":"题目描述：已知存在一个按非降序排列的整数数组 nums ，数组中的值不必互不相同。在传递给函数之前，nums 在预先未知的某个下标 k（0 &lt;= k &lt; nums.length）上进行了 旋转 ，使数组变为 [nums[k], nums[k+1], ..., nums[n-1], nums[0], nums[1], ..., nums[k-1]]（下标 从 0 开始 计数）。例如， [0,1,2,4,4,4,5,6,6,7] 在下标 5 处经旋转后可能变为 [4,5,6,6,7,0,1,2,4,4] 。给你 旋转后 的数组 nums 和一个整数 target ，请你编写一个函数来判断给定的目标值是否存在于数组中。如果 nums 中存在这个目标值 target ，则返回 true ，否则返回 false 。示例：输入：nums = [2,5,6,0,0,1,2], target = 0输出：true输入：nums = [2,5,6,0,0,1,2], target = 3输出：false提示：1. 1 &lt;= nums.length &lt;= 50002. -10^4 &lt;= nums[i] &lt;= 10^43. 题目数据保证 nums 在预先未知的某个下标上进行了旋转4. -10^4 &lt;= target &lt;= 10^4\n\n解法1：二分查找class Solution &#123;public:    bool search(vector&lt;int&gt;&amp; nums, int target) &#123;        int start = 0,end = nums.size() - 1;        while (start &lt;= end) &#123;  //条件都是&lt;=            int mid = (start + end) / 2;  //取中点                        if (nums[mid] == target) return true;  //先判断条件            if (nums[mid] &lt; nums[end]) &#123;  //右区间是递增的                if (target &gt; nums[mid] &amp;&amp; target &lt;= nums[end]) start = mid + 1;                else end = mid - 1;            &#125; else if (nums[mid] &gt; nums[end]) &#123;  //左区间是递增的                if (target &gt;= nums[start] &amp;&amp; target &lt; nums[mid]) end = mid - 1;                else start = mid + 1;                            &#125; else end -= 1;  //特殊情况：[1,1,1,1,2,1,1,1] 2        &#125;        return false;    &#125;&#125;;\n\n","categories":["计算机理论"],"tags":["LeetCode算法-查找算法"]},{"title":"剑指Offer_10-2_青蛙跳台阶问题","url":"/2019/06/30/%E8%AE%A1%E7%AE%97%E6%9C%BA%E7%90%86%E8%AE%BA/LeetCode%E7%AE%97%E6%B3%95/%E5%8A%A8%E6%80%81%E8%A7%84%E5%88%92/1.3_%E5%89%91%E6%8C%87Offer_10-2_%E9%9D%92%E8%9B%99%E8%B7%B3%E5%8F%B0%E9%98%B6%E9%97%AE%E9%A2%98/","content":"❗️LeetCode_70_爬楼梯(该题1 &lt;&#x3D; n &lt;&#x3D; 45)\n题目描述：一只青蛙一次可以跳上1级台阶，也可以跳上2级台阶。求该青蛙跳上一个 n 级的台阶总共有多少种跳法。答案需要取模 1e9+7（1000000007），如计算初始结果为：1000000008，请返回 1。示例：输入：n = 2输出：2输入：n = 7输出：21输入：n = 0输出：1提示：0 &lt;= n &lt;= 100\n\n解法1：迭代class Solution &#123;public:    int numWays(int n) &#123;        if (n &lt; 0) return 0;        //题目给出n = 0时，输出1        if (n == 0 || n == 1) return 1;        long long fibOne = 0;  //每次保存第一个数        long long fibTwo = 1;  //每次保存第二个数        int fibN = 1;  //最后的结果        for (int i = 2;i &lt;= n;i++) &#123;            fibOne = fibTwo;            fibTwo = fibN;            fibN = (fibOne + fibTwo) % 1000000007;        &#125;        return fibN;    &#125;&#125;;\n\n","categories":["计算机理论"],"tags":["LeetCode算法-动态规划"]},{"title":"剑指Offer_14-1_剪绳子","url":"/2019/06/30/%E8%AE%A1%E7%AE%97%E6%9C%BA%E7%90%86%E8%AE%BA/LeetCode%E7%AE%97%E6%B3%95/%E5%8A%A8%E6%80%81%E8%A7%84%E5%88%92/1.4_%E5%89%91%E6%8C%87Offer_14-1_%E5%89%AA%E7%BB%B3%E5%AD%90/","content":"❗️LeetCode_343_整数拆分\n题目描述：给你一根长度为 n 的绳子，请把绳子剪成整数长度的 m 段（m、n都是整数，n&gt;1并且m&gt;1），每段绳子的长度记为 k[0],k[1]...k[m-1] 。请问 k[0]*k[1]*...*k[m-1] 可能的最大乘积是多少？例如，当绳子的长度是8时，我们把它剪成长度分别为2、3、3的三段，此时得到的最大乘积是18。示例：输入: 2输出: 1解释: 2 = 1 + 1, 1 × 1 = 1输入: 10输出: 36解释: 10 = 3 + 3 + 4, 3 × 3 × 4 = 36提示：2 &lt;= n &lt;= 58\n\n解法1：动态规划class Solution &#123;public:    int cuttingRope(int n) &#123;        if (n == 2 || n == 3) return n - 1;        vector&lt;int&gt; dp(n + 1, 0);        dp[0] = 0;        dp[1] = 1;        dp[2] = 2;  //不等于1的原因是我可以不剪开这段长度为2的绳子        dp[3] = 3;  //不等于2        for (int i = 4; i &lt;= n; i++) &#123;            for (int j = 1; j &lt; i; j++) &#123;                dp[i] = max(dp[i], dp[j] * dp[i - j]);            &#125;        &#125;        return dp[n];    &#125;&#125;;\n\n","categories":["计算机理论"],"tags":["LeetCode算法-动态规划"]},{"title":"剑指Offer_10-1_斐波那契数列","url":"/2019/06/30/%E8%AE%A1%E7%AE%97%E6%9C%BA%E7%90%86%E8%AE%BA/LeetCode%E7%AE%97%E6%B3%95/%E5%8A%A8%E6%80%81%E8%A7%84%E5%88%92/1.2_%E5%89%91%E6%8C%87Offer_10-1_%E6%96%90%E6%B3%A2%E9%82%A3%E5%A5%91%E6%95%B0%E5%88%97/","content":"❗️LeetCode_509_斐波那契数【n的范围为：[0,30]】\n题目描述：写一个函数，输入 n ，求斐波那契（Fibonacci）数列的第 n 项（即 F(N)）。斐波那契数列的定义如下：F(0) = 0,   F(1) = 1F(N) = F(N - 1) + F(N - 2), 其中 N &gt; 1.斐波那契数列由 0 和 1 开始，之后的斐波那契数就是由之前的两数相加而得出。答案需要取模 1e9+7（1000000007），如计算初始结果为：1000000008，请返回 1。示例：输入：n = 2输出：1输入：n = 5输出：5提示：0 &lt;= n &lt;= 100\n\n解法1：递归class Solution &#123;public:    int fib(int n) &#123;        if (n &lt;= 0) return 0;        if (n == 1) return 1;        //效率很低的解法：递归        return (fib(n - 1) + fib(n - 2)) % 1000000007;    &#125;&#125;;\n\n解法2：迭代class Solution &#123;public:    int fib(int n) &#123;        if (n &lt; 0) return 0;        int result[2] = &#123;0,1&#125;;        if (n &gt;= 0 &amp;&amp; n &lt; 2) return result[n];        long long fibOne = 0;  //每次保存第一个数        long long fibTwo = 1;  //每次保存第二个数        int fibN = 0;  //最后的结果        for (int i = 2;i &lt;= n;i++) &#123;            fibN = (fibOne + fibTwo) % 1000000007;            fibOne = fibTwo;            fibTwo = fibN;        &#125;        return fibN;    &#125;&#125;;\n\n","categories":["计算机理论"],"tags":["LeetCode算法-动态规划"]},{"title":"LeetCode_413_等差数列划分","url":"/2019/06/30/%E8%AE%A1%E7%AE%97%E6%9C%BA%E7%90%86%E8%AE%BA/LeetCode%E7%AE%97%E6%B3%95/%E5%8A%A8%E6%80%81%E8%A7%84%E5%88%92/2.2_LeetCode_413_%E7%AD%89%E5%B7%AE%E6%95%B0%E5%88%97%E5%88%92%E5%88%86/","content":"题目描述：如果一个数列 至少有三个元素 ，并且任意两个相邻元素之差相同，则称该数列为等差数列。例如，[1,3,5,7,9]、[7,7,7,7] 和 [3,-1,-5,-9] 都是等差数列。给你一个整数数组 nums ，返回数组 nums 中所有为等差数组的 子数组 个数。子数组 是数组中的一个连续序列。示例：输入：nums = [1,2,3,4]输出：3解释：nums 中有三个子等差数组：[1, 2, 3]、[2, 3, 4] 和 [1,2,3,4] 自身。输入：nums = [1]输出：0提示：1. 1 &lt;= nums.length &lt;= 50002. -1000 &lt;= nums[i] &lt;= 1000\n\n解法1：动态规划class Solution &#123;public:    int numberOfArithmeticSlices(vector&lt;int&gt;&amp; nums) &#123;        int n = nums.size();        if (n &lt; 3)  return 0;        int dp = 0, sum = 0;        for (int i = 2; i &lt; n; i++) &#123;            if (nums[i - 1] - nums[i - 2] == nums[i] - nums[i - 1]) &#123;                dp++;                sum += dp;            &#125; else dp = 0;        &#125;        return sum;    &#125;&#125;;\n\n","categories":["计算机理论"],"tags":["LeetCode算法-动态规划"]},{"title":"LeetCode_198_打家劫舍","url":"/2019/06/30/%E8%AE%A1%E7%AE%97%E6%9C%BA%E7%90%86%E8%AE%BA/LeetCode%E7%AE%97%E6%B3%95/%E5%8A%A8%E6%80%81%E8%A7%84%E5%88%92/2.1_LeetCode_198_%E6%89%93%E5%AE%B6%E5%8A%AB%E8%88%8D/","content":"题目描述：你是一个专业的小偷，计划偷窃沿街的房屋。每间房内都藏有一定的现金，影响你偷窃的唯一制约因素就是相邻的房屋装有相互连通的防盗系统，如果两间相邻的房屋在同一晚上被小偷闯入，系统会自动报警。给定一个代表每个房屋存放金额的非负整数数组，计算你 不触动警报装置的情况下 ，一夜之内能够偷窃到的最高金额。示例：输入：[1,2,3,1]输出：4解释：偷窃 1 号房屋 (金额 = 1) ，然后偷窃 3 号房屋 (金额 = 3)。     偷窃到的最高金额 = 1 + 3 = 4 。输入：[2,7,9,3,1]输出：12解释：偷窃 1 号房屋 (金额 = 2), 偷窃 3 号房屋 (金额 = 9)，接着偷窃 5 号房屋 (金额 = 1)。     偷窃到的最高金额 = 2 + 9 + 1 = 12 。提示：1. 1 &lt;= nums.length &lt;= 1002. 0 &lt;= nums[i] &lt;= 400\n\n解法1：动态规划class Solution &#123;public:    int rob(vector&lt;int&gt;&amp; nums) &#123;        if (nums.empty()) return 0;        int n = nums.size();        if (n == 1) return nums[0];        int pre1 = 0, pre2 = nums[0], cur;        for (int i = 2; i &lt;= n; ++i) &#123;           cur = max(pre1 + nums[i-1], pre2);           pre1 = pre2;           pre2 = cur;        &#125;        return cur;     &#125;&#125;;\n\n","categories":["计算机理论"],"tags":["LeetCode算法-动态规划"]},{"title":"剑指Offer_56_数组中数字出现的次数","url":"/2019/06/30/%E8%AE%A1%E7%AE%97%E6%9C%BA%E7%90%86%E8%AE%BA/LeetCode%E7%AE%97%E6%B3%95/%E6%95%B0%E5%AD%A6/1.2_%E5%89%91%E6%8C%87Offer_56_%E6%95%B0%E7%BB%84%E4%B8%AD%E6%95%B0%E5%AD%97%E5%87%BA%E7%8E%B0%E7%9A%84%E6%AC%A1%E6%95%B0/","content":"题目1描述：一个整型数组 nums 里除两个数字之外，其他数字都出现了两次。请写程序找出这两个只出现一次的数字。要求时间复杂度是O(n)，空间复杂度是O(1)。示例：输入：nums = [4,1,4,6]输出：[1,6] 或 [6,1]输入：nums = [1,2,10,4,1,4,3,3]输出：[2,10] 或 [10,2]限制：2 &lt;= nums.length &lt;= 10000\n\n解法1：异或运算class Solution &#123;public:    vector&lt;int&gt; singleNumbers(vector&lt;int&gt;&amp; nums) &#123;        int x = 0, y = 0, n = 0, m = 1;        //异或运算有个重要的性质：两个相同数字异或为0，        //因此，若将nums中所有数字执行异或运算，留下的结果则为出现一次的数字        for (int num : nums) n ^= num;        //本题难点：数组nums有两个只出现一次的数字，因此无法通过异或直接得到这两个数字        //nums = [1,2,10,4,1,4,3,3] 异或后的n为1000        //循环左移，计算m的值为8，1000        while ((n &amp; m) == 0) m &lt;&lt;= 1;        //所以根据第4位是否为1将原数组分为两个子数组        //[10]、[1,2,4,1,4,3,3]        //分别进行异或计算        for (int num : nums) &#123;                   if ((num &amp; m) != 0) x ^= num;  //第4位为1            else y ^= num;  //第4位不为1        &#125;        return vector&lt;int&gt; &#123;x, y&#125;;  //返回只出现一次的数字    &#125;&#125;;\n\n❗️LeetCode_137_只出现一次的数字2\n题目2描述：在一个数组 nums 中除一个数字只出现一次之外，其他数字都出现了三次。请找出那个只出现一次的数字。示例：输入：nums = [3,4,3,3]输出：4输入：nums = [9,1,7,9,7,9,7]输出：1限制：1. 1 &lt;= nums.length &lt;= 100002. 1 &lt;= nums[i] &lt; 2^31\n\n解法1：哈希表class Solution &#123;public:    int singleNumber(vector&lt;int&gt;&amp; nums) &#123;        unordered_map&lt;int,int&gt; map;  //定义一个哈希表        for (int i = 0;i &lt; nums.size();++i) ++map[nums[i]];        //for (auto &amp;i : nums) ++map[i];        for (auto &amp;v : map) &#123;            if (v.second == 1) return v.first;        &#125;        return NULL;    &#125;&#125;;\n\n","categories":["计算机理论"],"tags":["LeetCode算法-数学"]},{"title":"LeetCode_69_x的平方根","url":"/2019/06/30/%E8%AE%A1%E7%AE%97%E6%9C%BA%E7%90%86%E8%AE%BA/LeetCode%E7%AE%97%E6%B3%95/%E6%9F%A5%E6%89%BE%E7%AE%97%E6%B3%95/2.1_LeetCode_69_x%E7%9A%84%E5%B9%B3%E6%96%B9%E6%A0%B9/","content":"题目描述：二分查找也常被称为二分法或者折半查找，每次查找时通过将待查找区间分成两部分并只取一部分继续查找，将查找的复杂度大大减少。对于一个长度为O(n)的数组，二分查找的时间复杂度为O(logn)二分查找也可以看作双指针的一种特殊情况，但我们一般会将二者区分。双指针类型的题，指针通常是一步一步移动的，而在二分查找里，指针每次移动半个区间长度实现 int sqrt(int x) 函数。计算并返回 x 的平方根，其中 x 是非负整数。由于返回类型是整数，结果只保留整数的部分，小数部分将被舍去。示例：输入: 4输出: 2输入: 8输出: 2说明: 8 的平方根是 2.82842...,      由于返回类型是整数，小数部分将被舍去。\n\n解法1：二分查找class Solution &#123;public:    int mySqrt(int x) &#123;        if (x == 0) return 0;        int l = 1,r = x,mid,sqrt;        while (l &lt;= r) &#123;            //求一串排列数的中间值的时候：最好用‘l + (r - l) / 2’             //用‘(l + r) / 2’会很容易造成溢出            //比如传入x = 2147483647的情况            mid = l + (r - l) / 2;              sqrt = x / mid;            if (sqrt == mid) return mid;            else if (mid &gt; sqrt) r = mid - 1;            else l = mid + 1;        &#125;        return r;    &#125;&#125;;\n\n","categories":["计算机理论"],"tags":["LeetCode算法-查找算法"]},{"title":"LeetCode_709_转换成小写字母","url":"/2019/06/30/%E8%AE%A1%E7%AE%97%E6%9C%BA%E7%90%86%E8%AE%BA/LeetCode%E7%AE%97%E6%B3%95/%E6%95%B0%E5%AD%A6/2.3_LeetCode_709_%E8%BD%AC%E6%8D%A2%E6%88%90%E5%B0%8F%E5%86%99%E5%AD%97%E6%AF%8D/","content":"题目描述：给你一个字符串 s ，将该字符串中的大写字母转换成相同的小写字母，返回新的字符串。示例：输入：s = &quot;Hello&quot;输出：&quot;hello&quot;输入：s = &quot;here&quot;输出：&quot;here&quot;输入：s = &quot;Hello@&#123;&#125;&quot;输出：&quot;hello@&#123;&#125;&quot;提示：1. 1 &lt;= s.length &lt;= 1002. s 由 ASCII 字符集中的可打印字符组成\n\n解法1：位运算class Solution &#123;public:    string toLowerCase(string s) &#123;        //A：01000001  a：01100001        //对应大小写字母的后4位二进制是一样的        //对应大小字母的前4位中，只有第3位bit值不一样        //把不一样的bit位单独取出来，其它位补0，也就是 0b0010 0000，对应的十进制数就是32        for (int i = 0;i &lt; s.size();i++) &#123;            //大写变小写、小写变大写：字符 ^= 32             //大写变小写、小写变小写：字符 |= 32            //大写变大写、小写变大写：字符 &amp;= -33            if (s[i] &gt;= &#x27;A&#x27; &amp;&amp; s[i] &lt;= &#x27;Z&#x27;) &#123;                s[i] |= 32;  //或者写成s[i] += 32;            &#125;        &#125;        return  s;    &#125;&#125;;\n\n","categories":["计算机理论"],"tags":["LeetCode算法-数学"]},{"title":"LeetCode_136_只出现一次的数字","url":"/2019/06/30/%E8%AE%A1%E7%AE%97%E6%9C%BA%E7%90%86%E8%AE%BA/LeetCode%E7%AE%97%E6%B3%95/%E6%95%B0%E5%AD%A6/2.4_LeetCode_136_%E5%8F%AA%E5%87%BA%E7%8E%B0%E4%B8%80%E6%AC%A1%E7%9A%84%E6%95%B0%E5%AD%97/","content":"题目描述：给定一个非空整数数组，除了某个元素只出现一次以外，其余每个元素均出现两次。找出那个只出现了一次的元素。说明：你的算法应该具有线性时间复杂度。 你可以不使用额外空间来实现吗？示例：输入: [2,2,1]输出: 1输入: [4,1,2,1,2]输出: 4\n\n解法1：异或运算class Solution &#123;public:    int singleNumber(vector&lt;int&gt;&amp; nums) &#123;        int x = 0;        //异或运算有个重要的性质：两个相同数字异或为0，        //因此，若将nums中所有数字执行异或运算，留下的结果则为出现一次的数字        for (int num : nums) x ^= num;        return x;    &#125;&#125;;\n\n","categories":["计算机理论"],"tags":["LeetCode算法-数学"]},{"title":"LeetCode_07_整数反转","url":"/2019/06/30/%E8%AE%A1%E7%AE%97%E6%9C%BA%E7%90%86%E8%AE%BA/LeetCode%E7%AE%97%E6%B3%95/%E6%95%B0%E5%AD%A6/2.1_LeetCode_07_%E6%95%B4%E6%95%B0%E5%8F%8D%E8%BD%AC/","content":"题目描述：给你一个 32 位的有符号整数 x ，返回将 x 中的数字部分反转后的结果。如果反转后整数超过 32 位的有符号整数的范围 [−231,  231 − 1] ，就返回 0。假设环境不允许存储 64 位整数（有符号或无符号）。示例：输入：x = 123输出：321输入：x = -123输出：-321输入：x = 120输出：21输入：x = 0输出：0提示：-2^31 &lt;= x &lt;= 2^31 - 1\n\n解法1：class Solution &#123;public:    int reverse(int x) &#123;        int rev = 0;  //反转后的结果        while (x != 0) &#123;                        if (rev &lt; INT_MIN / 10 || rev &gt; INT_MAX / 10) &#123;                return 0;            &#125;            int digit = x % 10;            x /= 10;            rev = rev * 10 + digit;        &#125;        return rev;    &#125;&#125;;\n\n","categories":["计算机理论"],"tags":["LeetCode算法-数学"]},{"title":"LeetCode_231_2的幂","url":"/2019/06/30/%E8%AE%A1%E7%AE%97%E6%9C%BA%E7%90%86%E8%AE%BA/LeetCode%E7%AE%97%E6%B3%95/%E6%95%B0%E5%AD%A6/2.2_LeetCode_231_2%E7%9A%84%E5%B9%82/","content":"位运算符：&amp;：与，两位都为1，那么结果为1|：或，有一位为1，那么结果为1~：非，~0 = 1, ~1 = 0^：异或，两位不相同，结果为1&lt;&lt;：左移，各二进位全部左移若干位，高位丢弃，低位补0&gt;&gt;：右移，各二进位全部右移若干位，对无符号数，高位补0；有符号数，各编译器处理方法不一样，有的补符号位，有的补0\n\n题目描述：给你一个整数 n，请你判断该整数是否是 2 的幂次方。如果是，返回 true ；否则，返回 false 。如果存在一个整数 x 使得 n == 2x ，则认为 n 是 2 的幂次方。示例：输入：n = 1输出：true解释：20 = 1输入：n = 16输出：true解释：24 = 16输入：n = 3输出：false输入：n = 4输出：true输入：n = 5输出：false提示：-2^31 &lt;= n &lt;= 2^31 - 1\n\n解法1：位运算class Solution &#123;public:    bool isPowerOfTwo(int n) &#123;                return (n &gt; 0 &amp;&amp; (n &amp; (n - 1)) == 0);    &#125;&#125;;\n\n","categories":["计算机理论"],"tags":["LeetCode算法-数学"]},{"title":"剑指Offer_64_求1+2+···+n","url":"/2019/06/30/%E8%AE%A1%E7%AE%97%E6%9C%BA%E7%90%86%E8%AE%BA/LeetCode%E7%AE%97%E6%B3%95/%E6%95%B0%E5%AD%A6/1.1_%E5%89%91%E6%8C%87Offer_64_%E6%B1%821+2+%C2%B7%C2%B7%C2%B7+n/","content":"题目描述：求 1+2+...+n ，要求不能使用乘除法、for、while、if、else、switch、case等关键字及条件判断语句（A?B:C）。示例：输入: n = 3输出: 6输入: n = 9输出: 45限制：1 &lt;= n &lt;= 10000\n\n解法1：递归class Solution &#123;public:    int sumNums(int n) &#123;        (n &gt; 0) &amp;&amp; (n += sumNums(n - 1));        return n;    &#125;&#125;;\n\n","categories":["计算机理论"],"tags":["LeetCode算法-数学"]},{"title":"剑指Offer_30_包含min函数的栈","url":"/2019/06/30/%E8%AE%A1%E7%AE%97%E6%9C%BA%E7%90%86%E8%AE%BA/LeetCode%E7%AE%97%E6%B3%95/%E6%A0%88%E5%92%8C%E9%98%9F%E5%88%97/1.3_%E5%89%91%E6%8C%87Offer_30_%E5%8C%85%E5%90%ABmin%E5%87%BD%E6%95%B0%E7%9A%84%E6%A0%88/","content":"❗️LeetCode_155_最小栈\n题目描述：定义栈的数据结构，请在该类型中实现一个能够得到栈的最小元素的 min 函数在该栈中，调用 min、push 及 pop 的时间复杂度都是 O(1)。示例：MinStack minStack = new MinStack();minStack.push(-2);minStack.push(0);minStack.push(-3);minStack.min();   --&gt; 返回 -3.minStack.pop();minStack.top();      --&gt; 返回 0.minStack.min();   --&gt; 返回 -2.提示：各函数的调用总次数不超过 20000 次\n\n解法1：/** * Your MinStack object will be instantiated and called as such: * MinStack* obj = new MinStack(); * obj-&gt;push(x); * obj-&gt;pop(); * int param_3 = obj-&gt;top(); * int param_4 = obj-&gt;min(); */class MinStack &#123;public:    stack&lt;int&gt; s;  //主栈    stack&lt;int&gt; Mins;  //辅助栈，用来保存最小值    MinStack() &#123;        //因为辅助栈保存的是最小值，所以要初始化成最大的数        Mins.push(INT_MAX);    &#125;        void push(int x) &#123;        s.push(x);  //主栈元素入栈            //辅助栈元素入栈，入的是辅助栈栈顶和已入主栈元素两者中的最小值        Mins.push(std::min(Mins.top(), x));  //min要加命名空间，因为下面重写了min    &#125;        void pop() &#123;                s.pop();  //主栈栈顶元素出栈                Mins.pop();  //辅助栈也必须同步将栈顶元素出栈    &#125;        int top() &#123;        return s.top();  //返回主栈的栈顶元素    &#125;        int min() &#123;        return Mins.top();  //返回主栈的最小值即辅助栈此时的栈顶元素    &#125;    &#125;;\n\n","categories":["计算机理论"],"tags":["LeetCode算法-栈和队列"]},{"title":"剑指Offer_09_用两个栈实现队列","url":"/2019/06/30/%E8%AE%A1%E7%AE%97%E6%9C%BA%E7%90%86%E8%AE%BA/LeetCode%E7%AE%97%E6%B3%95/%E6%A0%88%E5%92%8C%E9%98%9F%E5%88%97/1.1_%E5%89%91%E6%8C%87Offer_09_%E7%94%A8%E4%B8%A4%E4%B8%AA%E6%A0%88%E5%AE%9E%E7%8E%B0%E9%98%9F%E5%88%97/","content":"题目描述：用两个栈实现一个队列。队列的声明如下，请实现它的两个函数 appendTail 和 deleteHead ，分别完成在队列尾部插入整数和在队列头部删除整数的功能。(若队列中没有元素，deleteHead 操作返回 -1 )示例：输入：[&quot;CQueue&quot;,&quot;appendTail&quot;,&quot;deleteHead&quot;,&quot;deleteHead&quot;][[],[3],[],[]]输出：[null,null,3,-1]输入：[&quot;CQueue&quot;,&quot;deleteHead&quot;,&quot;appendTail&quot;,&quot;appendTail&quot;,&quot;deleteHead&quot;,&quot;deleteHead&quot;][[],[],[5],[2],[],[]]输出：[null,-1,null,null,5,2]提示：1. 1 &lt;= values &lt;= 100002. 最多会对 appendTail、deleteHead 进行 10000 次调用\n\n解法1：/** * Your CQueue object will be instantiated and called as such: * CQueue* obj = new CQueue(); * obj-&gt;appendTail(value); * int param_2 = obj-&gt;deleteHead(); */class CQueue &#123;public:    stack&lt;int&gt; stack1,stack2;  //定义两个栈    //总结删除一个元素的步骤：    //当stack2不为空时，在stack2中的栈顶元素是最先进入队列的元素，可以弹出    //当stack2为空时，我们把stack1中的元素逐个弹出并压入stack2，由于先进入队列的元素被压到stack1的底端，经过弹出和压入操作之后就处于stack2的顶端，又可以直接弹出    CQueue() &#123;        while (!stack1.empty()) stack1.pop();        while (!stack2.empty()) stack2.pop();        //现在两个栈中都没有元素了    &#125;        void appendTail(int value) &#123;        stack1.push(value);  //先往栈1中压入元素    &#125;        int deleteHead() &#123;        if (stack2.empty()) &#123;            while (!stack1.empty()) &#123;                stack2.push(stack1.top());                stack1.pop();            &#125;        &#125;         if (stack2.empty()) &#123;            return -1;        &#125; else &#123;            int deleteItem = stack2.top();            stack2.pop();            return deleteItem;        &#125;    &#125;    &#125;;\n\n","categories":["计算机理论"],"tags":["LeetCode算法-栈和队列"]},{"title":"剑指Offer_31_栈的压入、弹出序列","url":"/2019/06/30/%E8%AE%A1%E7%AE%97%E6%9C%BA%E7%90%86%E8%AE%BA/LeetCode%E7%AE%97%E6%B3%95/%E6%A0%88%E5%92%8C%E9%98%9F%E5%88%97/1.4_%E5%89%91%E6%8C%87Offer_31_%E6%A0%88%E7%9A%84%E5%8E%8B%E5%85%A5%E3%80%81%E5%BC%B9%E5%87%BA%E5%BA%8F%E5%88%97/","content":"❗️LeetCode_946_验证栈序列\n题目描述：输入两个整数序列，第一个序列表示栈的压入顺序，请判断第二个序列是否为该栈的弹出顺序。假设压入栈的所有数字均不相等。例如，序列 &#123;1,2,3,4,5&#125; 是某栈的压栈序列，序列 &#123;4,5,3,2,1&#125; 是该压栈序列对应的一个弹出序列，但 &#123;4,3,5,1,2&#125; 就不可能是该压栈序列的弹出序列。示例：输入：pushed = [1,2,3,4,5], popped = [4,5,3,2,1]输出：true解释：我们可以按以下顺序执行：push(1), push(2), push(3), push(4), pop() -&gt; 4,push(5), pop() -&gt; 5, pop() -&gt; 3, pop() -&gt; 2, pop() -&gt; 1输入：pushed = [1,2,3,4,5], popped = [4,3,5,1,2]输出：false解释：1 不能在 2 之前弹出。提示：1. 0 &lt;= pushed.length == popped.length &lt;= 10002. 0 &lt;= pushed[i], popped[i] &lt; 10003. pushed 是 popped 的排列。\n\n解法1：辅助栈//判断一个序列是不是栈的弹出序列的规律：如果下一个弹出的数字刚好是栈顶数字，那么直接弹出；如果下一个弹出的数字不在栈顶，则把压栈序列中还没有入栈的数字压入辅助栈，直到把下一个需要弹出的数字压入栈顶为止；如果所有数字都压入栈后仍然没有找到下一个弹出的数字，那么该序列不可能是一个弹出序列class Solution &#123;public:    bool validateStackSequences(vector&lt;int&gt;&amp; pushed, vector&lt;int&gt;&amp; popped) &#123;        int n = pushed.size();  //n表示压栈序列的个数        stack&lt;int&gt; s;  //辅助栈：模拟出栈入栈行为        //逐个检查能否得到popped出栈序列        for (int i = 0, j = 0; j &lt; n;++j) &#123;            //若栈顶元素不是当前popped序列所处理的那个或栈空，那就从pushed序列取元素入栈            while (i &lt; n &amp;&amp; (s.empty() || s.top() != popped[j])) &#123;            //当调用push成员函数时，我们将元素类型的对象传递给它们，这些对象被拷贝到容器中。            //而当我们调用一个emplace成员函数时，则是将参数传递给元素类型的构造函数。emplace成员使用这些参数在容器管理的内存空间中直接构造元素。                s.emplace(pushed[i++]);            &#125;            //如果出栈序列用完了都得不到出栈序列元素，说明pushed的入栈顺序不可能得到popped的出栈顺序            if (i == n &amp;&amp; s.top() != popped[j]) return false;            while (j &lt; n &amp;&amp; !s.empty() &amp;&amp; s.top() == popped[j]) &#123;                                s.pop();            &#125;        &#125;        return true;　　　　　　               &#125;&#125;;　　　　 　　　　　　　　　　 　　　　　　　　　　　\n\n","categories":["计算机理论"],"tags":["LeetCode算法-栈和队列"]},{"title":"LeetCode_28_实现strStr()","url":"/2019/06/30/%E8%AE%A1%E7%AE%97%E6%9C%BA%E7%90%86%E8%AE%BA/LeetCode%E7%AE%97%E6%B3%95/%E5%AD%97%E7%AC%A6%E4%B8%B2/2.1_LeetCode_28_%E5%AE%9E%E7%8E%B0strStr()/","content":"题目描述：实现 strStr() 函数。给你两个字符串 haystack 和 needle ，请你在 haystack 字符串中找出 needle 字符串出现的第一个位置（下标从 0 开始）。如果不存在，则返回  -1 。说明：当 needle 是空字符串时，我们应当返回什么值呢？这是一个在面试中很好的问题。对于本题而言，当 needle 是空字符串时我们应当返回 0 。这与 C 语言的 strstr() 以及 Java 的 indexOf() 定义相符。示例：输入：haystack = &quot;hello&quot;, needle = &quot;ll&quot;输出：2输入：haystack = &quot;aaaaa&quot;, needle = &quot;bba&quot;输出：-1输入：haystack = &quot;&quot;, needle = &quot;&quot;输出：0提示：1. 0 &lt;= haystack.length, needle.length &lt;= 5 * 10^42. haystack 和 needle 仅由小写英文字符组成\n\n解法1：串的朴素模式匹配算法class Solution &#123;public:    int strStr(string haystack, string needle) &#123;        int start = 0;  //记录当前检查的子串起始位置        int i = 0, j = 0;  //两个指针分别指向主串和模式串的开头        //这两行顺序不要颠倒        if (needle.size() == 0) return 0;        if (haystack.size() == 0) return -1;        while (i &lt; haystack.size() &amp;&amp; j &lt; needle.size()) &#123;            if (haystack[i] == needle[j]) &#123;                ++i;                ++j;            &#125; else &#123;                ++start;                i = start;                j = 0;            &#125;        &#125;        //可以发现：只要主串中含有模式串，最终j指针一定等于needle.size()        if (j == needle.size()) return start;        else return -1;    &#125;&#125;;\n\n解法2：KMP算法class Solution &#123;public:    //求模式串needle的next数组    //当模式串的第j个字符匹配失败时，令模式串跳到next[j]再继续匹配    void get_next(string needle,int *next) &#123;        int i = 0,j = -1;        next[0] = -1;        while (i &lt; needle.size() - 1) &#123;            if (j == -1 || needle[i] == needle[j]) &#123;                ++i;                ++j;                next[i] = j;            &#125; else j = next[j];        &#125;    &#125;    int strStr(string haystack, string needle) &#123;        if (needle.size() == 0) return 0;        if (haystack.size() == 0) return -1;        int i = 0,j = 0;        int next[needle.size()];        get_next(needle,next);  //得到模式串的next数组        int b = needle.size();          //这里必须写成：j &lt; b，写成j &lt; needle.size()运行结果为-1，不知道原因是啥❗️        while (i &lt; haystack.size() &amp;&amp; j &lt; b) &#123;            if (j == -1 || haystack[i] == needle[j]) &#123;                ++i;                ++j;            &#125; else j = next[j];        &#125;        if (j == needle.size()) return i - j;        else return -1;    &#125;&#125;;\n\n","categories":["计算机理论"],"tags":["LeetCode算法-字符串"]},{"title":"LeetCode_225_用队列实现栈","url":"/2019/06/30/%E8%AE%A1%E7%AE%97%E6%9C%BA%E7%90%86%E8%AE%BA/LeetCode%E7%AE%97%E6%B3%95/%E6%A0%88%E5%92%8C%E9%98%9F%E5%88%97/2.2_LeetCode_225_%E7%94%A8%E9%98%9F%E5%88%97%E5%AE%9E%E7%8E%B0%E6%A0%88/","content":"题目描述：请你仅使用两个队列实现一个后入先出（LIFO）的栈，并支持普通栈的全部四种操作（push、top、pop 和 empty）。实现 MyStack 类：1. void push(int x) 将元素 x 压入栈顶。2. int pop() 移除并返回栈顶元素。3. int top() 返回栈顶元素。4. boolean empty() 如果栈是空的，返回 true ；否则，返回 false 。注意：1. 你只能使用队列的基本操作 —— 也就是 push to back、peek/pop from front、size 和 is empty 这些操作。2. 你所使用的语言也许不支持队列。 你可以使用 list （列表）或者 deque（双端队列）来模拟一个队列 , 只要是标准的队列操作即可。示例：输入：[&quot;MyStack&quot;, &quot;push&quot;, &quot;push&quot;, &quot;top&quot;, &quot;pop&quot;, &quot;empty&quot;][[], [1], [2], [], [], []]输出：[null, null, null, 2, 2, false]解释：MyStack myStack = new MyStack();myStack.push(1);myStack.push(2);myStack.top(); // 返回 2myStack.pop(); // 返回 2myStack.empty(); // 返回 False提示：1. 1 &lt;= x &lt;= 92. 最多调用100 次 push、pop、top 和 empty3. 每次调用 pop 和 top 都保证栈不为空\n\n解法1：/** * Your MyStack object will be instantiated and called as such: * MyStack* obj = new MyStack(); * obj-&gt;push(x); * int param_2 = obj-&gt;pop(); * int param_3 = obj-&gt;top(); * bool param_4 = obj-&gt;empty(); */class MyStack &#123;public:    queue&lt;int&gt; queue1,queue2;  //定义两个队列    /** Initialize your data structure here. */    MyStack() &#123;&#125;    /** Push element x onto stack. */    void push(int x) &#123;        queue2.push(x);        while (!queue1.empty()) &#123;            queue2.push(queue1.front());            queue1.pop();        &#125;        //一开始先往队列2中压入a、b、c三个元素，然后交换队列1、队列2的位置，这个时候队列1中就有三个元素了        //再从队列1中弹出a、b元素到队列2中，再弹出c元素        //再交换队列1、队列2的位置，队列1中就有a、b两个元素了，再把a元素压入队列2中，一直这样循环下去        swap(queue1, queue2);    &#125;        /** Removes the element on top of the stack and returns that element. */    int pop() &#123;        int r = queue1.front();        queue1.pop();        return r;    &#125;        /** Get the top element. */    int top() &#123;        int r = queue1.front();        return r;    &#125;        /** Returns whether the stack is empty. */    bool empty() &#123;        return queue1.empty();    &#125;&#125;;\n\n","categories":["计算机理论"],"tags":["LeetCode算法-栈和队列"]},{"title":"剑指Offer_59_队列的最大值","url":"/2019/06/30/%E8%AE%A1%E7%AE%97%E6%9C%BA%E7%90%86%E8%AE%BA/LeetCode%E7%AE%97%E6%B3%95/%E6%A0%88%E5%92%8C%E9%98%9F%E5%88%97/1.2_%E5%89%91%E6%8C%87Offer_59_%E9%98%9F%E5%88%97%E7%9A%84%E6%9C%80%E5%A4%A7%E5%80%BC/","content":"❗️LeetCode_239_滑动窗口最大值\n题目1描述：滑动窗口的最大值给定一个数组 nums 和滑动窗口的大小 k，请找出所有滑动窗口里的最大值。示例：输入: nums = [1,3,-1,-3,5,3,6,7], 和 k = 3输出: [3,3,5,5,6,7] 解释: 见下图提示：你可以假设 k 总是有效的，在输入数组不为空的情况下，1 ≤ k ≤ 输入数组的大小。\n\n\n解法1：//一个滑动窗口可以看成一个队列，当窗口滑动时，处于窗口的第一个数字被删除，同时在窗口的末尾添加一个新的数字，这符合队列的“先进先出”特性，如果能从队列中找出它的最大数，那么这个问题也就解决了//思路：我们并不把滑动窗口的每个数值都存入队列，而是只把有可能成为滑动窗口最大值的数值存进去class Solution &#123;public:    vector&lt;int&gt; maxSlidingWindow(vector&lt;int&gt;&amp; nums, int k) &#123;        vector&lt;int&gt; maxInWindows;  //定义一个容器，存放所有滑动窗口里的最大值        if (nums.size() &gt;= k &amp;&amp; k &gt;= 1) &#123;            deque&lt;int&gt; index;  //deque是一个双端队列，本题该队列中存放的是数组的下标，而不是数值            for (int i = 0; i &lt; k; ++i) &#123;                //数组的后一个元素比前一个元素大，因此前一个元素不可能成为滑动窗口中的最大值                while (!index.empty() &amp;&amp; nums[i] &gt;= nums[index.back()])                    index.pop_back();  //从队列的尾部删除❗️                index.push_back(i);  //将数组下标存放到队列中，从队列的尾部放入❗️            &#125;            for (int i = k; i &lt; nums.size(); ++i) &#123;                //将当前队列的第一个值对应的数组的值存入容器中                maxInWindows.push_back(nums[index.front()]);                  while (!index.empty() &amp;&amp; nums[i] &gt;= nums[index.back()])                    index.pop_back();                 //当一个数字的下标与当前处理的数字的下标之差大于或者等于滑动窗口的大小时，                //这个数字已经从窗口中滑出，可以从队列中删除了                if (!index.empty() &amp;&amp; index.front() &lt;= (int) (i - k))                    index.pop_front();  //从队列的头部删除❗️                    //⭐️由于队列的头部和尾部都有可能删除数字，这也是需要双端队列的原因                index.push_back(i);            &#125;            //因为for循环已经结束，所以下面这句代码需要单独写            maxInWindows.push_back(nums[index.front()]);        &#125;        return maxInWindows;    &#125;&#125;;\n\n题目2描述：队列的最大值请定义一个队列并实现函数 max_value 得到队列里的最大值，要求函数max_value、push_back 和 pop_front 的均摊时间复杂度都是O(1)。若队列为空，pop_front 和 max_value 需要返回 -1示例：输入: [&quot;MaxQueue&quot;,&quot;push_back&quot;,&quot;push_back&quot;,&quot;max_value&quot;,&quot;pop_front&quot;,&quot;max_value&quot;][[],[1],[2],[],[],[]]输出: [null,null,null,2,1,2]输入: [&quot;MaxQueue&quot;,&quot;pop_front&quot;,&quot;max_value&quot;][[],[],[]]输出: [null,-1,-1]限制：1. 1 &lt;= push_back,pop_front,max_value的总操作数 &lt;= 100002. 1 &lt;= value &lt;= 10^5\n\n解法1：/** * Your MaxQueue object will be instantiated and called as such: * MaxQueue* obj = new MaxQueue(); * int param_1 = obj-&gt;max_value(); * obj-&gt;push_back(value); * int param_3 = obj-&gt;pop_front(); */class MaxQueue &#123;public:    queue&lt;int&gt; q;  //定义一个普通队列    deque&lt;int&gt; d;  //定义一个双端队列        int max_value() &#123;        if (d.empty()) return -1;        return d.front();  //双端队列的首部存放的就是队列在某一时刻的最大值    &#125;        void push_back(int value) &#123;                while (!d.empty() &amp;&amp; d.back() &lt;= value) &#123;            d.pop_back();        &#125;        q.push(value);  //先往普通队列中放入值        d.push_back(value);  //再往双端队列中放入值，从尾部放入    &#125;        int pop_front() &#123;        if (q.empty()) return -1;        //先执行void push_back(int value)函数，执行后的结果：        //普通队列q：2 3 2 1 3         //双端队列d：3 3        int ans = q.front();        if (ans == d.front()) d.pop_front();        q.pop();                return ans;  //ans的值分别为3、3    &#125;    &#125;;","categories":["计算机理论"],"tags":["LeetCode算法-栈和队列"]},{"title":"LeetCode_232_用栈实现队列","url":"/2019/06/30/%E8%AE%A1%E7%AE%97%E6%9C%BA%E7%90%86%E8%AE%BA/LeetCode%E7%AE%97%E6%B3%95/%E6%A0%88%E5%92%8C%E9%98%9F%E5%88%97/2.1_LeetCode_232_%E7%94%A8%E6%A0%88%E5%AE%9E%E7%8E%B0%E9%98%9F%E5%88%97/","content":"题目描述：请你仅使用两个栈实现先入先出队列。队列应当支持一般队列支持的所有操作（push、pop、peek、empty）：实现 MyQueue 类：1. void push(int x) 将元素 x 推到队列的末尾2. int pop() 从队列的开头移除并返回元素3. int peek() 返回队列开头的元素4. boolean empty() 如果队列为空，返回 true ；否则，返回 false说明：1. 你只能使用标准的栈操作 —— 也就是只有 push to top, peek/pop from top, size, 和 is empty 操作是合法的。2. 你所使用的语言也许不支持栈。你可以使用 list 或者 deque（双端队列）来模拟一个栈，只要是标准的栈操作即可。示例：输入：[&quot;MyQueue&quot;, &quot;push&quot;, &quot;push&quot;, &quot;peek&quot;, &quot;pop&quot;, &quot;empty&quot;][[], [1], [2], [], [], []]输出：[null, null, null, 1, 1, false]解释：MyQueue myQueue = new MyQueue();myQueue.push(1); // queue is: [1]myQueue.push(2); // queue is: [1, 2] (leftmost is front of the queue)myQueue.peek(); // return 1myQueue.pop(); // return 1, queue is [2]myQueue.empty(); // return false提示：1. 1 &lt;= x &lt;= 92. 最多调用 100 次 push、pop、peek 和 empty3. 假设所有操作都是有效的 （例如，一个空的队列不会调用 pop 或者 peek 操作）\n\n解法1：/** * Your MyQueue object will be instantiated and called as such: * MyQueue* obj = new MyQueue(); * obj-&gt;push(x); * int param_2 = obj-&gt;pop(); * int param_3 = obj-&gt;peek(); * bool param_4 = obj-&gt;empty(); */class MyQueue &#123;private:    stack&lt;int&gt; inStack, outStack;  //定义两个栈    void in2out() &#123;        while (!inStack.empty()) &#123;            outStack.push(inStack.top());            inStack.pop();        &#125;    &#125;public:    /** Initialize your data structure here. */    MyQueue() &#123;&#125;    /** Push element x to the back of queue. */    void push(int x) &#123;        inStack.push(x);    &#125;    /** Removes the element from in front of queue and returns that element. */    int pop() &#123;        if (outStack.empty()) in2out();        int x = outStack.top();        outStack.pop();        return x;    &#125;    /** Get the front element. */    int peek() &#123;        if (outStack.empty()) in2out();        return outStack.top();    &#125;    /** Returns whether the queue is empty. */    bool empty() &#123;        return inStack.empty() &amp;&amp; outStack.empty();    &#125;    &#125;;\n\n","categories":["计算机理论"],"tags":["LeetCode算法-栈和队列"]},{"title":"LeetCode_67_二进制求和","url":"/2019/06/30/%E8%AE%A1%E7%AE%97%E6%9C%BA%E7%90%86%E8%AE%BA/LeetCode%E7%AE%97%E6%B3%95/%E6%B1%82%E5%92%8C/2.4_LeetCode_67_%E4%BA%8C%E8%BF%9B%E5%88%B6%E6%B1%82%E5%92%8C/","content":"题目描述：给你两个二进制字符串，返回它们的和（用二进制表示）。输入为 非空 字符串且只包含数字 1 和 0。示例：输入: a = &quot;11&quot;, b = &quot;1&quot;输出: &quot;100&quot;输入: a = &quot;1010&quot;, b = &quot;1011&quot;输出: &quot;10101&quot;提示：1. 每个字符串仅由字符 &#x27;0&#x27; 或 &#x27;1&#x27; 组成。2. 1 &lt;= a.length, b.length &lt;= 10^43. 字符串如果不是 &quot;0&quot; ，就都不含前导零。\n\n解法1：逐项求和class Solution &#123;public:    string addBinary(string num1, string num2) &#123;        string res = &quot;&quot;;        int i1 = num1.length() - 1, i2 = num2.length() - 1;        int carry = 0;        while (i1 &gt;= 0 || i2 &gt;= 0) &#123;            int x = i1 &gt;= 0 ? num1[i1] - &#x27;0&#x27; : 0;            int y = i2 &gt;= 0 ? num2[i2] - &#x27;0&#x27; : 0;            int sum = x + y + carry;            res.push_back(&#x27;0&#x27; + sum % 2);            carry = sum / 2;            i1--;            i2--;        &#125;        if (carry != 0) res.push_back(&#x27;0&#x27; + carry);        reverse(res.begin(), res.end());        return res;    &#125;&#125;;\n\n","categories":["计算机理论"],"tags":["LeetCode算法-求和"]},{"title":"LeetCode_415_字符串相加","url":"/2019/06/30/%E8%AE%A1%E7%AE%97%E6%9C%BA%E7%90%86%E8%AE%BA/LeetCode%E7%AE%97%E6%B3%95/%E6%B1%82%E5%92%8C/2.3_LeetCode_415_%E5%AD%97%E7%AC%A6%E4%B8%B2%E7%9B%B8%E5%8A%A0/","content":"题目描述：给定两个字符串形式的非负整数 num1 和num2 ，计算它们的和。提示：1. num1 和num2 的长度都小于 51002. num1 和num2 都只包含数字 0-93. num1 和num2 都不包含任何前导零4. 你不能使用任何內建 BigInteger 库， 也不能直接将输入的字符串转换为整数形式示例：输入：&quot;11&quot;  &quot;123&quot;输出：&quot;134&quot;\n\n解法1：逐项求和class Solution &#123;public:    string addStrings(string num1, string num2) &#123;        string res = &quot;&quot;;        int i1 = num1.length() - 1, i2 = num2.length() - 1;        int carry = 0;        while (i1 &gt;= 0 || i2 &gt;= 0) &#123;            //❗️字符串中一定要注意&#x27;0&#x27;            int x = i1 &gt;= 0 ? num1[i1] - &#x27;0&#x27; : 0;            int y = i2 &gt;= 0 ? num2[i2] - &#x27;0&#x27; : 0;            int sum = x + y + carry;            res.push_back(&#x27;0&#x27; + sum % 10);            carry = sum / 10;            i1--;            i2--;        &#125;        if (carry != 0) res.push_back(&#x27;0&#x27; + carry);        reverse(res.begin(), res.end());        return res;    &#125;&#125;;\n\n","categories":["计算机理论"],"tags":["LeetCode算法-求和"]},{"title":"LeetCode_02_两数相加","url":"/2019/06/30/%E8%AE%A1%E7%AE%97%E6%9C%BA%E7%90%86%E8%AE%BA/LeetCode%E7%AE%97%E6%B3%95/%E6%B1%82%E5%92%8C/2.5_LeetCode_02_%E4%B8%A4%E6%95%B0%E7%9B%B8%E5%8A%A0/","content":"题目描述：给你两个 非空 的链表，表示两个非负的整数。它们每位数字都是按照 逆序 的方式存储的，并且每个节点只能存储 一位 数字。请你将两个数相加，并以相同形式返回一个表示和的链表。你可以假设除了数字 0 之外，这两个数都不会以 0 开头。示例：输入：l1 = [2,4,3], l2 = [5,6,4]输出：[7,0,8]解释：342 + 465 = 807.输入：l1 = [0], l2 = [0]输出：[0]输入：l1 = [9,9,9,9,9,9,9], l2 = [9,9,9,9]输出：[8,9,9,9,0,0,0,1]提示：1. 每个链表中的节点数在范围 [1, 100] 内2. 0 &lt;= Node.val &lt;= 93. 题目数据保证列表表示的数字不含前导零\n\n解法1：逐项求和/** * Definition for singly-linked list. * struct ListNode &#123; *     int val; *     ListNode *next; *     ListNode() : val(0), next(nullptr) &#123;&#125; *     ListNode(int x) : val(x), next(nullptr) &#123;&#125; *     ListNode(int x, ListNode *next) : val(x), next(next) &#123;&#125; * &#125;; */class Solution &#123;public:    ListNode* addTwoNumbers(ListNode* l1, ListNode* l2) &#123;        ListNode* dummy = new ListNode();        ListNode* curr = dummy;        int carry = 0;  //carry等于1时表示需要进一位        while (l1 != nullptr || l2 != nullptr) &#123;            int x = l1 != nullptr ? l1-&gt;val : 0;            int y = l2 != nullptr ? l2-&gt;val : 0;            int sum = x + y + carry;            curr-&gt;next = new ListNode(sum % 10);            curr = curr-&gt;next;            carry = sum / 10;            if (l1 != nullptr) l1 = l1-&gt;next;            if (l2 != nullptr) l2 = l2-&gt;next;        &#125;        if (carry != 0) curr-&gt;next = new ListNode(carry);                return dummy-&gt;next;    &#125;&#125;;\n\n","categories":["计算机理论"],"tags":["LeetCode算法-求和"]},{"title":"LeetCode_66_加一","url":"/2019/06/30/%E8%AE%A1%E7%AE%97%E6%9C%BA%E7%90%86%E8%AE%BA/LeetCode%E7%AE%97%E6%B3%95/%E6%B1%82%E5%92%8C/2.1_LeetCode_66_%E5%8A%A0%E4%B8%80/","content":"题目描述：给定一个由 整数 组成的 非空 数组所表示的非负整数，在该数的基础上加一。最高位数字存放在数组的首位， 数组中每个元素只存储单个数字。你可以假设除了整数 0 之外，这个整数不会以零开头。示例：输入：digits = [1,2,3]输出：[1,2,4]解释：输入数组表示数字 123。输入：digits = [4,3,2,1]输出：[4,3,2,2]解释：输入数组表示数字 4321。输入：digits = [0]输出：[1]提示：1. 1 &lt;= digits.length &lt;= 1002. 0 &lt;= digits[i] &lt;= 9\n\n解法1：逐项求和class Solution &#123;public:    vector&lt;int&gt; plusOne(vector&lt;int&gt;&amp; digits) &#123;        vector&lt;int&gt; res;        //carry为1表示需要进位        int i = digits.size() - 1, carry = 0;        int K = 1;  //K就是输入值加1中的那个1        while (i &gt;= 0 || K != 0) &#123;            int x = i &gt;= 0 ? digits[i] : 0;              int y = K != 0 ? K : 0;            int sum = x + y + carry;            res.push_back(sum % 10);            carry = sum / 10;            i--;            K /= 10;        &#125;        if (carry != 0) res.push_back(carry);        reverse(res.begin(), res.end());        return res;    &#125;&#125;;\n\n","categories":["计算机理论"],"tags":["LeetCode算法-求和"]},{"title":"常用的排序算法","url":"/2019/06/30/%E8%AE%A1%E7%AE%97%E6%9C%BA%E7%90%86%E8%AE%BA/LeetCode%E7%AE%97%E6%B3%95/%E6%8E%92%E5%BA%8F%E7%AE%97%E6%B3%95/0.1_%E5%B8%B8%E7%94%A8%E7%9A%84%E6%8E%92%E5%BA%8F%E7%AE%97%E6%B3%95/","content":"常用的排序算法：堆排序定义：priority_queue&lt;Type, Container, Functional&gt;1. Type 就是数据类型2. Container 就是容器类型（Container必须是用数组实现的容器，比如vector,deque等等，但不能用 list。STL里面默认用的是vector）3. Functional 就是比较的方式，当需要用自定义的数据类型时才需要传入这三个参数⭐️使用基本数据类型时，只需要传入数据类型，默认是大顶堆//小顶堆priority_queue &lt;int,vector&lt;int&gt;,greater&lt;int&gt; &gt; q;//大顶堆priority_queue &lt;int,vector&lt;int&gt;,less&lt;int&gt; &gt; q;\n\n快速排序：左闭右闭void quick_sort(vector&lt;int&gt; &amp;nums,int l,int r) &#123;        if (l &gt; r) return &#123;&#125;;        int first = l,last = r,key = nums[first];        while (first &lt; last) &#123;            while (first &lt; last &amp;&amp; nums[last] &gt;= key) &#123;                --last;            &#125;            nums[first] = nums[last];            while (first &lt; last &amp;&amp; nums[first] &lt;= key) &#123;                ++first;            &#125;            nums[last] = nums[first];        &#125;         nums[first] = key;        quick_sort(nums,l,first - 1);        quick_sort(nums,first + 1,r); &#125;\n\n快速排序：左闭右开void quick_sort(vector&lt;int&gt; &amp;nums,int l,int r) &#123;        if (l + 1 &gt; r) return &#123;&#125;;        int first = l,last = r - 1,key = nums[first];        while (first &lt; last) &#123;            while (first &lt; last &amp;&amp; nums[last] &gt;= key) &#123;                --last;            &#125;            nums[first] = nums[last];            while (first &lt; last &amp;&amp; nums[first] &lt;= key) &#123;                ++first;            &#125;            nums[last] = nums[first];        &#125;         nums[first] = key;        quick_sort(nums,l,first);        quick_sort(nums,first + 1,r);&#125;\n\n归并排序void merge_sort(vector&lt;int&gt; &amp;nums,int l,int r,vector&lt;int&gt; &amp;temp) &#123;    if (l + 1 &gt;= r) return;    //divide  int m = l + (r - l) / 2;  merge_sort(nums,l,m,temp);  merge_sort(nums,m,r,temp);    //conquer  int p = l,q = m,i = l;  while (p &lt; m || q &lt; r) &#123;        if (q &gt;= r || (p &lt; m &amp;&amp; nums[p] &lt;= nums[q])) &#123;      temp[i++] = nums[p++];    &#125; else &#123;      temp[i++] = nums[q++];    &#125;  &#125;    for (i = l;i &lt; r;++i) &#123;    nums[i] = temp[i];  &#125;&#125;\n\n插入排序void insertion_sort(vector&lt;int&gt; &amp;nums,int n) &#123;    for (int i = 0;i &lt; n;++i) &#123;                for (int j = i;j &gt; 0 &amp;&amp; nums[j] &lt; nums[j - 1];--j) &#123;            swap(nums[j],nums[j - 1]);        &#125;    &#125;&#125;\n\n冒泡排序void bubble_sort(vector&lt;int&gt; &amp;nums,int n) &#123;    bool swapped;    for (int i = 1;i &lt; n;++i) &#123;        swapped = false;    for (int j = 1;j &lt; n - i + 1;++j) &#123;            if (nums[j] &lt; nums[j - 1]) &#123;        swap(nums[j],nums[j - 1]);        swapped = true;      &#125;    &#125;        if (swapped == false) break;  &#125;&#125;\n\n选择排序void selection_sort(vector&lt;int&gt; &amp;nums,int n) &#123;    int mid;  for (int i = 0;i &lt; n - 1;++i) &#123;        mid = i;    for (int j = i + 1;j &lt; n;++j) &#123;            if (nums[j] &lt; nums[mid]) mid = j;    &#125;        swap(nums[mid],nums[i]);  &#125;&#125;\n","categories":["计算机理论"],"tags":["LeetCode算法-排序算法"]},{"title":"剑指Offer_40_最小的k个数","url":"/2019/06/30/%E8%AE%A1%E7%AE%97%E6%9C%BA%E7%90%86%E8%AE%BA/LeetCode%E7%AE%97%E6%B3%95/%E6%8E%92%E5%BA%8F%E7%AE%97%E6%B3%95/1.2_%E5%89%91%E6%8C%87Offer_40_%E6%9C%80%E5%B0%8F%E7%9A%84k%E4%B8%AA%E6%95%B0/","content":"题目描述：输入整数数组 arr ，找出其中最小的 k 个数。例如，输入4、5、1、6、2、7、3、8这8个数字，则最小的4个数字是1、2、3、4。示例：输入：arr = [3,2,1], k = 2输出：[1,2] 或者 [2,1]输入：arr = [0,1,2,1], k = 1输出：[0]限制：1. 0 &lt;= k &lt;= arr.length &lt;= 100002. 0 &lt;= arr[i] &lt;= 10000\n\n解法1：堆排序//大顶堆排序class Solution &#123;public:    vector&lt;int&gt; getLeastNumbers(vector&lt;int&gt;&amp; arr, int k) &#123;        vector&lt;int&gt; vec;        priority_queue&lt;int&gt; Q;  //定义一个大顶堆        if (k == 0 || arr.size() == 0) return vec;                for (int i = 0; i &lt; arr.size(); ++i) Q.push(arr[i]);                for (int i = 0; i &lt; arr.size()-k; ++i) Q.pop();        for (int i = 0; i &lt; k; ++i) &#123;                        vec.push_back(Q.top());            Q.pop();        &#125;        return vec;    &#125;&#125;;\n\n//小顶堆排序class Solution &#123;public:    vector&lt;int&gt; getLeastNumbers(vector&lt;int&gt;&amp; arr, int k) &#123;        vector&lt;int&gt; vec;        priority_queue &lt;int,vector&lt;int&gt;,greater&lt;int&gt; &gt; Q;  //定义一个小顶堆        if (k == 0 || arr.size() == 0) return vec;                for (int i = 0; i &lt; arr.size(); ++i) Q.push(arr[i]);        for (int i = 0; i &lt; k; ++i) &#123;                        vec.push_back(Q.top());            Q.pop();        &#125;        return vec;    &#125;&#125;;\n\n解法2：暴力解法class Solution &#123;public:    vector&lt;int&gt; getLeastNumbers(vector&lt;int&gt;&amp; arr, int k) &#123;        vector&lt;int&gt; vec;        if (k == 0 || arr.size() == 0) return vec;        sort(arr.begin(), arr.end());        for (int i = 0; i &lt; k; ++i) &#123;            vec.push_back(arr[i]);        &#125;        return vec;    &#125;&#125;;\n\n","categories":["计算机理论"],"tags":["LeetCode算法-排序算法"]},{"title":"剑指Offer_21_调整数组顺序使奇数位于偶数前面","url":"/2019/06/30/%E8%AE%A1%E7%AE%97%E6%9C%BA%E7%90%86%E8%AE%BA/LeetCode%E7%AE%97%E6%B3%95/%E6%8E%92%E5%BA%8F%E7%AE%97%E6%B3%95/1.1_%E5%89%91%E6%8C%87Offer_21_%E8%B0%83%E6%95%B4%E6%95%B0%E7%BB%84%E9%A1%BA%E5%BA%8F%E4%BD%BF%E5%A5%87%E6%95%B0%E4%BD%8D%E4%BA%8E%E5%81%B6%E6%95%B0%E5%89%8D%E9%9D%A2/","content":"题目描述：输入一个整数数组，实现一个函数来调整该数组中数字的顺序，使得所有奇数位于数组的前半部分，所有偶数位于数组的后半部分。示例：输入：nums = [1,2,3,4]输出：[1,3,2,4] 注：[3,1,2,4] 也是正确的答案之一。提示：1. 0 &lt;= nums.length &lt;= 500002. 1 &lt;= nums[i] &lt;= 10000\n\n解法1：快速排序思想class Solution &#123;public:    vector&lt;int&gt; exchange(vector&lt;int&gt;&amp; nums) &#123;        int left = 0, right = nums.size() - 1;        if (nums.size() &lt;= 1) return nums;        while (left &lt; right) &#123;            //当前值是奇数            //可以把left &lt; right去掉看看是什么结果            while (left &lt; right &amp;&amp; nums[left] % 2 == 1) ++left;            //当前值是偶数            while (left &lt; right &amp;&amp; nums[right] % 2 == 0) --right;            swap(nums[left], nums[right]);        &#125;        return nums;    &#125;&#125;;\n\n","categories":["计算机理论"],"tags":["LeetCode算法-排序算法"]},{"title":"LeetCode_989_数组形式的整数加法","url":"/2019/06/30/%E8%AE%A1%E7%AE%97%E6%9C%BA%E7%90%86%E8%AE%BA/LeetCode%E7%AE%97%E6%B3%95/%E6%B1%82%E5%92%8C/2.2_LeetCode_989_%E6%95%B0%E7%BB%84%E5%BD%A2%E5%BC%8F%E7%9A%84%E6%95%B4%E6%95%B0%E5%8A%A0%E6%B3%95/","content":"题目描述：对于非负整数 X 而言，X 的数组形式是每位数字按从左到右的顺序形成的数组。例如，如果 X = 1231，那么其数组形式为 [1,2,3,1]。给定非负整数 X 的数组形式 A，返回整数 X+K 的数组形式。示例：输入：A = [1,2,0,0], K = 34输出：[1,2,3,4]解释：1200 + 34 = 1234输入：A = [2,7,4], K = 181输出：[4,5,5]解释：274 + 181 = 455输入：A = [2,1,5], K = 806输出：[1,0,2,1]解释：215 + 806 = 1021输入：A = [9,9,9,9,9,9,9,9,9,9], K = 1输出：[1,0,0,0,0,0,0,0,0,0,0]解释：9999999999 + 1 = 10000000000提示：1. 1 &lt;= A.length &lt;= 100002. 0 &lt;= A[i] &lt;= 93. 0 &lt;= K &lt;= 100004. 如果 A.length &gt; 1，那么 A[0] != 0\n\n解法1：逐项求和class Solution &#123;public:    vector&lt;int&gt; addToArrayForm(vector&lt;int&gt;&amp; A, int K) &#123;        //输入：A = [1,2,3], K = 912        //输出：[1,0,3,5]        vector&lt;int&gt; res;        //carry为1表示需要进位        int i = A.size() - 1, carry = 0;        while (i &gt;= 0 || K != 0) &#123;            int x = i &gt;= 0 ? A[i] : 0;  //x每次取数组A最后一位            int y = K != 0 ? K % 10 : 0;  //y每次取K最后一位            int sum = x + y + carry;            res.push_back(sum % 10);            carry = sum / 10;            i--;            K = K / 10;        &#125;        if (carry != 0) res.push_back(carry);        reverse(res.begin(), res.end());        return res;    &#125;&#125;;\n\n","categories":["计算机理论"],"tags":["LeetCode算法-求和"]},{"title":"LeetCode_347_前K个高频元素","url":"/2019/06/30/%E8%AE%A1%E7%AE%97%E6%9C%BA%E7%90%86%E8%AE%BA/LeetCode%E7%AE%97%E6%B3%95/%E6%8E%92%E5%BA%8F%E7%AE%97%E6%B3%95/2.3_LeetCode_347_%E5%89%8DK%E4%B8%AA%E9%AB%98%E9%A2%91%E5%85%83%E7%B4%A0/","content":"题目描述：给你一个整数数组 nums 和一个整数 k ，请你返回其中出现频率前 k 高的元素。你可以按 任意顺序 返回答案。示例：输入: nums = [1,1,1,2,2,3], k = 2输出: [1,2]输入: nums = [1], k = 1输出: [1]提示：1. 1 &lt;= nums.length &lt;= 10^52. k 的取值范围是 [1, 数组中不相同的元素的个数]3. 题目数据保证答案唯一，换句话说，数组中前 k 个高频元素的集合是唯一的\n\n解法1：堆排序//小顶堆排序//时间复杂度：O(nlogk)，空间复杂度：O(n)class Solution &#123;public:    //自定义小顶堆内的排序方式    class mycomparison &#123;    public:        bool operator()(const pair&lt;int,int&gt;&amp; lhs, const pair&lt;int,int&gt;&amp; rhs) &#123;            //我们的目的是让小顶堆按照值也就是频率排序，优先弹出频率最小的            return lhs.second &gt; rhs.second;        &#125;    &#125;;    vector&lt;int&gt; topKFrequent(vector&lt;int&gt;&amp; nums, int k) &#123;        vector&lt;int&gt; ans;  //返回的结果        unordered_map&lt;int,int&gt; map;  //定义一个哈希表，统计元素出现的频率        for (int i = 0; i &lt; nums.size(); i++) ++map[nums[i]];        //定义一个小顶堆        //因为要统计前k个高频元素，小顶堆每次都会将最低频的元素弹出，小顶堆中剩余的就是高频元素        priority_queue&lt;pair&lt;int,int&gt;, vector&lt;pair&lt;int,int&gt;&gt;, mycomparison &gt; q;        //⭐️小顶堆默认按照键来排序，所以我们需要自己定义排序方式        //priority_queue&lt;pair&lt;int,int&gt;, vector&lt;pair&lt;int,int&gt;&gt;, greater&lt;pair&lt;int,int&gt;&gt; &gt; q;        for (auto &amp;a : map) &#123;            q.push(a);  //⭐️小顶堆内存放的是哈希表内的键值对            if (q.size() &gt; k) q.pop();  //如果堆的大小大于k，则优先队列弹出，保证堆的大小一直为k        &#125;        //找出前k个高频元素        for (int i = 0; i &lt; k; ++i) &#123;            ans.push_back(q.top().first);  //将键值对中的键存放到容器中            q.pop();        &#125;        return ans;    &#125;&#125;;\n\n//大顶堆排序class Solution &#123;public:    class mycomparison &#123;    public:        bool operator()(const pair&lt;int,int&gt;&amp; lhs, const pair&lt;int,int&gt;&amp; rhs) &#123;            //优先弹出频率最大的            return lhs.second &lt; rhs.second;        &#125;    &#125;;    vector&lt;int&gt; topKFrequent(vector&lt;int&gt;&amp; nums, int k) &#123;        vector&lt;int&gt; ans;          unordered_map&lt;int,int&gt; map;  //定义一个哈希表，统计元素出现的频率        for (int i = 0; i &lt; nums.size(); i++) ++map[nums[i]];        //定义一个大顶堆        priority_queue&lt;pair&lt;int,int&gt;, vector&lt;pair&lt;int,int&gt;&gt;, mycomparison &gt; q;        for (auto &amp;a : map) q.push(a);         //找出前k个高频元素        for (int i = 0; i &lt; k; ++i) &#123;            ans.push_back(q.top().first);  //将键值对中的键存放到容器中            q.pop();        &#125;        return ans;    &#125;&#125;;\n","categories":["计算机理论"],"tags":["LeetCode算法-排序算法"]},{"title":"LeetCode_215_数组中的第K个最大元素","url":"/2019/06/30/%E8%AE%A1%E7%AE%97%E6%9C%BA%E7%90%86%E8%AE%BA/LeetCode%E7%AE%97%E6%B3%95/%E6%8E%92%E5%BA%8F%E7%AE%97%E6%B3%95/2.2_LeetCode_215_%E6%95%B0%E7%BB%84%E4%B8%AD%E7%9A%84%E7%AC%ACK%E4%B8%AA%E6%9C%80%E5%A4%A7%E5%85%83%E7%B4%A0/","content":"题目描述：给定整数数组 nums 和整数 k，请返回数组中第 k 个最大的元素。请注意，你需要找的是数组排序后的第 k 个最大的元素，而不是第 k 个不同的元素。示例：输入: [3,2,1,5,6,4] 和 k = 2输出: 5输入: [3,2,3,1,2,4,5,5,6] 和 k = 4输出: 4提示：1. 1 &lt;= k &lt;= nums.length &lt;= 10^42. -10^4 &lt;= nums[i] &lt;= 10^4\n\n解法1：快速选择class Solution &#123;public:    int findKthLargest(vector&lt;int&gt;&amp; nums, int k) &#123;        int l = 0,r = nums.size() - 1,target = nums.size() - k;        while (l &lt; r) &#123;            int mid = quickSelection(nums,l,r);            if (mid == target) return nums[mid];            if (mid &lt; target) &#123;                l = mid + 1;            &#125; else &#123;                r = mid - 1;            &#125;        &#125;        return nums[l];    &#125;    //快速选择    //快速选择的实现和快速排序相似，不过只需要找到第k大的值即可，不需要对其左右再进行排序    //与快速排序一样，快速选择一般需要先打乱数组，否则最坏情况下时间复杂度为O(n^2)    int quickSelection(vector&lt;int&gt;&amp; nums,int l,int r) &#123;        int i = l + 1,j = r;        while (true) &#123;            while (i &lt; r &amp;&amp; nums[i] &lt;= nums[l]) &#123;                ++i;            &#125;            while (l &lt; j &amp;&amp; nums[j] &gt;= nums[l]) &#123;                --j;            &#125;            if (i &gt;= j) break;            swap(nums[i],nums[j]);        &#125;        swap(nums[l],nums[j]);        return j;    &#125;&#125;;\n\n解法2：堆排序//大顶堆排序class Solution &#123;public:    int findKthLargest(vector&lt;int&gt;&amp; nums, int k) &#123;        //定义一个大顶堆        priority_queue&lt;int, vector&lt;int&gt;, less&lt;int&gt; &gt; q;          for (int i = 0; i &lt; nums.size(); ++i) q.push(nums[i]);                for (int i = 0; i &lt; k-1; ++i) q.pop();        return q.top();    &#125;&#125;;\n\n//小顶堆排序class Solution &#123;public:    int findKthLargest(vector&lt;int&gt;&amp; nums, int k) &#123;        //定义一个小顶堆        priority_queue&lt;int, vector&lt;int&gt;, greater&lt;int&gt; &gt; q;          for (int i = 0; i &lt; nums.size(); ++i) q.push(nums[i]);                for (int i = 0; i &lt; nums.size()-k; ++i) q.pop();        return q.top();    &#125;&#125;;\n\n解法3：暴力解法class Solution &#123;public:    int findKthLargest(vector&lt;int&gt;&amp; nums, int k) &#123;        sort(nums.begin(),nums.end());        return nums[nums.size() - k];    &#125;&#125;;\n\nclass Solution &#123;public:    int findKthLargest(vector&lt;int&gt;&amp; nums, int k) &#123;        vector&lt;int&gt; numsSort = quick_sort(nums,0,nums.size() - 1);        return numsSort[numsSort.size() - k];    &#125;    //快速排序：左闭右闭    vector&lt;int&gt; quick_sort(vector&lt;int&gt; &amp;nums,int l,int r) &#123;        if (l &gt; r) return &#123;&#125;;        int first = l,last = r,key = nums[first];        while (first &lt; last) &#123;            while (first &lt; last &amp;&amp; nums[last] &gt;= key) &#123;                --last;            &#125;            nums[first] = nums[last];            while (first &lt; last &amp;&amp; nums[first] &lt;= key) &#123;                ++first;            &#125;            nums[last] = nums[first];        &#125;         nums[first] = key;        quick_sort(nums,l,first - 1);        quick_sort(nums,first + 1,r);        return nums;    &#125;&#125;;\n\n","categories":["计算机理论"],"tags":["LeetCode算法-排序算法"]},{"title":"剑指Offer_06_从尾到头打印链表","url":"/2019/06/30/%E8%AE%A1%E7%AE%97%E6%9C%BA%E7%90%86%E8%AE%BA/LeetCode%E7%AE%97%E6%B3%95/%E9%93%BE%E8%A1%A8/1.3_%E5%89%91%E6%8C%87Offer_06_%E4%BB%8E%E5%B0%BE%E5%88%B0%E5%A4%B4%E6%89%93%E5%8D%B0%E9%93%BE%E8%A1%A8/","content":"题目1描述：输入一个链表的头节点，从尾到头反过来打印出每个节点的值链表节点定义如下：struct ListNode &#123;    int m_nKey;    ListNode* m_pNext;&#125;;\n\n解法1：反转链表看到这道题后，很多人的第一反应是将链表中链接节点的指针反转过来，改变链表的方向，然后就可以从头到尾输出了，但该方法会改变原来链表的结构，是否允许在打印链表的时候修改链表的结构？这取决于面试官的要求，因此在面试的时候我们要询问清楚面试官的要求。\n⭐️在面试中，如果我们打算修改输入的数据，最好先问面试官是不是允许修改\n解法2：栈通常打印是一个只读操作，我们不希望打印时修改内容，假设面试官也要求这个题目不能改变链表的结构\n//栈：后进先出//每经过一个节点的时候，把该节点放到一个栈中，当遍历完整个链表后，再从栈顶开始逐个输出节点的值，此时输出的节点的顺序已经反转过来了void PrintListReversingly_Iteratively(ListNode* pHead)&#123;    std::stack&lt;ListNode*&gt; nodes;  //定义一个栈，栈名为nodes    ListNode* pNode = pHead;  //声明一个指针指向头节点      //只要该指针不为空，就将该指针指向的节点压入栈中，然后再将该指针指向下一个节点    while(pNode != nullptr)      &#123;        nodes.push(pNode);        pNode = pNode-&gt;m_pNext;    &#125;    //只要栈不为空，就一直不断的进行下列操作    while(!nodes.empty())    &#123;        pNode = nodes.top();  //pNode永远指向栈顶元素        printf(&quot;%d\\t&quot;, pNode-&gt;m_nValue);        nodes.pop();  //出栈操作    &#125;&#125;\n\n解法3：递归递归在本质上就是一个栈结构，于是我们又想到了用递归来实现\n//要实现反过来输出链表，我们每访问到一个节点的时候，先递归输出它后面的节点，再输出该节点自身，这样链表的输出结果就反过来了void PrintListReversingly_Recursively(ListNode* pHead)&#123;    if(pHead != nullptr)    &#123;        if (pHead-&gt;m_pNext != nullptr)        &#123;            PrintListReversingly_Recursively(pHead-&gt;m_pNext);        &#125;         printf(&quot;%d\\t&quot;, pHead-&gt;m_nValue);    &#125;&#125;\n\n⭐️递归的代码很简洁，但有一个问题：当链表非常长的时候，就会导致函数调用的层级很深，从而有可能导致函数调用栈溢出，显然用栈基于循环实现的代码鲁棒性要好一些\n题目2描述：输入一个链表的头节点，从尾到头反过来返回每个节点的值（用数组返回）。示例 1：输入：head = [1,3,2]输出：[2,3,1]限制：0 &lt;= 链表长度 &lt;= 10000\n\n解法1：递归/** * Definition for singly-linked list. * struct ListNode &#123; *     int val; *     ListNode *next; *     ListNode(int x) : val(x), next(NULL) &#123;&#125; * &#125;; */class Solution &#123;    vector&lt;int&gt; res;public:    //注意:返回值为引用，减少大量内存拷贝    vector&lt;int&gt;&amp; reversePrint(ListNode* head) &#123;                  //不可以加上条件：head-&gt;next == NULL        if (head == NULL) &#123;            return res;        &#125;        //递归实现        reversePrint(head -&gt; next);        res.push_back(head -&gt; val);        return res;    &#125;&#125;;\n\n解法2：栈/** * Definition for singly-linked list. * struct ListNode &#123; *     int val; *     ListNode *next; *     ListNode(int x) : val(x), next(NULL) &#123;&#125; * &#125;; */class Solution &#123;public:    vector&lt;int&gt; reversePrint(ListNode* head) &#123;        stack&lt;int&gt; nodes;  //定义一个栈        vector&lt;int&gt; res;  //定义一个容器        ListNode* pNode = head;        //遍历链表，并把链表的值压入栈中        while(pNode != NULL) &#123;            nodes.push(pNode-&gt;val);            pNode = pNode-&gt;next;        &#125;        //只要栈不为空，就把栈顶元素放入容器        while(!nodes.empty()) &#123;            res.push_back(nodes.top());            nodes.pop();        &#125;        return res;    &#125;&#125;;\n","categories":["计算机理论"],"tags":["LeetCode算法-链表"]},{"title":"剑指Offer_18_删除链表的节点","url":"/2019/06/30/%E8%AE%A1%E7%AE%97%E6%9C%BA%E7%90%86%E8%AE%BA/LeetCode%E7%AE%97%E6%B3%95/%E9%93%BE%E8%A1%A8/1.1_%E5%89%91%E6%8C%87Offer_18_%E5%88%A0%E9%99%A4%E9%93%BE%E8%A1%A8%E7%9A%84%E8%8A%82%E7%82%B9/","content":"题目1描述：给定单向链表的头指针和一个节点指针，定义一个函数在O(1)时间内删除该节点链表节点与函数的定义如下：struct ListNode &#123;    int m_nValue;    ListNode* m_pNext;&#125;;void DeleteNode(ListNode** pListHead,ListNode* pToBeDeleted);\n\n解法1：在单向链表中删除一个节点，常规的做法是从链表的头节点开始，顺序遍历查找要删除的节点，并在链表中删除该节点，这种思路由于需要顺序查找，时间复杂度自然就是O(n)了；之所以需要从头开始查找，是因为我们需要得到将被删除的节点的前一个节点。在单向链表中，节点中没有指向前一个节点的指针，所以只好从链表的头节点开始顺序查找\n//我们可以很方便的得到要删除的节点的下一个节点，如果我们把下一个节点的内容复制到需要删除的节点上覆盖原有的内容，再把下一个节点删除，那是不是就相当于把当前需要删除的节点删除了？//有一个问题：如果要删除的节点位于链表的尾部，那么它就没有下一个节点，我们仍需要从链表的头节点开始，顺序遍历得到该节点的前序节点，并完成删除操作void DeleteNode(ListNode** pListHead, ListNode* pToBeDeleted) &#123;      if(pListHead == NULL || pToBeDeleted == NULL) return;    //要删除的结点不是尾结点    if(pToBeDeleted-&gt;m_pNext != NULL) &#123;              ListNode* pNext = pToBeDeleted-&gt;m_pNext;        pToBeDeleted-&gt;m_nValue = pNext-&gt;m_nValue;        pToBeDeleted-&gt;m_pNext = pNext-&gt;m_pNext;         delete pNext;        pNext = NULL;    &#125;      //链表只有一个结点，删除头结点（也是尾结点）    else if(*pListHead == pToBeDeleted) &#123;              delete pToBeDeleted;        pToBeDeleted = NULL;        *pListHead = NULL;  //如果链表中只有一个节点，而我们又要删除链表的头节点（也是尾节点），那么此时我们在删除节点之后，还需要把链表的头节点设置为NULL    &#125;      //链表中有多个结点，删除尾结点    else &#123;              ListNode* pNode = *pListHead;              while(pNode-&gt;m_pNext != pToBeDeleted) &#123;            pNode = pNode-&gt;m_pNext;                    &#125;         pNode-&gt;m_pNext = NULL;              delete pToBeDeleted;        pToBeDeleted = NULL;    &#125;&#125;\n\n⭐️值得注意的是，上述代码仍然不是完美的代码，因为它基于一个假设：要删除的节点的确在链表中，我们需要O(n)的时间才能判断链表中是否包含某一节点。受到O(1)时间的限制，我们不得不把确保节点在链表中的责任推给了函数DeleteNode的调用者。在面试的时候，我们可以和面试官讨论这个假设。\n❗️LeetCode_83_删除排序链表中的重复元素\n题目2_1描述：存在一个按升序排列的链表，给你这个链表的头节点 head ，请你删除所有重复的元素，使每个元素只出现一次。返回同样按升序排列的结果链表。示例：输入：head = [1,1,2]输出：[1,2]输入：head = [1,1,2,3,3]输出：[1,2,3]提示：1. 链表中节点数目在范围 [0, 300] 内2. -100 &lt;= Node.val &lt;= 1003. 题目数据保证链表已经按升序排列\n\n解法1：/** * Definition for singly-linked list. * struct ListNode &#123; *     int val; *     ListNode *next; *     ListNode() : val(0), next(nullptr) &#123;&#125; *     ListNode(int x) : val(x), next(nullptr) &#123;&#125; *     ListNode(int x, ListNode *next) : val(x), next(next) &#123;&#125; * &#125;; */class Solution &#123;public:    ListNode* deleteDuplicates(ListNode* head) &#123;        if (head == NULL) return NULL;        ListNode* cur = head;        while (cur-&gt;next != NULL) &#123;                        if (cur-&gt;val == cur-&gt;next-&gt;val) &#123;                cur-&gt;next = cur-&gt;next-&gt;next;            &#125;            else &#123;                cur = cur-&gt;next;            &#125;        &#125;        return head;    &#125;&#125;;\n\n❗️LeetCode_82_删除排序链表中的重复元素2\n题目2_2描述：存在一个按升序排列的链表，给你这个链表的头节点 head ，请你删除链表中所有存在数字重复情况的节点，只保留原始链表中没有重复出现的数字。返回同样按升序排列的结果链表。示例：输入：head = [1,2,3,3,4,4,5]输出：[1,2,5]输入：head = [1,1,1,2,3]输出：[2,3]提示：1. 链表中节点数目在范围 [0, 300] 内2. -100 &lt;= Node.val &lt;= 1003. 题目数据保证链表已经按升序排列\n\n解法1：/** * Definition for singly-linked list. * struct ListNode &#123; *     int val; *     ListNode *next; *     ListNode() : val(0), next(nullptr) &#123;&#125; *     ListNode(int x) : val(x), next(nullptr) &#123;&#125; *     ListNode(int x, ListNode *next) : val(x), next(next) &#123;&#125; * &#125;; */class Solution &#123;public:    ListNode* deleteDuplicates(ListNode* head) &#123;        if (head == NULL) return NULL;                //创建哑节点，让它的指针指向链表的头节点，这样在删除节点的时候，就不需要再判断删除的是否是头结点了        //dummy-&gt;val = 0, dummy-&gt;next = head;        ListNode* dummy = new ListNode(0, head);        ListNode* cur = dummy;        while (cur-&gt;next != NULL &amp;&amp; cur-&gt;next-&gt;next != NULL) &#123;            if (cur-&gt;next-&gt;val == cur-&gt;next-&gt;next-&gt;val) &#123;                int x = cur-&gt;next-&gt;val;  //x表示要删除的节点的值                while (cur-&gt;next != NULL &amp;&amp; cur-&gt;next-&gt;val == x) &#123;                    cur-&gt;next = cur-&gt;next-&gt;next;                &#125;            &#125;            else &#123;                cur = cur-&gt;next;            &#125;        &#125;        return dummy-&gt;next;  //如果链表中只有一个节点，直接返回头节点    &#125;&#125;;\n\n❗️LeetCode_237_删除链表中的节点\n题目3_1描述：给定单向链表的头指针和一个要删除的节点的值，定义一个函数删除该节点。返回删除后的链表的头节点。示例1:输入: head = [4,5,1,9], val = 5输出: [4,1,9]解释: 给定你链表中值为 5 的第二个节点，那么在调用了你的函数之后，该链表应变为 4 -&gt; 1 -&gt; 9.示例2:输入: head = [4,5,1,9], val = 1输出: [4,5,9]解释: 给定你链表中值为 1 的第三个节点，那么在调用了你的函数之后，该链表应变为 4 -&gt; 5 -&gt; 9.说明：1.题目保证链表中节点的值互不相同2.若使用 C 或 C++ 语言，你不需要 free 或 delete 被删除的节点\n\n解法1：/** * Definition for singly-linked list. * struct ListNode &#123; *     int val; *     ListNode *next; *     ListNode(int x) : val(x), next(NULL) &#123;&#125; * &#125;; */class Solution &#123;public:    ListNode* deleteNode(ListNode* head, int val) &#123;        if (head -&gt; val == val) return head -&gt; next;        ListNode *pre = head, *cur = head -&gt; next;        while(cur != NULL &amp;&amp; cur -&gt; val != val) &#123;            pre = cur;            cur = cur-&gt;next;        &#125;        //注意这里不能加上条件：cur != NULL &amp;&amp; cur-&gt;next != NULL        //[-3,5,-99] -99        if(cur != NULL) pre -&gt; next = cur -&gt; next;        return head;    &#125;&#125;;\n\n解法2：/** * Definition for singly-linked list. * struct ListNode &#123; *     int val; *     ListNode *next; *     ListNode(int x) : val(x), next(NULL) &#123;&#125; * &#125;; */class Solution &#123;public:    void deleteNode(ListNode* node) &#123;                node -&gt; val = node -&gt; next -&gt; val;        node -&gt; next = node -&gt; next -&gt; next;    &#125;&#125;;\n\n❗️LeetCode_203_移除链表元素\n题目3_2描述：给你一个链表的头节点 head 和一个整数 val ，请你删除链表中所有满足 Node.val == val 的节点，并返回新的头节点 。示例：输入：head = [1,2,6,3,4,5,6], val = 6输出：[1,2,3,4,5]输入：head = [], val = 1输出：[]输入：head = [7,7,7,7], val = 7输出：[]提示：1. 列表中的节点数目在范围 [0, 10^4] 内2. 1 &lt;= Node.val &lt;= 503. 0 &lt;= val &lt;= 50\n\n解法1：/** * Definition for singly-linked list. * struct ListNode &#123; *     int val; *     ListNode *next; *     ListNode() : val(0), next(nullptr) &#123;&#125; *     ListNode(int x) : val(x), next(nullptr) &#123;&#125; *     ListNode(int x, ListNode *next) : val(x), next(next) &#123;&#125; * &#125;; */class Solution &#123;public:    ListNode* removeElements(ListNode* head, int val) &#123;        if (head == NULL) return NULL;        ListNode* dummyHead = new ListNode(0, head);        ListNode* temp = dummyHead;        while (temp-&gt;next != NULL) &#123;            if (temp-&gt;next-&gt;val == val) &#123;                temp-&gt;next = temp-&gt;next-&gt;next;            &#125; else &#123;                temp = temp-&gt;next;            &#125;        &#125;        return dummyHead-&gt;next;  //返回头节点    &#125;&#125;;\n\n❗️LeetCode_19_删除链表的倒数第N个节点\n题目4描述：给你一个链表，删除链表的倒数第 n 个结点，并且返回链表的头结点。示例:输入：head = [1,2,3,4,5], n = 2输出：[1,2,3,5]输入：head = [1], n = 1输出：[]输入：head = [1,2], n = 1输出：[1]输入：head = [1,2], n = 2输出：[2]提示：1. 链表中结点的数目为 sz2. 1 &lt;= sz &lt;= 303. 0 &lt;= Node.val &lt;= 1004. 1 &lt;= n &lt;= sz\n\n解法1：/** * Definition for singly-linked list. * struct ListNode &#123; *     int val; *     ListNode *next; *     ListNode() : val(0), next(nullptr) &#123;&#125; *     ListNode(int x) : val(x), next(nullptr) &#123;&#125; *     ListNode(int x, ListNode *next) : val(x), next(next) &#123;&#125; * &#125;; */class Solution &#123;public:    //得到链表的长度    int getLength(ListNode* head) &#123;        int length = 0;        while (head != NULL) &#123;            ++length;            head = head-&gt;next;        &#125;        return length;    &#125;    ListNode* removeNthFromEnd(ListNode* head, int n) &#123;        ListNode* dummy = head;        int length = getLength(head);  //链表的长度        if (length &lt; n || length == 0) return NULL;        else if (length == 1 &amp;&amp; n == 1) return NULL;        else if (length == n) return dummy-&gt;next;  //删除链表的头节点        ListNode* cur = dummy;        for (int i = 1; i &lt; length - n; ++i) &#123;            cur = cur-&gt;next;        &#125;        cur-&gt;next = cur-&gt;next-&gt;next;        return dummy;    &#125;&#125;;\n\n","categories":["计算机理论"],"tags":["LeetCode算法-链表"]},{"title":"剑指Offer_24_反转链表","url":"/2019/06/30/%E8%AE%A1%E7%AE%97%E6%9C%BA%E7%90%86%E8%AE%BA/LeetCode%E7%AE%97%E6%B3%95/%E9%93%BE%E8%A1%A8/1.2_%E5%89%91%E6%8C%87Offer_24_%E5%8F%8D%E8%BD%AC%E9%93%BE%E8%A1%A8/","content":"❗️LeetCode_206_反转链表\n题目描述：定义一个函数，输入一个链表的头节点，反转该链表并输出反转后链表的头节点示例：输入: 1-&gt;2-&gt;3-&gt;4-&gt;5-&gt;NULL输出: 5-&gt;4-&gt;3-&gt;2-&gt;1-&gt;NULL限制：0 &lt;= 节点个数 &lt;= 5000链表节点定义如下：struct ListNode &#123;    int m_nKey;    ListNode* m_pNext;&#125;;\n\n解法1：循环ListNode* ReverseList(ListNode* pHead)&#123;    ListNode* pReversedHead = nullptr;  //反转后的链表头节点    ListNode* pNode = pHead;  //pNode初始化时指向头节点    ListNode* pPrev = nullptr;      while(pNode != nullptr) &#123;              //通过后面的代码可以看到节点1、节点2之间的指针断了，所以需要有一个指针提前保存节点2        ListNode* pNext = pNode-&gt;m_pNext;        if(pNext == nullptr)            pReversedHead = pNode;        pNode-&gt;m_pNext = pPrev;  //这一行代码极容易理解错，pNode的下一个节点指向的是一个空节点，注意区分‘pPrev = pNode-&gt;m_pNext;’        //NULL &lt;- 1  2 -&gt; 3 -&gt; 4 -&gt; 5 -&gt; NULL        pPrev = pNode;  //pPrev指向节点1        pNode = pNext;  //pNode指向节点2    &#125;    return pReversedHead;&#125;\n\n解法2：递归/** * Definition for singly-linked list. * struct ListNode &#123; *     int val; *     ListNode *next; *     ListNode(int x) : val(x), next(NULL) &#123;&#125; * &#125;; */class Solution &#123;public:    ListNode* reverseList(ListNode* head) &#123;        if (head == NULL || head-&gt;next == NULL) &#123;            return head;        &#125;        //递归实现        ListNode* newHead = reverseList(head-&gt;next);  //递归到最里层的时候：newHead此时指向5        //递归到最里层的时候：head此时指向4，head-&gt;next指4-&gt;5，head-&gt;next-&gt;next = head指5-&gt;4        head-&gt;next-&gt;next = head;          head-&gt;next = NULL;  //4指向NULL        return newHead;    &#125;&#125;;\n","categories":["计算机理论"],"tags":["LeetCode算法-链表"]},{"title":"剑指Offer_22_链表中倒数第k个节点","url":"/2019/06/30/%E8%AE%A1%E7%AE%97%E6%9C%BA%E7%90%86%E8%AE%BA/LeetCode%E7%AE%97%E6%B3%95/%E9%93%BE%E8%A1%A8/1.4_%E5%89%91%E6%8C%87Offer_22_%E9%93%BE%E8%A1%A8%E4%B8%AD%E5%80%92%E6%95%B0%E7%AC%ACk%E4%B8%AA%E8%8A%82%E7%82%B9/","content":"题目1描述：输入一个链表，输出该链表中倒数第k个节点。为了符合大多数人的习惯，本题从1开始计数，即链表的尾节点是倒数第1个节点。例如，一个链表有 6 个节点，从头节点开始，它们的值依次是 1、2、3、4、5、6。这个链表的倒数第 3 个节点是值为 4 的节点。示例：给定一个链表: 1-&gt;2-&gt;3-&gt;4-&gt;5, 和 k = 2.返回链表 4-&gt;5.\n\n解法1：/** * Definition for singly-linked list. * struct ListNode &#123; *     int val; *     ListNode *next; *     ListNode(int x) : val(x), next(NULL) &#123;&#125; * &#125;; */class Solution &#123;public:    ListNode* getKthFromEnd(ListNode* head, int k) &#123;        if (head == NULL || k == 0) return NULL;        ListNode *pAhead = head;        ListNode *pBehind = NULL;        for (int i = 0;i &lt; k-1;++i) &#123;            //如果链表的节点数少于k，那么在for循环中遍历链表可能会出现指向NULL的next            if (pAhead -&gt; next != NULL) &#123;                pAhead = pAhead -&gt; next;            &#125; else &#123;                return NULL;            &#125;        &#125;        pBehind = head;        while (pAhead -&gt; next != NULL) &#123;                        pAhead = pAhead -&gt; next;            pBehind = pBehind -&gt; next;        &#125;        return pBehind;     &#125;&#125;;\n\n❗️LeetCode_876_链表的中间节点\n题目2描述：给定一个头结点为 head 的非空单链表，返回链表的中间结点。如果有两个中间结点，则返回第二个中间结点。\n\n解法1：//这道题目其实是上面题目的特殊示例，完全可以用上面的方法解决，但是因为没有给出k值，所以需要遍历一遍链表求出链表的长度。针对此题更简单的解题思路是：我们可以定义两个指针，同时从链表的头节点出发，一个指针一次走一步，另一个指针一次走两步，当走得快的指针走到链表的末尾时，走的慢的指针正好在链表的中间/** * Definition for singly-linked list. * struct ListNode &#123; *     int val; *     ListNode *next; *     ListNode() : val(0), next(nullptr) &#123;&#125; *     ListNode(int x) : val(x), next(nullptr) &#123;&#125; *     ListNode(int x, ListNode *next) : val(x), next(next) &#123;&#125; * &#125;; */class Solution &#123;public:    ListNode* middleNode(ListNode* head) &#123;        if (head == NULL) return NULL;        ListNode* fast = head;        ListNode* slow = head;        while(fast != NULL &amp;&amp; fast-&gt;next != NULL) &#123;            fast = fast-&gt;next-&gt;next;            slow = slow-&gt;next;        &#125;        return slow;    &#125;&#125;;\n","categories":["计算机理论"],"tags":["LeetCode算法-链表"]},{"title":"剑指Offer_52_两个链表的第一个公共节点","url":"/2019/06/30/%E8%AE%A1%E7%AE%97%E6%9C%BA%E7%90%86%E8%AE%BA/LeetCode%E7%AE%97%E6%B3%95/%E9%93%BE%E8%A1%A8/1.7_%E5%89%91%E6%8C%87Offer_52_%E4%B8%A4%E4%B8%AA%E9%93%BE%E8%A1%A8%E7%9A%84%E7%AC%AC%E4%B8%80%E4%B8%AA%E5%85%AC%E5%85%B1%E8%8A%82%E7%82%B9/","content":"❗️LeetCode_160_相交链表\n❗️注意本题与剑指Offer_68_树中两个节点的最低公共祖先有联系\n题目描述：输入两个链表，找出它们的第一个公共节点。输入：intersectVal = 8, listA = [4,1,8,4,5], listB = [5,0,1,8,4,5], skipA = 2, skipB = 3输出：Reference of the node with value = 8输入解释：相交节点的值为 8 （注意，如果两个列表相交则不能为 0）。从各自的表头开始算起，链表 A 为 [4,1,8,4,5]，链表 B 为 [5,0,1,8,4,5]。在 A 中，相交节点前有 2 个节点；在 B 中，相交节点前有 3 个节点。注意：1. 如果两个链表没有交点，返回 null.2. 在返回结果后，两个链表仍须保持原有的结构。3. 可假定整个链表结构中没有循环。4. 程序尽量满足 O(n) 时间复杂度，且仅用 O(1) 内存。\n\n解法1：用蛮力法，在第一个链表上顺序遍历每个节点，每遍历到一个节点，就在第二个链表上顺序遍历每个节点。如果在第二个链表上有一个节点和第一个链表上的节点一样，则说明两个链表在这个节点上重合，于是就找到了它们的公共节点。如果第一个链表的长度为m，第二个链表的长度为n，那么显然该方法的时间复杂度是O(mn)\n解法2：如果两个链表有公共节点，那么公共节点出现在两个链表的尾部，如果我们从两个链表的尾部开始往前比较，那么最后一个相同的节点就是我们要找的节点。于是我们就能想到用栈的特点来解决这个问题：分别把两个链表的节点放入两个栈里，这样两个链表的尾节点就位于两个栈的栈顶，接下来比较两个栈顶的节点是否相同，如果相同，则把栈顶弹出接着比较下一个栈顶，直到找到最后一个相同的节点。空间复杂度为O(m+n)，时间复杂度也是O(m+n)，和蛮力法相比，时间效率得到了提高，相当于用空间消耗换取了时间效率\n⭐️问题：当两个链表的长度不相同时，如果我们从头开始遍历，那么到达尾节点的时间就不一致\n解法3：首先遍历两个链表得到它们的长度，就能知道哪个链表比较长，以及长的链表比短的链表多几个节点。在第二次遍历的时候，在较长的链表上先走若干步，接着同时在两个链表上遍历，找到的第一个相同的节点就是它们的第一个公共节点。时间复杂度为O(m+n)，但我们不再需要辅助栈，因此提高了空间效率\n/** * Definition for singly-linked list. * struct ListNode &#123; *     int val; *     ListNode *next; *     ListNode(int x) : val(x), next(NULL) &#123;&#125; * &#125;; */class Solution &#123;public:    //返回链表的长度    unsigned int GetListLength(ListNode* pHead) &#123;        unsigned int nLength = 0;        ListNode* pNode = pHead;        while (pNode != NULL) &#123;            ++nLength;            pNode = pNode -&gt; next;        &#125;        return nLength;    &#125;    ListNode *getIntersectionNode(ListNode *headA, ListNode *headB) &#123;                unsigned int nLength1 = GetListLength(headA);  //headA的长度        unsigned int nLength2 = GetListLength(headB);  //headB的长度        int nLengthDif = nLength1 - nLength2;  //两个链表之差（假设headA &gt; headB）        ListNode* pListHeadLong = headA;        ListNode* pListHeadShort = headB;        if (nLength2 &gt; nLength1) &#123;            pListHeadLong = headB;            pListHeadShort = headA;            nLengthDif = nLength2 - nLength1;        &#125;        //先在长链表上走几步，再同时在两个链表上遍历        for (int i = 0;i &lt; nLengthDif;i++) &#123;            pListHeadLong = pListHeadLong -&gt; next;        &#125;        while (pListHeadLong != NULL &amp;&amp;                pListHeadShort != NULL &amp;&amp;                pListHeadLong != pListHeadShort) &#123;            pListHeadLong = pListHeadLong -&gt; next;            pListHeadShort = pListHeadShort -&gt;next;        &#125;        //得到第一个公共结点        ListNode* pFirstCommonNode = pListHeadLong;                return pFirstCommonNode;    &#125;&#125;;\n\n解法4：/** * Definition for singly-linked list. * struct ListNode &#123; *     int val; *     ListNode *next; *     ListNode(int x) : val(x), next(NULL) &#123;&#125; * &#125;; */class Solution &#123;public:    ListNode *getIntersectionNode(ListNode *headA, ListNode *headB) &#123;                ListNode* l1 = headA,*l2 = headB;        //假设链表A的头节点到相交点的距离是a，链表B的头节点到相交点的距离是b，相交点到链表终点的距离为c        //我们使用两个指针，分别指向两个链表的头节点，并以相同的速度前进，若到达链表结尾，则移动到另一条链表的头节点继续前进。按照这种前进方法，两个指针会在a+b+c次前进后同时到达相交节点        while (l1 != l2) &#123;            l1 = l1 ? l1-&gt;next : headB;            l2 = l2 ? l2-&gt;next : headA;        &#125;        return l1;    &#125;&#125;;\n\n","categories":["计算机理论"],"tags":["LeetCode算法-链表"]},{"title":"剑指Offer_23_链表中环的入口节点","url":"/2019/06/30/%E8%AE%A1%E7%AE%97%E6%9C%BA%E7%90%86%E8%AE%BA/LeetCode%E7%AE%97%E6%B3%95/%E9%93%BE%E8%A1%A8/1.5_%E5%89%91%E6%8C%87Offer_23_%E9%93%BE%E8%A1%A8%E4%B8%AD%E7%8E%AF%E7%9A%84%E5%85%A5%E5%8F%A3%E8%8A%82%E7%82%B9/","content":"❗️LeetCode_141_环形链表、LeetCode_142_环形链表2\n题目描述：如果一个链表中包含环，如何找出环的入口节点？\n\n解法1：快慢指针（Floyd判圈法）\n第一步是如何确定一个链表中包含环并返回两个指针相遇的节点，受到面试题22的启发，我们可以用两个指针来解决这个问题：定义两个指针，同时从链表的头节点出发，一个指针一次走一步，另一个指针一次走两步。如果走得快的指针追上了走的慢的指针，那么链表就包含环，如果走的快的指针走到了链表的末尾都没有追上第一个指针，那么链表就不包含环\n/** * Definition for singly-linked list. * struct ListNode &#123; *     int val; *     ListNode *next; *     ListNode(int x) : val(x), next(NULL) &#123;&#125; * &#125;; */class Solution &#123;public:      //该函数返回两个指针相遇的节点    ListNode* MeetingNode(ListNode *head) &#123;                if (head == NULL) return NULL;        ListNode* slow = head;  //定义慢指针        ListNode* fast = head;  //定义快指针        if (slow-&gt;next == NULL) return NULL;  //如果链表中只有一个节点，那就没有环        while (fast != NULL &amp;&amp; fast-&gt;next != NULL) &#123;            fast = fast-&gt;next-&gt;next;            slow = slow-&gt;next;            if (fast == slow) return fast;  //fast或slow指针指向的节点就是它们相遇的节点        &#125;        return NULL;    &#125;&#125;;\n\n第二步是如何找到环的入口节点\n/** * Definition for singly-linked list. * struct ListNode &#123; *     int val; *     ListNode *next; *     ListNode(int x) : val(x), next(NULL) &#123;&#125; * &#125;; */class Solution &#123;public:    ListNode *detectCycle(ListNode *head) &#123;                if (head == NULL) return NULL;        ListNode* slow = head;  //定义慢指针        ListNode* fast = head;  //定义快指针        bool hasCycle = false;        if (slow-&gt;next == NULL) return NULL;  //如果链表中只有一个节点，那就没有环        while (fast != NULL &amp;&amp; fast-&gt;next != NULL) &#123;            fast = fast-&gt;next-&gt;next;            slow = slow-&gt;next;            //fast或slow指针指向的节点就是它们相遇的节点            if (fast == slow) &#123;                hasCycle = true;  //该链表有环                break;  //跳出循环            &#125;        &#125;        //如果有环，找到入环开始的结点        if (hasCycle) &#123;            ListNode *p = head;            while (p != slow) &#123;                 p = p -&gt;next;                slow = slow-&gt;next;            &#125;            return p;  //p指针指向的节点就是环的入口节点        &#125; else return NULL;    &#125;&#125;;\n\n//代码更简洁/** * Definition for singly-linked list. * struct ListNode &#123; *     int val; *     ListNode *next; *     ListNode(int x) : val(x), next(NULL) &#123;&#125; * &#125;; */class Solution &#123;public:    ListNode *detectCycle(ListNode *head) &#123;        ListNode* slow = head,*fast = head;        //判断是否存在环路        do &#123;            if (fast == NULL || fast-&gt;next == NULL) return NULL;            fast = fast-&gt;next-&gt;next;            slow = slow-&gt;next;        &#125; while (fast != slow);        //如果存在，查找环路节点        fast = head;        while (fast != slow) &#123;            slow = slow-&gt;next;            fast = fast-&gt;next;        &#125;        return fast;    &#125;&#125;;\n\n","categories":["计算机理论"],"tags":["LeetCode算法-链表"]},{"title":"LeetCode_234_回文链表","url":"/2019/06/30/%E8%AE%A1%E7%AE%97%E6%9C%BA%E7%90%86%E8%AE%BA/LeetCode%E7%AE%97%E6%B3%95/%E9%93%BE%E8%A1%A8/2.2_LeetCode_234_%E5%9B%9E%E6%96%87%E9%93%BE%E8%A1%A8/","content":"题目描述：请判断一个链表是否为回文链表。示例：输入: 1-&gt;2输出: false输入: 1-&gt;2-&gt;2-&gt;1输出: true\n\n解法1：双指针/** * Definition for singly-linked list. * struct ListNode &#123; *     int val; *     ListNode *next; *     ListNode() : val(0), next(nullptr) &#123;&#125; *     ListNode(int x) : val(x), next(nullptr) &#123;&#125; *     ListNode(int x, ListNode *next) : val(x), next(next) &#123;&#125; * &#125;; */class Solution &#123;public:    bool isPalindrome(ListNode* head) &#123;        vector&lt;int&gt; vals;        //复制链表值到数组列表中        while (head != nullptr) &#123;            vals.emplace_back(head-&gt;val);            head = head-&gt;next;        &#125;        //使用双指针法判断是否为回文        for (int i = 0, j = (int)vals.size() - 1; i &lt; j; ++i, --j) &#123;                        if (vals[i] != vals[j]) &#123;                return false;            &#125;        &#125;        return true;    &#125;&#125;;\n\n","categories":["计算机理论"],"tags":["LeetCode算法-链表"]},{"title":"LeetCode_24_两两交换链表中的节点","url":"/2019/06/30/%E8%AE%A1%E7%AE%97%E6%9C%BA%E7%90%86%E8%AE%BA/LeetCode%E7%AE%97%E6%B3%95/%E9%93%BE%E8%A1%A8/2.1_LeetCode_24_%E4%B8%A4%E4%B8%A4%E4%BA%A4%E6%8D%A2%E9%93%BE%E8%A1%A8%E4%B8%AD%E7%9A%84%E8%8A%82%E7%82%B9/","content":"题目描述：一般来说，算法题不需要删除内存，在刷LeetCode的时候，如果想要删除一个节点，可以直接进行指针操作而无需回收内存。实际做软件工程时，对于无用的内存，建议尽量显式回收，或利用智能指针给定一个链表，两两交换其中相邻的节点，并返回交换后的链表。你不能只是单纯的改变节点内部的值，而是需要实际的进行节点交换。示例：输入：head = [1,2,3,4]输出：[2,1,4,3]输入：head = []输出：[]输入：head = [1]输出：[1]提示：1. 链表中节点的数目在范围 [0, 100] 内2. 0 &lt;= Node.val &lt;= 100\n\n解法1：迭代/** * Definition for singly-linked list. * struct ListNode &#123; *     int val; *     ListNode *next; *     ListNode() : val(0), next(nullptr) &#123;&#125; *     ListNode(int x) : val(x), next(nullptr) &#123;&#125; *     ListNode(int x, ListNode *next) : val(x), next(next) &#123;&#125; * &#125;; */class Solution &#123;public:    ListNode* swapPairs(ListNode* head) &#123;        ListNode* dummyHead = new ListNode(0,head);        ListNode* temp = dummyHead;        while (temp-&gt;next != nullptr &amp;&amp; temp-&gt;next-&gt;next != nullptr) &#123;            ListNode* node1 = temp-&gt;next;            ListNode* node2 = temp-&gt;next-&gt;next;            temp-&gt;next = node2;            node1-&gt;next = node2-&gt;next;            node2-&gt;next = node1;            temp = node1;        &#125;                return dummyHead-&gt;next;    &#125;&#125;;\n\n","categories":["计算机理论"],"tags":["LeetCode算法-链表"]},{"title":"LeetCode_75_颜色分类","url":"/2019/06/30/%E8%AE%A1%E7%AE%97%E6%9C%BA%E7%90%86%E8%AE%BA/LeetCode%E7%AE%97%E6%B3%95/%E6%8E%92%E5%BA%8F%E7%AE%97%E6%B3%95/2.1_LeetCode_75_%E9%A2%9C%E8%89%B2%E5%88%86%E7%B1%BB/","content":"题目描述：//经典的「荷兰国旗问题」，考察如何对三个重复且打乱的值进行排序给定一个包含红色、白色和蓝色，一共 n 个元素的数组，原地对它们进行排序，使得相同颜色的元素相邻，并按照红色、白色、蓝色顺序排列。此题中，我们使用整数 0、 1 和 2 分别表示红色、白色和蓝色。示例：输入：nums = [2,0,2,1,1,0]输出：[0,0,1,1,2,2]输入：nums = [2,0,1]输出：[0,1,2]输入：nums = [0]输出：[0]输入：nums = [1]输出：[1]提示：1. n == nums.length2. 1 &lt;= n &lt;= 3003. nums[i] 为 0、1 或 2\n\n解法1：快速排序思想class Solution &#123;public:    void sortColors(vector&lt;int&gt;&amp; nums) &#123;        int l = 0,r = nums.size() - 1;        int i = 0;        while (i &lt;= r) &#123;  //注意边界条件是i &lt;= r            if (nums[i] == 0) swap(nums[i++],nums[l++]);                        else if (nums[i] == 1) i++;            else if (nums[i] == 2) swap(nums[i],nums[r--]);        &#125;    &#125;&#125;;\n\n","categories":["计算机理论"],"tags":["LeetCode算法-排序算法"]},{"title":"LeetCode_92_反转链表2","url":"/2019/06/30/%E8%AE%A1%E7%AE%97%E6%9C%BA%E7%90%86%E8%AE%BA/LeetCode%E7%AE%97%E6%B3%95/%E9%93%BE%E8%A1%A8/2.3_LeetCode_92_%E5%8F%8D%E8%BD%AC%E9%93%BE%E8%A1%A82/","content":"题目描述：给你单链表的头指针 head 和两个整数 left 和 right ，其中 left &lt;= right 。请你反转从位置 left 到位置 right 的链表节点，返回 反转后的链表 。示例：输入：head = [1,2,3,4,5], left = 2, right = 4输出：[1,4,3,2,5]输入：head = [5], left = 1, right = 1输出：[5]提示：1. 链表中节点数目为 n2. 1 &lt;= n &lt;= 5003. -500 &lt;= Node.val &lt;= 5004. 1 &lt;= left &lt;= right &lt;= n\n\n解法1：循环/** * Definition for singly-linked list. * struct ListNode &#123; *     int val; *     ListNode *next; *     ListNode() : val(0), next(nullptr) &#123;&#125; *     ListNode(int x) : val(x), next(nullptr) &#123;&#125; *     ListNode(int x, ListNode *next) : val(x), next(next) &#123;&#125; * &#125;; */class Solution &#123;public:    ListNode *reverseBetween(ListNode *head, int left, int right) &#123;        //设置dummyNode哑节点是这一类问题的一般做法        ListNode *dummyNode = new ListNode(-1,head);        ListNode *pre = dummyNode;        for (int i = 0; i &lt; left - 1; i++) pre = pre-&gt;next;        ListNode *cur = pre-&gt;next;        for (int i = 0; i &lt; right - left; i++) &#123;            ListNode *next = cur-&gt;next;            cur-&gt;next = next-&gt;next;            next-&gt;next = pre-&gt;next;            pre-&gt;next = next;            //初始：1-&gt;2-&gt;3-&gt;4-&gt;5            //第一次循环：1-&gt;3-&gt;2-&gt;4-&gt;5            //第二次循环：1-&gt;4-&gt;3-&gt;2-&gt;5        &#125;        return dummyNode-&gt;next;    &#125;&#125;;\n\n","categories":["计算机理论"],"tags":["LeetCode算法-链表"]},{"title":"剑指Offer_25_合并两个排序的链表","url":"/2019/06/30/%E8%AE%A1%E7%AE%97%E6%9C%BA%E7%90%86%E8%AE%BA/LeetCode%E7%AE%97%E6%B3%95/%E9%93%BE%E8%A1%A8/1.6_%E5%89%91%E6%8C%87Offer_25_%E5%90%88%E5%B9%B6%E4%B8%A4%E4%B8%AA%E6%8E%92%E5%BA%8F%E7%9A%84%E9%93%BE%E8%A1%A8/","content":"❗️LeetCode_21_合并两个有序链表\n题目描述：输入两个递增排序的链表，合并这两个链表并使新链表中的节点仍然是递增排序的。示例：输入：1-&gt;2-&gt;4, 1-&gt;3-&gt;4输出：1-&gt;1-&gt;2-&gt;3-&gt;4-&gt;4限制：0 &lt;= 链表长度 &lt;= 1000\n\n解法1：递归/** * Definition for singly-linked list. * struct ListNode &#123; *     int val; *     ListNode *next; *     ListNode(int x) : val(x), next(NULL) &#123;&#125; * &#125;; */class Solution &#123;public:    ListNode* mergeTwoLists(ListNode* l1, ListNode* l2) &#123;        if (l1 == NULL) &#123;            return l2;        &#125; else if (l2 == NULL) &#123;            return l1;        &#125;        ListNode *pMergedHead = NULL;        //递归        if (l1-&gt;val &lt; l2-&gt;val) &#123;            pMergedHead = l1;            pMergedHead-&gt;next = mergeTwoLists(l1-&gt;next,l2);        &#125; else &#123;            pMergedHead = l2;            pMergedHead-&gt;next = mergeTwoLists(l1,l2-&gt;next);        &#125;        return pMergedHead;    &#125;&#125;;\n\n解法2：迭代/** * Definition for singly-linked list. * struct ListNode &#123; *     int val; *     ListNode *next; *     ListNode() : val(0), next(nullptr) &#123;&#125; *     ListNode(int x) : val(x), next(nullptr) &#123;&#125; *     ListNode(int x, ListNode *next) : val(x), next(next) &#123;&#125; * &#125;; */class Solution &#123;public:    ListNode* mergeTwoLists(ListNode* l1, ListNode* l2) &#123;        ListNode* preHead = new ListNode(-1);        ListNode* prev = preHead;        while (l1 != nullptr &amp;&amp; l2 != nullptr) &#123;            if (l1-&gt;val &lt;= l2-&gt;val) &#123;                prev-&gt;next = l1;                l1 = l1-&gt;next;            &#125; else &#123;                prev-&gt;next = l2;                l2 = l2-&gt;next;            &#125;            prev = prev-&gt;next;        &#125;        //合并后l1和l2最多只有一个还未被合并完，我们直接将链表末尾指向未合并完的链表即可        //l1现在如果指向空，prev-&gt;next指向l2，否则指向l1        prev-&gt;next = l1 == nullptr ? l2 : l1;        return preHead-&gt;next;    &#125;&#125;;\n\n","categories":["计算机理论"],"tags":["LeetCode算法-链表"]},{"title":"LeetCode_605_种花问题","url":"/2019/06/30/%E8%AE%A1%E7%AE%97%E6%9C%BA%E7%90%86%E8%AE%BA/LeetCode%E7%AE%97%E6%B3%95/%E8%B4%AA%E5%BF%83%E7%AE%97%E6%B3%95/2.4_LeetCode_605_%E7%A7%8D%E8%8A%B1%E9%97%AE%E9%A2%98/","content":"题目描述：假设有一个很长的花坛，一部分地块种植了花，另一部分却没有。可是，花不能种植在相邻的地块上，它们会争夺水源，两者都会死去。给你一个整数数组  flowerbed 表示花坛，由若干 0 和 1 组成，其中 0 表示没种植花，1 表示种植了花。另有一个数 n ，能否在不打破种植规则的情况下种入 n 朵花？能则返回 true ，不能则返回 false。示例：输入：flowerbed = [1,0,0,0,1], n = 1输出：true输入：flowerbed = [1,0,0,0,1], n = 2输出：false提示：1. 1 &lt;= flowerbed.length &lt;= 2 * 10^42. flowerbed[i] 为 0 或 13. flowerbed 中不存在相邻的两朵花4. 0 &lt;= n &lt;= flowerbed.length\n\n解法1：贪心算法class Solution &#123;public:    bool canPlaceFlowers(vector&lt;int&gt;&amp; flowerbed, int n) &#123;        //贪心思想：只要能种，那么都种上        if (n == 0) return true;\t    \t\t    int res = 0;\t    \t        for (int i = 0;i &lt; flowerbed.size();i++) &#123;            //可以种花            //注意：“i == 0 || flowerbed[i - 1] == 0”的顺序不能颠倒            //“i == flowerbed.size() - 1 || flowerbed[i + 1] == 0”的顺序不能颠倒\t    \tif (flowerbed[i] == 0 &amp;&amp;                (i == 0 || flowerbed[i - 1] == 0) &amp;&amp;                (i == flowerbed.size() - 1 || flowerbed[i + 1] == 0)) &#123;\t    \t\tflowerbed[i] = 1;\t    \t\tres++;\t    \t&#125;\t    &#125;\t    \t        return res &gt;= n;    &#125;&#125;;\n\n","categories":["计算机理论"],"tags":["LeetCode算法-贪心算法"]},{"title":"LeetCode_455_分发饼干","url":"/2019/06/30/%E8%AE%A1%E7%AE%97%E6%9C%BA%E7%90%86%E8%AE%BA/LeetCode%E7%AE%97%E6%B3%95/%E8%B4%AA%E5%BF%83%E7%AE%97%E6%B3%95/2.1_LeetCode_455_%E5%88%86%E5%8F%91%E9%A5%BC%E5%B9%B2/","content":"题目描述：//贪心算法或贪心思想采用贪心的策略，保证每次操作都是局部最优的，从而使最后得到的结果是全局最优的假设你是一位很棒的家长，想要给你的孩子们一些小饼干。但是，每个孩子最多只能给一块饼干。对每个孩子 i，都有一个胃口值 g[i]，这是能让孩子们满足胃口的饼干的最小尺寸；并且每块饼干 j，都有一个尺寸 s[j] 。如果 s[j] &gt;= g[i]，我们可以将这个饼干 j 分配给孩子 i ，这个孩子会得到满足。你的目标是尽可能满足越多数量的孩子，并输出这个最大数值。示例：输入: g = [1,2,3], s = [1,1]输出: 1解释: 你有三个孩子和两块小饼干，3个孩子的胃口值分别是：1,2,3。虽然你有两块小饼干，由于他们的尺寸都是1，你只能让胃口值是1的孩子满足。所以你应该输出1。输入: g = [1,2], s = [1,2,3]输出: 2解释: 你有两个孩子和三块小饼干，2个孩子的胃口值分别是1,2。你拥有的饼干数量和尺寸都足以让所有孩子满足。所以你应该输出2.提示：1. 1 &lt;= g.length &lt;= 3 * 10^42. 0 &lt;= s.length &lt;= 3 * 10^43. 1 &lt;= g[i], s[j] &lt;= 2^31 - 1\n\n解法1：贪心算法//因为饥饿度最小的孩子最容易吃饱，所以我们先考虑这个孩子。为了尽量使得剩下的饼干可以满足饥饿度更大的孩子，所以我们应该把大于等于这个孩子饥饿度的、且大小最小的饼干给这个孩子。满足了这个孩子之后，我们采取同样的策略，考虑剩下孩子里饥饿度最小的孩子，直到没有满足条件的饼干存在class Solution &#123;public:    int findContentChildren(vector&lt;int&gt;&amp; g, vector&lt;int&gt;&amp; s) &#123;        sort(g.begin(),g.end());        sort(s.begin(),s.end());        int child = 0,cookie = 0;        while (child &lt; g.size() &amp;&amp; cookie &lt; s.size()) &#123;            //给剩余孩子里最小饥饿度的孩子分配最小的能饱腹的饼干            if (g[child] &lt;= s[cookie]) ++child;            ++cookie;        &#125;        return child;    &#125;&#125;;\n\n","categories":["计算机理论"],"tags":["LeetCode算法-贪心算法"]},{"title":"LeetCode_435_无重叠区间","url":"/2019/06/30/%E8%AE%A1%E7%AE%97%E6%9C%BA%E7%90%86%E8%AE%BA/LeetCode%E7%AE%97%E6%B3%95/%E8%B4%AA%E5%BF%83%E7%AE%97%E6%B3%95/2.3_LeetCode_435_%E6%97%A0%E9%87%8D%E5%8F%A0%E5%8C%BA%E9%97%B4/","content":"题目描述：给定一个区间的集合，找到需要移除区间的最小数量，使剩余区间互不重叠。注意:1. 可以认为区间的终点总是大于它的起点。2. 区间 [1,2] 和 [2,3] 的边界相互“接触”，但没有相互重叠。示例：输入: [ [1,2], [2,3], [3,4], [1,3] ]输出: 1解释: 移除 [1,3] 后，剩下的区间没有重叠。输入: [ [1,2], [1,2], [1,2] ]输出: 2解释: 你需要移除两个 [1,2] 来使剩下的区间没有重叠。输入: [ [1,2], [2,3] ]输出: 0解释: 你不需要移除任何区间，因为它们已经是无重叠的了。\n\n解法1：贪心算法class Solution &#123;public:    int eraseOverlapIntervals(vector&lt;vector&lt;int&gt;&gt;&amp; intervals) &#123;        if (intervals.empty()) return 0;        int n = intervals.size();        //选择的区间结尾越小，余留给其他区间的空间就越大，就越能保留更多的区间。        //因此我们采取的贪心策略为，优先保留结尾小且不相交的区间        //先把区间按照结尾的大小进行增序排序，每次选择结尾最小且和前一个选择的区间不重叠的区间        sort(intervals.begin(),intervals.end(),[](vector&lt;int&gt;a,vector&lt;int&gt;b) &#123;            //注意：需要根据实际情况判断按区间开头排序还是按区间结尾排序            return a[1] &lt; b[1];        &#125;);  //C++中的Lambda表达式        int total = 0,prev = intervals[0][1];        for (int i = 1;i &lt; n;++i) &#123;            if (intervals[i][0] &lt; prev) &#123;                ++total;            &#125; else &#123;                prev = intervals[i][1];            &#125;        &#125;        return total;    &#125;&#125;;\n\n","categories":["计算机理论"],"tags":["LeetCode算法-贪心算法"]},{"title":"LeetCode_135_分发糖果","url":"/2019/06/30/%E8%AE%A1%E7%AE%97%E6%9C%BA%E7%90%86%E8%AE%BA/LeetCode%E7%AE%97%E6%B3%95/%E8%B4%AA%E5%BF%83%E7%AE%97%E6%B3%95/2.2_LeetCode_135_%E5%88%86%E5%8F%91%E7%B3%96%E6%9E%9C/","content":"题目描述老师想给孩子们分发糖果，有 N 个孩子站成了一条直线，老师会根据每个孩子的表现，预先给他们评分。你需要按照以下要求，帮助老师给这些孩子分发糖果：1. 每个孩子至少分配到 1 个糖果。2. 评分更高的孩子必须比他两侧的邻位孩子获得更多的糖果。那么这样下来，老师至少需要准备多少颗糖果呢？示例：输入：[1,0,2]输出：5解释：你可以分别给这三个孩子分发 2、1、2 颗糖果。输入：[1,2,2]输出：4解释：你可以分别给这三个孩子分发 1、2、1 颗糖果。     第三个孩子只得到 1 颗糖果，这已满足上述两个条件。\n\n解法1：贪心算法//贪心策略：在每次遍历中，只考虑并更新相邻一侧的大小关系class Solution &#123;public:    int candy(vector&lt;int&gt;&amp; ratings) &#123;        int size = ratings.size();        if (size &lt; 2) return size;        vector&lt;int&gt; num(size,1);  //定义一个长度为size的容器，num中每个值初始值都为1        //把所有孩子的糖果数初始化为1，先从左到右遍历一遍，如果右边孩子的评分比左边的高，则右边孩子的糖果数更新为左边孩子的糖果数加1；再从右往左遍历一遍，如果左边孩子的评分比右边的高，且左边孩子当前的糖果数不大于右边孩子的糖果数，则左边孩子的糖果数更新为右边孩子的糖果数加1        for (int i = 1;i &lt; size;++i) &#123;            if (ratings[i] &gt; ratings[i - 1]) num[i] = num[i - 1] + 1;        &#125;        for (int i = size - 1;i &gt; 0;--i) &#123;            if (ratings[i] &lt; ratings[i - 1]) num[i - 1] = max(num[i - 1],num[i] + 1);            //注意不可以这样写：[1,3,4,5,2]            //if (ratings[i] &lt; ratings[i - 1]) num[i - 1] = num[i] + 1;        &#125;        //accumulate函数将它的一个内部变量设置为指定的初始值，然后在此初值上累加输入范围内所有元素的值。   accumulate算法返回累加的结果，其返回类型就是其第三个实参的类型。        return accumulate(num.begin(),num.end(),0);  //求和    &#125;&#125;;\n\n","categories":["计算机理论"],"tags":["LeetCode算法-贪心算法"]},{"title":"剑指Offer_68-1_二叉搜索树的最近公共祖先","url":"/2019/06/30/%E8%AE%A1%E7%AE%97%E6%9C%BA%E7%90%86%E8%AE%BA/LeetCode%E7%AE%97%E6%B3%95/%E6%A0%91/1.10_%E5%89%91%E6%8C%87Offer_68-1_%E4%BA%8C%E5%8F%89%E6%90%9C%E7%B4%A2%E6%A0%91%E7%9A%84%E6%9C%80%E8%BF%91%E5%85%AC%E5%85%B1%E7%A5%96%E5%85%88/","content":"❗️LeetCode_235_二叉搜索树的最近公共祖先\n题目描述：给定一个二叉搜索树, 找到该树中两个指定节点的最近公共祖先。百度百科中最近公共祖先的定义为：“对于有根树 T 的两个结点 p、q，最近公共祖先表示为一个结点 x，满足 x 是 p、q 的祖先且 x 的深度尽可能大（一个节点也可以是它自己的祖先）。”示例：输入: root = [6,2,8,0,4,7,9,null,null,3,5], p = 2, q = 8输出: 6 解释: 节点 2 和节点 8 的最近公共祖先是 6。输入: root = [6,2,8,0,4,7,9,null,null,3,5], p = 2, q = 4输出: 2解释: 节点 2 和节点 4 的最近公共祖先是 2, 因为根据定义最近公共祖先节点可以为节点本身。说明：1. 所有节点的值都是唯一的。2. p、q 为不同节点且均存在于给定的二叉搜索树中。\n\n解法1：/** * Definition for a binary tree node. * struct TreeNode &#123; *     int val; *     TreeNode *left; *     TreeNode *right; *     TreeNode(int x) : val(x), left(NULL), right(NULL) &#123;&#125; * &#125;; */class Solution &#123;public:    TreeNode* lowestCommonAncestor(TreeNode* root, TreeNode* p, TreeNode* q) &#123;        TreeNode* ancestor = root;  //一开始先假设最近公共祖先是根节点，从根节点开始遍历        while (true) &#123;            //如果当前节点的值比两个节点的值都大，那么最低的共同父节点一定在当前节点的左子树中，            //于是下一步遍历当前节点的左子节点            if (p-&gt;val &lt; ancestor-&gt;val &amp;&amp; q-&gt;val &lt; ancestor-&gt;val) &#123;                ancestor = ancestor-&gt;left;              &#125; else if (p-&gt;val &gt; ancestor-&gt;val &amp;&amp; q-&gt;val &gt; ancestor-&gt;val) &#123;                ancestor = ancestor-&gt;right;            &#125; else break;  //跳出循环        &#125;                return ancestor;    &#125;&#125;;\n\n","categories":["计算机理论"],"tags":["LeetCode算法-树"]},{"title":"剑指Offer_68-2_二叉树的最近公共祖先","url":"/2019/06/30/%E8%AE%A1%E7%AE%97%E6%9C%BA%E7%90%86%E8%AE%BA/LeetCode%E7%AE%97%E6%B3%95/%E6%A0%91/1.11_%E5%89%91%E6%8C%87Offer_68-2_%E4%BA%8C%E5%8F%89%E6%A0%91%E7%9A%84%E6%9C%80%E8%BF%91%E5%85%AC%E5%85%B1%E7%A5%96%E5%85%88/","content":"❗️LeetCode_236_二叉树的最近公共祖先\n题目描述：给定一个二叉树, 找到该树中两个指定节点的最近公共祖先。百度百科中最近公共祖先的定义为：“对于有根树 T 的两个结点 p、q，最近公共祖先表示为一个结点 x，满足 x 是 p、q 的祖先且 x 的深度尽可能大（一个节点也可以是它自己的祖先）。”示例：输入: root = [3,5,1,6,2,0,8,null,null,7,4], p = 5, q = 1输出: 3解释: 节点 5 和节点 1 的最近公共祖先是节点 3。输入: root = [3,5,1,6,2,0,8,null,null,7,4], p = 5, q = 4输出: 5解释: 节点 5 和节点 4 的最近公共祖先是节点 5。因为根据定义最近公共祖先节点可以为节点本身。说明：1. 所有节点的值都是唯一的。2. p、q 为不同节点且均存在于给定的二叉树中。\n\n解法1：后序遍历/** * Definition for a binary tree node. * struct TreeNode &#123; *     int val; *     TreeNode *left; *     TreeNode *right; *     TreeNode(int x) : val(x), left(NULL), right(NULL) &#123;&#125; * &#125;; */class Solution &#123;public:    TreeNode* lowestCommonAncestor(TreeNode* root, TreeNode* p, TreeNode* q) &#123;        //递归跳出条件：根节点为空、根节点与q或p相等        if (root == NULL) return NULL;        //⭐️return root只是把root返回到递归的上一层，可以用二叉树[3,5,1]模拟一下        if (root == p || root == q) return root;        //后序遍历：先左子树再右子树        TreeNode* leftNode = lowestCommonAncestor(root-&gt;left, p, q);        TreeNode* rightNode = lowestCommonAncestor(root-&gt;right, p, q);        //第一种情况：左右子树中都没有找到与p或q相等的节点，说明树中没有这两个节点，返回空        if (!leftNode &amp;&amp; !rightNode) return NULL;        //第二种情况：在左右子树中找到了q和p两个节点，返回此时的根节点，即最近的公共祖先        else if (leftNode &amp;&amp; rightNode) return root;        //第三种情况：左子树中没找到p或q，且root与q和p都不相等，说明这两个节点都在右子树中，返回右子树        else if (!leftNode &amp;&amp; rightNode) return rightNode;  //❗️注意这里不能写root-&gt;rightNode                //第四种情况：右子树中没找到p或q，且root与q和p都不相等，说明这两个节点都在左子树中，返回左子树        else return leftNode;  //❗️注意这里不能写root-&gt;leftNode    &#125;&#125;;\n\n","categories":["计算机理论"],"tags":["LeetCode算法-树"]},{"title":"剑指Offer_27_二叉树的镜像","url":"/2019/06/30/%E8%AE%A1%E7%AE%97%E6%9C%BA%E7%90%86%E8%AE%BA/LeetCode%E7%AE%97%E6%B3%95/%E6%A0%91/1.2_%E5%89%91%E6%8C%87Offer_27_%E4%BA%8C%E5%8F%89%E6%A0%91%E7%9A%84%E9%95%9C%E5%83%8F/","content":"❗️LeetCode_226_翻转二叉树\n题目描述：请完成一个函数，输入一个二叉树，该函数输出它的镜像。例如输入：     4   /   \\  2     7 / \\   / \\1   3 6   9镜像输出：     4   /   \\  7     2 / \\   / \\9   6 3   1示例：输入：root = [4,2,7,1,3,6,9]输出：[4,7,2,9,6,3,1]限制：0 &lt;= 节点个数 &lt;= 1000\n\n解法1：递归/** * Definition for a binary tree node. * struct TreeNode &#123; *     int val; *     TreeNode *left; *     TreeNode *right; *     TreeNode(int x) : val(x), left(NULL), right(NULL) &#123;&#125; * &#125;; */class Solution &#123;public:    TreeNode* mirrorTree(TreeNode* root) &#123;        if (root == NULL) return &#123;&#125;;        if (root-&gt;left == NULL &amp;&amp; root-&gt;right == NULL) return root;        //先前序遍历这棵树的每个节点，如果遍历到的节点有子节点，就交换它的两个子节点        //当交换完所有非叶节点的左、右子节点之后，就得到了树的镜像        if (root-&gt;left != NULL) &#123;            mirrorTree(root-&gt;left);        &#125;        if (root-&gt;right != NULL) &#123;            mirrorTree(root-&gt;right);        &#125;        TreeNode* temp = root-&gt;left;        root-&gt;left = root-&gt;right;        root-&gt;right = temp;        return root;    &#125;&#125;;\n\n","categories":["计算机理论"],"tags":["LeetCode算法-树"]},{"title":"剑指Offer_34_二叉树中和为某一值的路径","url":"/2019/06/30/%E8%AE%A1%E7%AE%97%E6%9C%BA%E7%90%86%E8%AE%BA/LeetCode%E7%AE%97%E6%B3%95/%E6%A0%91/1.5_%E5%89%91%E6%8C%87Offer_34_%E4%BA%8C%E5%8F%89%E6%A0%91%E4%B8%AD%E5%92%8C%E4%B8%BA%E6%9F%90%E4%B8%80%E5%80%BC%E7%9A%84%E8%B7%AF%E5%BE%84/","content":"❗️LeetCode_113_路径总和2\n题目描述：输入一棵二叉树和一个整数，打印出二叉树中节点值的和为输入整数的所有路径。从树的根节点开始往下一直到叶节点所经过的节点形成一条路径。示例：给定如下二叉树，以及目标和 target = 22，              5             / \\            4   8           /   / \\          11  13  4         /  \\    / \\        7    2  5   1返回：[   [5,4,11,2],   [5,8,4,5]]提示：节点总数 &lt;= 10000\n\n解法1：递归/** * Definition for a binary tree node. * struct TreeNode &#123; *     int val; *     TreeNode *left; *     TreeNode *right; *     TreeNode() : val(0), left(nullptr), right(nullptr) &#123;&#125; *     TreeNode(int x) : val(x), left(nullptr), right(nullptr) &#123;&#125; *     TreeNode(int x, TreeNode *left, TreeNode *right) : val(x), left(left), right(right) &#123;&#125; * &#125;; */class Solution &#123;public://当用前序遍历的方式访问到某一节点时，我们把该节点添加到路径上，并累加该节点的值//如果该节点为叶节点，并且路径中节点值的和刚好等于输入的整数，则当前路径符合要求，我们把它打印出来//如果当前节点不是叶节点，则继续访问它的子节点//当前节点访问结束后，递归函数将自动回到它的父节点//因此我们在函数退出之前要在路径上删除当前节点并减去当前节点的值，以确保返回父节点时路径刚好是从根节点到父节点    vector&lt;vector&lt;int&gt;&gt; res;  //定义一个嵌套容器    vector&lt;int&gt; path;  //定义一个容器    vector&lt;vector&lt;int&gt;&gt; pathSum(TreeNode* root, int sum) &#123;        dfs(root, sum);        return res;    &#125;    //递归求解    void dfs(TreeNode* curr, int target) &#123;        if (curr != nullptr) &#123;            target -= curr-&gt;val;            path.push_back(curr-&gt;val);            if (target != 0 || curr-&gt;left != nullptr || curr-&gt;right != nullptr) &#123;                dfs(curr-&gt;left, target);                dfs(curr-&gt;right, target);            &#125; else &#123;                                res.push_back(path);  //满足结果            &#125;                        //注意理解这个回溯❗️可以注释这行代码看看效果            //当路径中有不对的值比如7、或者访问完左子树需要开始访问右子树，都需要回溯路径中的值            path.pop_back();          &#125;    &#125;&#125;;\n\n","categories":["计算机理论"],"tags":["LeetCode算法-树"]},{"title":"剑指Offer_26_树的子结构","url":"/2019/06/30/%E8%AE%A1%E7%AE%97%E6%9C%BA%E7%90%86%E8%AE%BA/LeetCode%E7%AE%97%E6%B3%95/%E6%A0%91/1.1_%E5%89%91%E6%8C%87Offer_26_%E6%A0%91%E7%9A%84%E5%AD%90%E7%BB%93%E6%9E%84/","content":"题目描述：输入两棵二叉树A和B，判断B是不是A的子结构。(约定空树不是任意一个树的子结构)B是A的子结构， 即A中有出现和B相同的结构和节点值。例如:给定的树 A:     3    / \\   4   5  / \\ 1   2 给定的树 B：   4   / 1 返回 true，因为 B 与 A 的一个子树拥有相同的结构和节点值。示例：输入：A = [1,2,3], B = [3,1]输出：false输入：A = [3,4,5,1,2], B = [4,1]输出：true限制：0 &lt;= 节点个数 &lt;= 10000\n\n解法1：/** * Definition for a binary tree node. * struct TreeNode &#123; *     int val; *     TreeNode *left; *     TreeNode *right; *     TreeNode(int x) : val(x), left(NULL), right(NULL) &#123;&#125; * &#125;; */class Solution &#123;public:    //注意：原书中节点值的类型为double，在判断两个节点的值是不是相等时，不能直接写A-&gt;val == B-&gt;val，这是因为在计算机内表示小数时（float、double）都有误差，判断两个小数是否相等，只能判断它们之差的绝对值是不是在一个很小的范围内，如果两个数相差很小，就可以认为它们相等    bool Equal(double num1,double num2) &#123;        if ((num1 - num2 &gt; -0.0000001) &amp;&amp; (num1 - num2 &lt; 0.0000001)) &#123;            return true;        &#125; else &#123;            return false;        &#125;    &#125;    bool isSubStructure(TreeNode* A, TreeNode* B) &#123;                bool result = false;        if (A == NULL) return false;        if (B == NULL) return false;  //约定空树不是任意一个树的子结构        if (A != NULL &amp;&amp; B != NULL) &#123;            if (Equal(A-&gt;val,B-&gt;val)) &#123;                result = DoesTree1HaveTree2(A,B);            &#125;            if (result == false) &#123;                result = isSubStructure(A-&gt;left,B);            &#125;            if (result == false) &#123;                result = isSubStructure(A-&gt;right,B);            &#125;        &#125;        return result;    &#125;    bool DoesTree1HaveTree2(TreeNode* A, TreeNode* B) &#123;        //注意：这两行代码不能调换        if (B == NULL) return true;        if (A == NULL) return false;                if (!Equal(A-&gt;val,B-&gt;val)) return false;        return DoesTree1HaveTree2(A-&gt;left,B-&gt;left) &amp;&amp; DoesTree1HaveTree2(A-&gt;right,B-&gt;right);    &#125;&#125;;\n\n/** * Definition for a binary tree node. * struct TreeNode &#123; *     int val; *     TreeNode *left; *     TreeNode *right; *     TreeNode(int x) : val(x), left(NULL), right(NULL) &#123;&#125; * &#125;; */class Solution &#123;public:    bool isSubStructure(TreeNode* A, TreeNode* B) &#123;                bool result = false;        if (A == NULL) return false;        if (B == NULL) return false;  //约定空树不是任意一个树的子结构        if (A != NULL &amp;&amp; B != NULL) &#123;            if (A-&gt;val == B-&gt;val) &#123;                result = DoesTree1HaveTree2(A,B);            &#125;            if (result == false) &#123;                result = isSubStructure(A-&gt;left,B);            &#125;            if (result == false) &#123;                result = isSubStructure(A-&gt;right,B);            &#125;        &#125;        return result;    &#125;    bool DoesTree1HaveTree2(TreeNode* A, TreeNode* B) &#123;        //注意：这两行代码不能调换        if (B == NULL) return true;        if (A == NULL) return false;                if (A-&gt;val != B-&gt;val) return false;        return DoesTree1HaveTree2(A-&gt;left,B-&gt;left) &amp;&amp; DoesTree1HaveTree2(A-&gt;right,B-&gt;right);    &#125;&#125;;\n\n","categories":["计算机理论"],"tags":["LeetCode算法-树"]},{"title":"剑指Offer_32_从上到下打印二叉树","url":"/2019/06/30/%E8%AE%A1%E7%AE%97%E6%9C%BA%E7%90%86%E8%AE%BA/LeetCode%E7%AE%97%E6%B3%95/%E6%A0%91/1.4_%E5%89%91%E6%8C%87Offer_32_%E4%BB%8E%E4%B8%8A%E5%88%B0%E4%B8%8B%E6%89%93%E5%8D%B0%E4%BA%8C%E5%8F%89%E6%A0%91/","content":"题目1描述：不分行从上到下打印二叉树//二叉树的层序遍历从上到下打印出二叉树的每个节点，同一层的节点按照从左到右的顺序打印。示例：给定二叉树: [3,9,20,null,null,15,7],    3   / \\  9  20    /  \\   15   7   返回：[3,9,20,15,7]提示：节点总数 &lt;= 1000\n\n解法1：队列/** * Definition for a binary tree node. * struct TreeNode &#123; *     int val; *     TreeNode *left; *     TreeNode *right; *     TreeNode(int x) : val(x), left(NULL), right(NULL) &#123;&#125; * &#125;; */class Solution &#123;public://每次打印一个节点的时候，如果该节点有子节点，则把该节点的子节点放到一个队列的队尾，接下来到队列的头部取出最早进入队列的节点，重复前面的操作，直至队列中所有的节点都被打印出来    vector&lt;int&gt; levelOrder(TreeNode* root) &#123;        vector&lt;int&gt; ret;  //定义一个容器        queue&lt;TreeNode* &gt; que;  //定义一个队列        if (root != NULL) que.push(root);        while (!que.empty()) &#123;                        TreeNode *node = que.front();  //node指向队列的首节点                        if (node-&gt;left != NULL) que.push(node-&gt;left);            if (node-&gt;right != NULL) que.push(node-&gt;right);            que.pop();            ret.push_back(node-&gt;val);        &#125;        return ret;    &#125;&#125;;\n\n❗️LeetCode_102_二叉树的层序遍历\n题目2描述：分行从上到下打印二叉树从上到下按层打印二叉树，同一层的节点按从左到右的顺序打印，每一层打印到一行。示例：给定二叉树: [3,9,20,null,null,15,7],    3   / \\  9  20    /  \\   15   7   返回其层次遍历结果：[  [3],  [9,20],  [15,7]]提示：节点总数 &lt;= 1000\n\n解法1：队列/** * Definition for a binary tree node. * struct TreeNode &#123; *     int val; *     TreeNode *left; *     TreeNode *right; *     TreeNode(int x) : val(x), left(NULL), right(NULL) &#123;&#125; * &#125;; */class Solution &#123;public:    vector&lt;vector&lt;int&gt;&gt; levelOrder(TreeNode* root) &#123;                queue&lt;TreeNode* &gt; que;  //定义一个队列        vector&lt;vector&lt;int&gt;&gt; ret;  //定义一个嵌套容器        if (root != NULL) que.push(root);  //初始化        while(!que.empty()) &#123;            int sz = que.size();  //本层节点个数            vector&lt;int&gt; ret1;  //定义一个容器            for(int i = 0; i &lt; sz; ++i) &#123;                 TreeNode* node = que.front();                if (node-&gt;left != NULL) que.push(node-&gt;left);  //压入左节点                if (node-&gt;right != NULL) que.push(node-&gt;right); //压入右节点                que.pop();                ret1.push_back(node-&gt;val);            &#125;            ret.push_back(ret1);        &#125;        return ret;    &#125;&#125;;\n\n题目3描述：之字形打印二叉树请实现一个函数按照之字形顺序打印二叉树，即第一行按照从左到右的顺序打印，第二层按照从右到左的顺序打印，第三行再按照从左到右的顺序打印，其他行以此类推。示例：给定二叉树: [3,9,20,null,null,15,7],    3   / \\  9  20    /  \\   15   7   返回其层次遍历结果：[  [3],  [20,9],  [15,7]]提示：节点总数 &lt;= 1000\n\n解法1：两个栈/** * Definition for a binary tree node. * struct TreeNode &#123; *     int val; *     TreeNode *left; *     TreeNode *right; *     TreeNode(int x) : val(x), left(NULL), right(NULL) &#123;&#125; * &#125;; */class Solution &#123;public://按之字形顺序打印二叉树需要两个栈，我们在打印某一层的节点时，把下一层的子节点保存到相应的栈里//如果当前打印的是奇数层（第一层、第三层等），则先保存左子节点再保存右子节点到第一个栈里//如果当前打印的是偶数层（第二层、第四层等），则先保存右子节点再保存左子节点到第二个栈里    vector&lt;vector&lt;int&gt;&gt; levelOrder(TreeNode* root) &#123;        stack&lt;TreeNode* &gt; left, right;  //定义两个栈        vector&lt;vector&lt;int&gt;&gt; ans;  //定义一个嵌套容器        if (root != nullptr) left.push(root);  //初始化：先将根节点放到左栈中        while(!left.empty() || !right.empty()) &#123;            vector&lt;int&gt; ans1;  //定义一个容器            if (!left.empty()) &#123;  //if else是不能去掉的                while (!left.empty()) &#123;                    TreeNode* nodeleft = left.top();                                        if (nodeleft-&gt;left != nullptr) right.push(nodeleft-&gt;left);                    if (nodeleft-&gt;right != nullptr) right.push(nodeleft-&gt;right);                    left.pop();                    ans1.push_back(nodeleft-&gt;val);                &#125;            &#125; else &#123;                while (!right.empty()) &#123;                    TreeNode* noderight = right.top();                                        if (noderight-&gt;right != nullptr) left.push(noderight-&gt;right);                    if (noderight-&gt;left != nullptr) left.push(noderight-&gt;left);                    right.pop();                    ans1.push_back(noderight-&gt;val);                &#125;            &#125;            ans.push_back(ans1);        &#125;        return ans;    &#125;&#125;;\n\n","categories":["计算机理论"],"tags":["LeetCode算法-树"]},{"title":"剑指Offer_28_对称的二叉树","url":"/2019/06/30/%E8%AE%A1%E7%AE%97%E6%9C%BA%E7%90%86%E8%AE%BA/LeetCode%E7%AE%97%E6%B3%95/%E6%A0%91/1.3_%E5%89%91%E6%8C%87Offer_28_%E5%AF%B9%E7%A7%B0%E7%9A%84%E4%BA%8C%E5%8F%89%E6%A0%91/","content":"❗️LeetCode_101_对称二叉树\n题目描述：请实现一个函数，用来判断一棵二叉树是不是对称的。如果一棵二叉树和它的镜像一样，那么它是对称的。例如，二叉树 [1,2,2,3,4,4,3] 是对称的。    1   / \\  2   2 / \\ / \\3  4 4  3但是下面这个 [1,2,2,null,3,null,3] 则不是镜像对称的:    1   / \\  2   2   \\   \\   3    3示例：输入：root = [1,2,2,3,4,4,3]输出：true输入：root = [1,2,2,null,3,null,3]输出：false限制：0 &lt;= 节点个数 &lt;= 1000\n\n解法1：递归/** * Definition for a binary tree node. * struct TreeNode &#123; *     int val; *     TreeNode *left; *     TreeNode *right; *     TreeNode(int x) : val(x), left(NULL), right(NULL) &#123;&#125; * &#125;; */class Solution &#123;public:    bool isSymmetric(TreeNode* root) &#123;        return isSymmetric(root,root);    &#125;      //四步法：    //1.如果两个子树都为空指针，则它们相等或对称    //2.如果两个子树只有一个为空指针，则它们不相等或不对称    //3.如果两个子树根节点的值不相等，则它们不相等或不对称    //4.根据相等或对称要求，进行递归处理    bool isSymmetric(TreeNode* root1,TreeNode* root2) &#123;        if (root1 == NULL &amp;&amp; root2 == NULL) return true;        if (root1 == NULL || root2 == NULL) return false;        if (root1 -&gt; val != root2 -&gt; val) return false;        //可以通过比较二叉树的前序遍历序列和对称前序遍历序列（根右左）来判断二叉树是不是对称的，        //如果两个序列是一样的，那么二叉树就是对称的        //注意考虑原书中这种情况：二叉树&#123;7,7,7,NULL,NULL,7,NULL,NULL,7,7,NULL,NULL,NULL&#125;        return isSymmetric(root1-&gt;left,root2-&gt;right) &amp;&amp; isSymmetric(root1-&gt;right,root2-&gt;left);    &#125;&#125;;\n\n","categories":["计算机理论"],"tags":["LeetCode算法-树"]},{"title":"剑指Offer_55_二叉树的深度","url":"/2019/06/30/%E8%AE%A1%E7%AE%97%E6%9C%BA%E7%90%86%E8%AE%BA/LeetCode%E7%AE%97%E6%B3%95/%E6%A0%91/1.6_%E5%89%91%E6%8C%87Offer_55_%E4%BA%8C%E5%8F%89%E6%A0%91%E7%9A%84%E6%B7%B1%E5%BA%A6/","content":"❗️LeetCode_104_二叉树的最大深度\n题目1描述：输入一棵二叉树的根节点，求该树的深度。从根节点到叶节点依次经过的节点（含根、叶节点）形成树的一条路径，最长路径的长度为树的深度。给定二叉树 [3,9,20,null,null,15,7]，    3   / \\  9  20    /  \\   15   7返回它的最大深度 3 。提示：节点总数 &lt;= 10000\n\n解法1：递归/** * Definition for a binary tree node. * struct TreeNode &#123; *     int val; *     TreeNode *left; *     TreeNode *right; *     TreeNode(int x) : val(x), left(NULL), right(NULL) &#123;&#125; * &#125;; */class Solution &#123;public:    int maxDepth(TreeNode* root) &#123;        if (root == NULL) return 0;        int nLeft = maxDepth(root -&gt; left);        int nRight = maxDepth(root -&gt; right);        return (nLeft &gt; nRight) ? (nLeft + 1) : (nRight + 1);     &#125;&#125;;\n\n❗️LeetCode_110_平衡二叉树\n题目2描述：平衡二叉树输入一棵二叉树的根节点，判断该树是不是平衡二叉树。如果某二叉树中任意节点的左右子树的深度相差不超过1，那么它就是一棵平衡二叉树。示例：给定二叉树 [3,9,20,null,null,15,7]    3   / \\  9  20    /  \\   15   7返回 true 。给定二叉树 [1,2,2,3,3,null,null,4,4]       1      / \\     2   2    / \\   3   3  / \\ 4   4返回 false 。限制：0 &lt;= 树的结点个数 &lt;= 10000\n\n解法1：需要重复遍历节点多次的解法/** * Definition for a binary tree node. * struct TreeNode &#123; *     int val; *     TreeNode *left; *     TreeNode *right; *     TreeNode(int x) : val(x), left(NULL), right(NULL) &#123;&#125; * &#125;; */class Solution &#123;public:    //求二叉树的深度    int maxDepth(TreeNode* root) &#123;        if (root == NULL) return 0;        int nLeft = maxDepth(root-&gt;left);        int nRight = maxDepth(root-&gt;right);        return (nLeft &gt; nRight) ? (nLeft + 1) : (nRight + 1);     &#125;    bool isBalanced(TreeNode* root) &#123;        if (root == NULL) return true;        int left = maxDepth(root-&gt;left);        int right = maxDepth(root-&gt;right);        int diff = left - right;        if (diff &gt; 1 || diff &lt; -1) return false;                //需要重复遍历节点多次的解法        return isBalanced(root-&gt;left) &amp;&amp; isBalanced(root-&gt;right);                 //注意不能直接return true，这样只是判断了根节点是平衡二叉树，实际上必须根节点的每个子节点都要是平衡二叉树        //层序遍历：[1,2,2,3,null,null,3,4,null,null,4]        //return true;    &#125;&#125;;\n\n解法2：每个节点只遍历一次的解法/** * Definition for a binary tree node. * struct TreeNode &#123; *     int val; *     TreeNode *left; *     TreeNode *right; *     TreeNode(int x) : val(x), left(NULL), right(NULL) &#123;&#125; * &#125;; */class Solution &#123;public:    bool isBalanced(TreeNode* root) &#123;        int depth = 0;        return Balanced(root,&amp;depth);    &#125;    //每个节点只遍历一次的解法    //如果我们用后序遍历的方式遍历二叉树的每个节点，那么在遍历到一个节点之前我们就已经遍历了它的左、右子树    //只要在遍历每个节点的时候记录它的深度，我们就可以一边遍历一边判断每个节点是不是平衡的    bool Balanced(TreeNode* pRoot,int *pDepth) &#123;        if (pRoot == NULL) &#123;            *pDepth = 0;  //❗️注意这一行不可以去掉，会出错            return true;        &#125;        int left,right;        if (Balanced(pRoot-&gt;left,&amp;left) &amp;&amp; Balanced(pRoot-&gt;right,&amp;right)) &#123;            int diff = left - right;            if (diff &lt;= 1 &amp;&amp; diff &gt;= -1) &#123;                *pDepth = 1 + (left &gt; right ? left : right);                return true;             &#125;        &#125;        return false;    &#125;&#125;;\n\n","categories":["计算机理论"],"tags":["LeetCode算法-树"]},{"title":"剑指Offer_07_重建二叉树","url":"/2019/06/30/%E8%AE%A1%E7%AE%97%E6%9C%BA%E7%90%86%E8%AE%BA/LeetCode%E7%AE%97%E6%B3%95/%E6%A0%91/1.7_%E5%89%91%E6%8C%87Offer_07_%E9%87%8D%E5%BB%BA%E4%BA%8C%E5%8F%89%E6%A0%91/","content":"❗️LeetCode_105_从前序与中序遍历序列构造二叉树\n题目描述：输入某二叉树的前序遍历和中序遍历的结果，请重建该二叉树。假设输入的前序遍历和中序遍历的结果中都不含重复的数字。示例：前序遍历 preorder = [3,9,20,15,7]中序遍历 inorder = [9,3,15,20,7]返回如下的二叉树：    3   / \\  9  20    /  \\   15   7   限制：0 &lt;= 节点个数 &lt;= 5000\n\n解法1：递归、左闭右闭/** * Definition for a binary tree node. * struct TreeNode &#123; *     int val; *     TreeNode *left; *     TreeNode *right; *     TreeNode(int x) : val(x), left(NULL), right(NULL) &#123;&#125; * &#125;; */class Solution &#123;public:    unordered_map&lt;int, int&gt; index;  //创建一个哈希表，用来存放中序序列    TreeNode* myBuildTree(const vector&lt;int&gt;&amp; preorder, const vector&lt;int&gt;&amp; inorder, int preorder_left, int preorder_right, int inorder_left, int inorder_right) &#123;        //左闭右闭的写法        if (preorder_left &gt; preorder_right || inorder_left &gt; inorder_right) &#123;            return NULL;        &#125;                //前序遍历中的第一个节点就是根节点        int preorder_root = preorder_left;        //在中序遍历中定位根节点        //这行代码就相当于把前序序列中根结点的值拿来跟哈希表比照，返回哈希表中与根结点值相同的索引        int inorder_root = index[preorder[preorder_root]];                  //先把根节点建立出来        TreeNode* root = new TreeNode(preorder[preorder_root]);        //得到左子树中的节点数目        int size_left_subtree = inorder_root - inorder_left;        //递归地构造左子树，并连接到根节点：左闭右闭        root-&gt;left = myBuildTree(preorder, inorder, preorder_left + 1, preorder_left + size_left_subtree, inorder_left, inorder_root - 1);        //递归地构造右子树，并连接到根节点：左闭右闭        root-&gt;right = myBuildTree(preorder, inorder, preorder_left + size_left_subtree + 1, preorder_right, inorder_root + 1, inorder_right);        return root;    &#125;    TreeNode* buildTree(vector&lt;int&gt;&amp; preorder, vector&lt;int&gt;&amp; inorder) &#123;        int n = inorder.size();  //中序序列的长度        //构造哈希映射，帮助我们快速定位根节点        //将中序序列存放到哈希表中        for (int i = 0; i &lt; n; ++i) &#123;            index[inorder[i]] = i;        &#125;        //返回最终的二叉树        return myBuildTree(preorder, inorder, 0, n - 1, 0, n - 1);      &#125;    &#125;;\n\n","categories":["计算机理论"],"tags":["LeetCode算法-树"]},{"title":"剑指Offer_33_二叉搜索树的后序遍历序列","url":"/2019/06/30/%E8%AE%A1%E7%AE%97%E6%9C%BA%E7%90%86%E8%AE%BA/LeetCode%E7%AE%97%E6%B3%95/%E6%A0%91/1.8_%E5%89%91%E6%8C%87Offer_33_%E4%BA%8C%E5%8F%89%E6%90%9C%E7%B4%A2%E6%A0%91%E7%9A%84%E5%90%8E%E5%BA%8F%E9%81%8D%E5%8E%86%E5%BA%8F%E5%88%97/","content":"题目描述：输入一个整数数组，判断该数组是不是某二叉搜索树的后序遍历结果。如果是则返回 true，否则返回 false。假设输入的数组的任意两个数字都互不相同。参考以下这颗二叉搜索树：     5    / \\   2   6  / \\ 1   3 输入: [1,6,3,2,5]输出: false输入: [1,3,2,6,5]输出: true提示：数组长度 &lt;= 1000\n\n解法1：递归（左闭右开）class Solution &#123;public:    bool verifyPostorder(vector&lt;int&gt;&amp; postorder) &#123;        return dfs(postorder, 0, postorder.size());    &#125;    bool dfs(vector&lt;int&gt;&amp; postorder, int start, int size) &#123;           //左闭右开固定写法        if (start + 1 &gt; size) return true;        //在后序遍历得到的序列中，根结点是最后一个元素        int root = postorder[size - 1];          //左子树都比根结点小，右子树都比根结点大        int i = start;        while (i &lt; size &amp;&amp; postorder[i] &lt; root) ++i;  //i = 3        //j = i，此时j指向右子树，右子树的值一定比根节点大，如果右子树的值比根节点小，返回false        for (int j = i; j &lt; size; ++j)&#123;            if (postorder[j] &lt; root) return false;        &#125;        //递归：左闭右开        return dfs(postorder, start, i) &amp;&amp; dfs(postorder, i, size - 1);    &#125;&#125;;\n\n","categories":["计算机理论"],"tags":["LeetCode算法-树"]},{"title":"剑指Offer_54_二叉搜索树的第k大节点","url":"/2019/06/30/%E8%AE%A1%E7%AE%97%E6%9C%BA%E7%90%86%E8%AE%BA/LeetCode%E7%AE%97%E6%B3%95/%E6%A0%91/1.9_%E5%89%91%E6%8C%87Offer_54_%E4%BA%8C%E5%8F%89%E6%90%9C%E7%B4%A2%E6%A0%91%E7%9A%84%E7%AC%ACk%E5%A4%A7%E8%8A%82%E7%82%B9/","content":"❗️LeetCode_230_二叉搜索树中第K小的元素\n题目描述：给定一棵二叉搜索树，请找出其中第k大的节点。示例：输入: root = [3,1,4,null,2], k = 1   3  / \\ 1   4  \\   2输出: 4输入: root = [5,3,6,2,4,null,null,1], k = 3       5      / \\     3   6    / \\   2   4  / 1输出: 4限制：1 ≤ k ≤ 二叉搜索树元素个数\n\n解法1：中序遍历/** * Definition for a binary tree node. * struct TreeNode &#123; *     int val; *     TreeNode *left; *     TreeNode *right; *     TreeNode(int x) : val(x), left(NULL), right(NULL) &#123;&#125; * &#125;; */class Solution &#123;public:    int a;  //a就是第k大的节点    int kthLargest(TreeNode* root, int k) &#123;        dfs(root, k);        return a;    &#125;    //为什么要写成int&amp; k❓    void dfs(TreeNode* root, int&amp; k) &#123;        if(root == NULL) return;        //二叉搜索树：        //如果按照中序遍历的顺序遍历一颗二叉搜索树，则遍历序列的数值是递增排序的，反之则是递减排序的        dfs(root-&gt;right, k);  //先遍历右边        k--;        if(k == 0) a = root-&gt;val;        if(k &gt; 0) dfs(root-&gt;left, k);  //再遍历左边    &#125;&#125;;\n\n","categories":["计算机理论"],"tags":["LeetCode算法-树"]},{"title":"LeetCode_1110_删点成林","url":"/2019/06/30/%E8%AE%A1%E7%AE%97%E6%9C%BA%E7%90%86%E8%AE%BA/LeetCode%E7%AE%97%E6%B3%95/%E6%A0%91/2.13_LeetCode_1110_%E5%88%A0%E7%82%B9%E6%88%90%E6%9E%97/","content":"题目描述：给出二叉树的根节点 root，树上每个节点都有一个不同的值。如果节点值在 to_delete 中出现，我们就把该节点从树上删去，最后得到一个森林（一些不相交的树构成的集合）。返回森林中的每棵树。你可以按任意顺序组织答案。示例：输入：root = [1,2,3,4,5,6,7], to_delete = [3,5]输出：[[1,2,null,4],[6],[7]]提示：1. 树中的节点数最大为 1000。2. 每个节点都有一个介于 1 到 1000 之间的值，且各不相同。3. to_delete.length &lt;= 10004. to_delete 包含一些从 1 到 1000、各不相同的值。\n\n\n解法1：递归、后序遍历/** * Definition for a binary tree node. * struct TreeNode &#123; *     int val; *     TreeNode *left; *     TreeNode *right; *     TreeNode() : val(0), left(nullptr), right(nullptr) &#123;&#125; *     TreeNode(int x) : val(x), left(nullptr), right(nullptr) &#123;&#125; *     TreeNode(int x, TreeNode *left, TreeNode *right) : val(x), left(left), right(right) &#123;&#125; * &#125;; */class Solution &#123;public:    vector&lt;TreeNode* &gt; delNodes(TreeNode* root, vector&lt;int&gt;&amp; to_delete) &#123;        vector&lt;TreeNode* &gt; forest;  //定义一个容器        //定义一个哈希集合，里面存放要删除的节点        //哈希集合，可以在O(1)的时间快速插入、查找、删除元素，常用于快速的查询一个元素是否在这个容器内        unordered_set&lt;int&gt; dict(to_delete.begin(), to_delete.end());        root = helper(root, dict, forest);        if (root != nullptr) forest.push_back(root);        return forest;    &#125;    TreeNode* helper(TreeNode* root, unordered_set&lt;int&gt;&amp; dict, vector&lt;TreeNode* &gt;&amp; forest) &#123;        if (root == nullptr)  return nullptr;        root-&gt;left = helper(root-&gt;left, dict, forest);        root-&gt;right = helper(root-&gt;right, dict, forest);        //如果该节点的val值存在于to_delete数组中        if (dict.count(root-&gt;val) != 0) &#123;            if (root-&gt;left != nullptr) forest.push_back(root-&gt;left);            if (root-&gt;right != nullptr) forest.push_back(root-&gt;right);            root = nullptr;            &#125;        return root;    &#125;&#125;;\n\n","categories":["计算机理论"],"tags":["LeetCode算法-树"]},{"title":"LeetCode_145_二叉树的后序遍历","url":"/2019/06/30/%E8%AE%A1%E7%AE%97%E6%9C%BA%E7%90%86%E8%AE%BA/LeetCode%E7%AE%97%E6%B3%95/%E6%A0%91/2.3_LeetCode_145_%E4%BA%8C%E5%8F%89%E6%A0%91%E7%9A%84%E5%90%8E%E5%BA%8F%E9%81%8D%E5%8E%86/","content":"题目描述：给定一个二叉树，返回它的 后序 遍历。示例：输入: [1,null,2,3]     1    \\     2    /   3 输出: [3,2,1]\n\n解法1：递归/** * Definition for a binary tree node. * struct TreeNode &#123; *     int val; *     TreeNode *left; *     TreeNode *right; *     TreeNode() : val(0), left(nullptr), right(nullptr) &#123;&#125; *     TreeNode(int x) : val(x), left(nullptr), right(nullptr) &#123;&#125; *     TreeNode(int x, TreeNode *left, TreeNode *right) : val(x), left(left), right(right) &#123;&#125; * &#125;; */class Solution &#123;public:    vector&lt;int&gt; res;  //容器要定义在外面    vector&lt;int&gt; postorderTraversal(TreeNode *root) &#123;        if (root == nullptr) return &#123;&#125;;        postorderTraversal(root-&gt;left);        postorderTraversal(root-&gt;right);        res.push_back(root-&gt;val);        return res;    &#125;&#125;;\n\n解法2：栈/** * Definition for a binary tree node. * struct TreeNode &#123; *     int val; *     TreeNode *left; *     TreeNode *right; *     TreeNode() : val(0), left(nullptr), right(nullptr) &#123;&#125; *     TreeNode(int x) : val(x), left(nullptr), right(nullptr) &#123;&#125; *     TreeNode(int x, TreeNode *left, TreeNode *right) : val(x), left(left), right(right) &#123;&#125; * &#125;; */class Solution &#123;public:    //因为递归的本质是栈调用，因此我们可以通过栈来实现后序遍历    vector&lt;int&gt; postorderTraversal(TreeNode* root) &#123;        vector&lt;int&gt; ret;  //定义一个容器        stack&lt;TreeNode* &gt; s;  //定义一个栈         if (root != nullptr) s.push(root);        while (!s.empty()) &#123;            TreeNode* node = s.top();            s.pop();            ret.push_back(node-&gt;val);            //先左后右，保证右子树先遍历            if (node-&gt;left != nullptr) s.push(node-&gt;left);            if (node-&gt;right != nullptr) s.push(node-&gt;right);        &#125;        //将结果再反转一下：根右左 -&gt; 左右根        reverse(ret.begin(), ret.end());        return ret;    &#125;&#125;;\n\n","categories":["计算机理论"],"tags":["LeetCode算法-树"]},{"title":"LeetCode_530_二叉搜索树的最小绝对差","url":"/2019/06/30/%E8%AE%A1%E7%AE%97%E6%9C%BA%E7%90%86%E8%AE%BA/LeetCode%E7%AE%97%E6%B3%95/%E6%A0%91/2.11_LeetCode_530_%E4%BA%8C%E5%8F%89%E6%90%9C%E7%B4%A2%E6%A0%91%E7%9A%84%E6%9C%80%E5%B0%8F%E7%BB%9D%E5%AF%B9%E5%B7%AE/","content":"❗️LeetCode_783_二叉搜索树节点最小距离\n题目描述：给你一棵所有节点为非负值的二叉搜索树，请你计算树中任意两节点的差的绝对值的最小值。示例：输入：   1    \\     3    /   2输出：1解释：最小绝对差为 1，其中 2 和 1 的差的绝对值为 1（或者 2 和 3）。提示：树中至少有 2 个节点。\n\n解法1：中序遍历/** * Definition for a binary tree node. * struct TreeNode &#123; *     int val; *     TreeNode *left; *     TreeNode *right; *     TreeNode() : val(0), left(nullptr), right(nullptr) &#123;&#125; *     TreeNode(int x) : val(x), left(nullptr), right(nullptr) &#123;&#125; *     TreeNode(int x, TreeNode *left, TreeNode *right) : val(x), left(left), right(right) &#123;&#125; * &#125;; */class Solution &#123;public:    int getMinimumDifference(TreeNode* root) &#123;        int ans = INT_MAX, pre = -1;        dfs(root, pre, ans);                return ans;    &#125;    //中序遍历    void dfs(TreeNode* root, int&amp; pre, int&amp; ans) &#123;        if (root == nullptr) return;        dfs(root-&gt;left, pre, ans);        if (pre == -1) &#123;            pre = root-&gt;val;        &#125; else &#123;            ans = min(ans, root-&gt;val - pre);            pre = root-&gt;val;        &#125;        dfs(root-&gt;right, pre, ans);    &#125;&#125;;\n\n","categories":["计算机理论"],"tags":["LeetCode算法-树"]},{"title":"LeetCode_669_修剪二叉搜索树","url":"/2019/06/30/%E8%AE%A1%E7%AE%97%E6%9C%BA%E7%90%86%E8%AE%BA/LeetCode%E7%AE%97%E6%B3%95/%E6%A0%91/2.10_LeetCode_669_%E4%BF%AE%E5%89%AA%E4%BA%8C%E5%8F%89%E6%90%9C%E7%B4%A2%E6%A0%91/","content":"题目描述：给你二叉搜索树的根节点 root ，同时给定最小边界low 和最大边界 high。通过修剪二叉搜索树，使得所有节点的值在[low, high]中。修剪树不应该改变保留在树中的元素的相对结构（即，如果没有被移除，原有的父代子代关系都应当保留）。 可以证明，存在唯一的答案。所以结果应当返回修剪好的二叉搜索树的新的根节点。注意，根节点可能会根据给定的边界发生改变。示例：输入：root = [1,0,2], low = 1, high = 2输出：[1,null,2]输入：root = [3,0,4,null,2,null,null,1], low = 1, high = 3输出：[3,2,null,1]输入：root = [1], low = 1, high = 2输出：[1]输入：root = [1,null,2], low = 1, high = 3输出：[1,null,2]输入：root = [1,null,2], low = 2, high = 4输出：[2]提示：1. 树中节点数在范围 [1, 10^4] 内2. 0 &lt;= Node.val &lt;= 10^43. 树中每个节点的值都是唯一的4. 题目数据保证输入是一棵有效的二叉搜索树5. 0 &lt;= low &lt;= high &lt;= 10^4\n\n解法1：递归/** * Definition for a binary tree node. * struct TreeNode &#123; *     int val; *     TreeNode *left; *     TreeNode *right; *     TreeNode() : val(0), left(nullptr), right(nullptr) &#123;&#125; *     TreeNode(int x) : val(x), left(nullptr), right(nullptr) &#123;&#125; *     TreeNode(int x, TreeNode *left, TreeNode *right) : val(x), left(left), right(right) &#123;&#125; * &#125;; */class Solution &#123;public:    TreeNode* trimBST(TreeNode* root, int low, int high) &#123;        if (root == nullptr) return nullptr;        if (root-&gt;val &gt; high) return trimBST(root-&gt;left,low,high);        if (root-&gt;val &lt; low) return trimBST(root-&gt;right,low,high);        root-&gt;left = trimBST(root-&gt;left,low,high);        root-&gt;right = trimBST(root-&gt;right,low,high);        return root;    &#125;&#125;;\n\n","categories":["计算机理论"],"tags":["LeetCode算法-树"]},{"title":"LeetCode_637_二叉树的层平均值","url":"/2019/06/30/%E8%AE%A1%E7%AE%97%E6%9C%BA%E7%90%86%E8%AE%BA/LeetCode%E7%AE%97%E6%B3%95/%E6%A0%91/2.4_LeetCode_637_%E4%BA%8C%E5%8F%89%E6%A0%91%E7%9A%84%E5%B1%82%E5%B9%B3%E5%9D%87%E5%80%BC/","content":"题目描述：给定一个非空二叉树, 返回一个由每层节点平均值组成的数组。示例：输入：    3   / \\  9  20    /  \\   15   7输出：[3, 14.5, 11]解释：第 0 层的平均值是 3 ,第1层是 14.5 , 第2层是 11 。因此返回 [3, 14.5, 11] 。提示：节点值的范围在32位有符号整数范围内。\n\n解法1：队列/** * Definition for a binary tree node. * struct TreeNode &#123; *     int val; *     TreeNode *left; *     TreeNode *right; *     TreeNode() : val(0), left(nullptr), right(nullptr) &#123;&#125; *     TreeNode(int x) : val(x), left(nullptr), right(nullptr) &#123;&#125; *     TreeNode(int x, TreeNode *left, TreeNode *right) : val(x), left(left), right(right) &#123;&#125; * &#125;; */class Solution &#123;public:    vector&lt;double&gt; averageOfLevels(TreeNode* root) &#123;        vector&lt;double&gt; ret;  //定义一个容器        queue&lt;TreeNode* &gt; que;  //定义一个队列        if (root != NULL) que.push(root);        while (!que.empty()) &#123;            int count = que.size();            double sum = 0;                        for (int i = 0;i &lt; count;++i) &#123;                TreeNode *node = que.front();  //node指向队列的首节点                que.pop();                sum += node-&gt;val;                            if (node-&gt;left != NULL) que.push(node-&gt;left);                if (node-&gt;right != NULL) que.push(node-&gt;right);            &#125;                        ret.push_back(sum / count);        &#125;                return ret;    &#125;&#125;;\n\n","categories":["计算机理论"],"tags":["LeetCode算法-树"]},{"title":"LeetCode_94_二叉树的中序遍历","url":"/2019/06/30/%E8%AE%A1%E7%AE%97%E6%9C%BA%E7%90%86%E8%AE%BA/LeetCode%E7%AE%97%E6%B3%95/%E6%A0%91/2.2_LeetCode_94_%E4%BA%8C%E5%8F%89%E6%A0%91%E7%9A%84%E4%B8%AD%E5%BA%8F%E9%81%8D%E5%8E%86/","content":"题目描述：给定一个二叉树的根节点 root ，返回它的 中序 遍历。示例：输入：root = [1,null,2,3]输出：[1,3,2]输入：root = []输出：[]输入：root = [1]输出：[1]输入：root = [1,2]输出：[2,1]输入：root = [1,null,2]输出：[1,2]提示：1. 树中节点数目在范围 [0, 100] 内2. -100 &lt;= Node.val &lt;= 100\n\n解法1：递归/** * Definition for a binary tree node. * struct TreeNode &#123; *     int val; *     TreeNode *left; *     TreeNode *right; *     TreeNode() : val(0), left(nullptr), right(nullptr) &#123;&#125; *     TreeNode(int x) : val(x), left(nullptr), right(nullptr) &#123;&#125; *     TreeNode(int x, TreeNode *left, TreeNode *right) : val(x), left(left), right(right) &#123;&#125; * &#125;; */class Solution &#123;public:    vector&lt;int&gt; res;  //容器要定义在外面    vector&lt;int&gt; inorderTraversal(TreeNode *root) &#123;        if (root == nullptr) return &#123;&#125;;        inorderTraversal(root-&gt;left);        res.push_back(root-&gt;val);        inorderTraversal(root-&gt;right);        return res;    &#125;&#125;;\n\n解法2：栈/** * Definition for a binary tree node. * struct TreeNode &#123; *     int val; *     TreeNode *left; *     TreeNode *right; *     TreeNode() : val(0), left(nullptr), right(nullptr) &#123;&#125; *     TreeNode(int x) : val(x), left(nullptr), right(nullptr) &#123;&#125; *     TreeNode(int x, TreeNode *left, TreeNode *right) : val(x), left(left), right(right) &#123;&#125; * &#125;; */class Solution &#123;public:    vector&lt;int&gt; inorderTraversal(TreeNode* root) &#123;        vector&lt;int&gt; ret;  //定义一个容器        stack&lt;TreeNode* &gt; s;  //定义一个栈        TreeNode* cur = root;        while (cur != NULL || !s.empty()) &#123;            if (cur != NULL) &#123;                 s.push(cur);                 cur = cur-&gt;left;                       &#125; else &#123;                cur = s.top();                 s.pop();                ret.push_back(cur-&gt;val);                  cur = cur-&gt;right;                    &#125;        &#125;        return ret;    &#125;&#125;;\n\n","categories":["计算机理论"],"tags":["LeetCode算法-树"]},{"title":"LeetCode_144_二叉树的前序遍历","url":"/2019/06/30/%E8%AE%A1%E7%AE%97%E6%9C%BA%E7%90%86%E8%AE%BA/LeetCode%E7%AE%97%E6%B3%95/%E6%A0%91/2.1_LeetCode_144_%E4%BA%8C%E5%8F%89%E6%A0%91%E7%9A%84%E5%89%8D%E5%BA%8F%E9%81%8D%E5%8E%86/","content":"题目描述：//前序遍历、中序遍历和后序遍历是三种利用深度优先搜索遍历二叉树的方式，它们是在对节点访问的顺序有一点不同，其他完全相同给你二叉树的根节点 root ，返回它节点值的 前序 遍历。示例：输入：root = [1,null,2,3]输出：[1,2,3]输入：root = []输出：[]输入：root = [1]输出：[1]输入：root = [1,2]输出：[1,2]输入：root = [1,null,2]输出：[1,2]提示：1. 树中节点数目在范围 [0, 100] 内2. -100 &lt;= Node.val &lt;= 100\n\n解法1：递归/** * Definition for a binary tree node. * struct TreeNode &#123; *     int val; *     TreeNode *left; *     TreeNode *right; *     TreeNode() : val(0), left(nullptr), right(nullptr) &#123;&#125; *     TreeNode(int x) : val(x), left(nullptr), right(nullptr) &#123;&#125; *     TreeNode(int x, TreeNode *left, TreeNode *right) : val(x), left(left), right(right) &#123;&#125; * &#125;; */class Solution &#123;public:    vector&lt;int&gt; res;  //容器要定义在外面    vector&lt;int&gt; preorderTraversal(TreeNode *root) &#123;        if (root == nullptr) return &#123;&#125;;        res.push_back(root-&gt;val);        preorderTraversal(root-&gt;left);        preorderTraversal(root-&gt;right);        return res;    &#125;&#125;;\n\n解法2：栈/** * Definition for a binary tree node. * struct TreeNode &#123; *     int val; *     TreeNode *left; *     TreeNode *right; *     TreeNode() : val(0), left(nullptr), right(nullptr) &#123;&#125; *     TreeNode(int x) : val(x), left(nullptr), right(nullptr) &#123;&#125; *     TreeNode(int x, TreeNode *left, TreeNode *right) : val(x), left(left), right(right) &#123;&#125; * &#125;; */class Solution &#123;public:    //因为递归的本质是栈调用，因此我们可以通过栈来实现前序遍历    vector&lt;int&gt; preorderTraversal(TreeNode* root) &#123;        vector&lt;int&gt; ret;  //定义一个容器        stack&lt;TreeNode* &gt; s;  //定义一个栈         if (root != nullptr) s.push(root);        while (!s.empty()) &#123;            TreeNode* node = s.top();            s.pop();            ret.push_back(node-&gt;val);            //先右后左，保证左子树先遍历            if (node-&gt;right != nullptr) s.push(node-&gt;right);            if (node-&gt;left != nullptr) s.push(node-&gt;left);        &#125;        return ret;    &#125;&#125;;\n\n","categories":["计算机理论"],"tags":["LeetCode算法-树"]},{"title":"LeetCode_112_路径总和","url":"/2019/06/30/%E8%AE%A1%E7%AE%97%E6%9C%BA%E7%90%86%E8%AE%BA/LeetCode%E7%AE%97%E6%B3%95/%E6%A0%91/2.7_LeetCode_112_%E8%B7%AF%E5%BE%84%E6%80%BB%E5%92%8C/","content":"题目描述：给你二叉树的根节点 root 和一个表示目标和的整数 targetSum ，判断该树中是否存在 根节点到叶子节点 的路径，这条路径上所有节点值相加等于目标和 targetSum 。叶子节点 是指没有子节点的节点。示例：输入：root = [5,4,8,11,null,13,4,7,2,null,null,null,1], targetSum = 22输出：true输入：root = [1,2,3], targetSum = 5输出：false输入：root = [1,2], targetSum = 0输出：false提示：1. 树中节点的数目在范围 [0, 5000] 内2. -1000 &lt;= Node.val &lt;= 10003. -1000 &lt;= targetSum &lt;= 1000\n\n解法1：递归/** * Definition for a binary tree node. * struct TreeNode &#123; *     int val; *     TreeNode *left; *     TreeNode *right; *     TreeNode() : val(0), left(nullptr), right(nullptr) &#123;&#125; *     TreeNode(int x) : val(x), left(nullptr), right(nullptr) &#123;&#125; *     TreeNode(int x, TreeNode *left, TreeNode *right) : val(x), left(left), right(right) &#123;&#125; * &#125;; */class Solution &#123;public:    bool hasPathSum(TreeNode *root, int sum) &#123;        if (root == nullptr) return false;                if (root-&gt;left == nullptr &amp;&amp; root-&gt;right == nullptr) &#123;            if (sum == root-&gt;val) return true;            else return false;        &#125;                return hasPathSum(root-&gt;left, sum - root-&gt;val) ||               hasPathSum(root-&gt;right, sum - root-&gt;val);    &#125;&#125;;\n\n","categories":["计算机理论"],"tags":["LeetCode算法-树"]},{"title":"LeetCode_208_实现Trie(前缀树)","url":"/2019/06/30/%E8%AE%A1%E7%AE%97%E6%9C%BA%E7%90%86%E8%AE%BA/LeetCode%E7%AE%97%E6%B3%95/%E6%A0%91/2.12_LeetCode_208_%E5%AE%9E%E7%8E%B0Trie(%E5%89%8D%E7%BC%80%E6%A0%91)/","content":"字典树：字典树(Trie)用于判断字符串是否存在或者是否具有某种字符串前缀。为什么需要用字典树解决这类问题呢？假设我们有一个储存了近万个单词的字典，即使我们使用哈希，在其中搜索一个单词的实际开销也是非常大的，且无法轻易支持搜索单词前缀。然而由于一个英文单词的长度n通常在10以内，如果我们使用字典树，则可以在O(n)--近似O(1)的时间内完成搜索，且额外开销非常小。字典树的性质：1. Trie的形状和单词的插入或删除顺序无关，也就是说对于任意给定的一组单词，Trie的形状都是唯一的。2. 查找或插入一个长度为 L 的单词，访问 next 数组的次数最多为 L+1，和 Trie 中包含多少个单词无关。3. Trie 的每个结点中都保留着一个字母表，这是很耗费空间的。如果 Trie 的高度为 n，字母表的大小为 m，最坏的情况是 Trie 中还不存在前缀相同的单词，那空间复杂度就为 O(m^n)\n\n\n题目描述：Trie（发音类似 &quot;try&quot;）或者说 前缀树 是一种树形数据结构，用于高效地存储和检索字符串数据集中的键。这一数据结构有相当多的应用情景，例如自动补完和拼写检查。请你实现 Trie 类：1. Trie() 初始化前缀树对象。2. void insert(String word) 向前缀树中插入字符串 word 。3. boolean search(String word) 如果字符串 word 在前缀树中，返回 true（即，在检索之前已经插入）；否则，返回 false 。4. boolean startsWith(String prefix) 如果之前已经插入的字符串 word 的前缀之一为 prefix ，返回 true ；否则，返回 false 。示例：输入[&quot;Trie&quot;, &quot;insert&quot;, &quot;search&quot;, &quot;search&quot;, &quot;startsWith&quot;, &quot;insert&quot;, &quot;search&quot;][[], [&quot;apple&quot;], [&quot;apple&quot;], [&quot;app&quot;], [&quot;app&quot;], [&quot;app&quot;], [&quot;app&quot;]]输出[null, null, true, false, true, null, true]解释Trie trie = new Trie();trie.insert(&quot;apple&quot;);trie.search(&quot;apple&quot;);   // 返回 Truetrie.search(&quot;app&quot;);     // 返回 Falsetrie.startsWith(&quot;app&quot;); // 返回 Truetrie.insert(&quot;app&quot;);trie.search(&quot;app&quot;);     // 返回 True提示：1. 1 &lt;= word.length, prefix.length &lt;= 20002. word 和 prefix 仅由小写英文字母组成3. insert、search 和 startsWith 调用次数 总计 不超过 3 * 10^4 次\n\n解法1：字典树的基本操作/** * Your Trie object will be instantiated and called as such: * Trie* obj = new Trie(); * obj-&gt;insert(word); * bool param_2 = obj-&gt;search(word); * bool param_3 = obj-&gt;startsWith(prefix); *///Trie是一颗非典型的多叉树模型，它和一般的多叉树不一样，尤其在结点的数据结构设计上，比如一般的多叉树的结点包括结点值、指向孩子结点的指针，而Trie的结点包括该结点是否是一个串的结束、字母映射表class Trie &#123;private:    bool isEnd;  //该结点是否是一个串的结束    Trie* next[26];  //字母映射表，保存了对当前结点而言下一个可能出现的所有字符的链接，因此我们可以通过一个父结点来预知它所有子结点的值public:    Trie() &#123;        isEnd = false;        //memset是计算机中C/C++语言初始化函数。        //作用是将某一块内存中的内容全部设置为指定的值，这个函数通常为新申请的内存做初始化工作。        //将next数组中的值全部设置为0        memset(next, 0, sizeof(next));    &#125;        //向字典树中插入一个单词    void insert(string word) &#123;        Trie* node = this;        for (char c : word) &#123;            if (node-&gt;next[c-&#x27;a&#x27;] == NULL) &#123;                node-&gt;next[c-&#x27;a&#x27;] = new Trie();            &#125;            node = node-&gt;next[c-&#x27;a&#x27;];        &#125;        node-&gt;isEnd = true;  //要将最后一个结点isEnd = true; 表示它是一个单词的末尾    &#125;        //判断字典树中是否存在一个单词    bool search(string word) &#123;        Trie* node = this;        for (char c : word) &#123;            node = node-&gt;next[c-&#x27;a&#x27;];            if (node == NULL) return false;        &#125;        return node-&gt;isEnd;    &#125;        //判断字典树中是否有一个以prefix开始的前缀    bool startsWith(string prefix) &#123;        Trie* node = this;        for (char c : prefix) &#123;            node = node-&gt;next[c-&#x27;a&#x27;];            if (node == NULL) return false;        &#125;        return true;    &#125;&#125;;\n\n","categories":["计算机理论"],"tags":["LeetCode算法-树"]},{"title":"LeetCode_662_二叉树最大宽度","url":"/2019/06/30/%E8%AE%A1%E7%AE%97%E6%9C%BA%E7%90%86%E8%AE%BA/LeetCode%E7%AE%97%E6%B3%95/%E6%A0%91/2.5_LeetCode_662_%E4%BA%8C%E5%8F%89%E6%A0%91%E6%9C%80%E5%A4%A7%E5%AE%BD%E5%BA%A6/","content":"题目描述：给定一个二叉树，编写一个函数来获取这个树的最大宽度。树的宽度是所有层中的最大宽度。这个二叉树与满二叉树（full binary tree）结构相同，但一些节点为空。每一层的宽度被定义为两个端点（该层最左和最右的非空节点，两端点间的null节点也计入长度）之间的长度。示例：输入:            1         /   \\        3     2       / \\     \\        5   3     9 输出: 4解释: 最大值出现在树的第 3 层，宽度为 4 (5,3,null,9)。输入:           1         /          3           / \\             5   3     输出: 2解释: 最大值出现在树的第 3 层，宽度为 2 (5,3)。输入:           1         / \\        3   2        /              5      输出: 2解释: 最大值出现在树的第 2 层，宽度为 2 (3,2)。输入:           1         / \\        3   2       /     \\        5       9      /         \\    6           7输出: 8解释: 最大值出现在树的第 4 层，宽度为 8 (6,null,null,null,null,null,null,7)。注意：答案在32位有符号整数的表示范围内。\n\n解法1：广度优先遍历/** * Definition for a binary tree node. * struct TreeNode &#123; *     int val; *     TreeNode *left; *     TreeNode *right; *     TreeNode() : val(0), left(nullptr), right(nullptr) &#123;&#125; *     TreeNode(int x) : val(x), left(nullptr), right(nullptr) &#123;&#125; *     TreeNode(int x, TreeNode *left, TreeNode *right) : val(x), left(left), right(right) &#123;&#125; * &#125;; */class Solution &#123;public:    int widthOfBinaryTree(TreeNode* root) &#123;        if (root == nullptr) return 0;            int res = 0;  //返回的最大宽度值        queue&lt;TreeNode* &gt; q;  //定义一个队列        root-&gt;val = 0;  //假设根节点的编号为0        q.push(root);        while (!q.empty()) &#123;            //返回的最大宽度值            res = max(res, q.back()-&gt;val - q.front()-&gt;val + 1);            //❗️推演一下下面的两个例子            //[1,3,2,5,3,null,9] 输出结果为4            //[1,null,2,null,3] 输出结果为1            int offset = q.front()-&gt;val;  //编号缩小的差值            int n = q.size();            for (int i = 0; i &lt; n; ++i) &#123;                TreeNode* curr = q.front();                q.pop();                            curr-&gt;val -= offset;  //缩小数值                if (curr-&gt;left != nullptr) &#123;                    //转换为对应的编号                    curr-&gt;left-&gt;val = curr-&gt;val * 2;                    q.push(curr-&gt;left);                &#125;                if (curr-&gt;right != nullptr) &#123;                    //转换为对应的编号                    curr-&gt;right-&gt;val = curr-&gt;val * 2 + 1;                    q.push(curr-&gt;right);                &#125;            &#125;        &#125;        return res;    &#125;&#125;;\n\n","categories":["计算机理论"],"tags":["LeetCode算法-树"]},{"title":"LeetCode_99_恢复二叉搜索树","url":"/2019/06/30/%E8%AE%A1%E7%AE%97%E6%9C%BA%E7%90%86%E8%AE%BA/LeetCode%E7%AE%97%E6%B3%95/%E6%A0%91/2.9_LeetCode_99_%E6%81%A2%E5%A4%8D%E4%BA%8C%E5%8F%89%E6%90%9C%E7%B4%A2%E6%A0%91/","content":"题目描述：给你二叉搜索树的根节点 root ，该树中的两个节点被错误地交换。请在不改变其结构的情况下，恢复这棵树。示例：输入：root = [1,3,null,null,2]输出：[3,1,null,null,2]解释：3 不能是 1 左孩子，因为 3 &gt; 1 。交换 1 和 3 使二叉搜索树有效。输入：root = [3,1,4,null,null,2]输出：[2,1,4,null,null,3]解释：2 不能在 3 的右子树中，因为 2 &lt; 3 。交换 2 和 3 使二叉搜索树有效。提示：1. 树上节点的数目在范围 [2, 1000] 内2. -2^31 &lt;= Node.val &lt;= 2^31 - 1\n\n解法1：中序遍历/** * Definition for a binary tree node. * struct TreeNode &#123; *     int val; *     TreeNode *left; *     TreeNode *right; *     TreeNode() : val(0), left(nullptr), right(nullptr) &#123;&#125; *     TreeNode(int x) : val(x), left(nullptr), right(nullptr) &#123;&#125; *     TreeNode(int x, TreeNode *left, TreeNode *right) : val(x), left(left), right(right) &#123;&#125; * &#125;; *///二叉查找树(Binary Search Tree,BST)是一种特殊的二叉树：对于每个父节点，其左子节点的值小于等于父节点的值，其右子节点的值大于等于父节点的值//因此对于一个二叉查找树，我们可以在O(nlogn)的时间内查找一个值是否存在：从根节点开始，若当前节点的值大于查找值则向左下走，若当前节点的值小于查找值则向右下走//因为二叉查找树是有序的，对其中序遍历的结果即为排好序的数组class Solution &#123;public:    TreeNode* t1 = nullptr, *t2 = nullptr, *pre = nullptr;    void recoverTree(TreeNode* root) &#123;        inorder(root);        //交换t1、t2节点的值        int temp = t1-&gt;val;        t1-&gt;val = t2-&gt;val;        t2-&gt;val = temp;    &#125;    void inorder(TreeNode* root) &#123;        if (root == nullptr) return;        //先中序遍历这个二叉查找树，同时设置一个pre指针，记录当前节点中序遍历时的前节点        //如果当前节点小于pre节点的值，说明需要调整次序        inorder(root-&gt;left);        if (pre != nullptr &amp;&amp; pre-&gt;val &gt; root-&gt;val) &#123;            if (t1 == nullptr) &#123;                t1 = pre;            &#125;                        t2 = root;        &#125;        pre = root;        inorder(root-&gt;right);    &#125;&#125;;\n\n","categories":["计算机理论"],"tags":["LeetCode算法-树"]},{"title":"LeetCode_437_路径总和3","url":"/2019/06/30/%E8%AE%A1%E7%AE%97%E6%9C%BA%E7%90%86%E8%AE%BA/LeetCode%E7%AE%97%E6%B3%95/%E6%A0%91/2.8_LeetCode_437_%E8%B7%AF%E5%BE%84%E6%80%BB%E5%92%8C3/","content":"题目描述：给定一个二叉树，它的每个结点都存放着一个整数值。找出路径和等于给定数值的路径总数。路径不需要从根节点开始，也不需要在叶子节点结束，但是路径方向必须是向下的（只能从父节点到子节点）。二叉树不超过1000个节点，且节点数值范围是 [-1000000,1000000] 的整数。示例：root = [10,5,-3,3,2,null,11,3,-2,null,1], sum = 8      10     /  \\    5   -3   / \\    \\  3   2   11 / \\   \\3  -2   1返回 3。和等于 8 的路径有:1.  5 -&gt; 32.  5 -&gt; 2 -&gt; 13.  -3 -&gt; 11\n\n解法1：递归/** * Definition for a binary tree node. * struct TreeNode &#123; *     int val; *     TreeNode *left; *     TreeNode *right; *     TreeNode() : val(0), left(nullptr), right(nullptr) &#123;&#125; *     TreeNode(int x) : val(x), left(nullptr), right(nullptr) &#123;&#125; *     TreeNode(int x, TreeNode *left, TreeNode *right) : val(x), left(left), right(right) &#123;&#125; * &#125;; */class Solution &#123;public:    int count = 0;  //定义一个全局变量    int pathSum(TreeNode* root, int targetSum) &#123;        if (root == nullptr) return 0;        dfs(root, targetSum);  //以root为起始点查找路径        pathSum(root-&gt;left,targetSum);  //左子树递归        pathSum(root-&gt;right,targetSum);  //右子树递归        return count;    &#125;    //递归求解    void dfs(TreeNode* curr, int target) &#123;        if (curr != nullptr) &#123;            target -= curr-&gt;val;            if (target == 0) count++;            dfs(curr-&gt;left,target);            dfs(curr-&gt;right,target);                    &#125;        &#125;    &#125;;\n\n","categories":["计算机理论"],"tags":["LeetCode算法-树"]},{"title":"操作系统的状态","url":"/2020/06/15/%E8%AE%A1%E7%AE%97%E6%9C%BA%E7%90%86%E8%AE%BA/%E6%93%8D%E4%BD%9C%E7%B3%BB%E7%BB%9F%E5%8E%9F%E7%90%86/%E6%93%8D%E4%BD%9C%E7%B3%BB%E7%BB%9F%E5%8E%9F%E7%90%86%E9%9D%A2%E8%AF%95%E9%A2%98/1.3_%E6%93%8D%E4%BD%9C%E7%B3%BB%E7%BB%9F%E7%9A%84%E7%8A%B6%E6%80%81/","content":"两种程序：应用程序、内核程序\n两种指令：\n\n特权指令：操作系统内核作为“管理者”，有时会让CPU执行一些“特权指令”，如“内存清零指令”。这些指令影响重大，只允许“管理者”，即操作系统内核来使用\n非特权指令：应用程序只能使用“非特权指令”，如加法指令、减法指令等\n\nCPU能判断出指令类型，但是它怎么区分此时正在运行的是内核程序还是应用程序？\n两种处理器状态：\n\n内核态（核心态、管态）：处于内核态时，说明此时正在运行的是内核程序，此时可以执行特权指令\n用户态（目态）：处于用户态时，说明此时正在运行的是应用程序，此时只能执行非特权指令，CPU中有一个寄存器叫程序状态字寄存器（PSW），其中有个二进制位，1表示“内核态”，0表示“用户态”\n\n内核态 -&gt; 用户态：执行一条特权指令，修改PSW的标志位为“用户态”，这个动作意味着操作系统将主动让出CPU使用权\n用户态 -&gt; 内核态：由“中断”引发，硬件自动完成变态过程，触发中断信号意味着操作系统将强行夺回CPU的使用权（除了非法使用特权指令之外，还有很多事件会触发中断信号，一个共性是，但凡需要操作系统介入的地方，都会触发中断信号）\n","categories":["计算机理论"],"tags":["操作系统原理-操作系统原理面试题"]},{"title":"LeetCode_543_二叉树的直径","url":"/2019/06/30/%E8%AE%A1%E7%AE%97%E6%9C%BA%E7%90%86%E8%AE%BA/LeetCode%E7%AE%97%E6%B3%95/%E6%A0%91/2.6_LeetCode_543_%E4%BA%8C%E5%8F%89%E6%A0%91%E7%9A%84%E7%9B%B4%E5%BE%84/","content":"题目描述：给定一棵二叉树，你需要计算它的直径长度。一棵二叉树的直径长度是任意两个结点路径长度中的最大值。这条路径可能穿过也可能不穿过根结点。示例：给定二叉树：          1         / \\        2   3       / \\           4   5    返回 3, 它的长度是路径 [4,2,1,3] 或者 [5,2,1,3]。注意：注意：两结点之间的路径长度是以它们之间边的数目表示。\n\n解法1：递归/** * Definition for a binary tree node. * struct TreeNode &#123; *     int val; *     TreeNode *left; *     TreeNode *right; *     TreeNode() : val(0), left(nullptr), right(nullptr) &#123;&#125; *     TreeNode(int x) : val(x), left(nullptr), right(nullptr) &#123;&#125; *     TreeNode(int x, TreeNode *left, TreeNode *right) : val(x), left(left), right(right) &#123;&#125; * &#125;; */class Solution &#123;public:    int ans = 0;  //ans存储的是每次递归时当前最大的直径长度    int depth(TreeNode* rt) &#123;        if (rt == NULL) return 0;        int L = depth(rt-&gt;left);         int R = depth(rt-&gt;right);         //两个叶子节点之间路径 = 根节点左右儿子的深度之和        //每次递归时都计算一次，如果当前找到最大的就替换        ans = max(ans, L + R);        return max(L, R) + 1; // 返回该节点为根的子树的深度    &#125;    int diameterOfBinaryTree(TreeNode* root) &#123;        depth(root);        return ans;    &#125;&#125;;\n\n","categories":["计算机理论"],"tags":["LeetCode算法-树"]},{"title":"什么是操作系统，它有哪些功能","url":"/2020/06/15/%E8%AE%A1%E7%AE%97%E6%9C%BA%E7%90%86%E8%AE%BA/%E6%93%8D%E4%BD%9C%E7%B3%BB%E7%BB%9F%E5%8E%9F%E7%90%86/%E6%93%8D%E4%BD%9C%E7%B3%BB%E7%BB%9F%E5%8E%9F%E7%90%86%E9%9D%A2%E8%AF%95%E9%A2%98/1.1_%E4%BB%80%E4%B9%88%E6%98%AF%E6%93%8D%E4%BD%9C%E7%B3%BB%E7%BB%9F%EF%BC%8C%E5%AE%83%E6%9C%89%E5%93%AA%E4%BA%9B%E5%8A%9F%E8%83%BD/","content":"操作系统是指控制和管理整个计算机系统的硬件和软件资源，并合理的组织调度计算机的工作和资源的分配；以提供给用户和其他软件方便的接口和环境；它是计算机系统中最基本的系统软件\n\n操作系统是系统资源的管理者，包含处理机管理、存储器管理、文件管理和设备管理\n向上层提供方便易用的服务\n是最接近硬件的一层软件\n\n","categories":["计算机理论"],"tags":["操作系统原理-操作系统原理面试题"]},{"title":"操作系统的四个特征","url":"/2020/06/15/%E8%AE%A1%E7%AE%97%E6%9C%BA%E7%90%86%E8%AE%BA/%E6%93%8D%E4%BD%9C%E7%B3%BB%E7%BB%9F%E5%8E%9F%E7%90%86/%E6%93%8D%E4%BD%9C%E7%B3%BB%E7%BB%9F%E5%8E%9F%E7%90%86%E9%9D%A2%E8%AF%95%E9%A2%98/1.2_%E6%93%8D%E4%BD%9C%E7%B3%BB%E7%BB%9F%E7%9A%84%E5%9B%9B%E4%B8%AA%E7%89%B9%E5%BE%81/","content":"并发：并发是指两个或多个事件在同一时间间隔内发生，这些事件宏观上是同时发生的，但微观上是交替发生的\n并行是指两个或多个事件在同一时刻同时发生\n共享：共享即资源共享，是指系统中的资源可供内存中多个并发执行的进程共同使用\n\n互斥共享方式：系统中的某些资源，虽然可以提供给多个进程使用，但一个时间段内只允许一个进程访问该资源【摄像头】\n同时共享方式：系统中的某些资源，允许一个时间段内由多个进程“同时”对它们进行访问，所谓的“同时”往往是宏观上的，而在微观上，这些进程可能是交替的对该资源进行访问（即分时共享）【硬盘资源】\n\n虚拟：虚拟是指把一个物理上的实体变成若干个逻辑上的对应物，物理实体是实际存在的，而逻辑上对应物是用户感受到的\n\n显然，如果失去了并发性，则一个时间段内系统中只需运行一道程序，那么就失去了实现虚拟性的意义了，因此，没有并发性，就谈不上虚拟性\n\n异步：异步是指，在多道程序环境下，允许多个程序并发执行，但由于资源有限，进程的执行不是一贯到底的，而是走走停停，以不可预知的速度向前推进，这就是进程的异步性\n如果失去了并发性，即系统只能串行的运行各个程序，，那么每个程序的执行会一贯到底，只有系统拥有并发性，才有可能导致异步性\n","categories":["计算机理论"],"tags":["操作系统原理-操作系统原理面试题"]},{"title":"中断和异常","url":"/2020/06/15/%E8%AE%A1%E7%AE%97%E6%9C%BA%E7%90%86%E8%AE%BA/%E6%93%8D%E4%BD%9C%E7%B3%BB%E7%BB%9F%E5%8E%9F%E7%90%86/%E6%93%8D%E4%BD%9C%E7%B3%BB%E7%BB%9F%E5%8E%9F%E7%90%86%E9%9D%A2%E8%AF%95%E9%A2%98/1.5_%E4%B8%AD%E6%96%AD%E5%92%8C%E5%BC%82%E5%B8%B8/","content":"中断的作用：“中断”是让操作系统内核夺回CPU使用权的唯一途径，中断会让CPU由用户态变为内核态，如果没有“中断”机制，那么一旦应用程序上CPU运行，CPU就会一直运行这个应用程序，既如此，何来并发。\n中断的类型：\n\n内中断（也称异常），与当前执行的指令有关，中断信号来源于CPU内部，CPU在执行指令时会检查是否有异常发生\n陷阱、陷入（trap）：由陷入指令引发，是应用程序故意引发的，执行陷入指令，意味着应用程序主动的将CPU控制权还给操作系统内核，“系统调用”就是通过陷入指令完成的（注意陷入指令并不是特权指令）\n故障（fault）：由错误条件引起的，可能被内核程序修复。\n终止（abort）：由致命错误引起，内核程序无法修复该错误，因此一般不再将CPU使用权还给引发终止的应用程序（整数除0，非法使用特权指令）\n\n\n外中断（也称中断）：与当前执行的指令无关，中断信号来源于CPU外部，每一条指令执行结束时，CPU都会例行检查是否有外中断信号需要处理\n时钟中断：由时钟部件发来的中断信号，时钟部件每隔一个时间片会给CPU发送一个时钟中断信号（多个应用程序的并发运行）\nI&#x2F;O中断：由输入&#x2F;输出设备发来的中断信号（打印机）\n\n\n\n中断处理的过程：\n\n保护现场：将当前执行程序的相关数据保存在寄存器中，然后入栈。\n开中断：以便执行中断时能响应较高级别的中断请求。\n中断处理\n关中断：保证恢复现场时不被新中断打扰\n恢复现场：从堆栈中按序取出程序数据，恢复中断前的执行状态。\n\n","categories":["计算机理论"],"tags":["操作系统原理-操作系统原理面试题"]},{"title":"同步和异步","url":"/2020/06/15/%E8%AE%A1%E7%AE%97%E6%9C%BA%E7%90%86%E8%AE%BA/%E6%93%8D%E4%BD%9C%E7%B3%BB%E7%BB%9F%E5%8E%9F%E7%90%86/%E6%93%8D%E4%BD%9C%E7%B3%BB%E7%BB%9F%E5%8E%9F%E7%90%86%E9%9D%A2%E8%AF%95%E9%A2%98/1.4_%E5%90%8C%E6%AD%A5%E5%92%8C%E5%BC%82%E6%AD%A5/","content":"\n同步方法调用一旦开始，调用者必须等到方法调用返回后，才能继续后续的行为。\n异步方法调用更像一个消息传递，一旦开始，方法调用就会立即返回，调用者就可以继续后续的操作。而异步方法通常会在另外一个线程中，“真实”地执行着。整个过程，不会阻碍调用者的工作，异步方法执行完后会通知调用者，调用者来处理一下就好了\n\n同步异步和阻塞非阻塞不能混为一谈：\n阻塞和非阻塞 强调的是程序在等待调用结果（消息，返回值）时的状态. 阻塞调用是指调用结果返回之前，当前线程会被挂起。调用线程只有在得到结果之后才会返回。非阻塞调用指在不能立刻得到结果之前，该调用不会阻塞当前线程。 对于同步调用来说，很多时候当前线程还是激活的状态，只是从逻辑上当前函数没有返回而已，即同步等待时什么都不干，白白占用着资源。\n同步和异步强调的是消息通信机制。所谓同步，就是在发出一个”调用”时，在没有得到结果之前，该“调用”就不返回。但是一旦调用返回，就得到返回值了。换句话说，就是由“调用者”主动等待这个“调用”的结果。而异步则是相反，”调用”在发出之后，这个调用就直接返回了，所以没有返回结果。换句话说，当一个异步过程调用发出后，调用者不会立刻得到结果。而是在”调用”发出后，”被调用者”通过状态、通知来通知调用者，或通过回调函数处理这个调用\n","categories":["计算机理论"],"tags":["操作系统原理-操作系统原理面试题"]},{"title":"线程的种类","url":"/2020/06/15/%E8%AE%A1%E7%AE%97%E6%9C%BA%E7%90%86%E8%AE%BA/%E6%93%8D%E4%BD%9C%E7%B3%BB%E7%BB%9F%E5%8E%9F%E7%90%86/%E6%93%8D%E4%BD%9C%E7%B3%BB%E7%BB%9F%E5%8E%9F%E7%90%86%E9%9D%A2%E8%AF%95%E9%A2%98/2.11_%E7%BA%BF%E7%A8%8B%E7%9A%84%E7%A7%8D%E7%B1%BB/","content":"从线程的运行空间来说，分为用户级线程ULT和内核级线程KLT\n\n内核级线程：这类线程依赖于内核，又称为内核支持的线程或轻量级进程。无论是在用户程序中的线程还是系统进程中的线程，它们的创建、撤销和切换都由内核实现。\n\n用户级线程：它仅存在于用户级中，这种线程是不依赖于操作系统核心的。应用进程利用线程库来完成其创建和管理，速度比较快，操作系统内核无法感知用户级线程的存在。\n\n\n","categories":["计算机理论"],"tags":["操作系统原理-操作系统原理面试题"]},{"title":"中断和轮询","url":"/2020/06/15/%E8%AE%A1%E7%AE%97%E6%9C%BA%E7%90%86%E8%AE%BA/%E6%93%8D%E4%BD%9C%E7%B3%BB%E7%BB%9F%E5%8E%9F%E7%90%86/%E6%93%8D%E4%BD%9C%E7%B3%BB%E7%BB%9F%E5%8E%9F%E7%90%86%E9%9D%A2%E8%AF%95%E9%A2%98/1.6_%E4%B8%AD%E6%96%AD%E5%92%8C%E8%BD%AE%E8%AF%A2/","content":"轮询：CPU对特定设备轮流询问，效率低等待时间长，CPU利用率不高。\n中断：通过特定事件提醒CPU，容易遗漏问题，CPU利用率不高。\n","categories":["计算机理论"],"tags":["操作系统原理-操作系统原理面试题"]},{"title":"进程、线程实现同步的方式","url":"/2020/06/15/%E8%AE%A1%E7%AE%97%E6%9C%BA%E7%90%86%E8%AE%BA/%E6%93%8D%E4%BD%9C%E7%B3%BB%E7%BB%9F%E5%8E%9F%E7%90%86/%E6%93%8D%E4%BD%9C%E7%B3%BB%E7%BB%9F%E5%8E%9F%E7%90%86%E9%9D%A2%E8%AF%95%E9%A2%98/2.13_%E8%BF%9B%E7%A8%8B%E3%80%81%E7%BA%BF%E7%A8%8B%E5%AE%9E%E7%8E%B0%E5%90%8C%E6%AD%A5%E7%9A%84%E6%96%B9%E5%BC%8F/","content":"\n临界区：临界区只限制在同一进程的各个线程之间使用，先V后P\n\n互斥量：互斥量跟临界区很相似，只是它允许在进程间使用\n\n信号量：为控制一个具有有限数量用户资源而设计。它允许多个线程在同一时刻访问同一资源，但是需要限制在同一时刻访问此资源的最大线程数目。互斥量是信号量的一种特殊情况，当信号量的最大资源数&#x3D;1就是互斥量了。\n\n事件机制：允许一个线程在处理完一个任务后，主动唤醒另外一个线程执行任务。\n\n\n互斥量与临界区的作用非常相似，但互斥量是可以命名的，也就是说互斥量可以跨越进程使用，但创建互斥量需要的资源更多，所以如果只为了在进程内部是用的话使用临界区会带来速度上的优势并能够减少资源占用量 。因为互斥量是跨进程的互斥量一旦被创建，就可以通过名字打开它。\n互斥量，信号量，事件机制都可以被跨越进程使用来进行同步数据操作。\n线程间的通信目的主要是用于线程同步，所以线程没有像进程通信中的用于数据交换的通信机制\n","categories":["计算机理论"],"tags":["操作系统原理-操作系统原理面试题"]},{"title":"程序、进程、线程、协程","url":"/2020/06/15/%E8%AE%A1%E7%AE%97%E6%9C%BA%E7%90%86%E8%AE%BA/%E6%93%8D%E4%BD%9C%E7%B3%BB%E7%BB%9F%E5%8E%9F%E7%90%86/%E6%93%8D%E4%BD%9C%E7%B3%BB%E7%BB%9F%E5%8E%9F%E7%90%86%E9%9D%A2%E8%AF%95%E9%A2%98/2.1_%E7%A8%8B%E5%BA%8F%E3%80%81%E8%BF%9B%E7%A8%8B%E3%80%81%E7%BA%BF%E7%A8%8B%E3%80%81%E5%8D%8F%E7%A8%8B/","content":"进程和程序的区别：\n\n程序：是静态的，就是个存放在磁盘里的可执行文件，就是一系列的指令集合\n\n进程（Process）：是动态的，是程序的一次执行过程，同一个程序多次执行会对应多个进程\n\n\n进程和线程的区别：\n\n调度：进程是资源管理的基本单位，线程是程序执行的基本单位。\n切换：线程上下文切换比进程上下文切换要快得多。\n拥有资源： 进程是拥有资源的一个独立单位，线程不拥有系统资源，但是可以访问隶属于进程的资源。\n系统开销： 创建或撤销进程时，系统都要为之分配或回收系统资源，如内存空间，I&#x2F;O设备等，OS所付出的开销显著大于在创建或撤销线程时的开销，进程切换的开销也远大于线程切换的开销。\n\n线程和协程的区别：\n\n线程和进程都是同步机制，而协程是异步机制。\n\n线程是抢占式，而协程是非抢占式的。需要用户释放使用权切换到其他协程，因此同一时间其实只有一个协程拥有运行权，相当于单线程的能力。\n\n一个线程可以有多个协程，一个进程也可以有多个协程。\n\n协程不被操作系统内核管理，而完全是由程序控制。这样带来的好处就是性能得到了很大的提升，不会像线程切换那样消耗资源。\n\n协程的暂停完全由程序控制，线程的阻塞状态是由操作系统内核来进行切换。\n因此，协程的开销远远小于线程的开销。\n\n协程能保留上一次调用时的状态。\n\n\nPCB是进程存在的唯一标志，当进程被创建时，操作系统为其创建PCB，当进程结束时，会回收其PCB\n","categories":["计算机理论"],"tags":["操作系统原理-操作系统原理面试题"]},{"title":"处理机调度的层次","url":"/2020/06/15/%E8%AE%A1%E7%AE%97%E6%9C%BA%E7%90%86%E8%AE%BA/%E6%93%8D%E4%BD%9C%E7%B3%BB%E7%BB%9F%E5%8E%9F%E7%90%86/%E6%93%8D%E4%BD%9C%E7%B3%BB%E7%BB%9F%E5%8E%9F%E7%90%86%E9%9D%A2%E8%AF%95%E9%A2%98/2.4_%E5%A4%84%E7%90%86%E6%9C%BA%E8%B0%83%E5%BA%A6%E7%9A%84%E5%B1%82%E6%AC%A1/","content":"当有一堆任务要处理，但由于资源有限，这些事情没法同时处理。这就需要确定某种规则来决定处理这些任务的顺序，这就是“调度”研究的问题\n\n高级调度（作业调度）：按一定的原则从外存的作业后备队列中挑选一个作业调入内存，并创建进程。每个作业只调入一次，调出一次，作业调入时会建立PCB，调出时才撤销PCB\n中级调度（内存调度）：内存不够时，可将某些进程的数据调出外存，等内存空闲或者进程需要运行时再重新调入内存，暂时调到外存等待的进程状态为挂起状态，挂起状态又可以进一步细分为就绪挂起、阻塞挂起两种状态，被挂起的进程PCB会被组织成挂起队列（为减轻系统负载，提高资源利用率），按照某种策略决定将哪个处于挂起状态的进程重新调入内存，一个进程可能会被多次调出、调入内存，因此中级调度发生的频率要比高级调度更高\n低级调度（进程调度&#x2F;处理机调度）：按照某种策略从就绪队列中选取一个进程，将处理机分配给它\n\n","categories":["计算机理论"],"tags":["操作系统原理-操作系统原理面试题"]},{"title":"进程与线程的切换流程","url":"/2020/06/15/%E8%AE%A1%E7%AE%97%E6%9C%BA%E7%90%86%E8%AE%BA/%E6%93%8D%E4%BD%9C%E7%B3%BB%E7%BB%9F%E5%8E%9F%E7%90%86/%E6%93%8D%E4%BD%9C%E7%B3%BB%E7%BB%9F%E5%8E%9F%E7%90%86%E9%9D%A2%E8%AF%95%E9%A2%98/2.12_%E8%BF%9B%E7%A8%8B%E4%B8%8E%E7%BA%BF%E7%A8%8B%E7%9A%84%E5%88%87%E6%8D%A2%E6%B5%81%E7%A8%8B/","content":"进程切换：一个进程让出处理机，由另一个进程占用处理机的过程，进程切换、调度是有代价的，因此如果过于频繁的进行进程调度、切换，必然会使整个系统的效率降低，使系统大部分时间都花在了进程切换上，而真正用于执行进程的时间减少，并不是调度越频繁，并发度就越高\n进程切换分两步：\n1、切换页表以使用新的地址空间，一旦去切换上下文，处理器中所有已经缓存的内存地址一瞬间都作废了。\n2、切换内核栈和硬件上下文。\n对于linux来说，线程和进程的最大区别就在于地址空间，对于线程切换，第1步是不需要做的，第2步是进程和线程切换都要做的。因为每个进程都有自己的虚拟地址空间，而线程是共享所在进程的虚拟地址空间的，因此同一个进程中的线程进行线程切换时不涉及虚拟地址空间的转换。\n","categories":["计算机理论"],"tags":["操作系统原理-操作系统原理面试题"]},{"title":"进程调度的方式","url":"/2020/06/15/%E8%AE%A1%E7%AE%97%E6%9C%BA%E7%90%86%E8%AE%BA/%E6%93%8D%E4%BD%9C%E7%B3%BB%E7%BB%9F%E5%8E%9F%E7%90%86/%E6%93%8D%E4%BD%9C%E7%B3%BB%E7%BB%9F%E5%8E%9F%E7%90%86%E9%9D%A2%E8%AF%95%E9%A2%98/2.5_%E8%BF%9B%E7%A8%8B%E8%B0%83%E5%BA%A6%E7%9A%84%E6%96%B9%E5%BC%8F/","content":"\n非剥夺调度方式，又称非抢占方式，即只允许进程主动放弃处理机，在运行过程中即便有更紧迫的任务到达，当前进程依然会继续使用处理机，直到该进程终止或主动要求进入阻塞态\n剥夺调度方式，又称抢占方式，可由操作系统剥夺当前进程的CPU使用权，当一个进程正在处理机上执行时，如果有一个更重要或更紧急的进程需要使用处理机，则立即暂停正在执行的进程，将处理机分配给更重要紧迫的那个进程\n\n","categories":["计算机理论"],"tags":["操作系统原理-操作系统原理面试题"]},{"title":"进程间通信方式有哪些","url":"/2020/06/15/%E8%AE%A1%E7%AE%97%E6%9C%BA%E7%90%86%E8%AE%BA/%E6%93%8D%E4%BD%9C%E7%B3%BB%E7%BB%9F%E5%8E%9F%E7%90%86/%E6%93%8D%E4%BD%9C%E7%B3%BB%E7%BB%9F%E5%8E%9F%E7%90%86%E9%9D%A2%E8%AF%95%E9%A2%98/2.3_%E8%BF%9B%E7%A8%8B%E9%97%B4%E9%80%9A%E4%BF%A1%E6%96%B9%E5%BC%8F%E6%9C%89%E5%93%AA%E4%BA%9B/","content":"进程通信就是指进程之间的信息交换，进程是分配系统资源的单位（包括内存地址空间），因此各进程拥有的内存地址空间相互独立，为了保证安全，一个进程不能直接访问另一个进程的地址空间，但是进程之间的信息交换又是必须实现的。为了保证进程间的安全通信，操作系统提供了一些方法\n\n共享内存：共享内存就是映射一段能被其他进程所访问的内存，这段共享内存由一个进程创建，但多个进程都可以访问。\n消息传递：进程通过操作系统提供的“发送消息&#x2F;接收消息”两个原语进行数据交换\n管道：管道这种通讯方式有两种限制，一是半双工的通信，数据只能单向流动，二是只能在具有亲缘关系的进程间使用。进程的亲缘关系通常是指父子进程关系。\n匿名管道：单向的，只能在有亲缘关系的进程间通信；\n命名管道：可以实现本机任意两个进程通信。\n\n\n信号 ： 信号是一种比较复杂的通信方式，信号可以在任何时候发给某一进程，而无需知道该进程的状态。\n信号量：信号量是一个计数器，可以用来控制多个进程对共享资源的访问。它常作为一种锁机制，防止某进程正在访问共享资源时，其他进程也访问该资源。因此，主要作为进程间以及同一进程内不同线程之间的同步手段。\nSocket：与其他通信机制不同的是，它可用于不同机器间的进程通信。\n\n","categories":["计算机理论"],"tags":["操作系统原理-操作系统原理面试题"]},{"title":"进程的状态与转换","url":"/2020/06/15/%E8%AE%A1%E7%AE%97%E6%9C%BA%E7%90%86%E8%AE%BA/%E6%93%8D%E4%BD%9C%E7%B3%BB%E7%BB%9F%E5%8E%9F%E7%90%86/%E6%93%8D%E4%BD%9C%E7%B3%BB%E7%BB%9F%E5%8E%9F%E7%90%86%E9%9D%A2%E8%AF%95%E9%A2%98/2.2_%E8%BF%9B%E7%A8%8B%E7%9A%84%E7%8A%B6%E6%80%81%E4%B8%8E%E8%BD%AC%E6%8D%A2/","content":"创建状态：进程正在被创建时，它的状态是“创建态”，在这个阶段操作系统会为进程分配资源、初始化PCB\n就绪状态：当进程创建完成后，便进入了“就绪态”，处于就绪态的进程已经具备运行条件，但由于没有空闲CPU，就暂时不能运行\n运行状态：如果一个进程此时在CPU上运行，那么这个进程处于“运行态”，CPU会执行该进程对应的程序（执行指令序列）\n阻塞状态（等待态）：在进程运行过程中，可能会请求等待某个事件的发生（如等待某种系统资源的分配，或者等待其他进程的响应），在这个事件发生之前，进程无法继续往下执行，此时操作系统会让这个进程下CPU，并让它进入“阻塞态”，如果等待的某个事件发生了，进程就会由“阻塞态”变为“就绪态”，当CPU空闲时，会选择一个“就绪态”进程上CPU运行\n终止状态：一个进程可以执行exit系统调用，请求操作系统终止该进程，此时该进程会进入“终止态”，操作系统会让该进程下CPU，并回收内存空间等资源，最后还要回收该进程的PCB，当终止进程的工作完成之后，这个进程就彻底消失了（进程运行结束，或运行过程中遇到不可修复的错误）\n\n\n运行态→阻塞态：往往是由于等待外设，等待主存等资源分配或等待人工干预而引起的。 \n阻塞态→就绪态：则是等待的条件已满足，只需分配到处理器后就能运行。 \n运行态→就绪态：不是由于自身原因，而是由外界原因使运行状态的进程让出处理器，这时候就变成就绪态。例如时间片用完，或有更高优先级的进程来抢占处理器等。 \n就绪态→运行态：系统按某种策略选中就绪队列中的一个进程占用处理器，此时就变成了运行态。\n\n","categories":["计算机理论"],"tags":["操作系统原理-操作系统原理面试题"]},{"title":"进程调度算法","url":"/2020/06/15/%E8%AE%A1%E7%AE%97%E6%9C%BA%E7%90%86%E8%AE%BA/%E6%93%8D%E4%BD%9C%E7%B3%BB%E7%BB%9F%E5%8E%9F%E7%90%86/%E6%93%8D%E4%BD%9C%E7%B3%BB%E7%BB%9F%E5%8E%9F%E7%90%86%E9%9D%A2%E8%AF%95%E9%A2%98/2.6_%E8%BF%9B%E7%A8%8B%E8%B0%83%E5%BA%A6%E7%AE%97%E6%B3%95/","content":"\n先来先服务FCFS：按照作业&#x2F;进程到达的先后顺序进行服务，事实上就是等待时间越久的越优先得到服务，非抢占式算法，不会导致饥饿，缺点：排在长作业（进程）后面的短作业需要等待很长时间，带权周转时间很大，对短作业来说用户体验不好，即FCFS算法对长作业有利，对短作业不利\n\n最短作业优先SJF：最短的作业&#x2F;进程优先得到服务（所谓最短是指要求服务时间最短），每次调度时选择当前已到达的且运行时间最短的作业&#x2F;进程，缺点：不公平，对短作业有利，对长作业不利。作业&#x2F;进程的运行时间是由用户提供的，并不一定真实，不一定能做到真正的短作业优先，可能产生饥饿现象，如果源源不断的有短作业&#x2F;进程到来，可能使长作业&#x2F;进程长时间得不到服务，产生饥饿现象，如果一直得不到服务，则称为饿死【最短剩余时间优先：最短作业优先的抢占式版本】\n\n最高响应比优先HRRN：（等待时间+要求服务时间）&#x2F; 要求服务时间，非抢占式的算法\n\n时间片轮转RR：将所有就绪进程按 FCFS 的原则排成一个队列，每次调度时，把 CPU 时间分配给队首进程，该进程可以执行一个时间片。当时间片用完时，由计时器发出时钟中断，调度程序便停止该进程的执行，并将它送往就绪队列的末尾，同时继续把 CPU 时间分配给队首的进程。不会导致饥饿，缺点：由于高频率的进程切换，因此有一定的开销；不区分任务的紧急程度\n\n优先级调度：为每个进程分配一个优先级，按优先级进行调度。为了防止低优先级的进程永远等不到调度，可以随着时间的推移增加等待进程的优先级。缺点：若源源不断的有高优先级进程到来，则可能导致饥饿\n\n\n","categories":["计算机理论"],"tags":["操作系统原理-操作系统原理面试题"]},{"title":"上下文切换","url":"/2020/06/15/%E8%AE%A1%E7%AE%97%E6%9C%BA%E7%90%86%E8%AE%BA/%E6%93%8D%E4%BD%9C%E7%B3%BB%E7%BB%9F%E5%8E%9F%E7%90%86/%E6%93%8D%E4%BD%9C%E7%B3%BB%E7%BB%9F%E5%8E%9F%E7%90%86%E9%9D%A2%E8%AF%95%E9%A2%98/2.8_%E4%B8%8A%E4%B8%8B%E6%96%87%E5%88%87%E6%8D%A2/","content":"对于单核CPU而言，在某一时刻只能执行一条CPU指令，上下文切换是一种将CPU资源从一个进程分配给另一个进程的机制。从用户角度看，计算机能够并行运行多个进程，这恰恰是操作系统通过快速上下文切换造成的结果。在切换的过程中，操作系统需要先存储当前进程的状态，再读入下一个进程的状态，然后执行此进程\n","categories":["计算机理论"],"tags":["操作系统原理-操作系统原理面试题"]},{"title":"为什么虚拟地址空间切换会比较耗时","url":"/2020/06/15/%E8%AE%A1%E7%AE%97%E6%9C%BA%E7%90%86%E8%AE%BA/%E6%93%8D%E4%BD%9C%E7%B3%BB%E7%BB%9F%E5%8E%9F%E7%90%86/%E6%93%8D%E4%BD%9C%E7%B3%BB%E7%BB%9F%E5%8E%9F%E7%90%86%E9%9D%A2%E8%AF%95%E9%A2%98/2.9_%E4%B8%BA%E4%BB%80%E4%B9%88%E8%99%9A%E6%8B%9F%E5%9C%B0%E5%9D%80%E7%A9%BA%E9%97%B4%E5%88%87%E6%8D%A2%E4%BC%9A%E6%AF%94%E8%BE%83%E8%80%97%E6%97%B6/","content":"进程都有自己的虚拟地址空间，把虚拟地址转换为物理地址需要查找页表，页表查找是一个很慢的过程，因此通常使用Cache来缓存常用的地址映射，这样可以加速页表查找。\n由于每个进程都有自己的虚拟地址空间，那么显然每个进程都有自己的页表，那么当进程切换后页表也要进行切换，页表切换后Cache就失效了，Cache失效导致命中率降低，那么虚拟地址转换为物理地址就会变慢，表现出来的就是程序运行会变慢。\n而线程切换则不会导致Cache失效，因为线程无需切换地址空间，因此我们通常说线程切换要比较进程切换块，原因就在这里。\n","categories":["计算机理论"],"tags":["操作系统原理-操作系统原理面试题"]},{"title":"内存管理的概念","url":"/2020/06/15/%E8%AE%A1%E7%AE%97%E6%9C%BA%E7%90%86%E8%AE%BA/%E6%93%8D%E4%BD%9C%E7%B3%BB%E7%BB%9F%E5%8E%9F%E7%90%86/%E6%93%8D%E4%BD%9C%E7%B3%BB%E7%BB%9F%E5%8E%9F%E7%90%86%E9%9D%A2%E8%AF%95%E9%A2%98/3.1_%E5%86%85%E5%AD%98%E7%AE%A1%E7%90%86%E7%9A%84%E6%A6%82%E5%BF%B5/","content":"操作系统作为系统资源的管理者，当然也需要对内存进行管理：\n\n操作系统负责内存空间的分配与回收\n连续分配管理方式：指为用户进程分配的必须是一个连续的内存空间\n单一连续分配，无外部碎片\n固定分区分配：分区大小相等、分区大小不等\n动态分区分配，没有内部碎片，但是有外部碎片（紧凑技术解决）\n\n\n非连续分配管理方式\n基本分页存储管理\n基本分段存储管理\n段页式存储管理\n\n\n\n\n操作系统需要提供某种技术从逻辑上对内存空间进行扩充（虚拟性）\n什么叫虚拟内存：虚拟内存就是说，让物理内存扩充成更大的逻辑内存，从而让程序获得更多的可用内存。虚拟内存使用部分加载的技术，让一个进程或者资源的某些页面加载进内存，从而能够加载更多的进程，甚至能加载比内存大的进程，这样看起来好像内存变大了。\n覆盖技术，覆盖是在同一程序或进程中的，交换是在不同进程或作业之间的\n交换技术：内存空间紧张时，系统将内存中某些进程暂时换出外存，外存上的那块空间叫做交换空间，把外存中某些已具备运行条件的进程换入内存（进程在内存与磁盘间动态调度），虽然不常用的进程被调出内存了，但是该进程的PCB还在内存中保存着\n请求分页存储管理\n请求分段存储管理\n请求段页式存储管理\n\n\n\n\n\n\n操作系统需要提供地址转换功能，负责程序的逻辑地址与物理地址的转换\n操作系统需要提供内存保护功能，保证各进程在各自存储空间内运行，互不干扰\n\n","categories":["计算机理论"],"tags":["操作系统原理-操作系统原理面试题"]},{"title":"分页、分段","url":"/2020/06/15/%E8%AE%A1%E7%AE%97%E6%9C%BA%E7%90%86%E8%AE%BA/%E6%93%8D%E4%BD%9C%E7%B3%BB%E7%BB%9F%E5%8E%9F%E7%90%86/%E6%93%8D%E4%BD%9C%E7%B3%BB%E7%BB%9F%E5%8E%9F%E7%90%86%E9%9D%A2%E8%AF%95%E9%A2%98/3.2_%E5%88%86%E9%A1%B5%E3%80%81%E5%88%86%E6%AE%B5/","content":"分页：\n把内存空间划分为大小相等且固定的块，作为主存的基本单位。因为程序数据存储在不同的页面中，而页面又离散的分布在内存中，因此需要一个页表来记录映射关系，以实现从页号到物理块号的映射。\n访问分页系统中内存数据需要两次的内存访问 (一次是从内存中访问页表，从中找到指定的物理块号，加上页内偏移得到实际物理地址；第二次就是根据第一次得到的物理地址访问内存取出数据，引入快表机制可以减少一次访存)。\n\n分段：\n分页是为了提高内存利用率，而分段是为了满足程序员在编写代码的时候的一些逻辑需求(比如数据共享，数据保护，动态链接等)。\n分段内存管理当中，地址是二维的，一维是段号，二维是段内地址；其中每个段的长度是不一样的，而且每个段内部都是从0开始编址的。由于分段管理中，每个段内部是连续内存分配，但是段和段之间是离散分配的，因此也存在一个逻辑地址到物理地址的映射关系，相应的就是段表机制。\n分段也是需要两次访存。\n\n分页和分段的区别：\n\n页是信息的物理单位，段是信息的逻辑单位，分页的主要目的是为了实现离散分配，提高内存利用率。分段的主要目的是更好的满足用户需求。\n分页对程序员是透明的，但是分段需要程序员显式划分每个段。 \n分页的地址空间是一维地址空间，分段是二维的。 \n页的大小不可变，段的大小可以动态改变。 \n分页主要用于实现虚拟内存，从而获得更大的地址空间；分段主要是为了使程序和数据可以被划分为逻辑上独立的地址空间并且有助于共享和保护。\n\n","categories":["计算机理论"],"tags":["操作系统原理-操作系统原理面试题"]},{"title":"动态分区分配算法","url":"/2020/06/15/%E8%AE%A1%E7%AE%97%E6%9C%BA%E7%90%86%E8%AE%BA/%E6%93%8D%E4%BD%9C%E7%B3%BB%E7%BB%9F%E5%8E%9F%E7%90%86/%E6%93%8D%E4%BD%9C%E7%B3%BB%E7%BB%9F%E5%8E%9F%E7%90%86%E9%9D%A2%E8%AF%95%E9%A2%98/3.3_%E5%8A%A8%E6%80%81%E5%88%86%E5%8C%BA%E5%88%86%E9%85%8D%E7%AE%97%E6%B3%95/","content":"在动态分区分配方式中，当很多个空闲分区都能满足需求时，应该选择哪个分区进行分配？\n综合来看，四种算法中，首次适应算法的效果反而更好：\n\n首次适应算法和邻近适应算法比最佳适应算法和最坏适应算法好的一点：不用每次都更新空闲分区链&#x2F;表的排列顺序，减少开销\n","categories":["计算机理论"],"tags":["操作系统原理-操作系统原理面试题"]},{"title":"页面置换算法有哪些","url":"/2020/06/15/%E8%AE%A1%E7%AE%97%E6%9C%BA%E7%90%86%E8%AE%BA/%E6%93%8D%E4%BD%9C%E7%B3%BB%E7%BB%9F%E5%8E%9F%E7%90%86/%E6%93%8D%E4%BD%9C%E7%B3%BB%E7%BB%9F%E5%8E%9F%E7%90%86%E9%9D%A2%E8%AF%95%E9%A2%98/3.4_%E9%A1%B5%E9%9D%A2%E7%BD%AE%E6%8D%A2%E7%AE%97%E6%B3%95%E6%9C%89%E5%93%AA%E4%BA%9B/","content":"在程序运行过程中，如果要访问的页面不在内存中，就发生缺页中断从而将该页调入内存中。此时如果内存已无空闲空间，系统必须从内存中调出一个页面到磁盘对换区中来腾出空间：\n\n最佳置换算法OPT（性能最好）：所选择的被换出的页面将是最长时间内不再被访问，通常可以保证获得最低的缺页率。这是一种理论上的算法，因为无法知道一个页面多长时间不再被访问。\n\n先进先出置换算法FIFO：选择换出的页面是最先进入的页面。该算法将那些经常被访问的页面也被换出，从而使缺页率升高。\n\n最近最久未使用置换算法LRU（该算法性能最接近最佳置换算法）：虽然无法知道将来要使用的页面情况，但是可以知道过去使用页面的情况。LRU 将最近最久未使用的页面换出。为了实现 LRU，需要在内存中维护一个所有页面的链表。当一个页面被访问时，将这个页面移到链表表头。这样就能保证链表表尾的页面是最近最久未访问的。因为每次访问都需要更新链表，因此这种方式实现的 LRU 代价很高。\n\n时钟置换算法CLOCK：时钟算法使用环形链表将页面连接起来，再使用一个指针指向最老的页面。它将整个环形链表的每一个页面做一个标记，如果标记是0，那么暂时就不会被替换，然后时钟算法遍历整个环，遇到标记为1的就替换，否则将标记为0的标记为1。\n\n\n","categories":["计算机理论"],"tags":["操作系统原理-操作系统原理面试题"]},{"title":"什么是抖动","url":"/2020/06/15/%E8%AE%A1%E7%AE%97%E6%9C%BA%E7%90%86%E8%AE%BA/%E6%93%8D%E4%BD%9C%E7%B3%BB%E7%BB%9F%E5%8E%9F%E7%90%86/%E6%93%8D%E4%BD%9C%E7%B3%BB%E7%BB%9F%E5%8E%9F%E7%90%86%E9%9D%A2%E8%AF%95%E9%A2%98/3.5_%E4%BB%80%E4%B9%88%E6%98%AF%E6%8A%96%E5%8A%A8/","content":"刚刚换出的页面马上又要换入内存，刚刚换入的页面马上又要换出内存，这种频繁的页面调度行为称为抖动，或颠簸，产生抖动的主要原因是进程频繁访问的页面数目高于可用的物理块数（分配给进程的物理块不够）\n","categories":["计算机理论"],"tags":["操作系统原理-操作系统原理面试题"]},{"title":"硬链接和软链接有什么区别","url":"/2020/06/15/%E8%AE%A1%E7%AE%97%E6%9C%BA%E7%90%86%E8%AE%BA/%E6%93%8D%E4%BD%9C%E7%B3%BB%E7%BB%9F%E5%8E%9F%E7%90%86/%E6%93%8D%E4%BD%9C%E7%B3%BB%E7%BB%9F%E5%8E%9F%E7%90%86%E9%9D%A2%E8%AF%95%E9%A2%98/4.1_%E7%A1%AC%E9%93%BE%E6%8E%A5%E5%92%8C%E8%BD%AF%E9%93%BE%E6%8E%A5%E6%9C%89%E4%BB%80%E4%B9%88%E5%8C%BA%E5%88%AB/","content":"操作系统为用户提供文件共享功能，可以让多个用户共享的使用同一个文件\n多个用户共享同一个文件，意味着系统中只有一份文件数据，并且只要某个用户修改了该文件的数据，其他用户也可以看到文件数据的变化\n如果是多个用户都复制了同一个文件，那么系统中会有好几份文件数据，其中一个用户修改了自己的那份文件数据，对其他用户的文件数据并没有影响\n\n基于索引结点的共享方式（硬链接）：各个用户的目录项指向同一个索引结点，若count &gt; 0，说明还有别的用户要使用该文件，暂时不能把文件数据删除，否则会导致指针悬空；当count &#x3D; 0时，系统负责删除文件\n\n基于符号链的共享方式（软链接、符号链接）：即使软链接指向的共享文件已被删除，Link型文件依然存在，只是通过Link型文件中的路径去查找共享文件会失败（找不到对应目录项）,由于用软链接的方式访问共享文件时要查询多级目录，会有多次磁盘I&#x2F;O，因此用软链接访问共享文件的速度要比硬链接更慢【类似于Windows中的快捷方式】\n\n\n","categories":["计算机理论"],"tags":["操作系统原理-操作系统原理面试题"]},{"title":"磁盘调度算法","url":"/2020/06/15/%E8%AE%A1%E7%AE%97%E6%9C%BA%E7%90%86%E8%AE%BA/%E6%93%8D%E4%BD%9C%E7%B3%BB%E7%BB%9F%E5%8E%9F%E7%90%86/%E6%93%8D%E4%BD%9C%E7%B3%BB%E7%BB%9F%E5%8E%9F%E7%90%86%E9%9D%A2%E8%AF%95%E9%A2%98/5.2_%E7%A3%81%E7%9B%98%E8%B0%83%E5%BA%A6%E7%AE%97%E6%B3%95/","content":"延迟时间和传输时间都与磁盘转速相关，且为线性相关。而转速是硬件的固有属性，因此操作系统也无法优化延迟时间和传输时间，但是操作系统的磁盘调度算法会直接影响寻道时间\n\n先来先服务FCFS：根据进程请求访问磁盘的先后顺序进行调度\n最短寻找时间优先SSTF：优先处理与当前磁头最近的磁道，可以保证每次的寻道时间最短，但是并不能保证总的寻道时间最短（贪心算法），会产生饥饿现象\n扫描算法SCAN：只有磁头移动到最外侧磁道的时候才能往内移动，移动到最内侧磁道的时候才能往外移动\nLOOK调度算法（解决SCAN算法的第一个缺点）\n循环扫描算法C-SCAN（解决SCAN算法的第二个缺点）：只有磁头朝某个特定方向移动时才处理磁道访问请求，而返回时直接快速移动至起始端而不处理任何请求\nC-LOOK调度算法（解决C-SCAN算法的缺点）\n\n","categories":["计算机理论"],"tags":["操作系统原理-操作系统原理面试题"]},{"title":"什么是临界区，如何解决冲突","url":"/2020/06/15/%E8%AE%A1%E7%AE%97%E6%9C%BA%E7%90%86%E8%AE%BA/%E6%93%8D%E4%BD%9C%E7%B3%BB%E7%BB%9F%E5%8E%9F%E7%90%86/%E6%93%8D%E4%BD%9C%E7%B3%BB%E7%BB%9F%E5%8E%9F%E7%90%86%E9%9D%A2%E8%AF%95%E9%A2%98/2.7_%E4%BB%80%E4%B9%88%E6%98%AF%E4%B8%B4%E7%95%8C%E5%8C%BA%EF%BC%8C%E5%A6%82%E4%BD%95%E8%A7%A3%E5%86%B3%E5%86%B2%E7%AA%81/","content":"每个进程中访问临界资源的那段程序称为临界区，一次仅允许一个进程使用的资源称为临界资源。\n解决冲突的办法（为了实现对临界资源的互斥访问）：\n\n空闲让进：临界区空闲时，可以允许一个请求进入临界区的进程立即进入临界区\n忙则等待：当已有进程进入临界区时，其他试图进入临界区的进程必须等待\n有限等待：对请求访问的进程，应保证能在有限时间内进入临界区（保证不会饥饿）\n让权等待：当进程不能进入临界区时，应立即释放处理机，防止进程忙等待\n\n","categories":["计算机理论"],"tags":["操作系统原理-操作系统原理面试题"]},{"title":"什么是缓冲区溢出，有什么危害","url":"/2020/06/15/%E8%AE%A1%E7%AE%97%E6%9C%BA%E7%90%86%E8%AE%BA/%E6%93%8D%E4%BD%9C%E7%B3%BB%E7%BB%9F%E5%8E%9F%E7%90%86/%E6%93%8D%E4%BD%9C%E7%B3%BB%E7%BB%9F%E5%8E%9F%E7%90%86%E9%9D%A2%E8%AF%95%E9%A2%98/5.1_%E4%BB%80%E4%B9%88%E6%98%AF%E7%BC%93%E5%86%B2%E5%8C%BA%E6%BA%A2%E5%87%BA%EF%BC%8C%E6%9C%89%E4%BB%80%E4%B9%88%E5%8D%B1%E5%AE%B3/","content":"缓冲区溢出是指当计算机向缓冲区填充数据时超出了缓冲区本身的容量，溢出的数据覆盖在合法数据上。\n危害有以下两点：\n\n程序崩溃，导致拒绝额服务\n跳转并且执行一段恶意代码\n\n造成缓冲区溢出的主要原因是程序中没有仔细检查用户输入。\n","categories":["计算机理论"],"tags":["操作系统原理-操作系统原理面试题"]},{"title":"基础知识","url":"/2020/07/31/%E8%AE%A1%E7%AE%97%E6%9C%BA%E7%90%86%E8%AE%BA/%E6%B1%87%E7%BC%96%E8%AF%AD%E8%A8%80/%E3%80%8A%E6%B1%87%E7%BC%96%E8%AF%AD%E8%A8%80(%E7%AC%AC4%E7%89%88)%E3%80%8B/1_%E5%9F%BA%E7%A1%80%E7%9F%A5%E8%AF%86/","content":"——————————————————1.1.机器语言1.2.汇编语言的产生1.3.汇编语言的组成1.4.存储器1.5.指令和数据1.6.存储单元1.7.CPU对存储器的读写1.8.地址总线1.9.数据总线1.10.控制总线1.11.内存地址空间(概述)1.12.主板1.13.接口卡1.14.各类存储器芯片1.15.内存地址空间——————————————————\n汇编语言是直接在硬件之上工作的编程语言，首先要了解硬件系统的结构，才能有效的应用汇编语言对其编程\n机器语言是机器指令的集合，机器指令展开来讲就是一台机器可以正确执行的命令，电子计算机的机器指令是一列二进制数字，计算机将之转变为一列高低电平，以使计算机的电子器件受到驱动，进行运算\nCPU是一种微处理器，每一种微处理器，由于硬件设计和内部结构的不同，就需要不同的电平脉冲来控制，使他工作，所以每一种微处理器都有自己的机器指令集，也就是机器语言————————\n汇编语言的主体是汇编指令\n汇编指令和机器指令的差别在于指令的表示方法上，汇编指令是机器指令便于记忆的书写格式，汇编指令是机器指令的助记符\n寄存器，简单的讲是CPU中可以存储数据的器件，一个CPU中有多个寄存器，AX是其中一个寄存器的代号，BX是另一个寄存器的代号————————\n汇编语言由以下三类组成：1）汇编指令（机器码的助记符，有对应的机器码）2）伪指令（没有对应的机器码，由编译器执行，计算机并不执行）3）其他符号如+-*&#x2F;（由编译器识别，没有对应的机器码）\n汇编语言的核心是汇编指令，它决定了汇编语言的特性————————\nCPU是计算机的核心部件，它控制着整个计算机的运作并进行运算，要想让一个CPU工作，就必须向它提供指令和数据，指令和数据在存储器中存放，也就是平时所说的内存\n在一台PC机中内存的作用仅次于CPU，离开了内存，性能再好的CPU也无法工作，磁盘不同于内存，磁盘上的数据或程序如果不读到内存中，就无法被CPU使用————————\n指令和数据是应用上的概念，在内存或磁盘上，指令和数据没有任何区别，都是二进制信息————————\n存储器被划分为若干个存储单元，每个存储单元从0开始顺序编号【电子计算机的最小信息单位是bit（比特），也就是一个二进制位，8个bit组成一个Byte（字节），微型机存储器的存储单位可以存储一个Byte】—————————\nCPU要想进行数据的读写，必须和外部器件（芯片）进行三类信息的交互：1）地址信息：存储单元的地址2）控制信息：器件的选择，读或写命令3）数据信息：读或写的数据\n每一个CPU芯片都有许多管脚，这些管脚和总线相连，也可以说，这些管脚引出总线，一个CPU可以引出三种总线的宽度标志着这个CPU的不同方面的性能：地址总线的宽度决定了CPU的寻址能力数据总线的宽度决定了CPU与其他器件进行数据传送时的一次数据传送量控制总线的宽度决定了CPU对系统中其他器件的控制能力\n电子计算机能处理、传输的信息都是电信号，电信号当然要用导线传送，在计算机中专门有连接CPU和其他芯片的导线，通常称为总线物理上：一根根导线的集合逻辑上划分为：1）地址总线：CPU是通过地址总线来指定存储单元的，地址总线上能传送多少个不同的信息，CPU就可以对多少个存储单元进行寻址\n一个CPU有N根地址总线，则可以说这个CPU的地址总线的宽度为N，这样的CPU最多可以寻找2的N次方个内存单元\n2）数据总线：CPU与内存或其他器件之间的数据传送是通过数据总线来进行的，数据总线的宽度决定了CPU和外界的数据传送速度\n8088CPU的数据总线宽度为8，8086CPU的数据总线宽度为16\n3）控制总线：CPU对外部器件的控制是通过控制总线来进行的，在这里控制总线是个总称，控制总线是一些不同控制线的集合，有多少根控制总线，就意味着CPU提供了对外部器件的多少种控制，所以，控制总线的宽度决定了CPU对外部器件的控制能力\n要让一个计算机或微处理器工作，应向它输入能够驱动它进行工作的电平信号（机器码）——————————\n一个CPU的地址线宽度为10，那么可以寻址1024个内存单元，这1024个可寻到的内存单元就构成了这个CPU的内存地址空间——————————\n在每一台PC机中，都有一个主板，主板上有核心器件和一些主要器件，这些器件通过总线（地址总线、数据总线、控制总线）相连，这些器件有CPU、存储器、外围芯片组、扩展插槽等，扩展插槽上一般插有RAM内存条和各类接口卡——————————\n计算机系统中，所有可用程序控制其互作的设备，必须受到CPU的控制，CPU对外部设备不能直接控制，如显示器、音箱、打印机等，直接控制这些设备进行工作的是插在扩展插槽上的接口卡，扩展插槽通过总线和CPU相连，所以接口卡也通过总线同CPU相连——————————\n各类存储器芯片：1）从读写属性上看分为两类：随机存储器（RAM）和只读存储器（ROM），随机存储器可读可写，但必须带电存储，关机后存储的内容丢失；只读存储器只能读取不能写入，关机后其中的内容不丢失2）从功能和连接上分类：\n这些存储器在物理上是独立的器件：\n但是它们在以下两点上相同：1）都和CPU的总线相连2）CPU对它们进行读或写的时候都通过控制线发出内存读写命令\n不同的计算机系统的内存地址空间分配情况是不同的\n内存地址空间的大小受CPU地址总线宽度的限制\n对CPU来讲，系统中的所有存储器中的存储单元都处于一个统一的逻辑存储器中，它的容量受CPU寻址能力的限制，这个逻辑存储器即是我们所说的内存地址空间\n","categories":["计算机理论"],"tags":["汇编语言-《汇编语言(第4版)》"]},{"title":"实验1、查看CPU和内存，用机器指令和汇编指令编程","url":"/2020/07/31/%E8%AE%A1%E7%AE%97%E6%9C%BA%E7%90%86%E8%AE%BA/%E6%B1%87%E7%BC%96%E8%AF%AD%E8%A8%80/%E3%80%8A%E6%B1%87%E7%BC%96%E8%AF%AD%E8%A8%80(%E7%AC%AC4%E7%89%88)%E3%80%8B/3_%E5%AE%9E%E9%AA%8C1%E3%80%81%E6%9F%A5%E7%9C%8BCPU%E5%92%8C%E5%86%85%E5%AD%98%EF%BC%8C%E7%94%A8%E6%9C%BA%E5%99%A8%E6%8C%87%E4%BB%A4%E5%92%8C%E6%B1%87%E7%BC%96%E6%8C%87%E4%BB%A4%E7%BC%96%E7%A8%8B/","content":"Debug是DOS、Windows都提供的实模式（8086方式）程序的调试工具，使用它可以查看CPU各种寄存器的内容、内存的情况和在机器码级跟踪程序的运行\nDebug功能：1）R：查看、改变CPU寄存器的内容2）D：查看内存中的内容3）E：改写内存中的内容4）U：将内存中的机器指令翻译成汇编指令5）T：执行一条机器指令6）A：以汇编指令的格式在内存中写入一条机器指令\n1）使用R命令查看、修改CPU中各个寄存器的内容：\n2）用Debug的D命令查看内存中的内容\na.中间是从指定地址开始的128个内存单元的内容，用十六进制的格式输出，每行的输出从16的整数倍的地址开始，最多输出16个单元的内容b.左边是每行的起始地址c.右边是每个内存单元中的数据对应的可显示的ASCII码字符\n直接使用D命令，将列出Debug预设的地址处的内容在使用“d 段地址：偏移地址”之后，接着使用D命令，可列出后续的内容也可以指定D命令的查看范围：“d 段地址：起始偏移地址 结尾偏移地址”只想查看内存单元10000H中的内容：\n3）用Debug的E命令改写内存中的内容\n也可以采用提问的方式一个一个的改写内存中的内容：\n可以用E命令向内存中写入字符、字符串\n4）用E命令向内存中写入机器码，用U命令查看内存中机器码的含义，用T命令执行内存中的机器码\n向内存中写入机器码：\n查看写入的或内存中原有的机器码所对应的汇编指令：\nU命令的显示输出分为3部分：每一条机器指令的地址、机器指令、机器指令所对应的汇编指令\nT命令可以执行一条或多条指令，简单的使用T命令，可以执行CS：IP指向的指令\n若要用T命令控制CPU执行我们写到1000:0的指令，必须先让CS：IP指向1000:0\n5）用Debug的A命令以汇编指令的形式在内存中写入机器指令\n简单的使用A命令，可以从一个预设的地址开始输入指令\n","categories":["计算机理论"],"tags":["汇编语言-《汇编语言(第4版)》"]},{"title":"实验2、用机器指令和汇编指令编程","url":"/2020/07/31/%E8%AE%A1%E7%AE%97%E6%9C%BA%E7%90%86%E8%AE%BA/%E6%B1%87%E7%BC%96%E8%AF%AD%E8%A8%80/%E3%80%8A%E6%B1%87%E7%BC%96%E8%AF%AD%E8%A8%80(%E7%AC%AC4%E7%89%88)%E3%80%8B/5_%E5%AE%9E%E9%AA%8C2%E3%80%81%E7%94%A8%E6%9C%BA%E5%99%A8%E6%8C%87%E4%BB%A4%E5%92%8C%E6%B1%87%E7%BC%96%E6%8C%87%E4%BB%A4%E7%BC%96%E7%A8%8B/","content":"\n1）D命令也提供了一种符合CPU机理的格式：“d 段寄存器：偏移地址”，以段寄存器中的数据为段地址SA，列出从SA：偏移地址开始的内存区间中的数据\n查看从ds:0开始的内存区间中的内容：\n查看当前代码段和栈段中的内容：\n2）在E、A、U命令中使用段寄存器\n3）在Debug中，用A命令写一段程序\n在用T命令执行mov ss,ax的时候，它的下一条指令mov sp,10也紧接着执行了不单是mov ss,ax，对于如mov ss,bx    mov ss,[0]    pop ss等指令都会发生这种情况，这些指令的共性是都是修改栈段寄存器SS的指令\nDebug的T命令在执行修改寄存器SS的指令时，下一条指令也紧接着被执行\n","categories":["计算机理论"],"tags":["汇编语言-《汇编语言(第4版)》"]},{"title":"BX和loop指令","url":"/2020/07/31/%E8%AE%A1%E7%AE%97%E6%9C%BA%E7%90%86%E8%AE%BA/%E6%B1%87%E7%BC%96%E8%AF%AD%E8%A8%80/%E3%80%8A%E6%B1%87%E7%BC%96%E8%AF%AD%E8%A8%80(%E7%AC%AC4%E7%89%88)%E3%80%8B/7_%5BBX%5D%E5%92%8Cloop%E6%8C%87%E4%BB%A4/","content":"——————————————————————————5.1.[BX]5.2.Loop指令5.3.在Debug中跟踪用loop指令实现的循环程序5.4.Debug和汇编编译器masm对指令的不同处理5.5.loop和[bx]的联合应用5.6.段前缀5.7.一段安全的空间5.8.段前缀的使用——————————————————————————\n要完整的描述一个内存单元，需要两种信息：内存单元的地址、内存单元的长度（类型）\n用[0]表示一个内存单元时，0表示单元的偏移地址，段地址默认在ds中，单元的长度（类型）可以由具体指令中的其他操作对象（比如说寄存器）指出\n[bx]同样也表示一个内存单元，它的偏移地址在bx中\nloop：循环\n用一个描述性的符号“（）”来表示一个寄存器或一个内存单元中的内容，（）中的内存单元的地址为物理地址\n（）中的元素可以有3种类型：寄存器名、段寄存器名、内存单元的物理地址（一个20位数据）\n约定符号idata表示常量——————————————————\n\n———————————————\nloop指令的格式是：loop 标号CPU执行loop指令的时候，要进行两步操作：(cx)&#x3D;(cx)-1、判断cx中的值，不为零则转至标号处执行程序，如果为零则向下执行【通常，我们用loop指令来实现循环功能，cx中存放循环次数】\nassume cs:codecode segment    mov ax,2    mov cx,11s:    add ax,ax    loop s\nmov ax,4c00h\nint 21h\n\ncode endsend\n1）在cx中存放循环次数2）loop指令中的标号所标识地址要在前面3）要循环执行的程序段，要写在标号和loop指令的中间——————————————\n在Debug中跟踪用loop指令实现的循环程序：\n1）标号s前的指令我们已经确定在逻辑上完全正确，不想再一步一步跟踪了（g IP，直接跳转到IP值处）\n2）循环也不想再一步一步跟踪了（遇到loop，直接p）\n———————————————————\nDebug和汇编编译器masm对指令的不同处理：\n","categories":["计算机理论"],"tags":["汇编语言-《汇编语言(第4版)》"]},{"title":"寄存器(内存访问)","url":"/2020/07/31/%E8%AE%A1%E7%AE%97%E6%9C%BA%E7%90%86%E8%AE%BA/%E6%B1%87%E7%BC%96%E8%AF%AD%E8%A8%80/%E3%80%8A%E6%B1%87%E7%BC%96%E8%AF%AD%E8%A8%80(%E7%AC%AC4%E7%89%88)%E3%80%8B/4_%E5%AF%84%E5%AD%98%E5%99%A8(%E5%86%85%E5%AD%98%E8%AE%BF%E9%97%AE)/","content":"寄存器(内存访问)：\n——————————————————3.1.内存中字的存储3.2.DS和[address]3.3.字的传送3.4.mov、add、sub指令3.5.数据段3.6.栈3.7.CPU提供的栈机制3.8.栈顶超界的问题3.9.push、pop指令3.10.栈段——————————————————\nCPU中，用16位寄存器来存储一个字，高8位存放高位字节，低八位存放低位字节。在内存中存储时，由于内存单元是字节单位（一个单元存放一个字节），则一个字要用两个地址连续的内存单元来存放，这个字的低位字节存放在低地址单元中，高位字节存放在高地址单元中\n将起始地址为N的字单元简称为N地址字单元\n任何两个地址连续的内存单元，N号单元和N+1号单元，可以将它们看成两个内存单元，也可看成一个地址为N的字单元中的高位字节单元和低位字节单元——————————\nCPU要读写一个内存单元的时候，必须先给出这个内存单元的地址，在8086PC中，内存地址由段地址和偏移地址组成，8086CPU中有一个DS寄存器，通常用来存放要访问数据的段地址\n可以使用mov指令将一个内存单元中的内容送入一个寄存器中：mov 寄存器名，内存单元地址\n“[…]”表示一个内存单元，“[…]”中的0表示内存单元的偏移地址，指令执行时，8086CPU自动取ds中的数据为内存单元的段地址\n8086CPU不支持将数据直接送入段寄存器的操作，ds是一个段寄存器，所以mov ds,1000H这条指令是非法的——————————\n8086CPU是16位结构，有16根数据线，所以可以一次性传送16位的数据，也就是说可以一次性传送一个字，只要在mov指令中给出16位的寄存器就可以进行16位数据的传送了\n——————————\nmov 寄存器，段寄存器mov 内存单元，段寄存器mov 段寄存器，内存单元\nmov、add、sub是具有两个操作对象的指令，jmp是具有一个操作对象的指令——————————\n我们可以将一组长度为N（N&lt;&#x3D;64KB）、地址连续、起始地址为16的倍数的内存单元当作专门存储数据的内存空间，从而定义了一个数据段\n——————————\n栈是一种具有特殊的访问方式的存储空间，最后进入这个空间的数据，最先出去，栈的这种操作规则被称为：LIFO（Last In First Out，后进先出）——————————\n8086CPU提供相关的指令来以栈的方式访问内存空间，这意味着，在基于8086CPU编程的时候，可以将一段内存当作栈来使用：PUSH（入栈）和POP（出栈），8086CPU的入栈和出栈操作都是以字为单位进行的\nCS、IP中存放着当前指令的段地址和偏移地址8086CPU中，有两个寄存器，段寄存器SS和寄存器SP，栈顶的段地址存放在SS中，偏移地址存放在SP中，任意时刻，SS：SP指向栈顶元素，push指令和pop指令执行时，CPU从SS和SP中得到栈顶的地址\n——————————————\n当栈满的时候再使用push指令入栈，或栈空的时候再使用pop指令出栈，都将发生栈顶越界问题\n——————————————\npush和pop指令是可以在寄存器和内存之间传送数据的\n栈空间也是内存空间的一部分，它只是一段可以以一种特殊的方式进行访问的内存空间\n注意：push、pop等栈操作指令，修改的只是SP，也就是说，栈顶的变化范围最大为0～FFFFH\n提供SS、SP指示栈顶，改变SP后写内存的入栈指令，读内存后改变SP的出栈指令，这就是8086CPU提供的栈操作机制—————————————————\n在编程时，可以根据需要，将一组内存单元定义为一个段，我们可以将长度为N（N&lt;&#x3D;64KB）的一组地址连续、起始地址为16的倍数的内存单元，当作栈空间来用，从而定义了一个栈段\n","categories":["计算机理论"],"tags":["汇编语言-《汇编语言(第4版)》"]},{"title":"寄存器(CPU工作原理)","url":"/2020/07/31/%E8%AE%A1%E7%AE%97%E6%9C%BA%E7%90%86%E8%AE%BA/%E6%B1%87%E7%BC%96%E8%AF%AD%E8%A8%80/%E3%80%8A%E6%B1%87%E7%BC%96%E8%AF%AD%E8%A8%80(%E7%AC%AC4%E7%89%88)%E3%80%8B/2_%E5%AF%84%E5%AD%98%E5%99%A8(CPU%E5%B7%A5%E4%BD%9C%E5%8E%9F%E7%90%86)/","content":"—————————————————2.1.通用寄存器2.2.字在寄存器中的存储2.3.几条汇编指令2.4.物理地址2.5.16位结构的CPU2.6.8086CPU给出物理地址的方法2.7.“段地址*16+偏移地址&#x3D;物理地址”的本质含义2.8.段的概念2.9.段寄存器2.10.CS和IP2.11.修改CS、IP的指令2.12.代码段—————————————————\n一个典型的CPU由运算器、控制器、寄存器(CPU工作原理)等器件组成，这些器件靠内部总线相连\n内部总线实现CPU内部各个器件之间的联系，外部总线实现CPU和主板上其他器件的联系\n在CPU中：1）运算器进行信息处理2）寄存器进行信息存储3）控制器控制各种器件进行工作4）内部总线连接各种器件，在他们之间进行数据的传送\n对于一个汇编程序员来说，CPU中的主要部件是寄存器，寄存器是CPU中程序员可以用指令读写的部件，程序员通过改变各种寄存器中的内容来实现对CPU的控制\n8086CPU有14个寄存器，它们的名称为：AX，BX，CX，DX，SI，DI，SP，BP，CS，IP，SS，DS，ES，PSW\n8086CPU所有的寄存器都是16位的，可以存放两个字节，AX、BX、CX、DX通常用来存放一般性数据被称为通用寄存器\n一个16位寄存器可以存储一个16位的数据，所能存储的数据的最大值为2^16-1\n8086上一代CPU中的寄存器都是8位的，为保证兼容性，这四个通用寄存器都可以分为两个独立的8位寄存器使用AX可以分为AH和ALBX可以分为BH和BLCX可以分为CH和CLDX可以分为DH和DL—————————\n出于对兼容性的考虑，8086CPU可以一次性处理以下两种尺寸的数据：1）字节：记为byte，一个字节由8个bit组成，可以存在8位寄存器中2）字：记为word，一个字由两个字节组成，这两个字节分别称为这个字的高位字节和低位字节\n为了区分不同的进制，在十六进制表示的数据的后面加H，在二进制表示的数据的后面加B—————————\n在写一条汇编指令或一个寄存器的名称时不区分大小写：—————————\nCPU访问内存单元时，要给出内存单元的地址，所有的内存单元构成的存储空间是一个一维的线性空间，每一个内存单元在这个空间中都有唯一的地址，我们将这个唯一的地址称为物理地址\nCPU通过地址总线送入存储器的，必须是一个内存单元的物理地址。在CPU向地址总线上发出物理地址之前，必须要在内部先形成这个物理地址，不同的CPU可以有不同的形成物理地址的方式—————————\n概括来讲，16位结构描述了一个CPU具有下面几方面的结构特性：1）运算器一次最多可以处理16位的数据2）寄存器的最大宽度为16位3）寄存器和运算器之间的通路为16位—————————\n8086CPU给出物理地址的方法：\n8086CPU有20位地址总线，又是16位结构，采用一种在内部用两个16位地址合成的方法来形成一个20位的物理地址\n当8086CPU要读写内存时：1）CPU中的相关部件提供两个16位的地址，一个称为段地址，另一个称为偏移地址2）段地址和偏移地址通过内部总线送入一个称为地址加法器的部件3）地址加法器将两个16位地址合成为一个20位的物理地址4）地址加法器通过内部总线将20位物理地址送入输入输出控制电路5）输入输出控制电路将20位物理地址送上地址总线6）20位物理地址被地址总线传送到存储器\n——————————\n“段地址16+偏移地址&#x3D;物理地址”的本质含义是：CPU在访问内存时，用一个基础地址（段地址16）和一个相对于基础地址的偏移地址相加，给出内存单元的物理地址——————————\n在编程时可以根据需要，将若干地址连续的内存单元看作一个段，用段地址16定位段的起始地址（基础地址），用偏移地址定位段中的内存单元1）段地址16必然是16的倍数，所以一个段的起始地址也一定是16的倍数2)偏移地址为16位，16位地址的寻址能力为64KB，所以一个段的长度最大为64KB——————————\n段地址在8086CPU的段寄存器中存放，8086CPU有4个段寄存器：CS，DS，SS，ES——————————\nCS和IP是8086CPU中两个最关键的寄存器，它们指示了CPU当前要读取指令的地址，CS为代码段寄存器，IP为指令指针寄存器\n在8086PC机中，任意时刻，设CS中的内容为M，IP中的内容为N，8086CPU将从内存M*16+N单元开始，读取一条指令并执行\n8086CPU读取、执行一条指令的过程：\n1）从CS：IP指向的内存单元读取指令，读取的指令进入指令缓冲器2）IP&#x3D;IP+所读取指令的长度，从而指向下一条指令3）执行指令，转到步骤1），重复这个过程\nCPU将CS：IP指向的内存单元中的内容看作指令—————————\n程序员可以通过改变CS、IP中的内容来控制CPU执行目标指令\n8086CPU大部分寄存器的值，都可以用mov指令来改变，mov指令被称为传送指令，但是mov指令不能用于设置CS、IP的值；能够改变CS、IP的内容的指令被统称为转移指令（jmp指令）\n若想仅修改IP的内容，可用形如“jmp 某一合法寄存器”的指令完成：\n——————————\n","categories":["计算机理论"],"tags":["汇编语言-《汇编语言(第4版)》"]},{"title":"第一个程序","url":"/2020/07/31/%E8%AE%A1%E7%AE%97%E6%9C%BA%E7%90%86%E8%AE%BA/%E6%B1%87%E7%BC%96%E8%AF%AD%E8%A8%80/%E3%80%8A%E6%B1%87%E7%BC%96%E8%AF%AD%E8%A8%80(%E7%AC%AC4%E7%89%88)%E3%80%8B/6_%E7%AC%AC%E4%B8%80%E4%B8%AA%E7%A8%8B%E5%BA%8F/","content":"———————————————————4.1.一个源程序从写出到执行的过程4.2.源程序4.3.编辑源程序4.4.编译4.5.连接4.6：1.exe的执行4.7.谁将可执行文件中的程序装载进入内存并使它运行？4.8.程序执行过程的跟踪———————————————————\n1）编写汇编源程序：使用文本编辑器，用汇编语言编写汇编源程序，这一步工作的结果是产生了一个存储源程序的文本文件2）对源程序进行编译连接：使用汇编语言编译程序对源程序文件中的源程序进行编译，产生目标文件；再用连接程序对目标文件进行连接，生成可在操作系统中直接运行的可执行文件\n可执行文件包含两部分内容：程序（从源程序中的汇编指令翻译过来的机器码）和数据（源程序中定义的数据）、相关的描述信息（比如程序有多大、要占用多少内存空间）\n这一步工作的结果，产生了一个可在操作系统中运行的可执行文件\n3）执行可执行文件中的程序，在操作系统中，执行可执行文件中的程序，操作系统依照可执行文件中的描述信息，将可执行文件中的机器码和数据加载入内存，并进行相关的初始化（比如设置CS：IP指向第一条要执行的指令），然后由CPU执行程序———————————————\n1)伪指令：在汇编语言源程序中，包含两种指令，一种是汇编指令，一种是伪指令。汇编指令是有对应的机器码的指令，可以被编译为机器指令，最终为CPU所执行。而伪指令没有对应的机器指令，最终不被CPU所执行，伪指令是由编译器来执行的指令，编译器根据伪指令来进行相关的编译工作\nsegment和ends是一对成对使用的伪指令，功能是定义一个段end是一个汇编程序的结束标记，标记整个程序的结束assume假设某一段寄存器和程序中的某一个用segment…ends定义的段相关联2）源程序中的“程序”\n3）标号：一个标号指代了一个地址，比如codesg在segment的前面，作为一个段的名称，这个段的名称最终将被编译、连接程序处理为一个段的段地址4）程序的结构5）程序返回：一个程序结束后，将CPU的控制权交还给使它得以运行的程序，称这个过程为程序返回\n6）语法错误和逻辑错误程序在编译时被编译器发现的错误是语法错误在源程序编译后，在运行时发生的错误是逻辑错误，语法错误容易发现，也容易解决，而逻辑错误通常不容易被发现——————————————\n编辑源程序：\n可以用任意的文本编辑器来编辑源程序，只要最终将其存储为纯文本文件即可\n———————————————\n编译：在编译过程中，我们提供了一个输入，即源程序文件，最多可以得到3个输出：目标文件（.obj）、列表文件（.lst）、交叉引用文件（.crf），这3个输出文件中，目标文件是我们最终要得到的结果，而另外两个只是中间结果\n———————————————\n连接：连接的作用：\n最终生成3个文件：————————————————\n1.exe的执行：————————————————\n在DOS中直接执行1.exe时，是正在运行的command，将1.exe中的程序加载入内存，command设置CPU的CS：IP指向程序的第一条指令（即程序的入口），从而使程序得以运行，程序运行结束后，返回到command中，CPU继续运行command\n————————————————\n程序执行过程的跟踪（Debug）：\n为了观察程序的运行过程，可以使用Debug，Debug可以将程序加载入内存，设置CS：IP指向程序的入口，但Debug并不放弃对CPU的控制\nCX中存放的是程序的长度，1.exe中程序的机器码共有15个字节\nDS的值为075A，则PSP的地址为075A：0，程序的地址为076A：0（即075A+10:0）\n源程序中的指令是mov ax,0123H，在Debug中记为mov ax,0123，这是因为Debug默认所有数据都用十六进制表示\n可以用U命令看一下其他指令：\nT命令单步执行程序中的每一条指令：\n到了int 21，我们要用P命令执行：\n","categories":["计算机理论"],"tags":["汇编语言-《汇编语言(第4版)》"]},{"title":"封装","url":"/2018/10/15/%E8%AE%A1%E7%AE%97%E6%9C%BA%E7%90%86%E8%AE%BA/%E7%BC%96%E7%A8%8B%E8%AF%AD%E8%A8%80/C++/10_%E5%B0%81%E8%A3%85/","content":"C++面向对象的三大特征：封装、继承、多态\nC++认为万事万物皆为对象，对象上有其属性和行为\n封装的意义：1）将属性和行为作为一个整体，表现生活中的事物2）将属性和行为加以权限控制【public：公共权限(类内可以访问，类外可以访问)、protected：保护权限(类内可以访问，类外不可以访问)、private：私有权限(类内可以访问，类外不可以访问)】\nStruct和class的区别（都可以表示一个类）：1）struct默认权限为公共2）class默认权限为私有\n将成员属性设置为私有的优点：1）可以自己控制读写权限【提供一个public接口让外界访问】2）对于写权限，我们可以检测数据的有效性\n","categories":["计算机理论"],"tags":["编程语言-C++"]},{"title":"友元","url":"/2018/10/15/%E8%AE%A1%E7%AE%97%E6%9C%BA%E7%90%86%E8%AE%BA/%E7%BC%96%E7%A8%8B%E8%AF%AD%E8%A8%80/C++/13_%E5%8F%8B%E5%85%83/","content":"在程序里，有些私有属性也想让类外特殊的一些函数或者类进行访问，就需要用到友元的技术\n友元的目的就是让一个函数或者类访问另一个类中的私有成员，友元的关键字为friend\n友元的三种实现：1）全局函数做友元2）类做友元3）成员函数做友元\n全局函数做友元：\n友元类（类做友元）：\n成员函数做友元【为啥顺序不能变？？】：\n#include&lt;iostream&gt;**using** **namespace** std;**class** Building;**class** goodGay&#123;    **public**:        Building *building;        //可访问Building中的私有成员    **void** visit();        //不可访问Building中的私有成员    **void** visit1();        goodGay();    &#125;;**class** Building&#123;    **friend** **void** goodGay::visit();//表示goodGay类中的成员函数visit()作为本类的好朋友    **public**:        Building()&#123;        SittingRoom = “客厅”;        BedRoom = “卧室”;    &#125;    **public**:    string SittingRoom;    **private**:    string BedRoom;    &#125;;goodGay::goodGay()&#123;    building = **new** Building;&#125;**void** goodGay::visit()&#123;    cout&lt;&lt;“visit函数正在访问：”&lt;&lt;building-&gt;SittingRoom&lt;&lt;endl;    cout&lt;&lt;“visit函数正在访问：”&lt;&lt;building-&gt;BedRoom&lt;&lt;endl;&#125;**void** goodGay::visit1()&#123;    cout&lt;&lt;“visit2函数正在访问：”&lt;&lt;building-&gt;SittingRoom&lt;&lt;endl;    //cout&lt;&lt;“visit函数正在访问：”&lt;&lt;building-&gt;BedRoom&lt;&lt;endl;&#125;**int** main()&#123;    goodGay gg;    gg.visit();    gg.visit1();&#125;","categories":["计算机理论"],"tags":["编程语言-C++"]},{"title":"C++对象模型和this指针","url":"/2018/10/15/%E8%AE%A1%E7%AE%97%E6%9C%BA%E7%90%86%E8%AE%BA/%E7%BC%96%E7%A8%8B%E8%AF%AD%E8%A8%80/C++/12_C++%E5%AF%B9%E8%B1%A1%E6%A8%A1%E5%9E%8B%E5%92%8Cthis%E6%8C%87%E9%92%88/","content":"——————成员变量和成员函数分开存储：\n在C++中，类内的成员变量和成员函数分开存储\n只有非静态成员变量才属于类的对象上\n—————————this指针：\n每一个非静态成员函数只会诞生一份函数实例，也就是说多个同类型的对象会共用一块代码，那么这一块代码是如何区分哪个对象调用自己的呢？\nC++通过提供特殊的对象指针，this指针，解决上述问题，this指针指向被调用的成员函数所属的对象\nThis指针是隐含每一个非静态成员函数内的一种指针，不需要定义，直接使用即可\nThis指针的用途：1）当形参和成员变量同名时，可用this指针来区分2）在类的非静态成员函数中返回对象本身，可使用return *this；\n———————————空指针访问成员函数：\nC++中空指针也是可以调用成员函数的，但是也要注意有没有用到this指针\n如果用到this指针，需要加以判断保证代码的健壮性\n——————————const修饰成员函数：\n常函数：成员函数后加const后我们称这个函数为常函数；常函数内不可以修改成员属性；成员属性声明时加关键字mutable后，在常函数中依然可以修改\n常对象：声明对象前加const称该对象为常对象，常对象只能调用常函数\n","categories":["计算机理论"],"tags":["编程语言-C++"]},{"title":"C++运算符重载","url":"/2018/10/15/%E8%AE%A1%E7%AE%97%E6%9C%BA%E7%90%86%E8%AE%BA/%E7%BC%96%E7%A8%8B%E8%AF%AD%E8%A8%80/C++/14_C++%E8%BF%90%E7%AE%97%E7%AC%A6%E9%87%8D%E8%BD%BD/","content":"运算符重载：对已有的运算符重新进行定义，赋予其另一种功能，以适应不同的数据类型\n加号运算符重载：实现两个自定义数据类型相加的计算【对于内置的数据类型的表达式的运算符是不可能改变的；不要滥用运算符重载】\n左移运算符重载：可以输出自定义数据类型\n递增运算符重载：通过重载递增运算符，实现自己的整型数据\n赋值运算符重载：\nC++编译器至少给一个类添加4个函数：1）默认构造函数（无参，函数体为空）2）默认析构函数（无参，函数体为空）3）默认拷贝构造函数，对属性进行值拷贝4）赋值运算符operator&#x3D;，对属性进行值拷贝\n如果类中有属性指向堆区，做赋值操作时也会出现深浅拷贝问题\n关系运算符重载：重载关系运算符，可以让两个自定义类型对象进行对比操作\n函数调用运算符()重载：由于重载后使用的方式非常像函数的调用，因此称为仿函数；仿函数没有固定的写法，非常灵活\n","categories":["计算机理论"],"tags":["编程语言-C++"]},{"title":"多态","url":"/2018/10/15/%E8%AE%A1%E7%AE%97%E6%9C%BA%E7%90%86%E8%AE%BA/%E7%BC%96%E7%A8%8B%E8%AF%AD%E8%A8%80/C++/16_%E5%A4%9A%E6%80%81/","content":"多态是C++面向对象三大特性之一\n多态分为两类：1）静态多态：函数重载和运算符重载属于静态多态，复用函数名2）动态多态：派生类和虚函数实现运行时多态\n静态多态和动态多态的区别：1）静态多态的函数地址早绑定，编译阶段确定函数地址2）动态多态的函数地址晚绑定，运行阶段确定函数地址\n多态的底层原理：\n分别利用普通写法和多态技术，设计实现两个操作数进行运算的计算器类：\n多态的优点：代码组织结构清晰、可读性强、利于前期和后期的扩展以及维护\n纯虚函数和抽象类：在多态中，通常父类中虚函数的实现是毫无意义的，主要都是调用子类重写的内容，因此可以将虚函数改为纯虚函数，当类中有了纯虚函数，这个类也称为抽象类\n抽象类特点：1）无法实例化对象2）子类必须重写抽象类中的纯虚函数，否则也属于抽象类\n虚析构和纯虚析构：\n多态使用时，如果子类中有属性开辟到堆区，那么父类指针在释放时无法调用到子类的析构代码\n解决方式：将父类中的析构函数改为虚析构或者纯虚析构\n虚析构和纯虚析构共性：1）可以解决父类指针释放子类对象2）都需要有具体的函数实现\n虚析构和纯虚析构的区别：如果是纯虚析构，该类属于抽象类，无法实例化对象\n","categories":["计算机理论"],"tags":["编程语言-C++"]},{"title":"C++文件操作","url":"/2018/10/15/%E8%AE%A1%E7%AE%97%E6%9C%BA%E7%90%86%E8%AE%BA/%E7%BC%96%E7%A8%8B%E8%AF%AD%E8%A8%80/C++/17_C++%E6%96%87%E4%BB%B6%E6%93%8D%E4%BD%9C/","content":"程序运行时产生的数据都属于临时数据，程序一旦运行结束都会被释放，通过文件可以将数据持久化\nC++中对文件操作需要包含头文件\n文件类型分为两种：1）文本文件：文件以文本的ASCII码形式存储在计算机中2）二进制文件：文件以文本的二进制形式存储在计算机中，用户一般不能直接读懂它们\n操作文件的三大类：1）ofstream：写操作2）ifstream：读操作3）fstream：读写操作\n文本文件：\n写文件的步骤：1）包含头文件：#include2）创建流对象：ofstream ofs;3）打开文件：ofs.open(“文件路径”,打开方式);4）写数据：ofs&lt;&lt;“写入的数据”;5）关闭文件：ofs.close();\n文件打开方式【文件打开方式可以配合使用，利用|操作符】：1）ios::in        为读文件而打开文件2）ios::out     为写文件而打开文件3）ios::ate     初始位置：文件尾4）ios::app    追加方式写文件5）ios::trunc  如果文件存在先删除，再创建6）iOS::binary  二进制方式\n读文件的步骤：1）包含头文件：#include2）创建流对象：ifstream ifs;3）打开文件并判断文件是否打开成功：ifs.open(“文件路径”,打开方式);4）读数据：四种方式读取5）关闭文件：ifs.close();\n二进制文件：以二进制的方式对文件进行读写操作，打开方式要指定为ios::binary\n二进制方式写文件主要利用流对象调用成员函数write函数原型：ostream&amp; write(const char * buffer,int len);参数解释：字符指针buffer指向内存中的一段存储空间，len是读写的字节数\n二进制方式读文件主要利用流对象调用成员函数read函数原型：istream&amp; read(char *buffer,int len);参数解释：字符指针buffer指向内存中的一段存储空间，len是读写的字节数\n","categories":["计算机理论"],"tags":["编程语言-C++"]},{"title":"函数模板","url":"/2018/10/15/%E8%AE%A1%E7%AE%97%E6%9C%BA%E7%90%86%E8%AE%BA/%E7%BC%96%E7%A8%8B%E8%AF%AD%E8%A8%80/C++/19_%E5%87%BD%E6%95%B0%E6%A8%A1%E6%9D%BF/","content":"模板就是建立通用的模具，大大提高复用性\n模板的特点：模板不可以直接使用，它只是一个框架；模板的通用并不是万能的\n———————————————函数模板：\nC++另一种编程思想称为泛型编程，主要利用的技术就是模板\nC++提供两种模板机制：函数模板和类模板\n函数模板的作用：建立一个通用函数，其函数返回值类型和形参类型可以不具体制定，用一个虚拟的类型来代表\n函数模板注意事项：1）自动类型推导，必须推导出一致的数据类型T才可以使用2）模板必须要确定出T的数据类型，才可以使用\n\n普通函数与函数模板的区别：1）普通函数调用时可以发生自动类型转换（隐式类型转换）2）函数模板调用时，如果利用自动类型推导，不会发生隐式类型转换；如果利用显式指定类型的方式，可以发生隐式类型转换\n建议使用显示指定类型的方式，调用函数模板，因为可以自己确定通用类型T\n普通函数与函数模板的调用规则：1）如果函数模板和普通函数都可以实现，优先调用普通函数2）可以通过空模板参数列表来强制调用函数模板3）函数模板也可以发生重载4）如果函数模板可以产生更好的匹配，优先调用函数模板\n模板的局限性：模板的通用性并不是万能的\n因此C++为了解决这种问题，提供模板的重载，可以为这些特定的类型提供具体化的模板\n","categories":["计算机理论"],"tags":["编程语言-C++"]},{"title":"对象的初始化和清理","url":"/2018/10/15/%E8%AE%A1%E7%AE%97%E6%9C%BA%E7%90%86%E8%AE%BA/%E7%BC%96%E7%A8%8B%E8%AF%AD%E8%A8%80/C++/11_%E5%AF%B9%E8%B1%A1%E7%9A%84%E5%88%9D%E5%A7%8B%E5%8C%96%E5%92%8C%E6%B8%85%E7%90%86/","content":"—————1、构造函数和析构函数：\nC++中的面向对象来源于生活，每个对象也都会有初始设置以及对象销毁前的清理数据的设置\n构造函数和析构函数：对象的初始化和清理是两个非常重要的安全问题，一个对象或者变量没有初始状态，对其使用后果是未知的，同样的使用完一个对象或变量没有及时清理，也会造成一定的安全问题；C++利用了构造函数和析构函数解决上述问题，这两个函数将会被编译器自动调用，完成对象初始化和清理工作；\n对象的初始化和清理工作是编译器强制要我们做的事情，因此如果我们不提供构造和析构，编译器会提供；但是编译器提供的构造函数和析构函数是空实现\n构造函数：主要作用于创建对象时为对象的成员属性赋值，构造函数由编译器自动调用，无须手动调用析构函数：主要作用在对象销毁前系统自动调用，执行一些清理工作\n构造函数语法：类名(){}1）构造函数没有返回值也不写void2）函数名称与类名相同3）构造函数可以有参数，因此可以发生重载4）程序在调用对象时会自动调用构造，无须手动调用，而且只会调用一次\n析构函数语法：～类名(){}1）析构函数没有返回值也不写void2）函数名称与类名相同，在名称前加上符号～3）析构函数不可以有参数，因此不可以发生重载4）程序在对象销毁前会自动调用析构，无须手动调用，而且只会调用一次\n——————————2、构造函数的分类及调用：\n两种分类方式：1）按参数分类：有参构造和无参构造2）按类型分类：普通构造和拷贝构造\n三种调用方式：括号法、显示法、隐式转换法\n——————3、拷贝构造函数调用时机：\nC++中拷贝构造函数调用时机通常有三种情况：1）使用一个已经创建完毕的对象来初始化一个新对象2）值传递的方式给函数参数传值3）以值方式返回局部对象—————————4、构造函数调用规则：\n默认情况下，C++编译器至少给一个类添加三个函数：1）默认构造函数（无参，函数体为空）2）默认析构函数（无参，函数体为空）3）默认拷贝构造函数，对属性进行值拷贝\n构造函数调用规则：1）如果用户定义有参构造函数，C++不再提供默认无参构造函数，但是会提供默认拷贝构造2）如果用户定义拷贝构造函数，C++不会再提供其他构造函数\n—————————5、深拷贝与浅拷贝\n浅拷贝：简单的赋值拷贝操作深拷贝：在堆区重新申请空间，进行拷贝操作—————————6、初始化列表：\nC++提供了初始化列表语法，用来初始化属性\n———————————7、类对象作为类成员\nC++类中的成员可以是另一个类的对象，我们称该成员为对象成员\n————8、静态成员\n静态成员就是在成员变量和成员函数前加上关键字static，称为静态成员\n静态成员分为：1）静态成员变量：所有对象共享同一份数据，在编译阶段分配内存，类内声明，类外初始化2）静态成员函数：所有对象共享同一个函数，静态成员函数只能访问静态成员变量\n","categories":["计算机理论"],"tags":["编程语言-C++"]},{"title":"继承","url":"/2018/10/15/%E8%AE%A1%E7%AE%97%E6%9C%BA%E7%90%86%E8%AE%BA/%E7%BC%96%E7%A8%8B%E8%AF%AD%E8%A8%80/C++/15_%E7%BB%A7%E6%89%BF/","content":"继承是面向对象三大特性之一\n定义某些类时，下级别的成员除了拥有上一级的共性，还有自己的特性，这个时候我们就可以考虑利用继承的技术，减少重复代码\n继承方式：公共继承、保护继承、私有继承\n继承中的对象模型：\n继承中的构造和析构顺序：子类继承父类后，当创建子类对象，也会调用父类的构造函数；先构造父类，再构造子类，析构的顺序与构造的顺序相反\n继承同名成员处理方式：\n当子类与父类出现同名的成员，如何通过子类对象访问到子类或者父类中同名的数据呢？1）访问子类同名成员，直接访问即可2）访问父类同名成员，需要加作用域\n继承同名静态成员处理方式：静态成员和非静态成员出现同名，处理方式一致；访问子类同名成员，直接访问即可；访问父类同名成员，需要加作用域\n多继承：C++允许一个类继承多个类，多继承可能会引发父类中有同名成员出现，需要加作用域区分；C++实际开发中不建议用多继承class Son:public Base1,public Base2\n菱形继承：两个派生类继承同一个基类，又有某个类同时继承着两个派生类，这种继承被称为菱形继承，或者钻石继承\n出现的问题：1）羊继承了动物的数据，驼同样继承了动物的数据，当羊驼使用数据时，就会产生二义性2）羊驼继承自动物的数据继承了两份，但是这份数据我们只需要一份就可以\n","categories":["计算机理论"],"tags":["编程语言-C++"]},{"title":"C++基础","url":"/2018/10/15/%E8%AE%A1%E7%AE%97%E6%9C%BA%E7%90%86%E8%AE%BA/%E7%BC%96%E7%A8%8B%E8%AF%AD%E8%A8%80/C++/1_C++%E5%9F%BA%E7%A1%80/","content":"常量：用于记录程序中不可更改的数据\nC++定义常量的两种方式：1）#define 常量名 常量值2）const修饰的变量\n利用sizeof关键字可以统计数据类型所占内存的大小【sizeof（数据类型&#x2F;变量）】\n字符型变量并不是把字符本身放到内存中存储，而是将对应的ASCII编码放入到存储单元【a-97，A-65】\n水平制表符\\t：可以整齐的输出数据，水平制表符与前面的字符永远占据八个空格\n反斜杠：\\\n两种风格字符串：1）C风格字符串：char 变量名[] &#x3D; “字符串值”2）C++风格字符串：string 变量名 &#x3D; “字符串值”【使用这种风格字符串时要包含一个头文件#include 】\nCin数据的输入Cout数据的输出\nBool类型非零即真\n算术运算符【+(正号)、-(负号)、+、-、、&#x2F;、%、++、- -】赋值运算符【&#x3D;、+&#x3D;、-&#x3D;、&#x3D;、&#x2F;&#x3D;、%&#x3D;】比较运算符【&#x3D;&#x3D;、！&#x3D;、&lt;、&gt;、&lt;&#x3D;、&gt;&#x3D;】逻辑运算符【！非、&amp;&amp;与、||或】\n前置递增先对变量进行++，再计算表达式后置递增先计算表达式，后对变量进行++\n程序流程结构：顺序结构、选择结构【if语句、三目运算符、switch语句】、循环结构【while、do  while、for】\n跳转语句：break、continue、goto\nBreak出现在switch条件语句中，作用是终止case并跳出switch，出现在循环语句中，作用是跳出当前的循环语句，出现在嵌套循环中，跳出最近的内层循环语句\nContinue在循环语句中跳过本次循环中余下尚未执行的语句，继续执行下一次循环【可以筛选条件，奇数输出，偶数不输出】\nGoto语句：无条件的跳转语句\n三目运算符：表达式1？表达式2:表达式3\n在C++中三目运算符返回的是变量，可以继续赋值\nSwitch语句中的表达式类型只能是整型或者字符型\n系统生成随机数：rand()%100，会生成0～99的随机数【伪随机数】\n添加随机数种子，利用当前系统时间生成随机数，防止每次随机数都一样：\n#include&lt;ctime&gt;srand((unsigned int)time(NULL));","categories":["计算机理论"],"tags":["编程语言-C++"]},{"title":"类模板","url":"/2018/10/15/%E8%AE%A1%E7%AE%97%E6%9C%BA%E7%90%86%E8%AE%BA/%E7%BC%96%E7%A8%8B%E8%AF%AD%E8%A8%80/C++/20_%E7%B1%BB%E6%A8%A1%E6%9D%BF/","content":"","categories":["计算机理论"],"tags":["编程语言-C++"]},{"title":"数组","url":"/2018/10/15/%E8%AE%A1%E7%AE%97%E6%9C%BA%E7%90%86%E8%AE%BA/%E7%BC%96%E7%A8%8B%E8%AF%AD%E8%A8%80/C++/2_%E6%95%B0%E7%BB%84/","content":"一维数组的定义方式：1）数据类型  数组名[数组长度];2）数据类型  数组名[数组长度]&#x3D;{值1，值2…};3）数据类型  数组名[]&#x3D;{值1，值2…};\n如果在初始化数据的时候，没有全部填写完，会用0来填补剩余数据\n一维数组名称的用途：1）可以统计整个数组在内存中的长度2）可以获取数组在内存中的首地址：cout&lt;&lt;arr&lt;&lt;endl；cout&lt;&lt;&amp;arr[0]&lt;&lt;endl;\n数组名是一个常量，不可以进行赋值操作\n二维数组定义方式：1）数据类型  数组名[行数][列数]；2）数据类型  数组名[行数][列数]&#x3D;｛｛数据1，数据2｝，｛数据3，数据4｝｝；3）数据类型  数组名[行数][列数]&#x3D;｛数据1，数据2，数据3，数据4｝；4）数据类型  数组名[][列数]&#x3D;{数据1，数据2，数据3，数据4};\n","categories":["计算机理论"],"tags":["编程语言-C++"]},{"title":"函数","url":"/2018/10/15/%E8%AE%A1%E7%AE%97%E6%9C%BA%E7%90%86%E8%AE%BA/%E7%BC%96%E7%A8%8B%E8%AF%AD%E8%A8%80/C++/3_%E5%87%BD%E6%95%B0/","content":"值传递的时候，形参发生任何的改变，都不会影响实参\n地址传递：利用指针作为函数的参数，可以修改实参的值\n函数的声明可以写多次，但是定义只能有一次\n函数的分文件编写：1）创建后缀名为.h的头文件，在头文件中写函数的声明2）创建后缀名为.cpp的源文件，在源文件中写函数的定义\n","categories":["计算机理论"],"tags":["编程语言-C++"]},{"title":"死锁","url":"/2020/06/15/%E8%AE%A1%E7%AE%97%E6%9C%BA%E7%90%86%E8%AE%BA/%E6%93%8D%E4%BD%9C%E7%B3%BB%E7%BB%9F%E5%8E%9F%E7%90%86/%E6%93%8D%E4%BD%9C%E7%B3%BB%E7%BB%9F%E5%8E%9F%E7%90%86%E9%9D%A2%E8%AF%95%E9%A2%98/2.10_%E6%AD%BB%E9%94%81/","content":"什么是死锁：在并发环境下，各进程因竞争资源而造成的一种互相等待对方手里的资源，导致各进程都阻塞，都无法向前推进的现象，就是“死锁”。发生死锁后若无外力干涉，这些进程都将无法向前推进\n进程死锁、饥饿、死循环的区别：\n\n死锁：各进程互相等待对方手里的资源，导致各进程都阻塞，无法向前推进的现象\n\n饥饿：由于长期得不到想要的资源，某进程无法向前推进的现象\n\n死循环：某进程执行过程中一直跳不出某个循环的现象。有时是因为程序逻辑bug导致的，有时是程序员故意设计的\n\n\n死锁产生的四个必要条件：（有一个条件不成立，则不会产生死锁）\n\n互斥条件：一个资源一次只能被一个进程使用\n请求与保持条件：一个进程因请求资源而阻塞时，对已获得资源保持不放\n不剥夺条件：进程获得的资源，在未完全使用完之前，不能强行剥夺\n循环等待条件：若干进程之间形成一种头尾相接的环形等待资源关系，发生死锁时一定有循环等待，但是发生循环等待时未必死锁\n\n死锁的处理策略：\n\n预防死锁（静态策略，不允许死锁发生）：破坏死锁产生的四个必要条件中的一个或几个\n避免死锁（动态策略，不允许死锁发生）：用某种方法防止系统进入不安全状态，从而避免死锁（银行家算法）\n死锁的检测和解除：允许死锁的发生，不过操作系统会负责检测出死锁的发生，然后采取某种措施解除死锁\n忽略该问题，例如鸵鸟算法，该算法可以应用在极少发生死锁的的情况下\n\n","categories":["计算机理论"],"tags":["操作系统原理-操作系统原理面试题"]},{"title":"指针","url":"/2018/10/15/%E8%AE%A1%E7%AE%97%E6%9C%BA%E7%90%86%E8%AE%BA/%E7%BC%96%E7%A8%8B%E8%AF%AD%E8%A8%80/C++/4_%E6%8C%87%E9%92%88/","content":"指针前加一个*代表解引用，找到指针指向的内存中的数据【*p】\n不管是什么数据类型，在32位操作系统上指针是占据4个字节空间大小，在64位操作系统上占据8个字节空间大小\nint *p &#x3D;NULL；空指针：指针变量指向内存中编号为0的空间，用来初始化指针变量，空指针指向的内存是不可以访问的【0～255之间的内存编号是系统占用的，因此不可以访问】\n野指针：指针变量指向非法的内存空间\n空指针和野指针都不是我们申请的空间，因此不要访问\nConst修饰指针的三种情况：1）const修饰指针：常量指针【const int *p&#x3D;&amp;a；指针的指向可以修改，但是指针指向的值不可以修改）2）const修饰常量：指针常量【int * const p&#x3D;&amp;a；指针的指向不可以改，指针指向的值可以改】3）const既修饰指针又修饰常量【const int * const p&#x3D;&amp;a；指针的指向和指针指向的值都不可以改】\n","categories":["计算机理论"],"tags":["编程语言-C++"]},{"title":"结构体","url":"/2018/10/15/%E8%AE%A1%E7%AE%97%E6%9C%BA%E7%90%86%E8%AE%BA/%E7%BC%96%E7%A8%8B%E8%AF%AD%E8%A8%80/C++/5_%E7%BB%93%E6%9E%84%E4%BD%93/","content":"结构体属于用户自定义的数据类型，允许用户存储不同的数据类型\n在结构体中可以定义另一个结构体作为成员\n值传递传参的时候会耗费大量的内存空间，用地址传递可以减少内存空间，而且不会复制新的副本出来\n结构体中用const来防止误操作：\n—————————————\n#include &lt;iostream&gt;#include &lt;string&gt;using namespace std;struct Hero&#123;\tstring name;\tint age;\tstring sex;&#125;;//冒泡排序void bubbleSort(struct Hero heroArray[],int len)&#123;\tfor(int i=0;i&lt;len-1;i++)&#123;\t\tfor(int j=0;j&lt;len-1-i;j++)&#123;\t\t\tif(heroArray[j].age&gt;heroArray[j+1].age)&#123;\t\t\t\tstruct Hero temp=heroArray[j];\t\t\t\theroArray[j]=heroArray[j+1];\t\t\t\theroArray[j+1]=temp;\t\t\t&#125;\t\t&#125;\t&#125;&#125;void printHero(struct Hero heroArray[],int len)&#123;\tfor(int i=0;i&lt;len;i++)&#123;\t\tcout&lt;&lt;“姓名： “&lt;&lt;heroArray[I].name&lt;&lt;“年龄： “&lt;&lt;heroArray[I].age&lt;&lt;“性别：”&lt;&lt;heroArray[I].sex&lt;&lt;endl;\t&#125;&#125;int main(int argc, char *argv[]) &#123;\t\tstruct Hero heroArray[5]=&#123;\t\t&#123;“刘备”,23,”男”&#125;,\t\t&#123;“关羽”,22,”男”&#125;,\t\t&#123;“张飞”,20,”男”&#125;,\t\t&#123;“赵云”,21,”男”&#125;,\t\t&#123;“貂蝉”,19,”女”&#125;,\t&#125;;\t\tint len=sizeof(heroArray)/sizeof(heroArray[0]);\t\tbubbleSort(heroArray,len);\t\tprintHero(heroArray,len);\t&#125;","categories":["计算机理论"],"tags":["编程语言-C++"]},{"title":"通讯录管理系统","url":"/2018/10/15/%E8%AE%A1%E7%AE%97%E6%9C%BA%E7%90%86%E8%AE%BA/%E7%BC%96%E7%A8%8B%E8%AF%AD%E8%A8%80/C++/6_%E9%80%9A%E8%AE%AF%E5%BD%95%E7%AE%A1%E7%90%86%E7%B3%BB%E7%BB%9F/","content":"系统需求：1）添加联系人：向通讯录中添加新人，信息包括（姓名、性别、年龄、联系电话、家庭住址），最多记录1000人2）显示联系人：显示通讯录中所有联系人的信息3）删除联系人：按照姓名进行删除指定联系人4）查找联系人：按照姓名查看指定联系人信息5）修改联系人：按照姓名重新修改指定联系人6）清空联系人：清空通讯录中所有信息7）退出通讯录：退出当前使用的通讯录\n———————————\n//  main.cpp//  通讯录管理系统//  Created by 廖家龙 on 2020/10/8./* 本系统需要改进的点：姓名和地址显示不出中文 */#include &lt;iostream&gt;#include &lt;string&gt;#define MAX 1000    //通讯录存储的最大人数**using** **namespace** std;//1-显示菜单界面**void** showMenu()&#123;    cout&lt;&lt;“************************”&lt;&lt;endl;    cout&lt;&lt;“*****  1、添加联系人  *****”&lt;&lt;endl;    cout&lt;&lt;“*****  2、显示联系人  *****”&lt;&lt;endl;    cout&lt;&lt;“*****  3、删除联系人  *****”&lt;&lt;endl;    cout&lt;&lt;“*****  4、查找联系人  *****”&lt;&lt;endl;    cout&lt;&lt;“*****  5、修改联系人  *****”&lt;&lt;endl;    cout&lt;&lt;“*****  6、清空联系人  *****”&lt;&lt;endl;    cout&lt;&lt;“*****  0、退出通讯录  *****”&lt;&lt;endl;    cout&lt;&lt;“************************”&lt;&lt;endl;&#125;//3-联系人结构体**struct** Person&#123;    string m_Name;        //姓名    **int** m_Sex;            //性别：1、男  2、女    **int** m_Age;            //年龄    string m_Phone;       //电话    string m_Addr;        //住址&#125;;//3-通讯录结构体**struct** Addressbooks&#123;    **struct** Person personArray[MAX];   //通讯录中保存的联系人数组    **int** m_Size;                       //通讯录中人员个数&#125;;//3-添加联系人**void** addPerson(Addressbooks *abs)&#123;        //判断通讯录是否已满，如果满了就不再添加    **if**(abs-&gt;m_Size == MAX)&#123;        Cout&lt;&lt;“通讯录已满，无法添加！”&lt;&lt;endl;        **return**;    &#125;    **else**&#123;                //添加具体的联系人                //姓名        string name;        cout&lt;&lt;“请输入姓名：”&lt;&lt;endl;        cin&gt;&gt;name;        abs-&gt;personArray[abs-&gt;m_Size].m_Name=name;                //性别        cout&lt;&lt;“请输入性别：(1—男、2—女)”&lt;&lt;endl;        **int** sex=0;                **while**(**true**)&#123;            //如果输入的是1或者2，可以退出循环，因为输入的是正确的值；如果输入有误，重新输入            cin&gt;&gt;sex;            **if**(sex == 1 || sex == 2)&#123;                abs-&gt;personArray[abs-&gt;m_Size].m_Sex=sex;                **break**;            &#125;            Cout&lt;&lt;“输入有误，请重新输入！”&lt;&lt;endl;        &#125;                //年龄        cout&lt;&lt;“请输入年龄：(0~200)”&lt;&lt;endl;        **int** age=0;                **while**(**true**)&#123;            cin&gt;&gt;age;            **if**(age &gt;= 0 &amp;&amp; age &lt;= 200)&#123;                abs-&gt;personArray[abs-&gt;m_Size].m_Age=age;                **break**;            &#125;            Cout&lt;&lt;“输入有误，请重新输入！”&lt;&lt;endl;        &#125;                //电话        cout&lt;&lt;“请输入联系电话：”&lt;&lt;endl;        string phone;        cin&gt;&gt;phone;        abs-&gt;personArray[abs-&gt;m_Size].m_Phone=phone;                //住址        cout&lt;&lt;“请输入家庭住址：”&lt;&lt;endl;        string address;        cin&gt;&gt;address;        abs-&gt;personArray[abs-&gt;m_Size].m_Addr=address;                //更新通讯录的人数        abs-&gt;m_Size++;                cout&lt;&lt;“添加成功！”&lt;&lt;endl;                //system(“pause”);  //请按任意键继续        //system(“cls”);    //清屏操作    &#125;&#125;//4-显示所有联系人**void** showPerson(Addressbooks *abs)&#123;        //判断通讯录中人数是否为0.如果为0，提示记录为空；如果不为0，显示记录的联系人信息    **if**(abs-&gt;m_Size == 0)&#123;        cout&lt;&lt;“当前记录为空！”&lt;&lt;endl;    &#125;    **else**&#123;        **for**(**int** I=0;i&lt;abs-&gt;m_Size;i++)&#123;            cout&lt;&lt;“姓名：”&lt;&lt;abs-&gt;personArray[I].m_Name&lt;&lt;“\\t”;            cout&lt;&lt;“性别：”&lt;&lt;(abs-&gt;personArray[I].m_Sex == 1 ? “男”: “女”)&lt;&lt;“\\t”;            cout&lt;&lt;“年龄：”&lt;&lt;abs-&gt;personArray[I].m_Age&lt;&lt;“\\t”;            cout&lt;&lt;“电话：”&lt;&lt;abs-&gt;personArray[I].m_Phone&lt;&lt;“\\t”;            cout&lt;&lt;“住址：”&lt;&lt;abs-&gt;personArray[I].m_Addr&lt;&lt;endl;        &#125;    &#125;        //system(“pause”);  //请按任意键继续    //system(“cls”);    //清屏操作&#125;//5-检测联系人是否存在，如果存在返回联系人所在数组中的具体位置，不存在返回-1**int** isExist(Addressbooks *abs,string name)&#123;        **for**(**int** I=0;i&lt;abs-&gt;m_Size;i++)&#123;        //找到用户输入的姓名了        **if**(abs-&gt;personArray[I].m_Name == name)&#123;            **return** I;        &#125;    &#125;    **return** -1;&#125;//5-删除指定的联系人**void** deletePerson(Addressbooks *abs)&#123;        Cout&lt;&lt;“请输入您要删除的联系人：”&lt;&lt;endl;    string name;    cin&gt;&gt;name;        //ret == -1 未查到；ret != -1 已查到    **int** ret =isExist(abs,name);        **if**(ret != -1)&#123;        //查找到此人，要进行删除操作        **for**(**int** I=ret;i&lt;abs-&gt;m_Size;i++)&#123;            //数据前移            abs-&gt;personArray[I]=abs-&gt;personArray[I+1];        &#125;        Abs-&gt;m_Size—;    //更新通讯录中的人员数        cout&lt;&lt;“删除成功！”&lt;&lt;endl;    &#125;    **else**&#123;        cout&lt;&lt;“查无此人！”&lt;&lt;endl;    &#125;        //system(“pause”);  //请按任意键继续    //system(“cls”);    //清屏操作&#125;//6-查找指定联系人的信息**void** findPerson(Addressbooks *abs)&#123;        Cout&lt;&lt;“请输入您要查找的联系人：”&lt;&lt;endl;    string name;    cin&gt;&gt;name;        //判断指定的联系人是否在通讯录中    **int** ret=isExist(abs, name);        //找到联系人    **if**(ret != -1)&#123;        cout&lt;&lt;“姓名：”&lt;&lt;abs-&gt;personArray[ret].m_Name&lt;&lt;“\\t”;        cout&lt;&lt;“性别：”&lt;&lt;(abs-&gt;personArray[ret].m_Sex == 1 ? “男”: “女”)&lt;&lt;“\\t”;        cout&lt;&lt;“年龄：”&lt;&lt;abs-&gt;personArray[ret].m_Age&lt;&lt;“\\t”;        cout&lt;&lt;“电话：”&lt;&lt;abs-&gt;personArray[ret].m_Phone&lt;&lt;“\\t”;        cout&lt;&lt;“住址：”&lt;&lt;abs-&gt;personArray[ret].m_Addr&lt;&lt;endl;    &#125;    //未找到联系人    **else**&#123;        cout&lt;&lt;“查无此人！”&lt;&lt;endl;    &#125;        //system(“pause”);  //请按任意键继续    //system(“cls”);    //清屏操作&#125;//7-修改指定联系人的信息**void** modifyPerson(Addressbooks *abs)&#123;        Cout&lt;&lt;“请输入您要修改的联系人：”&lt;&lt;endl;    string name;    cin&gt;&gt;name;        **int** ret = isExist(abs, name);        **if**(ret != -1)&#123;                //姓名        string name;        cout&lt;&lt;“请输入姓名：”&lt;&lt;endl;        cin&gt;&gt;name;        abs-&gt;personArray[ret].m_Name=name;                //性别        cout&lt;&lt;“请输入性别：(1—男、2—女)”&lt;&lt;endl;        **int** sex=0;                **while**(**true**)&#123;            cin&gt;&gt;sex;            **if**(sex == 1 || sex == 2)&#123;                abs-&gt;personArray[ret].m_Sex=sex;                **break**;            &#125;            Cout&lt;&lt;“输入有误，请重新输入！”&lt;&lt;endl;        &#125;                //年龄        cout&lt;&lt;“请输入年龄：(0~200)”&lt;&lt;endl;        **int** age=0;                **while**(**true**)&#123;            cin&gt;&gt;age;            **if**(age &gt;= 0 &amp;&amp; age &lt;= 200)&#123;                abs-&gt;personArray[ret].m_Age=age;                **break**;            &#125;            Cout&lt;&lt;“输入有误，请重新输入！”&lt;&lt;endl;        &#125;                //电话        cout&lt;&lt;“请输入联系电话：”&lt;&lt;endl;        string phone;        cin&gt;&gt;phone;        abs-&gt;personArray[ret].m_Phone=phone;                //地址        cout&lt;&lt;“请输入家庭住址：”&lt;&lt;endl;        string address;        cin&gt;&gt;address;        abs-&gt;personArray[ret].m_Addr=address;                cout&lt;&lt;“修改成功！”&lt;&lt;endl;    &#125;    **else**&#123;        cout&lt;&lt;“查无此人！”&lt;&lt;endl;    &#125;        //system(“pause”);  //请按任意键继续    //system(“cls”);    //清屏操作&#125;//8-清空所有联系人//将通讯录所有联系人信息清除掉，只要将通讯录记录的联系人数量置于0，做逻辑清空即可**void** cleanPerson(Addressbooks *abs)&#123;    abs-&gt;m_Size=0;    cout&lt;&lt;“通讯录已清空！”&lt;&lt;endl;        //system(“pause”);  //请按任意键继续    //system(“cls”);    //清屏操作&#125;**int** main(**int** argc, **const** **char** * argv[]) &#123;    // insert code here…        //创建用户选择输入的变量    **int** select=0;        //3-创建通讯录结构体变量    Addressbooks abs;    //3-初始化通讯录中当前人员个数    abs.m_Size=0;        **while**(**true**)&#123;                //1-调用显示菜单界面的函数        showMenu();                cin&gt;&gt;select;                **switch**(select)&#123;                            //添加联系人            **case** 1:                addPerson(&amp;abs);  //利用地址传递，可以修饰实参                **break**;                            //显示联系人            **case** 2:                showPerson(&amp;abs);                **break**;                            //删除联系人            **case** 3:                                /*                                  //case中如果代码很长会报错，这个时候可以加一个大括号，代表一个代码段                 &#123;                 Cout&lt;&lt;“请输入要删除联系人的姓名：”&lt;&lt;endl;                 string name;                 cin&gt;&gt;name;                                  if(isExist(&amp;abs, name) == -1)&#123;                 Cout&lt;&lt;“查无此人！”;                 &#125;                 else&#123;                 Cout&lt;&lt;“找到此人！”;                 &#125;                 &#125;                                  */                                deletePerson(&amp;abs);                **break**;                            //查找联系人            **case** 4:                findPerson(&amp;abs);                **break**;                            //修改联系人            **case** 5:                modifyPerson(&amp;abs);                **break**;                            //清空联系人            **case** 6:                cleanPerson(&amp;abs);                **break**;                            //2-退出通讯录            **case** 0:                cout&lt;&lt;“欢迎下次使用”&lt;&lt;endl;                //system(“pause”);                **return** 0;                **break**;                            **default**:                **break**;        &#125;    &#125;        //system(“pause”);        **return** 0;&#125;","categories":["计算机理论"],"tags":["编程语言-C++"]},{"title":"函数高级","url":"/2018/10/15/%E8%AE%A1%E7%AE%97%E6%9C%BA%E7%90%86%E8%AE%BA/%E7%BC%96%E7%A8%8B%E8%AF%AD%E8%A8%80/C++/9_%E5%87%BD%E6%95%B0%E9%AB%98%E7%BA%A7/","content":"函数默认参数：在C++中，函数的形参列表中的形参是可以有默认值的\n函数占位参数：C++中函数的形参列表里可以有占位参数，用来做占位，调用函数时必须填补该位置\n函数重载：函数名可以相同，提高复用性\n函数重载满足条件：1）同一个作用域下2）函数名称相同3）函数参数类型不同或者个数不同或者顺序不同\n注意：函数的返回值不可以作为重载的条件\n函数重载的注意事项：\n","categories":["计算机理论"],"tags":["编程语言-C++"]},{"title":"职工管理系统","url":"/2018/10/15/%E8%AE%A1%E7%AE%97%E6%9C%BA%E7%90%86%E8%AE%BA/%E7%BC%96%E7%A8%8B%E8%AF%AD%E8%A8%80/C++/18_%E8%81%8C%E5%B7%A5%E7%AE%A1%E7%90%86%E7%B3%BB%E7%BB%9F/","content":"","categories":["计算机理论"],"tags":["编程语言-C++"]},{"title":"C++中的引用","url":"/2018/10/15/%E8%AE%A1%E7%AE%97%E6%9C%BA%E7%90%86%E8%AE%BA/%E7%BC%96%E7%A8%8B%E8%AF%AD%E8%A8%80/C++/8_C++%E4%B8%AD%E7%9A%84%E5%BC%95%E7%94%A8/","content":"作用：给变量起别名\n引用注意事项：1）引用必须初始化2）引用在初始化后，不可以改变\n引用做函数参数：函数传参时，可以利用引用的技术让形参修饰实参，可以简化指针修改实参\n引用做函数返回值：不要返回局部变量引用；函数的调用可以作为左值\n引用的本质：在C++内部实现是一个指针常量\n常量引用：常量引用主要用来修饰形参，防止误操作，在函数形参列表中，可以加const修饰形参，防止形参改变实参\n","categories":["计算机理论"],"tags":["编程语言-C++"]},{"title":"指针作为函数的参数、返回值","url":"/2018/09/30/%E8%AE%A1%E7%AE%97%E6%9C%BA%E7%90%86%E8%AE%BA/%E7%BC%96%E7%A8%8B%E8%AF%AD%E8%A8%80/C%E8%AF%AD%E8%A8%80/10_%E6%8C%87%E9%92%88%E4%BD%9C%E4%B8%BA%E5%87%BD%E6%95%B0%E7%9A%84%E5%8F%82%E6%95%B0%E3%80%81%E8%BF%94%E5%9B%9E%E5%80%BC/","content":"指针作为函数的参数：\n当我们调用一个函数的时候，如果这个函数的参数是一个指针，那么我们就必须要为这个指针传递一个和指针类型相同的普通变量的地址，这个时候，在函数的内部去访问参数指针指向的变量的时候，其实访问的就是实参变量\n\n下面的程序遇到了一个问题：函数内部只能返回一个数据\n当函数需要返回多个数据的时候就可以使用指针作为函数的参数\n解决方法：使用指针作为函数的参数，让调用者将自己的变量的地址传递到函数的内部，函数的内部通过指针就可以修改实参变量的值1）2）\n指针作为函数的返回值：\n可以返回局部变量的值，但是不能返回局部变量的地址\n\n如果你就是要返回一个指针，那么你就要保证这个指针指向的空间在函数结束以后仍然存在，那么这个时候，就可以将空间申请在堆区，然后返回堆区的地址【使用完后一定要记得free】\n","categories":["计算机理论"],"tags":["编程语言-C语言"]},{"title":"与申请字节空间有关的三个函数","url":"/2018/09/30/%E8%AE%A1%E7%AE%97%E6%9C%BA%E7%90%86%E8%AE%BA/%E7%BC%96%E7%A8%8B%E8%AF%AD%E8%A8%80/C%E8%AF%AD%E8%A8%80/13_%E4%B8%8E%E7%94%B3%E8%AF%B7%E5%AD%97%E8%8A%82%E7%A9%BA%E9%97%B4%E6%9C%89%E5%85%B3%E7%9A%84%E4%B8%89%E4%B8%AA%E5%87%BD%E6%95%B0/","content":"#include&lt;stdlib.h&gt;\n向堆区申请字节空间来使用：我们在堆区申请的字节空间，如果不主动释放，那么系统是不会释放掉的，除非程序结束\n1）malloc()：向堆空间申请指定连续的字节空间来使用【参数是size_t类型的，也就是unsigned long】返回值是void *，返回的是创建的空间中第一个字节的地址\n\n2）calloc()：calloc申请的字节，申请完之后，系统会将字节中的数据清零\n3）realloc()：当我们发现我们之前在堆区申请的字节空间不够用的时候，就可以使用realloc函数来为我们的字节空间扩容【如果原来的空间后面还有剩余的空间，并且足够扩容，那么直接就扩容在后面；如果原来的空间后面有剩余空间但是剩下的空间不够扩容，就重新找一块足够的空间申请，将原来的数据拷贝过来，原来的空间被自动释放】\n空间由3个变成4个，扩容了一个：\n","categories":["计算机理论"],"tags":["编程语言-C语言"]},{"title":"枚举(enum)","url":"/2018/09/30/%E8%AE%A1%E7%AE%97%E6%9C%BA%E7%90%86%E8%AE%BA/%E7%BC%96%E7%A8%8B%E8%AF%AD%E8%A8%80/C%E8%AF%AD%E8%A8%80/15_%E6%9E%9A%E4%B8%BE(enum)/","content":"支持新创建一种数据类型，这个数据类型的变量的取值被限定，枚举值的名称都以枚举类型来开头\n每一个枚举值&#x2F;枚举项都有一个对应的整型的数，默认从0开始，依次的递增【实际上可以手动的赋值】，无论是什么类型的枚举变量，都是占据4个字节，枚举变量中真正存储的是枚举值所对应的整型的数\n枚举类型名字通常并不真的使用，要用的是在大括号里的名字，因为它们就是常量符号，它们的类型是int，值依次从0到n\n虽然枚举类型可以当作类型使用，但是实际上很少用\n","categories":["计算机理论"],"tags":["编程语言-C语言"]},{"title":"指针","url":"/2018/09/30/%E8%AE%A1%E7%AE%97%E6%9C%BA%E7%90%86%E8%AE%BA/%E7%BC%96%E7%A8%8B%E8%AF%AD%E8%A8%80/C%E8%AF%AD%E8%A8%80/11_%E6%8C%87%E9%92%88/","content":"变量的值：存储在变量中的数据叫做变量的值变量的地址：一个变量是由一个或多个字节组成的，组成这个变量的低字节的地址，就是这个变量的地址\n变量的地址就叫做指针，指针变量就是专门用来存储地址的变量，专门用来存储另外一个变量的地址，那么我们就说这个指针变量指向了另外一个变量【它自己也有一个地址】，通过指针变量可以间接的访问指针变量指向的另外一个变量\nint* p1;，代表声明了一个叫做p1的指针变量，这个指针变量的类型是int*，这个*代表这个变量不是一个普通变量，而是一个专门用来存储地址的指针变量【只能存储int变量的地址】\n指针变量初始化只能给他一个地址：int* p1=&amp;num;\n使用指针间接的操作指向的变量：\nint num = 10;int* p1=&amp;num;*p1=100;  //*p1代表指向的变量，也就是num\n\n运算符&amp;：获得变量的地址，它的操作数必须是变量:int i;printf(“%p”,&amp;i);\n*是一个单目运算符，用来访问指针的值所表示的地址上的变量,可以做右值也可以做左值int k=*p;*p=k+1;\n指针的一些注意点：\n1）【指针+1】并不是在指针地址的基础之上加一个字节的地址，而是在这个指针地址的基础之上加一个单位变量占用的字节数【这个时候p1指向的就是num1】\n2）*p++的意思是取出p所指的那个数据，之后再把p移到下一个位置去，*的优先级虽然高，但是没有++高，常用于数组类的连续空间操作\n3）int* p1;我们声明一个指针变量，如果没有为其初始化，那么这个时候这个指针变量是有值的，这个值是一个垃圾值，，这个时候，这个指针变量就有可能指向了一块随机的空间，像这样的指针我们就叫做野指针【最好给他初始化一下：int *p1=NULL;NULL值代表指针变量不指向内存中的任何地址】\n4）多个指针指向同一变量：\n5）指针分好多类型，但无论指针什么类型，在内存中都是占据着8个字节，指向不同类型的指针是不能直接互相赋值的，这是为了避免用错指针\n6）p1指针变量中存储的是num变量的地址，也就是num变量的低字节的地址，这个时候p1指针能操作多少个字节是根据指针的类型来决定的【这就是为什么指针要分类型，还必须跟指向的普通变量的类型一致】\n一级指针和多级指针：\n一个指针变量中存储的是一个普通变量的地址，像这样的指针，我们就叫做一级指针一个指针变量中存储的是一个一级指针变量的地址，像这样的指针，我们就叫做二级指针\n声明多级指针：\n一级指针只能存储普通变量的地址，二级指针只能存储一级指针变量的地址\n\n指针与数组：\n使用指针来遍历数组：1）2）本方法中不能换成*(arr++)，数组名代表数组的地址，而数组一旦创建，数组的地址就确定了，不能改变，所以我们不能为数组名赋值，不能修改数组名的值，但是可以使用数组名的值3）此方法跟前两种不一样\n中括弧的本质【数组arr[0]等价于*(arr+0)，操作数组我们虽然使用中括弧下标来操作，实际上内部仍然是使用指针来操作】：指针变量后面可以使用中括弧，在中括弧中写上下标来访问数据：p1[n]完全等价于*(p1+n)\n函数参数表中的数组实际上是指针,但是可以用数组的运算符[]进行运算\n数组变量是特殊的指针：1）数组变量本身表达地址，所以int a[10];int *p=a;无需用&amp;取地址，但是数组的单元表达的是变量，需要用&amp;取地址2）[]运算符可以对数组做，也可以对指针做3）*运算符可以对指针做，也可以对数组做4）数组变量是const的指针，所以不能被赋值：int a[];int * const a;\n如果一个数组是用来存储指针类型的数据的话，那么这个数组就叫做存储指针的数组：int* arr[3];\n指针之间的运算：指针与指针之间只能做减法运算，不能做加乘除运算，可以做比较运算\n指针与指针之间可以做减法运算，结果是一个long类型的数据，代表两个指针指向的变量之间相差多少个单位变量\n如果参与减法运算的两个指针不指向同一个数组，先求出两个指针的差&#x2F;每一个指针变量对应的普通变量占用的字节数\n\n指针的比较运算：\n指向函数的指针：程序在运行的时候，会将程序加载到内存，程序中的函数肯定存在于内存的代码段中，我们可以声明一个指针，存储这个函数的地址，让这个指针指向这个函数，使用指针来间接的调用函数\n一个指向函数的指针，并不是任意的函数都可以指向，要求指向的函数的返回值类型和参数类型必须要与指针的描述一样函数的名称就代表这个函数的地址：【注意不要在函数名后加小括弧，如果加了小括弧，就代表指向这个函数，拿到这个函数的返回值】\n如果指向的函数有参数有返回值，调用的时候有参数就传参，有返回值就接！\n","categories":["计算机理论"],"tags":["编程语言-C语言"]},{"title":"const修饰基本数据类型","url":"/2018/09/30/%E8%AE%A1%E7%AE%97%E6%9C%BA%E7%90%86%E8%AE%BA/%E7%BC%96%E7%A8%8B%E8%AF%AD%E8%A8%80/C%E8%AF%AD%E8%A8%80/12_const%E4%BF%AE%E9%A5%B0%E5%9F%BA%E6%9C%AC%E6%95%B0%E6%8D%AE%E7%B1%BB%E5%9E%8B/","content":"const int num = 10;一般情况下来说，被const修饰的变量具备一定程度上的不可变性【只能取值不能修改】\nconst修饰数组：const int arr[4]=&#123;10,20,30,40&#125;;，数组的元素的值不能修改,数组变量已经是const的指针了，这里的const表明数组的每个单元都是const int，所以必须通过初始化进行赋值\nconst修饰指针：1）2）int const * p1=&amp;num;效果同上3）int * const p1=&amp;num;p1的值不能修改，但是可以通过p1去修改p1指向的变量的值4)int const * const p1=&amp;num;既不能修改p1的值，也不能通过p1去修改p1指向的变量的值\n当函数的参数是一个指针的时候，这个时候函数的内部是有可能会修改实参变量的值,所以要加一个const:\n","categories":["计算机理论"],"tags":["编程语言-C语言"]},{"title":"字符串","url":"/2018/09/30/%E8%AE%A1%E7%AE%97%E6%9C%BA%E7%90%86%E8%AE%BA/%E7%BC%96%E7%A8%8B%E8%AF%AD%E8%A8%80/C%E8%AF%AD%E8%A8%80/19_%E5%AD%97%E7%AC%A6%E4%B8%B2/","content":"字符串数据在C中的存储方式：内存中的五大区域：\n\n栈：是专门用来存储局部变量的，所有的局部变量都是声明在栈区域中\n堆：允许程序员手动的从堆申请指定字节数的空间来使用\nBSS段：是用来存储未初始化的全局变量和静态变量，声明一个全局变量，如果我们没有初始化，在程序运行最开始的时候，这个全局变量是没有初始化的，存储在BSS段【程序运行后系统就自动的初始化为0，并把初始化后的全局变量存储在数据段中】\n数据段&#x2F;常量区：用来存储已经初始化的全局变量、静态变量和常量数据\n代码段：用来存储程序的代码&#x2F;指令\n\n字符串数据在C语言中有两种存储方式：\n\n使用字符数组来存储：将字符串数据的每一个字符存储到字符数组中，并追加一个’\\0’代表存储结束char name[]=“jack”;\n\n使用字符指针来存储字符串数据：直接将一个字符串数据初始化给一个字符指针char* name =“jack”;\n\n\n1）当它们都是局部变量的时候：\n字符数组是申请在栈区，字符串的每一个字符存储在这个字符数组的每一个元素中；指针变量是声明在栈区的，字符串数据是以字符数组的形式存储在常量区的，指针变量中存储的是字符串在常量区的地址\n2）当它们作为全局变量的时候：\n字符数组是存储在常量区的，字符串的每一个字符存储在这个字符数组的每一个元素中；指针变量也是存储在常量区的，字符串数据是以字符数组的形式存储在常量区的，指针变量中存储的是字符串在常量区的地址\n3）以字符数组的形式存储字符串数据，不管是全局的还是局部的，都可以使用下标去修改字符数组中的每一个元素；以字符指针的形式存储字符串数据，不管是全局的还是局部的，都不能通过指针去修改指向的字符串数据\n当我们以字符指针的形式要将字符串数据存储到常量区的时候，并不是直接将字符串存储到常量区，而是先检查常量区中是否有相同内容的字符串，如果有直接将这个字符串的地址拿过来返回，如果没有，才会将这个字符串数据存储在常量区中\n当我们重新为字符指针初始化一个字符串的时候，并不是修改原来的字符串，而是重新的创建了一个字符串，把这个新的字符串的地址赋值给它\n几个比较容易混的点：\n\n这样是可以的，但是不是把“jack”改成了“rose”，而是重新创建了一个“rose”，把“rose”的地址赋值给namechar *name = &quot;jack&quot;;name = &quot;rose&quot;;\n\n这样是不行的，name是数组名，代表数组的地址，不能为数组名赋值char name[]=&quot;jack&quot;;name = &quot;rose&quot;;\n\n这样做是可以的，直接修改数组的元素name[0]=&#39;r&#39;;name[1]=&#39;o&#39;;name[2]=&#39;s&#39;;name[3]=&#39;e&#39;;name[4]=&#39;\\0&#39;;\n\n\n\n统计字符串中某一个字符出现的次数：\n\n使用字符指针数组来存储多个字符串数据：这是一个一维数组，每一个元素的类型是char指针：char* names[4] = &#123;&quot;jack&quot;,&quot;rose&quot;,&quot;lily&quot;,&quot;lilei&quot;&#125;;\n\n\n在声明字符数组的同时，如果初始化了部分元素，那么其他的字符会被初始化为’\\0’，‘\\0’是一个字符，是一个不可见的字符，打印出来啥都没有，这个字符的ASCII码是0\n在C语言中字符串数据必须要用双引号引起来\nC语言中存储字符串数据：将字符串数据的每一个字符存储到字符数组中，并在后面追加一个’\\0’代表字符串存储完毕\n最根本的方式存储字符串：char name[5]=&#123;‘j’,’a’,’c’,’k’,’\\0’&#125;;\nchar name[]=&#123;“jack”&#125;;系统会自动的将这个字符串中的每一个字符存储到字符数组中，并自动的追加一个’\\0’\n最常用的方式：char name[]=“jack”;\n如果我们使用字符数组存储字符串数据的时候，没有指定这个字符数组的长度，那么这个时候这个字符数组的长度为字符串长度+1\n我们在使用字符数组存储字符串数据的时候，最好不要指定长度了\n如果在声明一个字符数组的同时我们就初始化一个字符数据给这个数组，那么这个时候是可以用中文的【这个字符数组的长度为7，因为一个中文占3个字节】\n使用格式控制符%s就可以输出存储在字符数组中的字符串数据【%s从给定的数组的地址开始，一个字节一个字节的输出，直到遇到’\\0’为止】\n无需&amp;\n使用scanf函数：1）如果用户输入的字符串数据在给定的字符数组中存储不下的时候，就会运行报错2）用户在输入字符串的时候，如果输入了空格，就会认为输入结束\n不能使用sizeof去计算字符数组的长度来得到字符串的长度，因为有可能字符串数据存储在字符数组中只占了一部分空间解决方法：\n\n字符串常量：“Hello”会被编译器变成一个字符数组放在某处，这个数组的长度是6，结尾还有表示结束的0两个相邻的字符串常量会被自动连接起来\nC语言的字符串是以字符数组的形态存在的，不能用运算符对字符串做运算，通过数组的方式可以遍历字符串，唯一特殊的地方是字符串字面量可以用来初始化字符数组\nchar *s=“Hello,world!”;s是一个指针，初始化为指向一个字符串常量，由于这个常量所在的地方，所以实际上s是const char *s，但是由于历史的原因，编译器接受不带const的写法，但是试图对s所指的字符串做写入会导致严重的后果如果需要修改字符串，应该用数组：char s[]&#x3D;“Hello,world!”;数组：这个字符串在这里，作为本地变量空间自动被回收指针：这个字符串不知道在哪里，处理参数，动态分配空间\n如果要构造一个字符串，用数组如果要处理一个字符串，用指针\n在%和s之间的数字表示最多允许读入的字符的数量，这个数字应该比数组的大小小一\nstdio.h文件：puts()函数：用来输出字符串的【优点是输出完毕之后自动换行，缺点是只能输出字符串，也不能使用占位符】\nfputs()函数：将字符串数据输出到指定的流中【标准输出流：控制台；文件流：磁盘上的文件】输出到标准输出流中：将字符串存储到文件中：1）要先声明一个文件指针，指向磁盘上的文件【fopen函数可以创建一个指向文件的指针】2）使用fputs()函数将字符串写入到指定的文件流中3）写完之后一定要记得使用fclose()函数将这个文件关闭\ngets()函数：从控制台接收用户输入一个字符串数据【优点是当用户输入的数据包含空格的时候，会连空格一起接收；缺点是和scanf函数一样不安全，当用来存储字符串的数据的字符数组的长度不够的时候，程序就会崩溃】\n\nfgets()函数：从指定的流中读取字符串，这个流可以是标准输入流：控制台，也可以是文件流1）从标准输入流中读取数据解决方案：2）从文件流中读取数据\nstring.h头文件：strlen,strcmp,strcpy,strcat,strchr,strstrstrlen:size_t strlen(const char *s);返回s的字符串长度（不包括结尾的0）\nstrcmp:int strcmp(const char *s1,const char *s2);比较两个字符串，返回：0:  s1&#x3D;&#x3D;s21:   s1&gt;s2-1:  s1&lt;s2int strncmp(const char *s1,const char *s2,size_t n);只比较前几个字符\nstrcpy:【存储字符串1的字符数组长度不够，无法存储字符串2，这个时候运行就会崩溃】char *strcpy(char *restrict dst,const char *restrict src);把src的字符串拷贝到dst，restrict表明src和dst不重叠返回dst,为了能链起代码来\n复制一个字符串：char *dst=(char *)malloc(strlen(src)+1);strcpy(dst,src);把name2拷贝到name1:\nstrcat:【接的时候会把第一个字符串后的’\\0’干掉】char *strcat(char *restrict s1,const char *restrict s2);把s2拷贝到s1的后面，接成一个长的字符串返回s1s1必须具有足够的空间\nstrcpy,strcat不安全！！\n安全版本：char *strncpy(char *restrict dst,const char *restrict src,size_t n);char *strncat(char *restrict s1,const char *restrict s2,size_t n);\n字符串中找字符：char *strchr(const char *s,int c);char *strrchr(const char *s,int c);返回NULL表示没有找到\n字符串中找字符串：char *strstr(const char *s1,const char *s2);char *strcasestr(const char *s1,const char *s2);\n","categories":["计算机理论"],"tags":["编程语言-C语言"]},{"title":"进制","url":"/2018/09/30/%E8%AE%A1%E7%AE%97%E6%9C%BA%E7%90%86%E8%AE%BA/%E7%BC%96%E7%A8%8B%E8%AF%AD%E8%A8%80/C%E8%AF%AD%E8%A8%80/18_%E8%BF%9B%E5%88%B6/","content":"C语言可以识别的进制：1）二进制【C语言中如果要写二进制，就加一个0b的前缀】2）八进制【加一个0前缀】3）十进制4）十六进制【加一个0x前缀】\n%d：将整型变量中的数据以十进制的形式输出来%o：将整型变量中的数据以八进制的形式输出来%x：将整型变量中的数据以十六进制的形式输出来\n数码：指的是这个数据的每一位数字数位：数码在这个数中的位置，从右到左依次递增，从0开始基数：就是进制位权：数码*（基数的数位次方）\n进制转换：\n1）十进制转换为二进制(除2取余法)：将这个数除以2，直到商为0，然后将余数倒序 【十进制转换为八进制&#x2F;十六进制类似】\n2）二进制转换为十进制(加权法)：将这个二进制的每个数码的位权相加【八进制&#x2F;十六进制转换为十进制类似】\n3）二进制转换为八进制(三合一)：将这个二进制从低位到高位每三个分成一组，高位不够补0，将每一组转换为十进制，将每一组的十进制连起来（二进制转换为十六进制类似）\n4）八进制转换为二进制(一拆三)（十六进制转换为二进制类似）\n5）八进制—&gt;十六进制；八—&gt;二—&gt;十六\n6）十六进制—&gt;八进制：十六—&gt;二—&gt;八\n内存中的数据存储单元是由一个一个的二进制位组成的，每一个二进制位只能存储0或者1；把内存中的八个二进制位分为一组，叫做一个字节，作为存储数据的最小基本单元\n如果要往内存中存储数据的话，就至少要使用一个字节，这时候一个字节最多可以表示256种数据\n单位换算：1字节(byte)=8bit1KB=1024byte1MB=1024KB1GB=1024MB1TB=1024GB\n\n我们在声明变量的时候，并不是去开辟一块空间，而是向系统在内存中申请一块指定字节数的连续的字节空间\nchar——1个字节int——4个字节float—4个字节double—8个字节\nsizeof：计算常量、变量在当前系统上内存中占用的字节数【sizeof(数据类型)、sizeof(变量名)、sizeof(常量) 】\nchar类型的变量在内存中占据一个字节，char类型的常量在内存中占据四个字节\n变量在内存中占据的字节数，会因为系统版本、编译器的不同而发生变化\n原码、反码、补码都是二进制，只不过是二进制的不同表现形式，数据是以补码的二进制存储的\nint类型的变量，在内存中占据4个字节，32位，为了可以表示正负性，使用最高位来表示正负，最高位为0，表示正，最高位为1，表示负，所以用来表示数据的只有31位，2^31，最小值为-2147483648，最大值为2147483647\n原码：最高位表示符号位，剩下的位数是这个数的绝对值的二进制\n反码：正数的反码就是其原码，负数的反码就是在其原码的基础之上，符号位不变，其他位取反\n补码：正数的补码就是其原码，负数的补码就是在其反码的基础上+1\n为什么数据要以补码的形式存储呢？因为计算机中只有加法没有减法，为了更加低成本的计算出结果，所以使用补码来存储数据\n位运算指的是一个二进制数据的每一位来参与运算，前提是这个数必须是一个二进制\n注意：1）参与位运算的二进制数据必须是补码形式2）位运算的结果也是二进制的补码形式\n1）按位与(&amp;)：参与按位与的两个二进制数，如果都为1，那么结果就为1，只要有一位为0，那么结果就为0【3 &amp; 2 &#x3D; 2】\n任何数按位与1的结果是这个数的最低位，偶数的最低位一定是0，奇数的最低位一定是1，所以如果要判断这个数是奇数还是偶数，只要用这个数按位与1就可以了，如果结果为1，那么就是奇数，如果结果为0，那么就是偶数\n2）按位或(|)：参与按位或的二进制数据，只要有一位是1，那么结果就为1，只有当两位都是0的时候结果才为0\n3）按位取反(~)：单目运算符，将这个二进制数的每一位取反\n4）按位异或(^)：参与按位异或的二进制的位，相同为0，不同为1\n交换两个变量的值可以用异或运算\n5）按位左移(&lt;&lt;)：参与按位左移运算的二进制数据，向左移动指定的位数，低位不够补0，高位溢出丢弃【左移运算有可能会改变其正负性；将一个数左移n位，相当于将这个数乘以2的n次方】\n6）按位右移(&gt;&gt;)：参与按位右移运算的二进制数据，向右移动指定的位数，低位溢出丢弃，高位补符号位【右移运算不会改变其正负性；将一个数右移n位，相当于将这个数除以2的n次方】\n变量的存储：\n变量占用的字节空间一定是连续的，内存中存储数据的最小基本单位是字节，每个字节都有一个独一无二的内存地址，是一个十六进制的数\n在为变量分配字节空间的时候，是从高地址向低地址分配的\n存储在变量中的数据是以数据的二进制补码形式存储进去的【低位存储在低字节，高位存储在高字节】\n变量的地址：\n是组成这个变量的低字节的地址，使用&amp;取地址可以取出变量的地址\n%p：取地址\n声明变量就会占用内存空间，实际上程序在运行的时候，并不是说只有我们的代码才会声明变量，系统自己也会在内存中申请空间存储数据\nshort int：在内存中占据两个字节【最高位表示符号位，2^15，所以最小值：-32768，最大值：32767】【%hd来输出，%d可能会有问题】\nlong short：在32位系统下占4个字节，在64位占8个字节【%ld来输出】\nlong long int：在32位和64位下都占据8个字节【%lld来输出】\nunsigned int，2^32，最高位不用来表示符号位了，所以最小值为0【%u来输出】\nunsigned short int【%hu来输出】\n字符数据在内存中存储的是这个字符所对应的ASCII码的二进制补码【实际上就是一个整数，可以用%d输出】\nchar变量是一个有符号的，最高位表示符号位\n%c读取的时候，先从变量中读取出存储在变量中的整数，然后再去ASCII码表中去查找这个整数对应的字符，再显示这个字符\n","categories":["计算机理论"],"tags":["编程语言-C语言"]},{"title":"基本概念","url":"/2018/09/30/%E8%AE%A1%E7%AE%97%E6%9C%BA%E7%90%86%E8%AE%BA/%E7%BC%96%E7%A8%8B%E8%AF%AD%E8%A8%80/C%E8%AF%AD%E8%A8%80/1_%E5%9F%BA%E6%9C%AC%E6%A6%82%E5%BF%B5/","content":"C语言的发展：\n\nC语言是从B语言发展而来的，B语言是从BCPL发展而来的，BCPL是从FORTRAN发展而来的\nBCPL和B都支持指针间接方式，所以C也支持了\nC语言还受到了PL&#x2F;I的影响，还和PDP-II的机器语言有很大关系\n1973年3月，第三版的Unix上出现了C语言的编译器\n1973年11月，第四版的Unix(System Four)发布了，这个版本是完全用C语言重新写的\n\nC语言标准：\n\n1989年ANSI发布了一个标准：ANSI C\n1990年ISO接受了ANSI的标准：C89\nC的标准在1995年和1999年两次更新：C95和C99\n所有的当代编译器都支持C99了\n\n环境、开发环境和IDE：\n\n环境：就是一个软件\n开发环境：用于开发程序的一个软件，就是说这个软件是用来开发程序的\nIDE：集成开发环境，集成的意思是多个功能集合在一起，所以就是集多种功能于一身的用来开发程序的软件\n\n程序的执行：\n\n解释：借助一个程序，那个程序能试图理解你的程序，然后按照你的要求执行\n编译：借助一个程序，就像一个翻译，把你的程序翻译成计算机真正能懂的语言（机器语言写的程序），然后这个机器语言写的程序就能直接执行了\n解释型语言VS编译型语言：语言本无解释和编译之分，解释型语言有特殊的计算能力，编译型语言有确定的运算性能\nC需要被编译才能运行，所以你需要编辑器和编译器或者IDE（集成开发环境）\n\n现代的编程语言在语法上的差异很小，几乎都是C-like语言，语言的能力和适用领域主要是由库和传统所决定的\n程序是用特殊的编程语言写出来表达如何解决问题的，不是用编程语言来和计算机交谈，而是描述要求它如何做事情的过程和方法，我们要让计算机做计算，就需要找出计算的步骤，然后用编程语言写出来；计算机做的所有的事情都叫做计算，计算的步骤就是算法\n","categories":["计算机理论"],"tags":["编程语言-C语言"]},{"title":"typedef","url":"/2018/09/30/%E8%AE%A1%E7%AE%97%E6%9C%BA%E7%90%86%E8%AE%BA/%E7%BC%96%E7%A8%8B%E8%AF%AD%E8%A8%80/C%E8%AF%AD%E8%A8%80/16_typedef/","content":"为一个已经存在的数据类型取一个别名【为结构体和枚举取一个别名】\nsize_t其实就是unsigned long\nC语言提供了一个叫做typedef的功能来声明一个已有的数据类型的新名字，比如 typedef int Length;\n","categories":["计算机理论"],"tags":["编程语言-C语言"]},{"title":"联合(union)","url":"/2018/09/30/%E8%AE%A1%E7%AE%97%E6%9C%BA%E7%90%86%E8%AE%BA/%E7%BC%96%E7%A8%8B%E8%AF%AD%E8%A8%80/C%E8%AF%AD%E8%A8%80/17_%E8%81%94%E5%90%88(union)/","content":"所有的成员共享一个空间同一时间只有一个成员是有效的union的大小是其最大的成员\n","categories":["计算机理论"],"tags":["编程语言-C语言"]},{"title":"预处理指令","url":"/2018/09/30/%E8%AE%A1%E7%AE%97%E6%9C%BA%E7%90%86%E8%AE%BA/%E7%BC%96%E7%A8%8B%E8%AF%AD%E8%A8%80/C%E8%AF%AD%E8%A8%80/20_%E9%A2%84%E5%A4%84%E7%90%86%E6%8C%87%E4%BB%A4/","content":"C语言的代码主要分为两类：1）C代码2）预处理代码：以#开头的代码\n预处理指令的分类：1）文件包含指令：#include2）宏定义：#define【可以将一段C代码定义为一个标识，使用这个标识就可以使用这段代码】3）条件编译指令：#if【只编译指定的C代码为二进制指令】\n预处理指令的特点：1）都是以#开头2）预处理指令的后面没有分号\n文件包含指令：文件包含指令作用：可以将指定的文件的内容拷贝到写指令的地方#include”文件路径”#include&lt;文件路径&gt;\n绝对路径：路径从根目录开始相对路径：相对于当前这个文件夹的路径，和当前文件路径相同的部分删除【一般把导入文件放到和main.c相同的文件夹下】\n#include”文件路径”和#include&lt;文件路径&gt;的寻找指定文件的方式不一样：1）前者先去当前源文件所在的目录中查找这个文件，如果有直接包含，如果没有再去系统自带的编译器目录中查找，如果有直接包含，如果没有报错2）后者直接去编译器目录中查找，如果有包含，没有报错\n宏定义：它是一个预处理指令，所以它在编译之前执行，可以将一段C代码定义为一个标识，使用这个标识就可以使用这段代码\n宏的原理：在预编译的时候，就会执行源文件中的预处理指令，会将C代码中使用宏名的地方替换为宏值【任意的C代码】，将C代码中的宏名替换为宏值的过程叫做宏替换&#x2F;宏代换\n在定义宏的时候不会去检查语法，只有当完成了宏替换的时候，才会去检查替换以后是否符合语法规范\n如果宏值是一个表达式，那么宏值并不是这个表达式的结果，而是这个表达式本身\n如果宏值中包括一个变量名，那么在使用这个宏之前必须要保证这个变量已经存在\n【默认情况下，宏从定义的地方一直到文件结束都可以使用，#undef 宏名可以让指定的宏提前失效】#define N 10\n只能在中间使用这个宏，#undef N下面宏失效\n#undef N\n字符串中如果出现了宏名，系统不会认为这是一个宏，而是认为是字符串的一部分\n\n如果宏后面跟了分号，那么就会把分号作为宏值的一部分\n我们在定义宏的时候，宏名是可以带参数的，在这个宏值中可以直接使用这个参数，如果使用的宏有参数，那么就必须要在使用它的时候为这个宏的参数传值\n宏不是函数，所以宏的参数不需要加类型说明符\n为带参数的宏传值的时候，是本色传递，如果传递一个变量，并不是传递这个变量的值\n条件编译指令：默认的情况下，所有的C代码都会被编译为二进制代码，条件编译指令可以让编译器只编译指定部分的代码\n在预编译的时候，如果条件成立，就会将其中的C代码编译成二进制指令，如果条件不成立，就不会将其中的C代码编译成二进制指令【条件只能是宏，不能是变量】\n\nIf语句无论如何全部都要被编译为二进制指令，条件编译指令只会将符合条件的C代码编译为二进制指令\n如果定义了指定的宏，就编译其中的代码\n无论一个文件被#include多少次，只希望它最终只会被包含一次\nstatic和extern：C语言中的关键字，用来修饰变量和函数\n如果局部变量被static修饰，这个变量就叫做静态变量，静态变量不再存储在栈区域，而是存储在常量区，当函数执行完之后，这个静态变量不会被回收，后面再去执行这个函数的时候，声明静态变量的这句话就不会再执行了，直接略过，直接使用这个静态变量的值【静态变量只有一份】\nextern不能修饰局部变量\n当我们分模块开发的时候，如果要在模块中声明全局变量，全局变量的声明要写在.h文件中，全局变量的实现要写在.c文件中【如果将全局变量定义在模块中，这个全局变量就必须要使用static或者extern修饰】\n如果定义在模块中的全局变量使用extern修饰，这个模块中的全局变量就可以跨模块访问；使用static修饰，这个模块中的全局变量就只能在当前模块中访问\n如果函数被extern修饰，那么这个函数可以跨模块调用；如果函数被static修饰，那么这个函数只能在当前模块中调用，无法跨模块调用\n如果函数没有写static或者extern，那么这个函数默认就是extern\n","categories":["计算机理论"],"tags":["编程语言-C语言"]},{"title":"数据类型","url":"/2018/09/30/%E8%AE%A1%E7%AE%97%E6%9C%BA%E7%90%86%E8%AE%BA/%E7%BC%96%E7%A8%8B%E8%AF%AD%E8%A8%80/C%E8%AF%AD%E8%A8%80/3_%E6%95%B0%E6%8D%AE%E7%B1%BB%E5%9E%8B/","content":"C数据类型、格式控制符整理C数据类型：1⃣️基本数据类型：整型：char、short、int、long、long long(C99)浮点型：float、double、long double(C99)布尔型：bool(C99)1）char：字符类型，一个字节（一个字节=八个比特），-128～+1272）short：短整型，通常为16位，两个字节，-32768～327673）int：取值范围取决于具体的机器，通常代表特定机器中整数的自然长度，通常为16位，其取值范围在-2147483648 ～ +2147483647之间，也有用32位表示的int类型4）long：长整型，四个字节，至少占32位存储单元，在某些机器上int与long类型的长度相同5）long long：八个字节6）float类型：取值范围取决于具体的机器，通常是32位，可以存储有效位数不超过7位的小数，取值范围一般在10^(-38)~10^(+38)之间7）double：双精度浮点型，64位，可以存储有效位数不超过16位的小数2⃣️构造类型：数组、结构体、枚举3⃣️指针类型4⃣️空类型：void5⃣️typedef自定义类型C格式控制符：不同类型的数据在变量中存储的形式是不一样的，所以在读取变量中的数据的时候，类型不同读取的方式也不同%hd：short%d：读取int整型，以十进制输出%o：读取int整型，以八进制输出（一个以0开始的数字字面量是8进制）%x：读取int整型，以十六进制输出（一个以0x开始的数字字面量是16进制，8进制和16进制只是如何把数字表达为字符串，与内部如何表达数字无关）%ld：long%lld：long long%hu：unsigned short%u：unsigned int%lu：unsigned long%llu：unsigned long longfloat和double类型的printf都使用%f或%e，float的scanf使用%f，double的scanf使用%lf%c：char类型，表示字符%s表示字符串%p：地址%%表示百分号（%）本身\n\n数据类型的一些注意点\n一个C语言程序，无论其大小如何，都是由函数和变量组成的，函数中包含一些语句，以指定所要执行的计算操作；变量则用于存储计算过程中使用的值。main是一个特殊的函数名，每个程序都从main函数的起点开始执行，每个程序都必须在某个位置包含一个main函数；函数之间进行数据交换的一种方法是调用函数向被调用函数提供一个值（称为参数）列表\n\n变量的命名规则：变量名是由字母和数字组成的序列，但其第一个字符必须为字母，下划线“_”被看作是字母，通常用于命名较长的变量名，以提高其可读性。由于库例程的名字通常以下划线开头，因此变量名不要以下划线开头\n\n变量就是内存中开辟的用来存储数据的那块空间，所以变量是用来存储数据的，我们声明一个变量，如果没有为这个变量赋值，这个变量是有值的，这个值是一个随机数、垃圾值\n\n在同一个大括弧中不允许定义多个变量名相同的变量，不同大括弧可以\n\n\n\n自动类型转换：当我们为变量赋值的时候，如果赋值的数据的类型和变量的类型不一致，这时候C系统会将赋值的数据的类型转换为变量的类型再赋值\n如果某个算术运算符的所有操作数均为整型，则执行整型运算。但是，如果某个算术运算符有一个浮点型操作数和一个整型操作数，则在开始运算之前整型操作数将会被转换为浮点型\n强制类型转换：要把一个量强制转换成另一个类型（通常是较小的类型）:(int)10.2，注意这时候的安全性，小的变量不总能表达大的量：(short)32768\n强制类型转换只是从那个变量计算出了一个新的类型的值，它并不改变那个变量，无论是值还是类型都不改变\n强制类型转换的优先级高于四则运算：\ndouble a=1.0;double b=2.0;int I=(int)a/b;\n\n\n在printf函数的参数中，只能用\\n表示换行符，如果用程序的换行代替\\n，C编译器将会产生一条错误信息。printf函数永远不会自动换行，这样我们可以多次调用该函数以分阶段得到一个长的输出行。\n\nprintf函数并不是C语言本身的一部分，C语言本身并没有定义输入&#x2F;输出功能。printf仅仅是标准库函数中一个有用的函数而已，这些标准库函数在C语言程序中通常都可以使用。\n\nprintf输出inf表示超过范围的浮点数，printf输出nan表示不存在的浮点数\n\nscanf函数是一个阻塞式的函数，当CPU执行到这个函数的时候，CPU的执行就会暂停，不会继续往下执行了，并等待用户输入数据\n\nscanf函数后面不要加\\n\n\n如果没有特殊需要，只使用double，现代CPU能直接对double做硬件运算，性能不会比float差，在64位的机器上，数据存储的速度也不比float慢\n\n#include&lt;stdbool.h&gt;之后就可以使用bool和true、false了\n\n在C语言中如果我们直接写一个小数，那么这个小数的类型是double类型的，如果我们就是希望这个小数是一个float类型的，那么就在这个小数的后面加一个f&#x2F;F\n\nchar类型的变量中只能存储单个字符，并且这单个字符还要用单引号引起来；如果char类型的变量中存储的字符超过一个，那么它只会保存最后一个字符（char变量中可以存储一个空格，无法存储中文，因为在C语言中，一个中文占3个字节）\n\n字符型变量是用来存储字符常量的变量。将一个字符常量存储到一个字符变量中，实际上是将该字符的ASCII码值（无符号整数）存储到内存单元中。【‘A’——65、‘a’——97、‘0’——48，为char变量赋值的时候可以直接赋值ASCII码】\n\n\n\n所有整型都包括signed(带符号)和unsigned(无符号)两种形式，且可以表示无符号常量与十六进制字符常量；\nunsigned类型的数总是正值或0，如果char对象占用8位，那么unsigned char类型变量的取值范围为0～255，而signed char类型变量的取值范围则为-128～127（在采用对二的补码的机器上）\n如果一个字面量常数想要表达自己是unsigned，可以在后面加U【255U】，用l或L表示long(long)\nunsigned的初衷并非扩展数能表达的范围，而是为了做纯二进制运算，主要是为了移位\n17.无论是float还是double，默认都只显示小数点后6位(不足的用0补齐，多余六位的只保留六位)%.nf：表示显示小数点后n位%m.nf：如果变量整体的位数(小数点默认显示n位，无n的默认显示6位，小数点不足6位的在后面补0，大于6位的按6位计算)小于m，不足的地方就会以空格补齐（正数在前面补齐，负数在后面补齐）；如果变量整体的位数大于字符宽，那么实际有多少位就显示多少位(%0mf，不足的地方以0补齐)\n","categories":["计算机理论"],"tags":["编程语言-C语言"]},{"title":"macOS终端下执行第一个C程序","url":"/2018/09/30/%E8%AE%A1%E7%AE%97%E6%9C%BA%E7%90%86%E8%AE%BA/%E7%BC%96%E7%A8%8B%E8%AF%AD%E8%A8%80/C%E8%AF%AD%E8%A8%80/2_macOS%E7%BB%88%E7%AB%AF%E4%B8%8B%E6%89%A7%E8%A1%8C%E7%AC%AC%E4%B8%80%E4%B8%AAC%E7%A8%8B%E5%BA%8F/","content":"在其他操作系统中，编译，加载，运行等规则会有所不同！\n1）新建一个文件夹“C语言程序演示”\n2）在终端中cd进入这个新建的文件夹\n3）在新文件夹中touch hello.c建立一个后缀名为.c的源程序\n4）在hello.c源文件中写第一个C语言的代码\n5）通过cc hello.c命令进行编译，如果源程序没有什么错误，编译过程将顺利进行，并生成一个可执行文件a.out【cc -c 源文件名称：编译，生成.o文件，叫做目标文件，存储的是.c文件中的代码对应的二进制指令；cc 目标文件名称：连接，为.o的目标文件添加启动代码，告诉编译器，要调用的函数在什么地方】\n6）然后我们输入.&#x2F;a.out，即可运行a.out，打印出程序结果\n","categories":["计算机理论"],"tags":["编程语言-C语言"]},{"title":"scanf函数输入多个数据后导致的问题","url":"/2018/09/30/%E8%AE%A1%E7%AE%97%E6%9C%BA%E7%90%86%E8%AE%BA/%E7%BC%96%E7%A8%8B%E8%AF%AD%E8%A8%80/C%E8%AF%AD%E8%A8%80/4_scanf%E5%87%BD%E6%95%B0%E8%BE%93%E5%85%A5%E5%A4%9A%E4%B8%AA%E6%95%B0%E6%8D%AE%E5%90%8E%E5%AF%BC%E8%87%B4%E7%9A%84%E9%97%AE%E9%A2%98/","content":"如果使用scanf函数一次输入多个数据，只能是整型和浮点型，如果有char字符型混合输入，就会出现问题：\n图中可以看到：num3的值并没有打印出来，出现这种情况的原因是什么呢？？？\n\n在执行scanf函数的时候，会让用户输入一个数据，数据输入完毕之后，并不是将这个数据直接赋值给变量，而是先将数据存储在缓冲区，输入的任何数据都会存储在缓冲区中\n\n在执行scanf函数的时候，会先检查缓冲区中是否有数据，如果缓冲区中没有数据，那么就会让用户从键盘输入，如果缓冲区中有数据，直接从缓冲区中将数据拿出来，不会让用户输入数据\n\n当从缓冲区中拿数据的时候，如果要拿的数据的类型是整型或者实型，如果拿到的数据的类型是空格、回车、Tab键，就会被自动忽略，继续往下拿；如果要拿的数据是字符型，不会忽略任何数据\n\n\n我们来分析下面的一段程序：程序中要求用户输入一个整型数据num1，但是这个时候我们偏偏输入两个整型数据10、20，这个时候缓冲区其实有四个数据：10、空格、20、换行，执行第一个printf后结果为10，这是我们事先预料好的；当第二个scanf执行的时候，程序根本就不会让用户输入数据，因为缓冲区中已经有整型数据20了【当从缓冲区中拿数据的时候，如果要拿的数据的类型是整型或者实型，如果拿到的数据的类型是空格、回车、Tab键，就会被自动忽略，继续往下拿】，所以最终程序会直接打印出num2&#x3D;20\n让我们再回头看第一个程序：为什么num3的值打印出来的结果为空？？？执行完第11行程序以后，缓冲区中的数据为10、空格、2.5、空格、a、换行；打印num1、num2的值的时候，因为是整型或者浮点型，程序会自动忽略空格和换行，所以输出结果为num1&#x3D;10，num2&#x3D;2.500000；但是num3是一个字符型的数据，程序并不会忽略任何的数据，最后打印出来的结果为num3&#x3D; ；【这里打印出来了一个空格，并不是空】\n那这个时候就有问题了，如果scanf输入多个数据中包含字符型数据时，我就是想要输出来字符型数据，该怎么做呢？？？\n解决方案：通过rewind(stdin);这行代码把缓冲区中的数据全部清空，这个时候缓冲区中没有任何数据了\n写C代码时，如果遇到整型、浮点型、字符型同时出现在scanf函数中的时候，要十分注意缓冲区中数据的情况！！\n","categories":["计算机理论"],"tags":["编程语言-C语言"]},{"title":"运算符和表达式","url":"/2018/09/30/%E8%AE%A1%E7%AE%97%E6%9C%BA%E7%90%86%E8%AE%BA/%E7%BC%96%E7%A8%8B%E8%AF%AD%E8%A8%80/C%E8%AF%AD%E8%A8%80/5_%E8%BF%90%E7%AE%97%E7%AC%A6%E5%92%8C%E8%A1%A8%E8%BE%BE%E5%BC%8F/","content":"C运算符、优先级整理C运算符：赋值运算符【=、+=、-=、*=、/=、%=】算术运算符【+、-、*、/、%】关系运算符【==、!=、&gt;、&gt;=、&lt;、&lt;=】自增自减运算符【++、—-】逗号运算符【,】逻辑运算符【&amp;&amp;(与)、||(或)、！】取地址运算符【&amp;】C优先级：1）（）：从左到右2）!  +  -  ++  —：从右到左（单目的+和-）3）*  /  %：从左到右4）+  -：从左到右5）&lt;  &lt;=  &gt;  &gt;=：从左到右6）==  !=：从左到右7）&amp;&amp;：从左到右8）||：从左到右9）=  +=  -=  *=  /=  %=：从右到左\n\n运算符和表达式的一些注意点1）逃逸字符：用来表达无法印出来的控制字符或特殊字符，它由一个反斜杠”\\”开头，后面跟上另一个字符，这两个字符合起来，组成了一个字符：printf(“请分别输入身高的英尺和英寸，”“如输入\\“5 7 \\”表示5英尺7英寸：“);\n\\b：回退一格\\t：到下一个表格位\\n：换行\\r：回车\\”：双引号\\’：单引号\\：反斜杠本身\n转义符只能是小写字母，每个转义符只能看作一个字符\n垂直制表符“\\v”和换页符“\\f”对屏幕没有任何影响，但会影响打印机执行相应的操作\n在C语言程序中，通常会用转义符表示不可打印的字符\n2）如果参与算术表达式的操作数的类型不一致，那么这个算术表达式的结果的类型就是范围最大的那个类型\n3）m % n的结果一定是在0～（n-1）之间\n4）char类型的数据可以参与算术运算，当算术表达式中的操作数是一个char数据的时候，会先将这个char数据的ASCII码取出来代替，然后再参与算术运算，实际上它是一个int类型的数据在参与运算；char数据也可以参与比较运算\n5）const是一个修饰符，加在int的前面，用来给这个变量加上一个const（不变的）的属性。这个const的属性表示这个变量的值一旦初始化，就不能再修改了，如果你试图对常量做修改，把它放在赋值运算符的左边，就会被编译器发现，指出为一个错误\n6）无论是前自增表达式还是后自增表达式，都是将自身的值增加1\n7）sizeof是一个运算符，给出某个类型或变量在内存中所占据的字节数：sizeof(int)、sizeof(i)\nsizeof是静态运算符，它的结果在编译时刻就决定了，不要在sizeof的括号里做运算，这些运算不会做的\n8）逻辑运算是对逻辑量进行的运算，结果只有0或1，逻辑量是关系运算或逻辑运算的结果\n逻辑非！【!a，如果a是true，结果就是false，如果a是false，结果是true】逻辑与&amp;&amp;【a &amp;&amp; b，如果a和b都是true，结果就是true，否则就是false】逻辑或||【a || b，如果a和b有一个是true，结果为true，两个都是false，结果为false】\nx&gt;4 &amp;&amp; x&lt;6：像4&lt;x&lt;6这样的式子，不是C能正确计算的式子，因为4&lt;x的结果是一个逻辑值(0或1)\n短路：逻辑运算是自左向右进行的，如果左边的结果已经能够决定结果了，就不会做右边的计算；对于&amp;&amp;，左边是false时就不做右边了；对于||，左边是true时就不做右边了\n不要把赋值，包括复合赋值组合进表达式！a==6 &amp;&amp; b==1；a==6 &amp;&amp; b+=1\n9）三元表达式、条件运算符（可以部分代替if else）：\ncount = (count&gt;20) ? count-10 : count+10;if(count &gt; 20)     count = count-10;else     count = count+10;\n\n10）逗号运算符：逗号用来连接两个表达式，并以其右边的表达式的值作为它的结果。逗号的优先级是所有的运算符中最低的，所以它两边的表达式会先计算；逗号的组合关系是自左向右，所以左边的表达式会先计算，而右边的表达式的值就留下来作为逗号运算的结果for（i=0，j=10；i&lt;j；i++，j—）\n逗号表达式的目的并不是想要前面表达式的结果，而只是想要前面的表达式执行，要最后一个表达式的结果\n","categories":["计算机理论"],"tags":["编程语言-C语言"]},{"title":"控制流","url":"/2018/09/30/%E8%AE%A1%E7%AE%97%E6%9C%BA%E7%90%86%E8%AE%BA/%E7%BC%96%E7%A8%8B%E8%AF%AD%E8%A8%80/C%E8%AF%AD%E8%A8%80/6_%E6%8E%A7%E5%88%B6%E6%B5%81/","content":"C选择结构、循环结构整理1）if-else if-else2）switch-case：选择结构switch(表达式)&#123;    case 值1:         执行代码;         break;    case 值2:         执行代码;         break;    case 值3:         执行代码;         break;    default:         执行代码;         break;&#125;3）while循环4）do while循环【当循环体无论如何至少要执行一次的时候使用】do&#123;    循环体;&#125;while(条件表达式);5）for循环【当循环次数确定的时候，一般使用for循环；当循环次数不确定的时候，一般使用while循环】\n\n控制流的一些注意点1）小技巧：Xcode中选中要对齐的代码：control+i，就会自动对齐\n2）while循环应用场景：\n-循环体确定，循环次数也确定-循环体确定，循环的次数不确定，但是循环继续或者结束的条件确定-遍历指定范围的数-找出指定范围中符合特定条件的数-求累加和与平均值-找一堆数中的最大数和最小数-计数-穷举【一个一个试】\n3）定义在一个大括弧中的变量，只能在这个大括弧中访问，出了大括弧，CPU立即将变量回收，无法访问到了:\n#include&lt;stdio.h&gt;int main(int argc,const char * argv[])&#123;    int num=1;    if(num &gt; 0)&#123;        int age = 10;        printf(&quot;age=%d\\n&quot;,age);  &#125;  printf(&quot;age=%d\\n&quot;,age);  return 0;&#125;\n\n我们可以自定义一个作用域来提前释放一个变量:\n&#123;    int i=1;    printf(&quot;i=%d\\n&quot;,i);&#125;   //这个时候，i就会在这里释放\n\n4）无大括号else的匹配：else总是和最近的那个if匹配\n5）if-else与switch-case的区别：前者从头开始遍历，后者直接跳转到符合要求处\n每一个case块后面的break在语法上是可以不写的，break的意思代表立即结束整个switch-case结构，如果case块中没有break，那么就会直接穿透到下一个case中执行代码，直到遇到break才会结束switch结构，或者执行完\n如果多个case块的处理逻辑是一样的，那么我们可以利用case穿透简写代码\nswitch后面的表达式任何类型都是可以的，除了实型\n如果case块中要声明变量，那么这个case块就必须要使用大括弧\nswitch结构只能做等值判断，不能直接做范围判断，并且case后面的数据不能有变量\nbreak的作用：\n6）break和continue的区别：\n如果在循环体中遇到了break，就会立即结束当前循环结构，但是还会继续外层循环\ncontinue只能使用在循环体中，如果遇到了continue，会立即结束本次循环，然后回去判断循环条件【注意一下while循环体和for循环体不一样(前者可能包括i++，后者不包括)】\nbreak和continue都只能作用于当前循环体！\n一道比较有意思的面试题：\n7）while和do-while的区别：前者先判断条件后进循环体，后者先进循环体再判断条件\n8）for循环中，三个表达式都可以省略，但是分号不能省略；如果第二个表达式省略，那么循环条件默认就是成立的\nfor循环三个表达式其实可以是任意的C语句：\n9）goto：可以将CPU的执行跳转到当前函数的别的地方继续执行\n当执行到goto语句的时候，CPU就会跳转到指定的标签的地方继续往下执行\ngoto语句也可以实现循环操作\ngoto可以往前跳，也可以往后跳，但是只能在当前函数中跳\n取标签名下面的那一句代码不能是声明变量：\n10）break和goto：\n","categories":["计算机理论"],"tags":["编程语言-C语言"]},{"title":"程序的内存分区模型","url":"/2018/10/15/%E8%AE%A1%E7%AE%97%E6%9C%BA%E7%90%86%E8%AE%BA/%E7%BC%96%E7%A8%8B%E8%AF%AD%E8%A8%80/C++/7_%E7%A8%8B%E5%BA%8F%E7%9A%84%E5%86%85%E5%AD%98%E5%88%86%E5%8C%BA%E6%A8%A1%E5%9E%8B/","content":"C++程序在执行时，将内存大方向划分为4个区域1）代码区：存放函数体的二进制代码，由操作系统进行管理2）全局区：存放全局变量和静态变量以及常量【静态变量：static int s_a&#x3D;10;】【常量分为字符串常量和const修饰的全局变量】3）栈区：由编译器自动分配释放，存放函数的参数值，局部变量和const修饰的局部变量等4）堆区：由程序员分配和释放，若程序不释放，程序结束时由操作系统回收\n内存四区的意义：不同区域存放的数据，赋予不同的生命周期，给我们更大的灵活编程\n程序运行前：在程序编译后，生成了exe可执行程序，未执行该程序前分为两个区域：1）代码区：存放CPU执行的机器指令；代码区是共享的，共享的目的是对于频繁被执行的程序，只需要在内存中有一份代码即可；代码区是只读的，使其只读的原因是防止程序意外的修改了它的指令2）全局区：全局变量和静态变量存放在此；全局区还包含了常量区，字符串常量和其他常量也存放在此；该区域的数据在程序结束后由操作系统释放\n程序运行后：1）栈区：由编译器自动分配释放，存放函数的参数值，局部变量等；不要返回局部变量的地址，栈区开辟的数据由编译器自动释放\n第一次可以打印正确的数字，是因为编译器做了保留；第二次这个数据就不再保留了：2）堆区：在C++中主要利用new在堆区开辟内存，释放利用操作符delete【利用new创建的数据，会返回该数据对应的类型的指针】\n在堆区创建数组：int * arr &#x3D; new int[10];释放堆区数组：delete[] arr;\n","categories":["计算机理论"],"tags":["编程语言-C++"]},{"title":"数组","url":"/2018/09/30/%E8%AE%A1%E7%AE%97%E6%9C%BA%E7%90%86%E8%AE%BA/%E7%BC%96%E7%A8%8B%E8%AF%AD%E8%A8%80/C%E8%AF%AD%E8%A8%80/7_%E6%95%B0%E7%BB%84/","content":"局部变量的回收：在大括弧执行完毕之后，定义在这个大括弧中的变量就会被系统立即回收，声明变量的时候，其实是找系统为你从高地址向低地址分配指定字节数的连续空间，当变量回收的时候，其实就是告诉系统变量占用的字节不再使用了，可以分配给别的变量了，变量所占用的字节的数据是不会清空的【垃圾值的由来】\n当将全局变量声明出来以后，系统会自动的将全局变量中的数据清零\n一维数组：\nint arr[3];，其中所有的元素具有相同的数据类型，一旦创建，不能改变大小\n数组中的元素在内存中是连续依次排列的：\n遍历数组：\n一维数组的初始化：1）使用这种方式初始化，数组的长度就不能使用变量了，但是使用宏可以【也可以干脆直接省略数组中的长度，这样数组的长度就是由大括弧中的数据的个数来决定的】\nint len=3;int arr[len]=&#123;10,20,30&#125;;  //错误\n\n2）int arr[3]=&#123;10&#125;;这个时候数组的第0个元素的值是10，其他的元素的值被自动初始化为0，所以如果我们要将数组中的所有元素全部初始化为0，只需要在大括弧中写一个0就可以了\n3）指定下标的初始化，其他的元素的值就自动初始化为0：int arr[3]=&#123;[1]=10,[2]=20&#125;;\n声明一个数组，在内存中从高字节向低字节申请连续的（数组的长度*每个元素的字节数）个字节的空间\n数组的元素的本质就是一个普通类型的变量，一个数组就是由多个普通类型的变量联合而成的\nC语言的数组名中存储的就是数组的地址！\n数组的大小：sizeof(a)/sizeof(a[0])sizeof给出整个数组所占据的内容的大小，单位是字节；sizeof(a[0])给出数组中单个元素的大小，于是相除就得到了数组的单元个数；这样的代码，一旦修改数组中初始的数据，不需要修改遍历的代码\n数组的赋值：数组变量本身不能被赋值，要把一个数组的所有元素交给另一个数组，必须采用遍历\nfor(int i=0;i&lt;length;i++)&#123;     b[i]=a[i];&#125;\n\n二维数组：\n二维数组的长度一般认为是元素的个数【行*列】\n二维数组的遍历：a[i][j]是一个int，表示第i行第j列上的单元\n二维数组的初始化：\n1）1.列数是必须给出的，行数可以由编译器来数2.每行一个{}，逗号分隔3.最后的逗号可以存在，有古老的传统\n2）\nint arr[3][4]=&#123;&#123;10&#125;,&#123;20&#125;,&#123;30&#125;&#125;;a[0][0]=10a[1][0]=20a[2][0]=30\n其他元素会自动初始化为0\n3）int arr[3][4]=&#123;10,20,30,40,50&#125;;按照顺序去初始化每一个元素，其他的元素的值就会被自动初始化为0\n4）int arr[3][4]=&#123;[1]=&#123;10,20,30,40&#125;,[2]=&#123;50,60,70,80&#125;&#125;;给指定的行初始化，其他的元素自动初始化为0\n二维数组从高地址向低地址申请了连续的（行列每一个元素占用的字节）个字节空间\n二维数组在内存中仍然是一块连续的空间，并不是一个表格\n\n求二维数组的长度的方法与一维数组一样：sizeof(arr)/sizeof(arr[0][0]);\n求二维数组的行数：sizeof(arr)/sizeof(arr[0]);\n求二维数组的列数：sizeof(arr[0])/sizeof(arr[0][0]);\n如果函数的参数是一个一维数组，那么我们在传递的时候可以传递二维数组的某一行，二维数组的行其实是一个一维数组\n二维数组也可以作为函数的参数【与一维数组类似】，但是其中形参的行数可以省略，列数不能省略，实参与形参的行数可以任意，实参的列数与形参的列数必须一致\n解决方案【与一维数组稍微不同！】\n","categories":["计算机理论"],"tags":["编程语言-C语言"]},{"title":"值传递、地址传递","url":"/2018/09/30/%E8%AE%A1%E7%AE%97%E6%9C%BA%E7%90%86%E8%AE%BA/%E7%BC%96%E7%A8%8B%E8%AF%AD%E8%A8%80/C%E8%AF%AD%E8%A8%80/9_%E5%80%BC%E4%BC%A0%E9%80%92%E3%80%81%E5%9C%B0%E5%9D%80%E4%BC%A0%E9%80%92/","content":"值传递：当函数参数的类型是int、float、double、char类型的时候，调用者传入一个实参变量，函数执行完毕之后，对实参变量的值没有影响\n我们来分析下面一段代码：为啥test函数和main函数中num的值不一样呢？？\n程序执行原理：\n地址传递：数组作为函数的参数时是地址传递，在传值的时候，是把实参数组名传递进来，数组名代表数组地址，所以这个时候传值传的是数组的地址，把数组的地址传递给了函数的参数，所以函数的参数也指向了实参数组【当数组作为函数的参数的时候，在函数的内部去修改这个参数数组的元素，其实修改的就是实参数组的元素】\n当数组作为函数的参数的时候，那么在传递的时候，会丢失数组的长度，在函数的内部使用sizeof计算参数数组的字节数，得到的永远都是8\n内部原理：如果函数的参数是一个数组，在声明这个参数的时候，并不会去真正的创建数组，而是去声明一个用来存储数组地址的指针变量，这个指针变量在内存中占据8个字节\n那我们函数内部想要得到原来的数组长度该怎么办呢？？\n如果我们的函数的参数是一个数组，这个时候还必须得加一个参数，让调用者将这个数组的长度传递进来\n如果我们为函数写了一个数组作为参数，其实编译器在编译的时候，已经把这个数组换成了指针【所以，以后为函数写一个数组参数的时候，不要写数组了，直接按照下图写一个指针】\n","categories":["计算机理论"],"tags":["编程语言-C语言"]},{"title":"汇总数据","url":"/2020/04/30/%E8%AE%A1%E7%AE%97%E6%9C%BA%E7%90%86%E8%AE%BA/%E6%95%B0%E6%8D%AE%E5%BA%93%E7%B3%BB%E7%BB%9F%E5%8E%9F%E7%90%86/%E3%80%8AMySQL%E5%BF%85%E7%9F%A5%E5%BF%85%E4%BC%9A%E3%80%8B/11_%E6%B1%87%E6%80%BB%E6%95%B0%E6%8D%AE/","content":"汇总数据\n聚集函数：运行在行组上，计算和返回单个值的函数\n1）AVG()函数：AVG()通过对表中行数计算并计算特定列值之和，求得该列的平均值。AVG()可用来返回所有列的平均值，也可以用来返回特定列或行的平均值\n返回products表中所有产品的平均价格SELECT AVG(prodprice) AS avgpriceFROM products;\n返回特定供应商所提供产品的平均价格SELECT AVG(prodprice) AS avgpriceFROM productsWHERE vend_id &#x3D;1003;\n2)COUNT()函数\n返回customers表中客户的总数：SELECT COUNT(*) AS num_custFROM customers;\n只对具有电子邮件地址的客户计数SELECT COUNT(custemail) AS numcustFROM customers;\n3)MAX()函数：要求指定列名SELECT MAX(prodprice) AS maxpriceFROM products;\n4)MIN()函数：要求指定列名SELECT MIN(prodprice) AS minpriceFROM products;\n5)SUM()函数：用来返回指定列值的和（总计）\n检索所订购物品的总数（所有quantity值之和）SELECT SUM(quantity) AS items_orderedFROM orderitemsWHERE order_num&#x3D;20005;\n合计每项物品的items_pricequantity，得到总的订单金额SELECT SUM(itempricequantity) AS totalpriceFROM orderitemsWHERE order_num&#x3D;20005;\n6)聚集不同值\n7）组合聚集函数SELECT COUNT(*) AS num_items,               MIN(prodprice) AS pricemin,               MAX(prodprice) AS pricemax,               AVG(prodprice) AS priceavgFROM products;\n","categories":["计算机理论"],"tags":["数据库系统原理-《MySQL必知必会》"]},{"title":"结构体(struct)","url":"/2018/09/30/%E8%AE%A1%E7%AE%97%E6%9C%BA%E7%90%86%E8%AE%BA/%E7%BC%96%E7%A8%8B%E8%AF%AD%E8%A8%80/C%E8%AF%AD%E8%A8%80/14_%E7%BB%93%E6%9E%84%E4%BD%93(struct)/","content":"我们使用结构体仅仅是创建了一个新的数据类型而已，并没有声明变量，是在指定新的数据类型是由哪些成员组合而成\nstruct Student&#123;   char *name;   int age;   int score;   float height;&#125;;struct Student stu;  //代表声明了一个struct Student类型的变量，变量名字叫做stu，这个时候stu才是一个变量，才会在内存中申请空间\n\n结构体初始化：\n结构和数组有点像，数组用[]运算符和下标访问其成员，结构用.运算符和名字访问其成员\n匿名结构体：这个结构体类型没有名称，只能在声明结构体的同时就创建变量，不能单独的声明这个结构体类型的变量\nstruct&#123;   char *barnd;   char *color;   int price;&#125;fengshan1;\n\n声明一个结构体变量，如果没有为这个结构体变量的成员赋值，那么成员是有值的，这个值是一个垃圾值；在声明结构体变量的同时，只要初始化一个成员，其他的成员就会被自动的初始化为0\n如果结构体类型是定义在函数的内部的，那么这个结构体类型只能在这个函数的内部使用，如果我们希望这个结构体类型可以用在所有的函数中，那么就把这个结构体类型定义在函数的外面\n结构体之间比较：\n相同结构体类型的变量之间是可以相互赋值的【值传递】\nstruct Student xiaoMing=&#123;&quot;小明&quot;,19,100&#125;;struct Student xiaoHua=xiaoMing;\n\n结构体数组：\n结构体指针：结构体变量是一个变量，struct Student xiaoMing=&#123;“小明”,18,100&#125;; xiaoMing首先是一个变量，类型是struct Student类型的，既然xiaoMing是一个变量，那么这个变量肯定是有地址的，既然有地址，那么就可以声明一个指针指向这个结构体变量\n结构指针：和数组不同，结构变量的名字并不是结构变量的地址，必须使用&amp;运算符struct date *pDate=&amp;today;\n结构体作为函数参数：int numberOfDays(struct date d)整个结构可以作为参数的值传入函数这时候是在函数内新建一个结构变量，并复制调用者的结构的值也可以返回一个结构这与数组完全不同\n\n\n结构体作为函数的参数【值传递】：\n改成指针后就是地址传递了\n结构体完全可以作为函数的返回值，在返回的时候，直接将这个结构体变量的值返回即可\n如果你要返回结构体变量的地址，那么就要把这个结构体变量创建在堆区：\n","categories":["计算机理论"],"tags":["编程语言-C语言"]},{"title":"分组数据","url":"/2020/04/30/%E8%AE%A1%E7%AE%97%E6%9C%BA%E7%90%86%E8%AE%BA/%E6%95%B0%E6%8D%AE%E5%BA%93%E7%B3%BB%E7%BB%9F%E5%8E%9F%E7%90%86/%E3%80%8AMySQL%E5%BF%85%E7%9F%A5%E5%BF%85%E4%BC%9A%E3%80%8B/12_%E5%88%86%E7%BB%84%E6%95%B0%E6%8D%AE/","content":"分组数据\n分组允许把数据分为多个逻辑组，以便能对每个组进行聚集计算\n1）SELECT  vendid,COUNT(*) AS numprodsFROM productsGROUP BY vend_id;\n2)WHERE过滤行，HAVING过滤分组SELECT  cust_id,COUNT() AS ordersFROM ordersGROUP BY cust_idHAVING COUNT() &gt;&#x3D;2;\n这里WHERE子句不起作用，因为过滤是基于分组聚集值而不是特定行值的\n3）列出具有2个（含）以上、价格为10（含）以上的产品的供应商SELECT  vendid,COUNT() AS numprodsFROM productsWHERE prod_price &gt;&#x3D;10GROUP BY vend_idHAVING COUNT() &gt;&#x3D;2;\nSELECT  vendid,COUNT() AS numprodsFROM productsGROUP BY vend_idHAVING COUNT() &gt;&#x3D;2;\n4）检索总计订单价格大于等于50的订单号和总计订单价格SELECT ordernum,SUM(quantityitemprice) AS ordertotalFROM orderitemsGROUP BY order_numHAVING SUM(quantityitem_price) &gt;&#x3D; 50;\n按总计订单价格排序输出：SELECT ordernum,SUM(quantityitemprice) AS ordertotalFROM orderitemsGROUP BY order_numHAVING SUM(quantityitem_price) &gt;&#x3D; 50ORDER BY ordertotal;\n5）\n","categories":["计算机理论"],"tags":["数据库系统原理-《MySQL必知必会》"]},{"title":"使用数据处理函数","url":"/2020/04/30/%E8%AE%A1%E7%AE%97%E6%9C%BA%E7%90%86%E8%AE%BA/%E6%95%B0%E6%8D%AE%E5%BA%93%E7%B3%BB%E7%BB%9F%E5%8E%9F%E7%90%86/%E3%80%8AMySQL%E5%BF%85%E7%9F%A5%E5%BF%85%E4%BC%9A%E3%80%8B/10_%E4%BD%BF%E7%94%A8%E6%95%B0%E6%8D%AE%E5%A4%84%E7%90%86%E5%87%BD%E6%95%B0/","content":"使用数据处理函数\n\n1）文本处理函数Upper()SELECT vendname,Upper(vendname) AS vendnameupcaseFROM vendorsORDER BY vend_name;\n2)日期和时间处理函数\nSELECT custid,ordernumFROM ordersWHERE order_date&#x3D;‘2005-09-01’;SELECT custid,ordernumFROM ordersWHERE Date(order_date)&#x3D;‘2005-09-01’;\n检索出2005年9月下的所有订单法1:SELECT custid,ordernumFROM ordersWHERE Date(order_date) BETWEEN ‘2005-09-01’ AND ‘2005-09-30’;\n法2:SELECT custid,ordernumFROM ordersWHERE Year(orderdate)&#x3D;2005 AND Month(orderdate)&#x3D;9;\n3)数值处理函数\n","categories":["计算机理论"],"tags":["数据库系统原理-《MySQL必知必会》"]},{"title":"使用子查询","url":"/2020/04/30/%E8%AE%A1%E7%AE%97%E6%9C%BA%E7%90%86%E8%AE%BA/%E6%95%B0%E6%8D%AE%E5%BA%93%E7%B3%BB%E7%BB%9F%E5%8E%9F%E7%90%86/%E3%80%8AMySQL%E5%BF%85%E7%9F%A5%E5%BF%85%E4%BC%9A%E3%80%8B/13_%E4%BD%BF%E7%94%A8%E5%AD%90%E6%9F%A5%E8%AF%A2/","content":"使用子查询\n查询：任何SQL语句都是查询，但此术语一般指SELECT语句\n1）列出订购物品TNT2的所有客户：\n法1:SELECT order_numFROM orderitemsWHERE prod_id&#x3D;’TNT2’;\nSELECT cust_idFROM ordersWHERE order_num IN(20005,20007);\nSELECT custname,custcontactFROM customersWHERE cust_id IN(10001,10004);\n法2:(在SELECT语句中，子查询总是从内向外处理)SELECT custname,custcontactFROM customersWHERE custid IN(SELECT custid                                FROM orders                                WHERE ordernum IN(SELECT ordernum                                                                      FROM orderitems                                                                      WHERE prod_id&#x3D;’TNT2’));\n法3:SELECT custname,custcontactFROM customers,orders,orderitemsWHERE customers.custid&#x3D;orders.custid   AND orderitems..ordernum&#x3D;orders.ordernum   AND prod_id&#x3D;’TNT2’;\n2)显示customers表中每个客户的订单总数SELECT custname,custstate,               (SELECT COUNT(*)                FROM orders                WHERE orders.custid&#x3D;customers.custid) AS ordersFROM customersORDER BY cust_name;\n相关子查询：涉及外部查询的子查询\n","categories":["计算机理论"],"tags":["数据库系统原理-《MySQL必知必会》"]},{"title":"联结表、内部联结或等值联结","url":"/2020/04/30/%E8%AE%A1%E7%AE%97%E6%9C%BA%E7%90%86%E8%AE%BA/%E6%95%B0%E6%8D%AE%E5%BA%93%E7%B3%BB%E7%BB%9F%E5%8E%9F%E7%90%86/%E3%80%8AMySQL%E5%BF%85%E7%9F%A5%E5%BF%85%E4%BC%9A%E3%80%8B/14_%E8%81%94%E7%BB%93%E8%A1%A8%E3%80%81%E5%86%85%E9%83%A8%E8%81%94%E7%BB%93%E6%88%96%E7%AD%89%E5%80%BC%E8%81%94%E7%BB%93/","content":"联结表【内部联结或等值联结】\n\n联结是一种机制，用来在一条SELECT语句中关联表，使用特殊的语法，可以联结多个表返回一组输出，联结在运行时关联表中正确的行\n1）SELECT vendname,prodname,prod_priceFROM vendors,productsWHERE vendors.vendid&#x3D;products.vendidORDER BY vendname,prodname;\n笛卡尔积：由没有联结条件的表关系返回的结果为笛卡尔积，检索出的行的数目将是第一个表中的行数乘以第二个表中的行数SELECT vendname,prodname,prod_priceFROM vendors,productsORDER BY vendname,prodname;\n2）SELECT vendname,prodname,prod_priceFROM vendors INNER JOIN productsON vendors.vendid&#x3D;products.vendid;\n\n\n\nSELECT prodname,vendname,prod_price,quantityFROM orderitems,products,vendorsWHERE products.vendid&#x3D;vendors.vendid   AND orderitems.prodid&#x3D;products.prodid   AND order_num&#x3D;20005;\n","categories":["计算机理论"],"tags":["数据库系统原理-《MySQL必知必会》"]},{"title":"全文本搜索","url":"/2020/04/30/%E8%AE%A1%E7%AE%97%E6%9C%BA%E7%90%86%E8%AE%BA/%E6%95%B0%E6%8D%AE%E5%BA%93%E7%B3%BB%E7%BB%9F%E5%8E%9F%E7%90%86/%E3%80%8AMySQL%E5%BF%85%E7%9F%A5%E5%BF%85%E4%BC%9A%E3%80%8B/17_%E5%85%A8%E6%96%87%E6%9C%AC%E6%90%9C%E7%B4%A2/","content":"全文本搜索\n\n1）CREATE TABLE语句接受FULLTEXT子句，它给出被索引列的一个逗号分隔的列表\n2）在索引之后，使用两个函数Match()和Against()执行全文本搜索，其中Match()指定被搜索的列，Against()指定要使用的搜索表达式；传递给Match()的值必须与FULLTEXT()定义中的相同，如果指定多个列，则必须列出它们（而且次序正确）SELECT note_textFROM productnotesWHERE Match(note_text) Against(‘rabbit’);\n3）这条SELECT语句同样检索出两行，但次序不同（虽然并不总是出现这种情况）SELECT note_textFROM productnotesWHERE note_text LIKE ‘%rabbit%’;\n上述两条SELECT语句都不包含ORDER BY子句，后者以不特别有用的顺序返回数据。前者返回以文本匹配的良好程度排序的数据。两个行都包含词rabbit，但包含词rabbit作为第3个词的行的等级比作为第20个词的行高\n4）演示排序如何工作SELECT note_text，      Match(note_text) Against(‘rabbit’) AS rankFROM productnotes\n如果指定多个搜索项，则包含多数匹配词的那些行将具有比包含较少词（或仅有一个匹配）的那些行高的等级值\n\n\n\n查询扩展用来设法放宽所返回的全文本搜索结果的范围SELECT note_textFROM productnotesWHERE Match(note_text) Against(‘anvils’);\n表中的行越多（这些行中的文本就越多，使用查询扩展返回的结果越好）SELECT note_textFROM productnotesWHERE Match(note_text) Against(‘anvils’ WITH QUERY EXPANSION);\n6）布尔文本搜索，以布尔方式，可以提供关于如下内容的细节：SELECT note_textFROM productnotesWHERE Match(note_text) Against(‘heavy’ IN BOOLEAN MODE);\n匹配包含heavy但不包含任意以rope开始的词的行：SELECT note_textFROM productnotesWHERE Match(note_text) Against(‘heavy -rope*’ IN BOOLEAN MODE);\n","categories":["计算机理论"],"tags":["数据库系统原理-《MySQL必知必会》"]},{"title":"组合查询","url":"/2020/04/30/%E8%AE%A1%E7%AE%97%E6%9C%BA%E7%90%86%E8%AE%BA/%E6%95%B0%E6%8D%AE%E5%BA%93%E7%B3%BB%E7%BB%9F%E5%8E%9F%E7%90%86/%E3%80%8AMySQL%E5%BF%85%E7%9F%A5%E5%BF%85%E4%BC%9A%E3%80%8B/16_%E7%BB%84%E5%90%88%E6%9F%A5%E8%AF%A2/","content":"组合查询\nMySQL也允许执行多个查询（多条SELECT语句），并将结果作为单个查询结果集返回，这些组合查询通常称为并或复合查询\n1）假如需要价格小于等于5的所有物品的一个列表，而且还想包括供应商1001和1002生产的所有物品（不考虑价格）\n法1:SELECT vendid,prodid,prod_priceFROM productsWHERE prod_price&lt;&#x3D;5;\nSELECT vendid,prodid,prod_priceFROM productsWHERE vend_id IN(1001,1002);\n法2:SELECT vendid,prodid,prod_priceFROM productsWHERE prod_price&lt;&#x3D;5;UNIONSELECT vendid,prodid,prod_priceFROM productsWHERE vend_id IN(1001,1002);\nUNION从查询结果集中自动去除了重复的行，这是UNION的默认行为，但是如果需要，可以改变它，事实上，如果想返回所有匹配行，可使用UNION ALL而不是UNIONSELECT vendid,prodid,prod_priceFROM productsWHERE prod_price&lt;&#x3D;5;UNION ALLSELECT vendid,prodid,prod_priceFROM productsWHERE vend_id IN(1001,1002);\n2）SELECT语句的输出用ORDER BY子句排序。在用UNION组合查询时，只能使用一条ORDER BY子句，它必须出现在最后一条SELECT语句之后。对于结果集，不存在用一种方式排序一部分，而又用另一种方式排序另一部分的情况。因此不允许使用多条ORDER BY子句SELECT vendid,prodid,prod_priceFROM productsWHERE prod_price&lt;&#x3D;5;UNIONSELECT vendid,prodid,prod_priceFROM productsWHERE vend_id IN(1001,1002)ORDER BY vendid,prodprice;\n","categories":["计算机理论"],"tags":["数据库系统原理-《MySQL必知必会》"]},{"title":"创建高级联结、自联结、自然联结、外部联结","url":"/2020/04/30/%E8%AE%A1%E7%AE%97%E6%9C%BA%E7%90%86%E8%AE%BA/%E6%95%B0%E6%8D%AE%E5%BA%93%E7%B3%BB%E7%BB%9F%E5%8E%9F%E7%90%86/%E3%80%8AMySQL%E5%BF%85%E7%9F%A5%E5%BF%85%E4%BC%9A%E3%80%8B/15_%E5%88%9B%E5%BB%BA%E9%AB%98%E7%BA%A7%E8%81%94%E7%BB%93%E3%80%81%E8%87%AA%E8%81%94%E7%BB%93%E3%80%81%E8%87%AA%E7%84%B6%E8%81%94%E7%BB%93%E3%80%81%E5%A4%96%E9%83%A8%E8%81%94%E7%BB%93/","content":"创建高级联结【自联结、自然联结、外部联结】\n别名除了用于列名和计算字段外，SQL还允许给表名起别名，这样做有两个主要理由：1）缩短SQL语句2）允许在单条SELECT语句中多次使用相同的表\n1）表别名不仅能用于WHERE子句，它还可以用于SELECT的列表、ORDER BY子句以及语句的其他部分，表别名只在查询执行中使用，与列别名不一样，表别名不返回到客户机SELECT custname,custcontactFROM customers AS c,orders AS o,orderitems AS oiWHERE c.custid&#x3D;o.custid      AND oi.ordernum&#x3D;o.ordernum      AND prod_id&#x3D;’TNT2’;\n2）自联结首先找到生产ID为DTNTR的物品的供应商，然后找出这个供应商生产的其他物品SELECT prodid,prodnameFROM productsWHERE vendid &#x3D;(SELECT vendid                                FROM products                                WHERE prod_id&#x3D;‘DTNTR’);\nSELECT p1.prodid,p1.prodnameFROM products AS p1,products AS p2WHERE p1.vendid&#x3D;p2.vendid    AND p2.prod_id&#x3D;‘DTNTR’;\n3)无论何时对表进行联结，应该至少有一个列出现在不止一个表中（被联结的列），标准的联结返回所有数据，甚至相同的列多次出现。自然联结排除多次出现，使每个列只返回一次\n4）联结包含了那些在相关表中没有关联行的行，这种类型的联结称为外部联结\n检索所有客户及其订单（内部联结）SELECT customers.custid,orders.ordernumFROM customers INNER JOIN orders   ON customers.custid&#x3D;orders.custid;\n为了检索所有客户，包括那些没有订单的客户（外部联结）：SELECT customers.custid,orders.ordernumFROM customers LEFT OUTER JOIN orders   ON customers.custid&#x3D;orders.custid;\n5)检索所有客户及每个客户所下的订单数SELECT customers.cust_name,               customers.cust_id,               COUNT(orders.ordernum) AS numordFROM customers INNER JOIN orders   ON customers.custid&#x3D;orders.custidGROUP BY customers.cust_id;\n\n\n\nSELECT customers.cust_name,               customers.cust_id,               COUNT(orders.ordernum) AS numordFROM customers LEFT OUTER JOIN orders   ON customers.custid&#x3D;orders.custidGROUP BY customers.cust_id;\n","categories":["计算机理论"],"tags":["数据库系统原理-《MySQL必知必会》"]},{"title":"插入数据","url":"/2020/04/30/%E8%AE%A1%E7%AE%97%E6%9C%BA%E7%90%86%E8%AE%BA/%E6%95%B0%E6%8D%AE%E5%BA%93%E7%B3%BB%E7%BB%9F%E5%8E%9F%E7%90%86/%E3%80%8AMySQL%E5%BF%85%E7%9F%A5%E5%BF%85%E4%BC%9A%E3%80%8B/18_%E6%8F%92%E5%85%A5%E6%95%B0%E6%8D%AE/","content":"插入数据\nINSERT是用来插入（或添加）行到数据库表的【INSERT语句一般不会产生输出】插入可以用几种方式使用：\n1）插入完整的行INSERT INTO CustomersVALUES(NULL,               ‘Pep E.LaPew’,               ‘100 Main Street’,               ‘Los Angeles’,               ‘CA’,               ‘90046’,               ‘USA’,               NULL,               NULL);\nINSERT INTO Customers(cust_name,         cust_address,         cust_city,         cust_state,         cust_zip,         cust_country,         cust_contact,         cust_email)VALUES(‘Pep E.LaPew’,               ‘100 Main Street’,               ‘Los Angeles’,               ‘CA’,               ‘90046’,               ‘USA’,               NULL,               NULL);\n2)插入多个行INSERT INTO Customers(cust_name,         cust_address,         cust_city,         cust_state,         cust_zip,         cust_country)VALUES(‘Pep E.LaPew’,               ‘100 Main Street’,               ‘Los Angeles’,               ‘CA’,               ‘90046’,               ‘USA’);INSERT INTO Customers(cust_name,         cust_address,         cust_city,         cust_state,         cust_zip,         cust_country)VALUES(‘M.Martian’,               ’42 Galaxy Way’,               ’New York’,               ‘NY’,               ’11213’,               ‘USA’);\n只要每条INSERT语句中的列名（和次序）相同，可以如下组合各语句：INSERT INTO Customers(cust_name,         cust_address,         cust_city,         cust_state,         cust_zip,         cust_country)VALUES(               ‘Pep E.LaPew’,               ‘100 Main Street’,               ‘Los Angeles’,               ‘CA’,               ‘90046’,               ‘USA’              )，              (               ‘M.Martian’,               ’42 Galaxy Way’,               ’New York’,               ‘NY’,               ’11213’,               ‘USA’               );\n3）插入检索出的数据INSERT INTO Customers(cust_id,         cust_contact,         cust_email,         cust_name,         cust_address,         cust_city,         cust_state,         cust_zip,         cust_country)SELECT cust_id,         cust_contact,         cust_email,         cust_name,         cust_address,         cust_city,         cust_state,         cust_zip,         cust_countryFROM custnew;\nINSERT SELECT中SELECT语句可包含WHERE子句以过滤插入的数据\n","categories":["计算机理论"],"tags":["数据库系统原理-《MySQL必知必会》"]},{"title":"数据库基本术语","url":"/2020/04/30/%E8%AE%A1%E7%AE%97%E6%9C%BA%E7%90%86%E8%AE%BA/%E6%95%B0%E6%8D%AE%E5%BA%93%E7%B3%BB%E7%BB%9F%E5%8E%9F%E7%90%86/%E3%80%8AMySQL%E5%BF%85%E7%9F%A5%E5%BF%85%E4%BC%9A%E3%80%8B/1_%E6%95%B0%E6%8D%AE%E5%BA%93%E5%9F%BA%E6%9C%AC%E6%9C%AF%E8%AF%AD/","content":"\n数据库：保存有组织的数据的容器（通常是一个文件或一组文件）\n表：某种特定类型数据的结构化清单，数据库中的每个表都有一个名字，用来标识自己，此名字是唯一的，这表示数据库中没有其他表具有相同的名字【虽然在相同数据库中不能两次使用相同的表名，但在不同数据库中却可以使用相同的表名】\n模式：关于数据库和表的布局及特性的信息\n列：表中的一个字段，所有表都是由一个或多个列组成的\n数据类型：所容许的数据的类型，每个表列都有相应的数据类型，它限制（或容许）该列中存储的数据\n行：表中的一个记录\n主键：一列（或一组列），其值能够唯一区分表中每个行\n表中的任何列都可以作为主键，只要他满足以下条件：1）任意两行都不具有相同的主键值2）每个行都必须具有一个主键值（主键列不允许NULL值）\nps aux | grep mysql\n&#x2F;usr&#x2F;local&#x2F;mysql&#x2F;bin&#x2F;mysql -u root -p\n关键字：作为MySQL语言组成部分的一个保留字，绝不要用关键字命名一个表或列\nSQL语句不区分大小写！！\n","categories":["计算机理论"],"tags":["数据库系统原理-《MySQL必知必会》"]},{"title":"使用存储过程","url":"/2020/04/30/%E8%AE%A1%E7%AE%97%E6%9C%BA%E7%90%86%E8%AE%BA/%E6%95%B0%E6%8D%AE%E5%BA%93%E7%B3%BB%E7%BB%9F%E5%8E%9F%E7%90%86/%E3%80%8AMySQL%E5%BF%85%E7%9F%A5%E5%BF%85%E4%BC%9A%E3%80%8B/22_%E4%BD%BF%E7%94%A8%E5%AD%98%E5%82%A8%E8%BF%87%E7%A8%8B/","content":"使用存储过程\n存储过程简单来说，就是为以后的使用而保存的一条或多条MySQL语句的集合。可将其视为批文件，虽然它们的作用不仅限于批处理\n1）执行存储过程：MySQL称存储过程的执行为调用，因此MySQL执行存储过程的语句为CALL，CALL接受存储过程的名字以及需要传递给它的任意参数CALL productpricing(@pricelow,                                    @pricehigh,                                    @priceaverage);\n2）创建存储过程CREATE PROCEDURE productpricing()BEGIN     SELECT Avg(prod_price) AS priceaverage     FROM products;END;3)使用存储过程：CALL productpricing();\n4）删除存储过程：DROP PROCEDURE productpricing;\n变量：内存中一个特定的位置，用来临时存储数据变量名：所有MySQL变量都必须以@开始\n5)每个参数必须具有指定的类型，这里使用十进制值，关键字OUT指出相应的参数用来从存储过程传出一个值（返回给调用者）；MySQL支持IN（传递给存储过程）、OUT（从存储过程传出）和INOUT（对存储过程传入和传出）类型的参数CREATE PROCEDURE productpricing(     OUT pl DECIMAL(8,2),     OUT ph DECIMAL(8,2),     OUT pa DECIMAL(8,2))BEGIN     SELECT Min(prod_price)     INTO pl     FROM products;     SELECT Max(prod_price)     INTO ph     FROM products;     SELECT Avg(prod_price)     INTO pa     FROM products;END;\nCALL productpricing(@pricelow,                                    @pricehigh,                                    @priceaverage);为了获得3个值，可使用：SELECT @pricehigh,@pricelow, @priceaverage;\n\n\n\nCREATE PROCEDURE ordertotal(     IN onumber INT,     OUT ototal DECIMAL(8,2))BEGIN   SELECT Sum(item_price*quantity)   FROM orderitems;   WHERE order_num&#x3D;onumber   INTO ototal;END;\nCALL ordertotal(20005,@total);\nSELECT @total;\n\n","categories":["计算机理论"],"tags":["数据库系统原理-《MySQL必知必会》"]},{"title":"更新和删除数据","url":"/2020/04/30/%E8%AE%A1%E7%AE%97%E6%9C%BA%E7%90%86%E8%AE%BA/%E6%95%B0%E6%8D%AE%E5%BA%93%E7%B3%BB%E7%BB%9F%E5%8E%9F%E7%90%86/%E3%80%8AMySQL%E5%BF%85%E7%9F%A5%E5%BF%85%E4%BC%9A%E3%80%8B/19_%E6%9B%B4%E6%96%B0%E5%92%8C%E5%88%A0%E9%99%A4%E6%95%B0%E6%8D%AE/","content":"更新和删除数据\n1）为了更新（修改）表中的数据，可使用UPDATE语句，可采用两种方式使用UPDATE：更新表中特定行；更新表中所有行；\nUPDATE语句的组成：1）要更新的表2）列名和它们的新值3）确定要更新行的过滤条件\nUPDATE customersSET cust_email&#x3D;‘ elmer@fudd.com ’WHERE cust_id&#x3D;10005;\nUPDATE customersSET cust_name&#x3D;’The Fudds’,        cust_email&#x3D;‘ elmer@fudd.com ’WHERE cust_id&#x3D;10005;\n为了删除某个列的值，可设置它为NULL（假定表定义允许NULL值）UPDATE customersSET cust_email&#x3D;NULLWHERE cust_id&#x3D;10005;\n2）为了从一个表中删除（去掉）数据，可使用DELETE语句从表中删除特定的行从表中删除所有行\nDELETE FROM customersWHERE cust_id &#x3D;10006;\n\n","categories":["计算机理论"],"tags":["数据库系统原理-《MySQL必知必会》"]},{"title":"管理事务处理","url":"/2020/04/30/%E8%AE%A1%E7%AE%97%E6%9C%BA%E7%90%86%E8%AE%BA/%E6%95%B0%E6%8D%AE%E5%BA%93%E7%B3%BB%E7%BB%9F%E5%8E%9F%E7%90%86/%E3%80%8AMySQL%E5%BF%85%E7%9F%A5%E5%BF%85%E4%BC%9A%E3%80%8B/25_%E7%AE%A1%E7%90%86%E4%BA%8B%E5%8A%A1%E5%A4%84%E7%90%86/","content":"管理事务处理\n\n事务处理可以用来维护数据库的完整性，它保证成批的MySQL操作要么完全执行，要么完全不执行\n事务处理是一种机制，用来管理必须成批执行的MySQL操作，以保证数据库不包含不完整的操作结果，利用事务处理，可以保证一组操作不会中途停止，它们或者作为整体执行，或者完全不执行（除非明确指示），如果没有发生错误，整组语句提交给（写到）数据库表。如果发生错误，则进行回退（撤销）以恢复数据库到某个已知且安全的状态\n事务：指一组SQL语句回退：指撤销指定SQL语句的过程提交：指将未存储的SQL语句结果写入数据库表保留点：指事务处理中设置的临时占位符，你可以对它发布回退（与回退整个事务处理不同）\n1）START TRANSACTION标识事务的开始\n2）MySQL的ROLLBACK命令用来回退（撤销）MySQL语句：SELECT * FROM ordertotals;START TRANSACTION;DELETE FROM ordertotals;SELECT * FROM ordertotals;ROLLBACK;SELECT * FROM ordertotals;\n3)一般的MySQL语句都是直接针对数据库表执行和编写的，这就是所谓的隐含提交，即提交（写或保存）操作是自动进行的；但是，在事务处理块中，提交不会隐含的进行。为进行明确的提交，使用COMMIT语句START TRANSACTION;DELETE FROM orderitems WHERE order_num&#x3D;20010;DELETE FROM orders WHERE order_num&#x3D;20010;COMMIT;\n\n使用保留点：这些占位符称为保留点\n创建占位符：SAVEPOINT deletel;\n每个保留点都取标识它的唯一名字，以便在回退时，MySQL知道要回退到何处。为了回退到本例给出的保留点，可如下进行：ROLLBACK TO deletel;\n","categories":["计算机理论"],"tags":["数据库系统原理-《MySQL必知必会》"]},{"title":"使用视图","url":"/2020/04/30/%E8%AE%A1%E7%AE%97%E6%9C%BA%E7%90%86%E8%AE%BA/%E6%95%B0%E6%8D%AE%E5%BA%93%E7%B3%BB%E7%BB%9F%E5%8E%9F%E7%90%86/%E3%80%8AMySQL%E5%BF%85%E7%9F%A5%E5%BF%85%E4%BC%9A%E3%80%8B/21_%E4%BD%BF%E7%94%A8%E8%A7%86%E5%9B%BE/","content":"使用视图\n视图是虚拟的表，与包含数据的表不一样，视图只包含使用时动态检索数据的查询\nSELECT custname,custcontactFROM customers,orders,orderitemsWHERE customers.custid&#x3D;orders.custid     AND orderitems.ordernum&#x3D;orders.ordernum     AND prod_id&#x3D;’TNT2’;\n现在，假如可以把整个查询包装成一个名为productcustomers的虚拟表，则可以如下轻松地检索出相同的数据：SELECT custname,custcontactFROM productcustomersWHERE prod_id&#x3D;’TNT2’;\n1）CREATE VIEW productcustomers ASSELECT custname,custcontact,prod_idFROM customers,orders,orderitemsWHERE customers.custid&#x3D;orders.custid   AND orderitems.ordernum&#x3D;orders.ordernum;\n为检索订购了产品TNT2的客户：SELECT custname,custcontactFROM productcustomersWHERE prod_id&#x3D;’TNT2’;\n可以看出，视图极大的简化了复杂SQL语句的使用，利用视图，可一次性编写基础的SQL，然后根据需要多次使用\n2）SELECT Concat(RTrim(vendname)，‘ （’，RTrim(vendcountry)，‘）’）AS vend_titleFROM vendorsORDER BY vend_name;\nCREATE VIEW vendorlocations ASSELECT Concat(RTrim(vendname)，‘ （’，RTrim(vendcountry)，‘）’）AS vend_titleFROM vendorsORDER BY vend_name;\nSELECT *FROM vendorlocations;\n\n\n\nCREATE VIEW customeremaillist ASSELECT custid,custname,cust_emailFROM customersWHERE cust_email IS NOT NULL;\nSELECT *FROM customeremaillist;\n\n\n\nSELECT prod_id,              quantity,              item_price,              quantity*itemprice AS expandedpriceFROM orderitemsWHERE order_num&#x3D;20005;\nCREATE VIEW orderitemsexpanded ASSELECT prod_id,              quantity,              item_price,              quantity*itemprice AS expandedpriceFROM orderitems;\nSELECT *FROM orderitemsexpandedWHERE order_num&#x3D;20005;\n\n","categories":["计算机理论"],"tags":["数据库系统原理-《MySQL必知必会》"]},{"title":"使用触发器","url":"/2020/04/30/%E8%AE%A1%E7%AE%97%E6%9C%BA%E7%90%86%E8%AE%BA/%E6%95%B0%E6%8D%AE%E5%BA%93%E7%B3%BB%E7%BB%9F%E5%8E%9F%E7%90%86/%E3%80%8AMySQL%E5%BF%85%E7%9F%A5%E5%BF%85%E4%BC%9A%E3%80%8B/24_%E4%BD%BF%E7%94%A8%E8%A7%A6%E5%8F%91%E5%99%A8/","content":"使用触发器\n触发器是MySQL响应以下任意语句而自动执行的一条MySQL语句（或位于BEGIN和END语句之间的一组语句）：                 DELETE;                 INSERT;                 UPDATE;其他MySQL语句不支持触发器\n在创建触发器时，需要给出4条信息：1）唯一的触发器名2）触发器关联的表3）触发器应该响应的活动（DELETE、INSERT、UPDATE）4）触发器何时执行（处理之前或之后）\n1）创建触发器CREATE TRIGGER newproduct AFTER INSERT ON productsFOR EACH ROW SELECT ‘Product added’;\n只有表才支持触发器，视图不支持（临时表也不支持）；触发器按每个表每个事件每次的定义，每个表每个事件每次只允许一个触发器，因此每个表最多支持6个触发器（每条INSERT、UPDATE、DELETE的之前和之后）。单一触发器不能与多个事件或多个表关联，所以，如果你需要一个对INSERT和UPDATE操作执行的触发器，则应该定义两个触发器。\n2）删除触发器DROP TRIGGER newproduct;触发器不能更新或覆盖，为了修改一个触发器，必须先删除它，然后再重新创建\n3）使用触发器（1）INSERT触发器CREATE TRIGGER neworder AFTER INSERT ON ordersFOR EACH ROW SELECT NEW.order_num;\n(2)DELETE触发器\n【原书缺页？？？？】\n","categories":["计算机理论"],"tags":["数据库系统原理-《MySQL必知必会》"]},{"title":"创建和操纵表","url":"/2020/04/30/%E8%AE%A1%E7%AE%97%E6%9C%BA%E7%90%86%E8%AE%BA/%E6%95%B0%E6%8D%AE%E5%BA%93%E7%B3%BB%E7%BB%9F%E5%8E%9F%E7%90%86/%E3%80%8AMySQL%E5%BF%85%E7%9F%A5%E5%BF%85%E4%BC%9A%E3%80%8B/20_%E5%88%9B%E5%BB%BA%E5%92%8C%E6%93%8D%E7%BA%B5%E8%A1%A8/","content":"创建和操纵表\n一般有两种创建表的方法：1）使用具有交互式创建和管理表的工具2）表也可以直接用MySQL语句操纵\n值得注意的是，在使用交互式工具时，实际上使用的是MySQL语句，但是这些语句不是用户编写的，界面工具会自动生成并执行相应的MySQL语句（更改现有表时也是这样）\n为利用CREATE TABLE创建表，必须给出下列信息：1）新表的名字，在关键字CREATE TABLE之后给出2）表列的名字和定义，用逗号分隔\n1）表的主键可以在创建表时用PRIMARY KEY关键字指定，为创建由多个列组成的主键，应该以逗号分隔的列表给出各列名；主键为其值唯一标识表中每个行的列，主键中只能使用不允许NULL值的列，允许NULL值的列不能作为唯一标识CREATE TABLE customers(     custid              int                NOT NULL AUTOINCREMENT,     cust_name        char(50)     NOT NULL,     cust_address    char(50)     NULL,     cust_city           char(50)     NULL,     cust_state         char(5)       NULL,     cust_zip             char(10)     NULL,     cust_country     char(50)     NULL,     cust_contact     char(50)     NULL,     cust_email         char(255)   NULL,     PRIMARY KEY (cust_id))ENGINE-InnoDB;\n\nAUTOINCREMENT告诉MySQL，本列每当增加一行时自动增量。每次执行一个INSERT操作时，MySQL自动对该列增量（从而才有这个关键字AUTOINCREMENT），给该列赋予下一个可用的值。这样给每个行分配一个唯一的custid，从而可以用作主键值；每个表只允许一个AUTOINCREMENT列，而且它必须被索引（如通过使它成为主键）\n2）如果在插入行时没有给出值，MySQL允许指定此时使用的默认值。默认值用CREATE TABLE语句的列定义中的DEFAULT关键字指定CREATE TABLE orderitems(     order_num        int                     NOT NULL,     order_item        int                     NOT NULL,     prod_id             char(10)           NOT NULL,     quantity            int                     NOT NULL DEFAULT 1,     item_price        decimal(8,2)    NOT NULL,     PRIMARY KEY(ordernum,orderitem))ENGINE-InnoDB;\n3)更新表为了使用ALTER TABLE更改表结构，必须给出下面的信息：1）在ALTER TABLE之后给出要更改的表名（该表必须存在，否则将出错）2）所做更改的列表\nALTER TABLE vendorsADD vend_phone CHAR(20);\n删除刚刚添加的列：ALTER TABLE VendorsDROP COLUMN vend_phone;\n4)删除表：删除整个表而不是其内容，删除表没有确认，也不能撤销，执行这条语句将永久删除该表\nDROP TABLE customers2;\n5)重命名表\nRENAME TABLE customers2 TO customers,                            backup_vendors TO vendors;\n","categories":["计算机理论"],"tags":["数据库系统原理-《MySQL必知必会》"]},{"title":"全球化和本地化","url":"/2020/04/30/%E8%AE%A1%E7%AE%97%E6%9C%BA%E7%90%86%E8%AE%BA/%E6%95%B0%E6%8D%AE%E5%BA%93%E7%B3%BB%E7%BB%9F%E5%8E%9F%E7%90%86/%E3%80%8AMySQL%E5%BF%85%E7%9F%A5%E5%BF%85%E4%BC%9A%E3%80%8B/26_%E5%85%A8%E7%90%83%E5%8C%96%E5%92%8C%E6%9C%AC%E5%9C%B0%E5%8C%96/","content":"","categories":["计算机理论"],"tags":["数据库系统原理-《MySQL必知必会》"]},{"title":"函数","url":"/2018/09/30/%E8%AE%A1%E7%AE%97%E6%9C%BA%E7%90%86%E8%AE%BA/%E7%BC%96%E7%A8%8B%E8%AF%AD%E8%A8%80/C%E8%AF%AD%E8%A8%80/8_%E5%87%BD%E6%95%B0/","content":"函数：函数是一块代码，接收零个或多个参数，做一件事情，并返回零个或一个值\n循环：同一段代码反复不停的执行重用&#x2F;复用：有一段代码，多个地方都要执行一次，但是不是反复不停的执行\n定义在函数内部的变量，我们就叫做局部变量定义在函数外部的变量，我们就叫做全局变量，直接定义在源文件下面\n局部变量只能在当前函数的内部访问全局变量从定义的地方开始，后面的所有函数中都可以访问这个全局变量\n声明一个局部变量，如果没有为这个局部变量赋初始值，那么这个局部变量中的值是一个垃圾值；声明一个全局变量，如果没有为这个全局变量赋初始值，那么这个全局变量的初始值为0\n如果全局变量的类型是char类型，并且我们也没有初始化，那么系统就会自动的为这个char变量赋值一个‘\\0’，代表一个不可见的字符，这个字符的ASCII码就是0\nCPU执行声明局部变量的那句话的时候，才会在内存中声明局部变量，当作用域结束以后，就会自动回收；程序一启动，就在内存中创建全局变量，程序结束的时候全局变量才会被回收\n可以定义一个和全局变量名称相同的局部变量【不建议】\n声明在函数名称后面的小括弧中的变量就叫做这个函数的参数，参数实际上就是定义在函数内部的局部变量，所以在函数的内部不能再定义一个局部变量的名称和参数的名称一样\n形参：声明在函数名的小括弧中的参数实参：在调用函数的时候，实际上为形参赋的值\nreturn关键字用在函数体中，在函数体中如果遇到了return关键字，就会立即结束这个函数的执行\n函数的声明(.h)和实现(.c)\n当我们的程序的函数过多的时候，就要考虑分模块开发，一个模块至少包含两个文件，.h文件专门写函数的声明，.c文件专门写函数的实现 ，其他人想要调用函数，只需要导入头文件就可以了\n","categories":["计算机理论"],"tags":["编程语言-C语言"]},{"title":"数据库维护","url":"/2020/04/30/%E8%AE%A1%E7%AE%97%E6%9C%BA%E7%90%86%E8%AE%BA/%E6%95%B0%E6%8D%AE%E5%BA%93%E7%B3%BB%E7%BB%9F%E5%8E%9F%E7%90%86/%E3%80%8AMySQL%E5%BF%85%E7%9F%A5%E5%BF%85%E4%BC%9A%E3%80%8B/28_%E6%95%B0%E6%8D%AE%E5%BA%93%E7%BB%B4%E6%8A%A4/","content":"","categories":["计算机理论"],"tags":["数据库系统原理-《MySQL必知必会》"]},{"title":"改善性能","url":"/2020/04/30/%E8%AE%A1%E7%AE%97%E6%9C%BA%E7%90%86%E8%AE%BA/%E6%95%B0%E6%8D%AE%E5%BA%93%E7%B3%BB%E7%BB%9F%E5%8E%9F%E7%90%86/%E3%80%8AMySQL%E5%BF%85%E7%9F%A5%E5%BF%85%E4%BC%9A%E3%80%8B/29_%E6%94%B9%E5%96%84%E6%80%A7%E8%83%BD/","content":"","categories":["计算机理论"],"tags":["数据库系统原理-《MySQL必知必会》"]},{"title":"检索数据SELECT语句","url":"/2020/04/30/%E8%AE%A1%E7%AE%97%E6%9C%BA%E7%90%86%E8%AE%BA/%E6%95%B0%E6%8D%AE%E5%BA%93%E7%B3%BB%E7%BB%9F%E5%8E%9F%E7%90%86/%E3%80%8AMySQL%E5%BF%85%E7%9F%A5%E5%BF%85%E4%BC%9A%E3%80%8B/3_%E6%A3%80%E7%B4%A2%E6%95%B0%E6%8D%AESELECT%E8%AF%AD%E5%8F%A5/","content":"检索数据【SELECT语句】：\n检索单个列：\n从db表中检索一个名为Host的列：从db表中检索多个列：从db表中检索所有列：\n检索不同的行？？\n限制结果：LIMIT 1；【指示MySQL返回不多于1行】LIMIT 1，2；【第一个数为开始位置，第二个数为要检索的行数】1）所以，带一个值的LIMIT总是从第一行开始，给出的数为返回的行数。带两个值的LIMIT可以指定从行号为第一个值的位置开始2）检索出来的第一行为行0而不是行1，因此，LIMIT 1，1将检索出第二行而不是第一行3）LIMIT中指定要检索的行数为检索的最大行数，如果没有足够的行（例如，给出LIMIT 10，5，但只有13行)，MySQL将只返回它能返回的那么多行\n使用完全限定的表名：\n","categories":["计算机理论"],"tags":["数据库系统原理-《MySQL必知必会》"]},{"title":"数据过滤","url":"/2020/04/30/%E8%AE%A1%E7%AE%97%E6%9C%BA%E7%90%86%E8%AE%BA/%E6%95%B0%E6%8D%AE%E5%BA%93%E7%B3%BB%E7%BB%9F%E5%8E%9F%E7%90%86/%E3%80%8AMySQL%E5%BF%85%E7%9F%A5%E5%BF%85%E4%BC%9A%E3%80%8B/6_%E6%95%B0%E6%8D%AE%E8%BF%87%E6%BB%A4/","content":"数据过滤\n操作符：用来联结或改变WHERE子句中的子句的关键字，也称为逻辑操作符\n1）AND:用在WHERE子句中的关键字，用来指示检索满足所有给定条件的行SELECT prodid,prodname,prod_priceFROM productsWHERE vendid&#x3D;1003 AND prodprice&lt;&#x3D;10;\n2)OR：用来表示检索匹配任一给定条件的行SELECT prodname,prodpriceFROM productsWHERE vendid&#x3D;1002 OR vendid&#x3D;1003;\n3）SELECT prodname,prodpriceFROM productsWHERE vendid&#x3D;1002 OR vendid&#x3D;1003 AND prod_price&gt;&#x3D;10;\nSELECT prodname,prodpriceFROM productsWHERE (vendid&#x3D;1002 OR vendid&#x3D;1003) AND prod_price&gt;&#x3D;10;\n4)IN WHERE子句中用来指定要匹配值的清单的关键字，功能与OR相当SELECT prodname,prodpriceFROM productsWHERE vend_id IN(1002,1003)ORDER BY prod_name;\n5）NOT WHERE子句中用来否定后跟条件的关键字SELECT prodname,prodpriceFROM productsWHERE vend_id NOT IN(1002,1003)ORDER BY prod_name;\n","categories":["计算机理论"],"tags":["数据库系统原理-《MySQL必知必会》"]},{"title":"用通配符进行过滤","url":"/2020/04/30/%E8%AE%A1%E7%AE%97%E6%9C%BA%E7%90%86%E8%AE%BA/%E6%95%B0%E6%8D%AE%E5%BA%93%E7%B3%BB%E7%BB%9F%E5%8E%9F%E7%90%86/%E3%80%8AMySQL%E5%BF%85%E7%9F%A5%E5%BF%85%E4%BC%9A%E3%80%8B/7_%E7%94%A8%E9%80%9A%E9%85%8D%E7%AC%A6%E8%BF%9B%E8%A1%8C%E8%BF%87%E6%BB%A4/","content":"用通配符进行过滤\n通配符：用来匹配值的一部分的特殊字符搜索模式：由字面值、通配符或两者组合构成的搜索条件\n1）%表示任何字符出现的任意次数，下列找出所有以词jet起头的产品，%告诉MySQL接受jet之后的任意字符，不管它有多少字符SELECT prodid,prodnameFROM productsWHERE prod_name LIKE ‘jet%’;\n2）搜索模式’%anvil%’表示匹配任何位置包含文本anvil的值，而不论它之前或之后出现什么字符SELECT prodid,prodnameFROM productsWHERE prod_name LIKE ‘%anvil%’;\n3）下划线只匹配单个字符而不是多个字符SELECT prodid,prodnameFROM productsWHERE prodname LIKE ‘ ton anvil’;\nSELECT prodid,prodnameFROM productsWHERE prod_name LIKE ‘% ton anvil’;与%能匹配0个字符不一样，_总是匹配一个字符，不能多也不能少\n","categories":["计算机理论"],"tags":["数据库系统原理-《MySQL必知必会》"]},{"title":"SHOW语句HELP SHOW","url":"/2020/04/30/%E8%AE%A1%E7%AE%97%E6%9C%BA%E7%90%86%E8%AE%BA/%E6%95%B0%E6%8D%AE%E5%BA%93%E7%B3%BB%E7%BB%9F%E5%8E%9F%E7%90%86/%E3%80%8AMySQL%E5%BF%85%E7%9F%A5%E5%BF%85%E4%BC%9A%E3%80%8B/2_SHOW%E8%AF%AD%E5%8F%A5HELP%20SHOW/","content":"SHOW语句【HELP SHOW;】：\n可使用的数据库名：\nUSE选择数据库（必须先使用USE打开数据库，才能读取其中的数据）\nSHOW TABLES；返回当前选择的数据库内可用表的列表\nSHOW COLUMNS FROM…….【DESCRIBE…..】（从某个表中查找）\n","categories":["计算机理论"],"tags":["数据库系统原理-《MySQL必知必会》"]},{"title":"使用游标","url":"/2020/04/30/%E8%AE%A1%E7%AE%97%E6%9C%BA%E7%90%86%E8%AE%BA/%E6%95%B0%E6%8D%AE%E5%BA%93%E7%B3%BB%E7%BB%9F%E5%8E%9F%E7%90%86/%E3%80%8AMySQL%E5%BF%85%E7%9F%A5%E5%BF%85%E4%BC%9A%E3%80%8B/23_%E4%BD%BF%E7%94%A8%E6%B8%B8%E6%A0%87/","content":"使用游标\n有时，需要在检索出来的行中前进或后退一行或多行。这就是使用游标的原因。游标是一个存储在MySQL服务器上的数据库查询，它不是一条SELECT语句，而是被该语句检索出来的结果集。在存储了游标之后，应用程序可以根据需要滚动或浏览其中的数据；游标主要用于交互式应用，其中用户需要滚动屏幕上的数据，并对数据进行浏览或做出更改\n不像多数DBMS，MySQL游标只能用于存储过程（和函数）\n1）创建游标【存储过程处理完成后，游标就消失（因为它局限于存储过程）】游标用DECLARE语句创建，DECLARE命名游标，并定义相应的SELECT语句，根据需要带WHERE和其他子句CREATE PROCEDURE processorders()BEGIN     DECLARE ordernumbers CURSOR     FOR     SELECT order_num FROM orders;END;\n2）打开和关闭游标OPEN ordernumbers;\nCLOSE ordernumbers;\n在一个游标关闭后，如果没有重新打开，则不能使用它。但是，使用声明过的游标不需要再次声明，用OPEN语句打开它就可以了，如果你不明确关闭游标，MySQL将会在到达END语句时自动关闭它\n这个存储过程声明、打开和关闭一个游标，但对检索出来的数据什么也没做CREATE PROCEDURE processorders()BEGIN     DECLARE ordernumbers CURSOR     FOR     SELECT order_num FROM orders;\n OPEN ordernumbers;\n\n CLOSE ordernumbers;\n\nEND;\n3）使用游标数据：在一个游标被打开后，可以使用FETCH语句分别访问它的每一行。FETCH指定检索什么数据（所需的列），检索出来的数据存储在什么地方。它还向前移动游标中的内部行指针，使下一条FETCH语句检索下一行（不重复读取同一行）\n从游标中检索单个行（第一行）：CREATE PROCEDURE processorders()BEGIN\n DECLARE o INT;\n\n DECLARE ordernumbers CURSOR\n FOR\n SELECT order_num FROM orders;\n\n OPEN ordernumbers;\n\n FETCH ordernumbers INTO o;\n\n CLOSE ordernumbers;\n\nEND;\n循环检索数据，从第一行到最后一行：【如果一切正常，你可以在循环内放入任意需要的处理（在FETCH语句之后，循环结束之前）】CREATE PROCEDURE processorders()BEGIN\n DECLARE done BOOLEAN DEFAULT 0;\n DECLARE o INT;\n\n DECLARE ordernumbers CURSOR\n FOR\n SELECT order_num FROM orders;\n\n DECLARE CONTINUE HANDLER FOR SQLSTATE ’02000’ SET done=1;\n\n OPEN ordernumbers;\n\n REPEAT\n\n FETCH ordernumbers INTO o;\n\n UNTIL done END REPEAT;\n\n CLOSE ordernumbers;\n\nEND;\nCREATE PROCEDURE processorders()BEGIN\n DECLARE done BOOLEAN DEFAULT 0;\n DECLARE o INT;\n DECLARE t DECIMAL(8,2);\n\n DECLARE ordernumbers CURSOR\n FOR\n SELECT order_num FROM orders;\n\n DECLARE CONTINUE HANDLER FOR SQLSTATE ’02000’ SET done=1;\n\n CREATE TABLE IF NOT EXISTS ordertotals\n         (order_num INT,total DECIMAL(8,2));\n\n OPEN ordernumbers;\n\n REPEAT\n\n      FETCH ordernumbers INTO o;\n\n      CALL ordertotal(o,l,t);\n      \n      INSERT INTO ordertotals(order_num,total)\n      VALUES(o,t);\n\n UNTIL done END REPEAT;\n\n CLOSE ordernumbers;\n\nEND;\nSELECT *FROM ordertotals;\n","categories":["计算机理论"],"tags":["数据库系统原理-《MySQL必知必会》"]},{"title":"安全管理","url":"/2020/04/30/%E8%AE%A1%E7%AE%97%E6%9C%BA%E7%90%86%E8%AE%BA/%E6%95%B0%E6%8D%AE%E5%BA%93%E7%B3%BB%E7%BB%9F%E5%8E%9F%E7%90%86/%E3%80%8AMySQL%E5%BF%85%E7%9F%A5%E5%BF%85%E4%BC%9A%E3%80%8B/27_%E5%AE%89%E5%85%A8%E7%AE%A1%E7%90%86/","content":"","categories":["计算机理论"],"tags":["数据库系统原理-《MySQL必知必会》"]},{"title":"排序检索数据","url":"/2020/04/30/%E8%AE%A1%E7%AE%97%E6%9C%BA%E7%90%86%E8%AE%BA/%E6%95%B0%E6%8D%AE%E5%BA%93%E7%B3%BB%E7%BB%9F%E5%8E%9F%E7%90%86/%E3%80%8AMySQL%E5%BF%85%E7%9F%A5%E5%BF%85%E4%BC%9A%E3%80%8B/4_%E6%8E%92%E5%BA%8F%E6%A3%80%E7%B4%A2%E6%95%B0%E6%8D%AE/","content":"排序检索数据\n子句：SQL语句由子句构成，有些子句是必须的，而有的是可选的。一个子句通常由一个关键字和所提供的数据组成。\n1）指示MySQL对列以字母顺序排序SELECT 列名FROM 表名ORDER BY 列名;\n2）先按价格，再按名称排序：SELECT prodid,prodprice,prod_nameFROM productsORDER BY prodprice,prodname;\n3）按价格以降序排序SELECT prodid,prodprice,prod_nameFROM productsORDER BY prod_price DESC;\n4）先按价格以降序排序，再对产品名排序SELECT prodid,prodprice,prod_nameFROM productsORDER BY prodprice DESC,prodname;DESC关键字只应用到直接位于其前面的列名，在上例中，只对prodprice列指定DESC，对prodname列不指定。因此，prodprice列以降序排序，而prodname列（在每个价格内)仍然按标准的升序排序\n5）prod_price DESC保证行是按照由最昂贵到最便宜检索的，而LIMIT 1告诉MySQL仅返回一行SELECT prod_priceFROM productsORDER BY prod_price DESCLIMIT 1;\n","categories":["计算机理论"],"tags":["数据库系统原理-《MySQL必知必会》"]},{"title":"过滤数据","url":"/2020/04/30/%E8%AE%A1%E7%AE%97%E6%9C%BA%E7%90%86%E8%AE%BA/%E6%95%B0%E6%8D%AE%E5%BA%93%E7%B3%BB%E7%BB%9F%E5%8E%9F%E7%90%86/%E3%80%8AMySQL%E5%BF%85%E7%9F%A5%E5%BF%85%E4%BC%9A%E3%80%8B/5_%E8%BF%87%E6%BB%A4%E6%95%B0%E6%8D%AE/","content":"过滤数据\n1）只返回prod_price值为2.50的行SELECT prodname,prodpriceFROM productsWHERE prod_price&#x3D;2.50;\n2）\n3）MySQL在执行匹配时默认不区分大小写，所以fuses与Fuses匹配SELECT prodname,prodpriceFROM productsWHERE prod_name&#x3D;‘fuses’;【注意单引号】\n4）SELECT prodname,prodpriceFROM productsWHERE prod_price&lt;10;\n5)列出不是由供应商1003制造的所有产品SELECT vendid,prodnameFROM productsWHERE vend_id&lt;&gt;1003;\n6）检索价格在5美元和10美元之间的所有产品SELECT prodname,prodpriceFROM productsWHERE prod_price BETWEEN 5 AND 10;\n7）NULL：无值，它与字段包含0、空字符串或仅仅包含空格不同这条语句返回没有价格（空prod_price字段，不是价格为0）的所有产品SELECT prod_nameFROM productsWHERE prod_price IS NULL;\n","categories":["计算机理论"],"tags":["数据库系统原理-《MySQL必知必会》"]},{"title":"创建计算字段","url":"/2020/04/30/%E8%AE%A1%E7%AE%97%E6%9C%BA%E7%90%86%E8%AE%BA/%E6%95%B0%E6%8D%AE%E5%BA%93%E7%B3%BB%E7%BB%9F%E5%8E%9F%E7%90%86/%E3%80%8AMySQL%E5%BF%85%E7%9F%A5%E5%BF%85%E4%BC%9A%E3%80%8B/9_%E5%88%9B%E5%BB%BA%E8%AE%A1%E7%AE%97%E5%AD%97%E6%AE%B5/","content":"创建计算字段\n计算字段并不实际存在于数据库表中，计算字段是运行时在SELECT语句内创建的\n字段：基本上与列的意思相同，经常互换使用，不过数据库列一般称为列，而术语字段通常用在计算字段的连接上\n只有数据库知道SELECT语句中哪些列是实际的表列，哪些列是计算字段。从客户机（如应用程序）的角度来看，计算字段的数据是以与其他列的数据相同的方式返回的\n拼接：将值联结到一起构成单个值\n1）SELECT Concat(vendname，‘ （’，vendcountry，‘）’）FROM vendorsORDER BY vend_name;\nRTrim()函数去掉值右边的所有空格，通过使用RTrim()，各个列都进行了整理SELECT Concat(RTrim(vendname)，‘ （’，RTrim(vendcountry)，‘）’）FROM vendorsORDER BY vend_name;\n2）别名是一个字段或值的替换名，别名用AS关键字赋予SELECT Concat(RTrim(vendname)，‘ （’，RTrim(vendcountry)，‘）’）AS vend_titleFROM vendorsORDER BY vend_name;\n3)检索订单号20005中的所有物品SELECT prodid,quantity,itempriceFROM orderitemsWHERE order_num&#x3D;20005;\nitem_price列包含订单中每项物品的单价，如下汇总物品的价格（单价乘以订购数量）SELECT prod_id,              quantity,              item_price,              quantity*itemprice AS expandedpriceFROM orderitemsWHERE order_num&#x3D;20005;\n","categories":["计算机理论"],"tags":["数据库系统原理-《MySQL必知必会》"]},{"title":"操作系统的发展与分类","url":"/2020/06/30/%E8%AE%A1%E7%AE%97%E6%9C%BA%E7%90%86%E8%AE%BA/%E6%93%8D%E4%BD%9C%E7%B3%BB%E7%BB%9F%E5%8E%9F%E7%90%86/%E6%93%8D%E4%BD%9C%E7%B3%BB%E7%BB%9F%E5%8E%9F%E7%90%86%E7%AC%94%E8%AE%B0/1.3_%E6%93%8D%E4%BD%9C%E7%B3%BB%E7%BB%9F%E7%9A%84%E5%8F%91%E5%B1%95%E4%B8%8E%E5%88%86%E7%B1%BB/","content":"手工操作阶段\n批处理阶段\n单道批处理系统（操作系统的雏形）\n引入脱机输入&#x2F;输出技术（用外围机+磁带完成），并由监督程序负责控制作业的输入、输出\n\n\n主要优点：缓解了一定程度的人机速度矛盾，资源利用率有所提升\n主要缺点：内存中仅能有一道程序运行，只有该程序运行结束之后才能调入下一道程序，CPU有大量的时间是在空闲等待I&#x2F;O完成，资源利用率依然很低\n\n多道批处理系统（操作系统开始出现）\n每次往内存中读入多道程序，操作系统正式诞生，用于支持多道程序并发运行\n\n\n\n分时操作系统计算机以时间片为单位轮流为各个用户&#x2F;作业服务，各个用户可通过终端与计算机进行交互\n主要优点：用户请求可以被即时响应，解决了人机交互问题，允许多个用户同时使用一台计算机，并且用户对计算机的操作相互独立，感受不到别人的存在\n主要缺点：不能优先处理一些紧急任务，操作系统对各个用户&#x2F;作业都是完全公平的，循环的为每个用户&#x2F;作业服务一个时间片，不区分任务的紧急性\n实时操作系统主要优点：能够优先响应一些紧急任务，某些紧急任务不需时间片排队\n在实时操作系统的控制下，计算机系统接收到外部信号后及时进行处理，并且要在严格的时限内处理完事件，实时操作系统的主要特点是及时性和可靠性\n\n硬实时系统：必须在绝对严格的规定时间内完成处理（导弹控制系统、自动驾驶系统）\n软实时系统：能接受偶尔违反时间规定（12306火车订票系统）\n\n网络操作系统是伴随着计算机网络的发展而诞生的，能把网络中各个计算机有机的结合起来，实现数据传送等功能，实现网络中各种资源的共享（如文件共享）和各台计算机之间的通信\nWindows NT就是一种典型的网络操作系统，网站服务器可以使用\n分布式操作系统主要特点是分布性和并行性，系统中的各台计算机地位相同，任何工作都可以分布在这些计算机上，由它们并行、协同完成这个任务\n个人计算机操作系统方便个人使用\n","categories":["计算机理论"],"tags":["操作系统原理-操作系统原理笔记"]},{"title":"用正则表达式进行搜索","url":"/2020/04/30/%E8%AE%A1%E7%AE%97%E6%9C%BA%E7%90%86%E8%AE%BA/%E6%95%B0%E6%8D%AE%E5%BA%93%E7%B3%BB%E7%BB%9F%E5%8E%9F%E7%90%86/%E3%80%8AMySQL%E5%BF%85%E7%9F%A5%E5%BF%85%E4%BC%9A%E3%80%8B/8_%E7%94%A8%E6%AD%A3%E5%88%99%E8%A1%A8%E8%BE%BE%E5%BC%8F%E8%BF%9B%E8%A1%8C%E6%90%9C%E7%B4%A2/","content":"用正则表达式进行搜索\n正则表达式是用来匹配文本的特殊的串（字符集合），正则表达式的作用是匹配文本，将一个模式（正则表达式）与一个文本串进行比较\n1）检索列prod_name包含文本1000的所有行SELECT prod_nameFROM productsWHERE prod_name REGEXP ‘1000’ORDER BY prod_name;\n2）SELECT prod_nameFROM productsWHERE prod_name REGEXP ‘.000’ORDER BY prod_name;\n3）|为正则表达式的OR操作符，它表示匹配其中之一，使用|从功能上类似于在SELECT语句中使用OR语句，多个OR条件可并入单个正则表达式SELECT prod_nameFROM productsWHERE prod_name REGEXP ‘1000|2000’ORDER BY prod_name;\n4）[123]定义一组字符，它的意思是匹配1或者2或者3，因此，1 ton 和2 ton都匹配且返回（没有 3 ton）,[123] Ton为[1|2|3] Ton的缩写SELECT prod_nameFROM productsWHERE prod_name REGEXP ‘[123] Ton’ORDER BY prod_name;\nMySQL假定你的意思是‘1’或‘2’或‘3 ton’，除非你把字符｜括在一个集合中，否则它将应用于整个串SELECT prod_nameFROM productsWHERE prod_name REGEXP ‘1|2|3 Ton’ORDER BY prod_name;\n[^123]匹配除这些字符外的任何东西\n5）SELECT prod_nameFROM productsWHERE prod_name REGEXP ‘[1-5] Ton’ORDER BY prod_name;\n6）.匹配任意字符，因此每个行都被检索出来SELECT vend_nameFROM vendorsWHERE vend_name REGEXP ‘.’ORDER BY vend_name;\n为了匹配特殊字符，必须用\\为前导。\\-表示查找-，\\.表示查找.SELECT vend_nameFROM vendorsWHERE vend_name REGEXP ‘\\.’ORDER BY vend_name;\n\n\n\n\n\n\n\nSELECT prod_nameFROM productsWHERE prod_name REGEXP ‘\\([0-9] sticks?\\)’ORDER BY prod_name;\nSELECT prod_nameFROM productsWHERE prod_name REGEXP ‘:digit:{4}’ORDER BY prod_name;\n\n\n\nSELECT prod_nameFROM productsWHERE prod_name REGEXP ‘^[0-9\\.]’ORDER BY prod_name;\n","categories":["计算机理论"],"tags":["数据库系统原理-《MySQL必知必会》"]},{"title":"操作系统的运行机制","url":"/2020/06/30/%E8%AE%A1%E7%AE%97%E6%9C%BA%E7%90%86%E8%AE%BA/%E6%93%8D%E4%BD%9C%E7%B3%BB%E7%BB%9F%E5%8E%9F%E7%90%86/%E6%93%8D%E4%BD%9C%E7%B3%BB%E7%BB%9F%E5%8E%9F%E7%90%86%E7%AC%94%E8%AE%B0/1.4_%E6%93%8D%E4%BD%9C%E7%B3%BB%E7%BB%9F%E7%9A%84%E8%BF%90%E8%A1%8C%E6%9C%BA%E5%88%B6/","content":"一条高级语言的代码翻译过来可能会对应多条机器指令\n程序运行的过程其实就是CPU执行一条一条的机器指令的过程\n二进制机器指令就是处理器CPU能识别、执行的最基本命令\n内核程序、应用程序我们普通程序员写的程序就是“应用程序”\n微软、苹果有一帮人负责实现操作系统，他们写的是“内核程序”\n有很多内核程序组成了“操作系统内核”，或简称“内核（Kernel）”，内核是操作系统最重要最核心的部分，也是最接近硬件的部分，甚至可以说，一个操作系统只要有内核就够了，操作系统的功能未必都在内核中，如图形化用户界面GUI\n两种指令特权指令操作系统内核作为“管理者”，有时会让CPU执行一些“特权指令”，如“内存清零指令”。这些指令影响重大，只允许“管理者”，即操作系统内核来使用\n非特权指令应用程序只能使用“非特权指令”，如加法指令、减法指令等\n在CPU设计和生产的时候就划分了特权指令和非特权指令，因此CPU执行一条指令前就能判断出其类型\n问题：CPU能判断出指令类型，但是它怎么区分此时正在运行的是内核程序还是应用程序？\n两种处理器状态内核态（核心态、管态）处于内核态时，说明此时正在运行的是内核程序，此时可以执行特权指令\n用户态（目态）处于用户态时，说明此时正在运行的是应用程序，此时只能执行非特权指令\nCPU中有一个寄存器叫程序状态字寄存器（PSW），其中有个二进制位，1表示“内核态”，0表示“用户态”\n内核态、用户态的切换\n\n刚开机时，CPU为“内核态”，操作系统内核程序先上CPU运行\n\n开机完成后，用户可以启动某个应用程序，操作系统内核程序在合适的时候主动让出CPU，让该应用程序上CPU运行，应用程序运行在“用户态”（操作系统内核在让出CPU之前，会用一条特权指令把PSW的标志位设置为“用户态”）\n\n此时，一位黑客在应用程序中植入了一条特权指令，企图破坏系统\n\nCPU发现接下来要执行的这条指令是特权指令，但是自己又处于“用户态”，这个非法事件会引发一个中断信号，CPU检测到中断信号后，会立即变为“核心态”，并停止运行当前的应用程序，转而运行处理中断信号的内核程序\n\n“中断”使操作系统再次夺回CPU的控制权，操作系统会对引发中断的事件进行处理，处理完了再把CPU使用权交给别的应用程序\n\n\n\n内核态 -&gt; 用户态：执行一条特权指令，修改PSW的标志位为“用户态”，这个动作意味着操作系统将主动让出CPU使用权\n用户态 -&gt; 内核态：由“中断”引发，硬件自动完成变态过程，触发中断信号意味着操作系统将强行夺回CPU的使用权（除了非法使用特权指令之外，还有很多事件会触发中断信号，一个共性是，但凡需要操作系统介入的地方，都会触发中断信号）\n","categories":["计算机理论"],"tags":["操作系统原理-操作系统原理笔记"]},{"title":"操作系统的四个特征","url":"/2020/06/30/%E8%AE%A1%E7%AE%97%E6%9C%BA%E7%90%86%E8%AE%BA/%E6%93%8D%E4%BD%9C%E7%B3%BB%E7%BB%9F%E5%8E%9F%E7%90%86/%E6%93%8D%E4%BD%9C%E7%B3%BB%E7%BB%9F%E5%8E%9F%E7%90%86%E7%AC%94%E8%AE%B0/1.2_%E6%93%8D%E4%BD%9C%E7%B3%BB%E7%BB%9F%E7%9A%84%E5%9B%9B%E4%B8%AA%E7%89%B9%E5%BE%81/","content":"操作系统的特征\n并发\n共享\n虚拟\n异步\n\n并发和共享是操作系统两个最基本的特征，二者互为存在条件\n并发并发是指两个或多个事件在同一时间间隔内发生，这些事件宏观上是同时发生的，但微观上是交替发生的\n并行是指两个或多个事件在同一时刻同时发生\n操作系统的并发性是指计算机系统中“同时”运行着多个程序，这些程序宏观上看是同时运行着的，而微观上看是交替运行的，操作系统就是伴随着“多道程序技术”而出现的，因此操作系统和程序并发是一起诞生的\n单核CPU同一时刻只能执行一个程序，各个程序只能并发的执行\n多核CPU同一时刻可以同时执行多个程序，多个程序可以并行的执行\n即使是对于4核CPU来说，只要有4个以上的程序需要“同时”运行，那么并发性依然是必不可少的，因此并发性是操作系统一个最基本的特性\n共享共享即资源共享，是指系统中的资源可供内存中多个并发执行的进程共同使用\n\n互斥共享方式：系统中的某些资源，虽然可以提供给多个进程使用，但一个时间段内只允许一个进程访问该资源【摄像头】\n同时共享方式：系统中的某些资源，允许一个时间段内由多个进程“同时”对它们进行访问，所谓的“同时”往往是宏观上的，而在微观上，这些进程可能是交替的对该资源进行访问（即分时共享）【硬盘资源】\n\n并发和共享的关系并发性指计算机系统中同时存在着多个运行着的程序\n共享性是指系统中的资源可供内存中多个并发执行的进程共同使用\n使用QQ发送文件A，同时使用微信发送文件B1.两个进程正在并发执行（并发性）2.需要共享的访问硬盘资源（共享性）如果失去并发性，则系统中只有一个程序正在运行，则共享性失去存在的意义如果失去共享性，则QQ和微信不能同时访问硬盘资源，就无法实现同时发送文件，也就无法并发\n\n虚拟虚拟是指把一个物理上的实体变成若干个逻辑上的对应物，物理实体是实际存在的，而逻辑上对应物是用户感受到的\n\n空分复用技术：如虚拟存储器技术\n时分复用技术：如虚拟处理器技术\n显然，如果失去了并发性，则一个时间段内系统中只需运行一道程序，那么就失去了实现虚拟性的意义了，因此，没有并发性，就谈不上虚拟性\n\n异步异步是指，在多道程序环境下，允许多个程序并发执行，但由于资源有限，进程的执行不是一贯到底的，而是走走停停，以不可预知的速度向前推进，这就是进程的异步性\n如果失去了并发性，即系统只能串行的运行各个程序，，那么每个程序的执行会一贯到底，只有系统拥有并发性，才有可能导致异步性\n","categories":["计算机理论"],"tags":["操作系统原理-操作系统原理笔记"]},{"title":"系统调用","url":"/2020/06/30/%E8%AE%A1%E7%AE%97%E6%9C%BA%E7%90%86%E8%AE%BA/%E6%93%8D%E4%BD%9C%E7%B3%BB%E7%BB%9F%E5%8E%9F%E7%90%86/%E6%93%8D%E4%BD%9C%E7%B3%BB%E7%BB%9F%E5%8E%9F%E7%90%86%E7%AC%94%E8%AE%B0/1.6_%E7%B3%BB%E7%BB%9F%E8%B0%83%E7%94%A8/","content":"什么是系统调用，有何作用？操作系统作为用户和计算机硬件之间的接口，需要向上提供一些简单易用的服务，主要包括命令接口和程序接口，其中程序接口由一组系统调用组成\n“系统调用”是操作系统提供给应用程序（程序员&#x2F;编程人员）使用的接口，可以理解为一种可供应用程序调用的特殊函数，应用程序可以通过系统调用来请求获得操作系统内核的服务\n系统调用与库函数的区别\n系统调用（按功能分类）\n设备管理：完成设备的请求&#x2F;释放&#x2F;启动等功能\n文件管理：完成文件的读&#x2F;写&#x2F;创建&#x2F;删除等功能\n进程控制：完成进程的创建&#x2F;撤销&#x2F;阻塞&#x2F;唤醒等功能\n进程通信：完成进程之间的消息传递&#x2F;信号传递等功能\n内存管理：完成内存的分配&#x2F;回收等功能\n\n什么功能要用到系统调用（Word和WPS同时使用打印机）应用程序通过系统调用请求操作系统的服务，而系统中的各种共享资源都由操作系统内核统一掌管，因此凡是与共享资源有关的操作（如存储分配、I&#x2F;O操作、文件管理等），都必须通过系统调用的方式向操作系统内核提出服务请求，由操作系统内核代为完成，这样可以保证系统的稳定性和安全性，防止用户进行非法操作\n系统调用的过程\n传递系统调用参数\n执行陷入指令（用户态）\n执行相应的内请求核程序处理系统调用（核心态）\n返回应用程序\n\n注意：\n\n陷入指令是在用户态执行的，执行陷入指令之后立即引发一个内中断，使CPU进入核心态\n发出系统调用请求是在用户态，而对系统调用的相应处理在核心态下进行\n\n","categories":["计算机理论"],"tags":["操作系统原理-操作系统原理笔记"]},{"title":"进程同步、进程互斥","url":"/2020/06/30/%E8%AE%A1%E7%AE%97%E6%9C%BA%E7%90%86%E8%AE%BA/%E6%93%8D%E4%BD%9C%E7%B3%BB%E7%BB%9F%E5%8E%9F%E7%90%86/%E6%93%8D%E4%BD%9C%E7%B3%BB%E7%BB%9F%E5%8E%9F%E7%90%86%E7%AC%94%E8%AE%B0/2.10_%E8%BF%9B%E7%A8%8B%E5%90%8C%E6%AD%A5%E3%80%81%E8%BF%9B%E7%A8%8B%E4%BA%92%E6%96%A5/","content":"进程同步进程具有异步性的特征，异步性是指，各并发执行的进程以各自独立的、不可预知的速度向前推进\n但是有时候我们需要进程确定性的顺序向前推进，操作系统提供“进程同步机制”来实现需求\n\n同步亦称直接制约关系，它是指为完成某种任务而建立的两个或多个进程，这些进程因为需要在某些位置上协调它们的工作次序而产生的制约关系。进程间的直接制约关系就是源于它们之间的相互合作\n进程互斥进程的“并发”需要“共享”的支持，各个并发执行的进程不可避免的需要共享一些系统资源（内存、打印机、摄像头）\n两种资源共享方式：\n\n互斥共享方式：系统中的某些资源，虽然可以提供给多个进程使用，但一个时间段内只允许一个进程访问该资源\n同时共享方式：系统中的某些资源，允许一个时间段内由多个进程“同时”对它们进行访问\n\n我们把一个时间段内只允许一个进程使用的资源称为临界资源，许多物理设备（摄像头、打印机）都属于临界资源，此外还有许多变量、数据、内存缓冲区等都属于临界资源。对临界资源的访问，必须互斥的进行\n互斥，亦称间接制约关系，进程互斥指当一个进程访问某临界资源时，另一个想要访问该临界资源的进程必须等待。当前访问临界资源的进程访问结束，释放该资源后，另一个进程才能去访问临界资源\n\n如果一个进程暂时不能进入临界区，那么该进程是否应该一直占着处理机？该进程有没有可能一直进不了临界区？\n为了实现对临界资源的互斥访问，同时保证系统整体性能，需要遵循以下原则：\n\n空闲让进：临界区空闲时，可以允许一个请求进入临界区的进程立即进入临界区\n忙着等待：当已有进程进入临界区时，其他试图进入临界区的进程必须等待\n有限等待：对请求访问的进程，应保证能在有限时间内进入临界区（保证不会饥饿）\n让权等待：当进程不能进入临界区时，应立即释放处理机，防止进程忙等待\n\n进程互斥的软件实现方法如果没有注意进程互斥：\n\n单标志法⭐️在进入区只做检查，不上锁\n算法思想：两个进程在访问完临界区后会把使用临界区的权限转交给另一个进程。也就是说每个进程进入临界区的权限只能被另一个进程赋予\n\n因此，该算法可以实现“同一时刻最多只允许一个进程访问临界区”\n只能轮流访问，这种必须轮流访问带来的问题是，如果此时允许进入临界区的进程是P0，而P0一直不访问临界区，那么虽然此时临界区空闲，但是并不允许P1访问，因此单标志法存在的主要问题是：违背了“空闲让进”原则\n双标志先检查⭐️在进入区先检查后上锁\n\n若按照1、5、2、6、3、7的顺序执行，P0和P1将会同时访问临界区，因此双标志先检查法的主要问题是：违反“忙则等待”原则\n原因在于，进入区的“检查”和“上锁”两个处理不是一气呵成的，检查后，上锁前可能发生进程切换\n❗️双标志先检查法其实是很好的，唯一的缺点就在于检查和上锁不是一气呵成的，如果能通过硬件方式改进这点就好了！\n双标志后检查⭐️在进入区先上锁后检查\n\nPeterson算法⭐️在进入区“主动争取–主动谦让–检查对方是否想进、己方是否谦让”\n\n\nPeterson算法用软件方法解决了进程互斥的问题，遵循了空闲让进、忙则等待、有限等待三个原则，但是依然未遵循让权等待的原则，会发生“忙等”\nPeterson算法相较于之前三种软件解决方案来说是最好的，但依然不够好\n进程互斥的硬件实现方法中断屏蔽方法利用“开&#x2F;关中断指令”实现（与原语的实现思想相同，即在某进程开始访问临界区到结束访问为止都不允许被中断，也就不能发生进程切换，因此也不可能发生两个同时访问临界区的情况）\n\n优点：简单、高效\n缺点：不适用于多处理机；只适用于操作系统内核进程，不适用于用户进程（因为开&#x2F;关中断指令只能运行在内核态，这组指令如果能让用户随意使用会很危险）\nTestAndSet（TS指令&#x2F;TSL指令）\n优点：实现简单，无需像软件实现方法那样严格检查是否会有逻辑漏洞；适用于多处理机环境\n缺点：不满足“让权等待”原则，暂时无法进入临界区的进程会占用CPU并循环执行TSL指令，从而导致“忙等”\nSwap指令（XCHG指令）\n❗️目前，所有的解决方案都无法实现“让权等待”\n","categories":["计算机理论"],"tags":["操作系统原理-操作系统原理笔记"]},{"title":"操作系统的概念、功能和目标","url":"/2020/06/30/%E8%AE%A1%E7%AE%97%E6%9C%BA%E7%90%86%E8%AE%BA/%E6%93%8D%E4%BD%9C%E7%B3%BB%E7%BB%9F%E5%8E%9F%E7%90%86/%E6%93%8D%E4%BD%9C%E7%B3%BB%E7%BB%9F%E5%8E%9F%E7%90%86%E7%AC%94%E8%AE%B0/1.1_%E6%93%8D%E4%BD%9C%E7%B3%BB%E7%BB%9F%E7%9A%84%E6%A6%82%E5%BF%B5%E3%80%81%E5%8A%9F%E8%83%BD%E5%92%8C%E7%9B%AE%E6%A0%87/","content":"操作系统的概念操作系统是指控制和管理整个计算机系统的硬件和软件资源，并合理的组织调度计算机的工作和资源的分配；以提供给用户和其他软件方便的接口和环境；它是计算机系统中最基本的系统软件\n\n操作系统是系统资源的管理者\n向上层提供方便易用的服务\n是最接近硬件的一层软件\n\n操作系统的功能和目标\n作为系统资源的管理者(目标：安全、高效)\n处理机管理\n存储器管理\n文件管理\n设备管理\n\n\n向上层提供方便易用的服务\n封装思想：操作系统把一些丑陋的硬件功能封装成简单易用的服务，使用户能更方便的使用计算机，用户无需关心底层硬件的原理，只需要对操作系统发出命令即可\nGUI：图形化用户接口，很多现代操作系统都提供GUI，用户可以使用形象的图形界面进行操作，而不再需要记忆复杂的命令、参数\n命令接口\n联机命令接口，联机命令接口 &#x3D; 交互式命令接口，特点是用户说一句，系统跟着做一句\n脱机命令接口，脱机命令接口 &#x3D; 批处理命令接口，特点是用户说一堆，系统跟着做一堆\n\n\n程序接口：可以在程序中进行系统调用来使用程序接口，普通用户不能直接使用程序接口，只能通过程序代码间接使用，系统调用类似于函数调用，是应用程序请求操作系统服务的唯一方式\n\n\n作为最接近硬件的层次\n需要实现对硬件机器的拓展，没有任何软件支持的计算机称为裸机，在裸机上安装的操作系统可以提供资源管理功能和方便用户的服务功能，将裸机改造成功能更强、使用更方便的机器，通常把覆盖了软件的机器称为扩充机器，又称为虚拟机\n操作系统对硬件机器的扩展：将CPU、内存、磁盘、显示器、键盘等硬件合理的组织起来，让各种硬件能够相互协调配合，实现更多更复杂的功能\n\n\n\n","categories":["计算机理论"],"tags":["操作系统原理-操作系统原理笔记"]},{"title":"信号量机制","url":"/2020/06/30/%E8%AE%A1%E7%AE%97%E6%9C%BA%E7%90%86%E8%AE%BA/%E6%93%8D%E4%BD%9C%E7%B3%BB%E7%BB%9F%E5%8E%9F%E7%90%86/%E6%93%8D%E4%BD%9C%E7%B3%BB%E7%BB%9F%E5%8E%9F%E7%90%86%E7%AC%94%E8%AE%B0/2.11_%E4%BF%A1%E5%8F%B7%E9%87%8F%E6%9C%BA%E5%88%B6/","content":"1965年，荷兰学者Dijkstra提出了一种卓有成效的实现进程互斥、同步的方法：信号量机制\n\n整型信号量用一个整数型的变量作为信号量，用来表示系统中某种资源的数量\n与普通整数变量的区别：对信号量的操作只有三种，初始化、P操作、V操作\n\n记录型信号量整型信号量的缺陷是存在“忙等”问题，因此人们又提出了“记录型信号量”，即用记录型数据结构表示的信号量\n\n⭐️有多少资源就把信号量初始值设为多少\n\n执行signal原语时：\n\nS.value + 1 后 &lt;&#x3D; 0，说明有进程在等待资源\nS.value + 1 后 &gt; 0，说明已经没有进程在等待资源\n\n注意：要能够自己推断在什么条件下需要执行block或wakeup\n⭐️记录型信号量遵循了“让权等待”原则，不会出现“忙等”现象\n用信号量机制实现进程互斥一个信号量对应一种资源\n信号量的值 &#x3D; 这种资源的剩余数量（信号量的值如果小于0，说明此时有进程在等待这种资源）\nP(S)：申请一个资源S，如果资源不够就阻塞等待\nV(S)：释放一个资源S，如果有进程在等待该资源，则唤醒一个进程\n注意：\n\n对不同的临界资源需要设置不同的互斥信号量，如打印机这个临界资源设置mutex1 &#x3D; 1，另一个摄像头临界资源设置mutex2 &#x3D; 1\nP、V操作必须成对出现，缺少P(mutex)就不能保证临界资源的互斥访问。缺少V(mutex)会导致资源永不被释放，等待进程永不被唤醒\n\n\n用信号量机制实现进程同步进程同步：要让各并发进程按要求有序的推进\n\n❗️在“前操作”之后执行V(S)，在“后操作”之前执行P(V)\n\n用信号量机制实现进程的前驱关系（进程同步）前驱关系问题，本质上就是多级同步问题\n\n","categories":["计算机理论"],"tags":["操作系统原理-操作系统原理笔记"]},{"title":"管程","url":"/2020/06/30/%E8%AE%A1%E7%AE%97%E6%9C%BA%E7%90%86%E8%AE%BA/%E6%93%8D%E4%BD%9C%E7%B3%BB%E7%BB%9F%E5%8E%9F%E7%90%86/%E6%93%8D%E4%BD%9C%E7%B3%BB%E7%BB%9F%E5%8E%9F%E7%90%86%E7%AC%94%E8%AE%B0/2.13_%E7%AE%A1%E7%A8%8B/","content":"为什么要引入管程信号量机制存在的问题：编写程序困难，易出错\n能不能设计一种机制，让程序员写程序时不需要再关注复杂的PV操作，让写代码更轻松呢？\n1973年，Brinch Hansen首次在程序设计语言（Pascal）中引入了“管程”成分：一种高级同步机制\n管程的定义和基本特征管程是一种特殊的软件模块，有这些部分组成：\n\n局部于管程的共享数据结构说明\n对该数据结构进行操作的一组过程（过程其实就是“函数”）\n对局部于管程的共享数据设置初始值的语句\n管程有一个名字\n\n管程的基本特征：\n\n局部于管程的数据只能被局部于管程的过程所访问\n一个进程只有通过调用管程内的过程才能进入管程访问共享数据\n每次仅允许一个进程在管程内执行某个内部过程\n\n用管程解决生产者消费者问题每次仅允许一个进程在管程内执行某个内部过程：\n\n\n\n","categories":["计算机理论"],"tags":["操作系统原理-操作系统原理笔记"]},{"title":"中断和异常","url":"/2020/06/30/%E8%AE%A1%E7%AE%97%E6%9C%BA%E7%90%86%E8%AE%BA/%E6%93%8D%E4%BD%9C%E7%B3%BB%E7%BB%9F%E5%8E%9F%E7%90%86/%E6%93%8D%E4%BD%9C%E7%B3%BB%E7%BB%9F%E5%8E%9F%E7%90%86%E7%AC%94%E8%AE%B0/1.5_%E4%B8%AD%E6%96%AD%E5%92%8C%E5%BC%82%E5%B8%B8/","content":"中断的作用“中断”是让操作系统内核夺回CPU使用权的唯一途径，中断会让CPU由用户态变为内核态\n如果没有“中断”机制，那么一旦应用程序上CPU运行，CPU就会一直运行这个应用程序，既如此，何来并发。\n中断的类型内中断（也称“异常”）\n陷阱、陷入（trap）：由陷入指令引发，是应用程序故意引发的\n故障（fault）：由错误条件引起的，可能被内核程序修复。内核程序修复故障后会把CPU使用权还给应用程序，让它继续执行下去（缺页故障）\n终止（abort）：由致命错误引起，内核程序无法修复该错误，因此一般不再将CPU使用权还给引发终止的应用程序（整数除0，非法使用特权指令）\n\n与当前执行的指令有关，中断信号来源于CPU内部\n若当前执行的指令是非法的，则会引发一个中断信号\n\n试图在用户态下执行特权指令\n执行除法指令时发现除数为0\n有时候应用程序想请求操作系统内核的服务，此时会执行一条特殊的指令：陷入指令，该指令会引发一个内部中断信号，执行陷入指令，意味着应用程序主动的将CPU控制权还给操作系统内核，“系统调用”就是通过陷入指令完成的（注意陷入指令并不是特权指令）（陷入指令 &#x3D; trap指令 &#x3D; 访管指令）\n\n外中断（也称“中断”）与当前执行的指令无关，中断信号来源于CPU外部\n\n时钟中断：由时钟部件发来的中断信号，时钟部件每隔一个时间片会给CPU发送一个时钟中断信号（多个应用程序的并发运行）\nI&#x2F;O中断：由输入&#x2F;输出设备发来的中断信号（打印机）\n\n中断机制的基本原理检查中断信号：\n内中断：CPU在执行指令时会检查是否有异常发生\n外中断：每一条指令执行结束时，CPU都会例行检查是否有外中断信号需要处理\n不同的中断信号，需要用不同的中断处理程序来处理。当CPU检测到中断信号后，会根据中断信号的类型去查询“中断向量表”，以此来找到相应的中断处理程序在内存中的存放位置\n\n","categories":["计算机理论"],"tags":["操作系统原理-操作系统原理笔记"]},{"title":"经典进程同步互斥问题","url":"/2020/06/30/%E8%AE%A1%E7%AE%97%E6%9C%BA%E7%90%86%E8%AE%BA/%E6%93%8D%E4%BD%9C%E7%B3%BB%E7%BB%9F%E5%8E%9F%E7%90%86/%E6%93%8D%E4%BD%9C%E7%B3%BB%E7%BB%9F%E5%8E%9F%E7%90%86%E7%AC%94%E8%AE%B0/2.12_%E7%BB%8F%E5%85%B8%E8%BF%9B%E7%A8%8B%E5%90%8C%E6%AD%A5%E4%BA%92%E6%96%A5%E9%97%AE%E9%A2%98/","content":"生产者-消费者问题（互斥、同步综合问题）系统中有一组生产者进程和一组消费者进程，生产者进程每次生产一个产品放入缓冲区，消费者进程每次从缓冲区中取出一个产品并使用\n\n生产者、消费者共享一个初始为空、大小为n的缓冲区\n只有缓冲区没满时，生产者才能把产品放入缓冲区，否则必须等待（进程同步：缓冲区没满 -&gt; 生产者生产）\n只有缓冲区不空时，消费者才能从中取出产品，否则必须等待（进程同步：缓冲区没空 -&gt; 消费者消费）\n缓冲区是临界资源，各进程必须互斥访问（如果两个生产者进程并发运行，同时往缓冲区的同一块区域放入数据，会出现问题）（互斥关系）\n\n❗️互斥信号量初值一般为1，同步信号量的初始值要看对应资源的初始值是多少\n\n\n能否改变相邻P、V操作的顺序？\n\n“生产一个产品”、“使用产品”这两句话逻辑上是可以放到PV操作之间，但是这样会增加临界区的代码，会导致进程的并发度降低，对系统的效能产生影响，造成不便\n多生产者-多消费者问题\n桌子上有一只盘子，每次只能向其中放入一个水果。（大小为1，初始为空的缓冲区）\n爸爸专向盘子中放苹果，妈妈专向盘子中放橘子，儿子专等着吃盘子中的橘子，女儿专等着吃盘子中的苹果。\n只有盘子空时，爸爸或妈妈才可向盘子中放一个水果。仅当盘子中有自己需要的水果时，儿子或女儿可以从盘子中取出水果。用PV操作实现上述过程\n\n\n互斥关系：对缓冲区（盘子）的访问要互斥的进行\n同步关系（一前一后）：\n\n盘子中有苹果，女儿才能取苹果\n盘子中有橘子，儿子才能取橘子\n只有盘子为空时，父亲或母亲才能放入水果（“盘子为空”这个事件可以由儿子或女儿触发，事件发生后才允许父亲或母亲放水果）\n\n\n\n\n问题：可不可以不用互斥信号量\n分析：刚开始，儿子、女儿进程即使上处理机运行也会被阻塞，如果刚开始是父亲进程先上处理机运行，则父亲P(plate)，可以访问盘子 -&gt; 母亲P(plate)，阻塞等待盘子 -&gt; 父亲放入苹果V(apple)，女儿进程被唤醒，其他进程即使运行也都会阻塞，暂时不能访问临界资源（盘子） -&gt; 女儿P(apple)，访问盘子，V(plate)，等待盘子的母亲进程被唤醒 -&gt; 母亲进程访问盘子（其他进程暂时无法进入临界区） -&gt; …\n结论：即使不设置专门的互斥变量mutex，也不会出现多个进程同时访问盘子的现象\n原因：本题中的缓冲区大小为1，在任何时刻，apple、orange、plate三个同步信号量中最多只有一个是1，因此在任何时刻，最多只有一个进程的P操作不会被阻塞，并顺利的进入临界区\n如果盘子的容量（缓冲区）设为2，可能出现两个进程同时访问缓冲区的情况，有可能导致两个进程写入缓冲区的数据相互覆盖的情况\n❗️因此，如果缓冲区大小大于1，就必须专门设置一个互斥信号量mutex来保证互斥访问缓冲区\n吸烟者问题（可生产多种产品的单生产者-多消费者）假设一个系统有三个抽烟者进程和一个供应者进程。每个抽烟者不停的卷烟并抽掉它，但是要卷起并抽掉一支烟，抽烟者需要有三种材料：烟草、纸和胶水。三个抽烟者中，第一个拥有烟草、第二个拥有纸、第三个拥有胶水。供应者进程无限的提供三种材料，供应者每次将两种材料放桌子上，拥有剩下那种材料的抽烟者卷一根烟并抽掉它，并给供应者进程一个信号告诉它完成了，供应者就会放另外两种材料在桌上，这个过程一直重复（让三个抽烟者轮流的抽烟）\n\n互斥关系：桌子可以抽象为容量为1的缓冲区，要互斥访问（这个容量为1表示组合）\n\n组合一：纸+胶水\n组合二：烟草+胶水\n组合三：烟草+纸\n\n同步关系（从事件的角度来分析）：\n\n桌上有组合一，第一个抽烟者取走东西\n桌上有组合二，第二个抽烟者取走东西\n桌上有组合三，第三个抽烟者取走东西\n发出完成信号，供应者将下一个组合放到桌上\n\n\n\n\n\n读者-写者问题（复杂的互斥问题）有读者和写者两组并发进程，共享一个文件，当两个或两个以上的读进程同时访问共享数据时不会产生副作用，但若某个写进程和其他进程（读进程或写进程）同时访问共享数据时则可能导致数据不一致的错误，因此要求：\n\n允许多个读者可以同时对文件执行读操作（与消费者进程不同，读者进程在读数据后并不会将数据清空，并不会改变数据。因此多个读者进程可同时访问共享数据）\n只允许一个写者往文件中写信息\n任一写者在完成写操作之前不允许其他读者或写者工作（两个写进程同时共享数据，可能导致数据错误覆盖的问题）（读进程与写进程同时共享数据，可能导致读出的数据不一致的问题）\n写者执行写操作前，应让已有的读者和写者全部退出\n\n\n两类进程：写进程、读进程\n互斥关系：写进程-写进程、写进程-读进程（读进程-读进程不存在互斥问题）\n\n\n\n思考：若两个读进程并发执行，则count&#x3D;0时两个进程也许都能满足if条件，都会执行P(rw)，从而使第二个读进程阻塞的情况\n如何解决：出现上述问题的原因在于对count变量的检查和赋值无法一气呵成，因此可以设置另一个互斥信号量来保证各读者进程对count的访问是互斥的\n\n潜在的问题：只要有读进程还在读，写进程就要一直阻塞等待，可能“饿死”。因此这种算法中，读进程是优先的\n\n\n\n\n结论；在这种算法中，连续进入的多个读者可以同时读文件；写者和其他进程不能同时访问文件；写者不会饥饿，但也并不是真正的“写优先”，而是相对公平的先来先服务原则。有的书上把这种算法称为“读写公平法”\n哲学家进餐问题（解决进程死锁）一张圆桌上坐着5名哲学家，每两个哲学家之间的桌上摆一根筷子，桌子的中间是一碗米饭。哲学家们倾注毕生的精力用于思考和进餐，哲学家在思考时，并不影响其他人。只有当哲学家饥饿时，才试图拿起左、右两根筷子（一根一根的拿起）。如果筷子已在他人手上，则需等待。饥饿的哲学家只有同时拿起两根筷子才可以开始进餐，当进餐完毕后，放下筷子继续思考\n\n系统中有5个哲学家进程，5位哲学家与左右邻居对其中间筷子的访问是互斥关系\n这个问题中只有互斥关系，但与之前遇到的问题不同的是，每个哲学家进程需要同时持有两个临界资源才能开始吃饭。如何避免临界资源分配不当造成的死锁现象，是哲学家问题的精髓\n定义互斥信号量数组chopstick[5] &#x3D; {1,1,1,1,1}，用于实现对5个筷子的互斥访问，并对哲学家按0～4编号，哲学家i左边的筷子编号为i，右边的筷子编号为(i+1) % 5\n\n如果5个哲学家并发的拿起了自己左手边的筷子，每位哲学家循环等待右边的人放下筷子（阻塞），发生“死锁”\n\n解决方法：\n\n可以对哲学家进程施加一些限制条件，比如最多只允许四个哲学家同时进餐。这样可以保证至少有一个哲学家是可以拿到左右两只筷子的\n\n要求奇数号哲学家先拿左边的筷子，然后再拿右边的筷子，而偶数号哲学家刚好相反。用这种方法可以保证如果相邻的两个奇偶号哲学家都想吃饭，那么只会有其中一个可以拿起第一支筷子，另一个会直接阻塞。这就避免了占有一支后再等待另一只的情况\n\n仅当一个哲学家左右两支筷子都可用时才允许他抓起筷子\n\n\n\n画图可知，进程分别调度哲学家0、1、2时可发现，哲学家0可正常吃饭，哲学家1被阻塞，哲学家2虽然左右都有筷子，但是他也被阻塞\n进程分别调度0、4时，哲学家0可正常吃饭，哲学家4右边的筷子不可用，但是4仍然可以拿起左边的筷子，因此这种方法并不能保证只有两边的筷子都可用时，才允许哲学家拿起筷子\n","categories":["计算机理论"],"tags":["操作系统原理-操作系统原理笔记"]},{"title":"死锁","url":"/2020/06/30/%E8%AE%A1%E7%AE%97%E6%9C%BA%E7%90%86%E8%AE%BA/%E6%93%8D%E4%BD%9C%E7%B3%BB%E7%BB%9F%E5%8E%9F%E7%90%86/%E6%93%8D%E4%BD%9C%E7%B3%BB%E7%BB%9F%E5%8E%9F%E7%90%86%E7%AC%94%E8%AE%B0/2.14_%E6%AD%BB%E9%94%81/","content":"死锁的概念什么是死锁在并发环境下，各进程因竞争资源而造成的一种互相等待对方手里的资源，导致各进程都阻塞，都无法向前推进的现象，就是“死锁”。发生死锁后若无外力干涉，这些进程都将无法向前推进\n进程死锁、饥饿、死循环的区别死锁：各进程互相等待对方手里的资源，导致各进程都阻塞，无法向前推进的现象\n饥饿：由于长期得不到想要的资源，某进程无法向前推进的现象\n死循环：某进程执行过程中一直跳不出某个循环的现象。有时是因为程序逻辑bug导致的，有时是程序员故意设计的\n\n死锁产生的必要条件产生死锁必须同时满足以下四个条件，只要有其中任一条件不成立，死锁就不会发生\n\n互斥条件：只有对必须互斥使用的资源的争抢才会导致死锁（如哲学家的筷子、打印机设备等），像内存、扬声器这种可以同时让多个进程使用的资源是不会导致死锁的\n不剥夺条件：进程所获得的资源在未使用完之前，不能由其他进程强行夺走，只能主动释放\n请求和保持条件：进程已经保持了至少一个资源，但又提出了新的资源请求，而该资源又被其他进程占有，此时请求进程被阻塞，但又对自己已有的资源保持不放\n循环等待条件：存在一种进程资源的循环等待链，链中的每一个进程已获得的资源同时被下一个进程所请求\n\n注意：发生死锁时一定有循环等待，但是发生循环等待时未必死锁（循环等待是死锁的必要不充分条件）\n什么时候会发生死锁\n死锁的处理策略\n预防死锁（静态策略，不允许死锁发生）：破坏死锁产生的四个必要条件中的一个或几个\n避免死锁（动态策略，不允许死锁发生）：用某种方法防止系统进入不安全状态，从而避免死锁（银行家算法）\n死锁的检测和解除：允许死锁的发生，不过操作系统会负责检测出死锁的发生，然后采取某种措施解除死锁\n\n死锁的处理策略：预防死锁破坏互斥条件互斥条件：只有对必须互斥使用的资源的争抢才会导致死锁\n如果把只能互斥使用的资源改造为允许共享使用，则系统不会进入死锁状态。比如SPOOLing技术，操作系统可以采用SPOOLing技术把独占设备在逻辑上改造成共享设备\n\n该策略的缺点：并不是所有的资源都可以改造成可共享使用的资源。并且为了系统安全，很多地方还必须保护这种互斥性，因此，很多时候都无法破坏互斥条件\n破坏不剥夺条件\n破坏请求和保持条件C类进程可能会饥饿：\n\n破坏循环等待条件\n死锁的处理策略：避免死锁（银行家算法）\n什么是安全序列所谓安全序列，就是指如果系统按照这种序列分配资源，则每个进程都能顺利完成。只要能找出一个安全序列，系统就是安全状态。当然，安全序列可能有多个\n什么是系统的不安全状态，与死锁有何联系如果分配了资源之后，系统中找不出任何一个安全序列，系统就进入了不安全状态。这就意味着之后可能所有进程都无法顺利的执行下去。当然，如果有进程提前归还了一些资源，那系统也有可能重新回到安全状态，不过我们在分配资源之前总是要考虑到最坏的情况\n❗️如果系统处于安全状态，就一定不会发生死锁。如果系统进入不安全状态，就可能发生死锁（处于不安全状态未必就是发生了死锁，但发生死锁时一定是在不安全状态）\n因此可以在资源分配之前预先判断这次分配是否会导致系统进入不安全状态，以此决定是否答应资源分配请求。这也是“银行家算法”的核心思想\n如何避免系统进入不安全状态：银行家算法银行家算法是荷兰学者Dijkstra为银行系统设计的，以确保银行在发放现金贷款时，不会发生不能满足所有客户需要的情况。后来该算法被用在操作系统中，用于避免死锁\n核心思想：在进程提出资源申请时，先预判此次分配是否会导致系统进入不安全状态。如果会进入不安全状态，就暂时不答应这次请求，让该进程先阻塞等待\n\n\n\n\n死锁的处理策略：死锁的检测和解除死锁的检测用于检测系统状态，以确定系统中是否发生了死锁\n\n\n\n最终还连着边的那些进程就是处于死锁状态的进程：\n\n\n死锁的解除当认定系统中已经发生了死锁，利用该算法可将系统从死锁状态中解脱出来\n一旦检测出死锁的发生，就应该立即解除死锁\n❗️并不是系统中所有的进程都是死锁状态，用死锁检测算法化简资源分配图后，还连着边的那些进程就是死锁进程\n\n如何决定先剥夺哪个进程的资源或先对谁动手？\n\n根据进程优先级（先动手优先级低的）\n根据进程已执行多长时间\n根据进程还要多久能完成\n根据进程已经使用了多少资源（先动手使用资源多的，这样很容易把更多死锁进程解除出来）\n根据进程是交互式的还是批处理式的（优先动手批处理式的，交互式的是跟用户打交道）\n\n","categories":["计算机理论"],"tags":["操作系统原理-操作系统原理笔记"]},{"title":"线程概念、多线程模型","url":"/2020/06/30/%E8%AE%A1%E7%AE%97%E6%9C%BA%E7%90%86%E8%AE%BA/%E6%93%8D%E4%BD%9C%E7%B3%BB%E7%BB%9F%E5%8E%9F%E7%90%86/%E6%93%8D%E4%BD%9C%E7%B3%BB%E7%BB%9F%E5%8E%9F%E7%90%86%E7%AC%94%E8%AE%B0/2.5_%E7%BA%BF%E7%A8%8B%E6%A6%82%E5%BF%B5%E3%80%81%E5%A4%9A%E7%BA%BF%E7%A8%8B%E6%A8%A1%E5%9E%8B/","content":"什么是线程，为什么要引入线程\n还没引入进程之前，系统中各个程序只能串行执行\n引入进程之后，可以边听音乐边玩QQ\n引入线程之后，在QQ里可以边聊天边传送文件等\n\n传统的进程是程序执行流的最小单位，引入线程后，线程成为了程序执行流的最小单位\n线程是一个基本的CPU执行单元，也是程序执行流的最小单位，引入线程之后，不仅是进程之间可以并发，进程内的各线程之间也可以并发，从而进一步提升了系统的并发度，使得一个进程内也可以并发处理各种任务\n引入线程后，进程只作为除CPU之外的系统资源的分配单元（如打印机、内存地址空间等都是分配给进程的）\n引入线程机制后，有什么变化\n线程有哪些重要的属性\n线程是处理机调度的单位\n多CPU计算机中，各个线程可占用不同的CPU\n每一个线程都有一个线程ID、线程控制块TCB\n线程也有就绪、阻塞、运行三种基本状态\n线程几乎不拥有系统资源\n同一进程的不同线程间共享进程的资源\n由于共享内存地址空间，同一进程中的线程间通信甚至无需系统干预\n同一进程中的线程切换，不会引起进程切换\n不同进程中的线程切换，会引起进程切换\n切换同进程内的线程，系统开销很小\n切换进程，系统开销较大\n\n线程的实现方式用户级线程ULT（从用户视角能看到的线程）早期的操作系统（早期Unix）只支持进程，不支持线程，当时的“线程”是由线程库实现的\n\n内核级线程KLT（从操作系统视角看到的线程）由操作系统支持的线程，内核级线程才是处理机分配的单位\n\n多线程模型在支持内核级线程的系统下，通过用户级线程和内核级线程的映射关系，可以划分为几种多线程模型\n一对一模型\n多对一模型（相当于用户级线程ULT）\n多对多模型（集二者之所长）\n","categories":["计算机理论"],"tags":["操作系统原理-操作系统原理笔记"]},{"title":"处理机调度概念、层次","url":"/2020/06/30/%E8%AE%A1%E7%AE%97%E6%9C%BA%E7%90%86%E8%AE%BA/%E6%93%8D%E4%BD%9C%E7%B3%BB%E7%BB%9F%E5%8E%9F%E7%90%86/%E6%93%8D%E4%BD%9C%E7%B3%BB%E7%BB%9F%E5%8E%9F%E7%90%86%E7%AC%94%E8%AE%B0/2.6_%E5%A4%84%E7%90%86%E6%9C%BA%E8%B0%83%E5%BA%A6%E6%A6%82%E5%BF%B5%E3%80%81%E5%B1%82%E6%AC%A1/","content":"基本概念当有一堆任务要处理，但由于资源有限，这些事情没法同时处理。这就需要确定某种规则来决定处理这些任务的顺序，这就是“调度”研究的问题\n三个层次高级调度（作业调度）作业：一个具体的任务\n用户向系统提交一个作业 &#x3D; 用户让操作系统启动一个程序（来处理一个具体的任务）\n内存空间有限，有时无法将用户提交的作业全部放入内存？\n高级调度（作业调度）：按一定的原则从外存的作业后备队列中挑选一个作业调入内存，并创建进程。每个作业只调入一次，调出一次，作业调入时会建立PCB，调出时才撤销PCB\n中级调度（内存调度）内存不够时，可将某些进程的数据调出外存，等内存空闲或者进程需要运行时再重新调入内存，暂时调到外存等待的进程状态为挂起状态，被挂起的进程PCB会被组织成挂起队列（为减轻系统负载，提高资源利用率）\n中级调度：按照某种策略决定将哪个处于挂起状态的进程重新调入内存，一个进程可能会被多次调出、调入内存，因此中级调度发生的频率要比高级调度更高\n进程的挂起态与七状态模型暂时调到外存等待的进程状态为挂起状态（挂起态，suspend），挂起状态又可以进一步细分为就绪挂起、阻塞挂起两种状态\n\n低级调度（进程调度&#x2F;处理机调度）按照某种策略从就绪队列中选取一个进程，将处理机分配给它\n进程调度是操作系统中最基本的一种调度，在一般的操作系统中都必须配置进程调度，进程调度的频率很高，一般几十毫秒一次\n三层调度的联系、对比\n","categories":["计算机理论"],"tags":["操作系统原理-操作系统原理笔记"]},{"title":"进程控制","url":"/2020/06/30/%E8%AE%A1%E7%AE%97%E6%9C%BA%E7%90%86%E8%AE%BA/%E6%93%8D%E4%BD%9C%E7%B3%BB%E7%BB%9F%E5%8E%9F%E7%90%86/%E6%93%8D%E4%BD%9C%E7%B3%BB%E7%BB%9F%E5%8E%9F%E7%90%86%E7%AC%94%E8%AE%B0/2.3_%E8%BF%9B%E7%A8%8B%E6%8E%A7%E5%88%B6/","content":"进程控制的主要功能是对系统中的所有进程实施有效的管理，它具有创建新进程、撤销已有进程、实现进程状态转换等功能\n\n如何实现进程控制：用“原语”实现，原语的执行具有“原子性”，一气呵成\n如果不能“一气呵成”，就有可能导致操作系统中的某些关键数据结构信息不统一的情况，这会影响操作系统进行别的管理工作\n假设此时进程2等待的事件发生，则操作系统中，负责进程控制的内核程序至少需要做两件事\n\n将PCB2的state设为1\n将PCB2从阻塞队列放到就绪队列\n\n完成了第一步后收到中断信号，那么PCB2的state &#x3D; 1，但是它却被放在阻塞队列里\n\n如何实现原语的“原子性”可以用“关中断指令”和“开中断指令”这两个特权指令实现原子性，CPU执行了关中断指令之后，就不再例行检查中断信号，直到执行开中断指令之后才会恢复检查，这样，关中断、开中断之间的这些指令序列就是不可被中断的，这就实现了“原子性”\n进程控制相关的原语进程的创建\n进程的终止\n进程的阻塞和唤醒\n进程的切换\n无论哪个进程控制原语，要做的无非三类事情：\n\n更新PCB中的信息：修改进程状态state、保存&#x2F;恢复运行环境\n将PCB插入合适的队列\n分配&#x2F;回收资源\n\n程序是如何运行的\n\nPSW程序状态字寄存器\nPC程序计数器：存放下一条指令的地址\nIR指令寄存器：存放当前正在执行的指令\n通用寄存器：其他一些必要信息\n\n指令顺序执行的过程中，很多中间结果是放在各种寄存器中的\n假设执行完某条指令后，另一个进程开始上CPU运行，另一个进程在运行过程中也会使用各个寄存器\n在进程切换时，先在PCB中保存这个进程的运行环境，保存一些必要的寄存器信息，当原来的进程再次投入运行时，可以通过PCB恢复它的运行环境\n","categories":["计算机理论"],"tags":["操作系统原理-操作系统原理笔记"]},{"title":"进程调度的时机、切换与进程调度方式","url":"/2020/06/30/%E8%AE%A1%E7%AE%97%E6%9C%BA%E7%90%86%E8%AE%BA/%E6%93%8D%E4%BD%9C%E7%B3%BB%E7%BB%9F%E5%8E%9F%E7%90%86/%E6%93%8D%E4%BD%9C%E7%B3%BB%E7%BB%9F%E5%8E%9F%E7%90%86%E7%AC%94%E8%AE%B0/2.7_%E8%BF%9B%E7%A8%8B%E8%B0%83%E5%BA%A6%E7%9A%84%E6%97%B6%E6%9C%BA%E3%80%81%E5%88%87%E6%8D%A2%E4%B8%8E%E8%BF%9B%E7%A8%8B%E8%B0%83%E5%BA%A6%E6%96%B9%E5%BC%8F/","content":"进程调度的时机进程调度（低级调度），就是按照某种算法从就绪队列中选择一个进程为其分配处理机\n需要进行进程调度与切换的情况\n当前运行的进程主动放弃处理机\n进程正常终止\n运行过程中发生异常而终止\n进程主动请求阻塞（如等待I&#x2F;O）\n\n\n当前运行的进程被动放弃处理机\n分给进程的时间片用完\n有更紧急的事需要处理（如I&#x2F;O中断）\n有更高优先级的进程进入就绪队列\n\n\n\n不能进行进程调度与切换的情况\n在处理中断的过程中，中断处理过程复杂，与硬件密切相关，很难做到在中断处理过程中进行进程切换\n进程在操作系统内核程序临界区中\n在原子操作过程中（原语），原子操作不可中断，要一气呵成（如修改PCB中进程状态标志，并把PCB放到相应队列）\n\n进程在操作系统内核程序临界区中不能进行调度与切换✅\n进程处于临界区时不能进行处理机调度❌\n临界资源：一个时间段内只允许一个进程使用的资源，各进程需要互斥的访问临界资源\n临界区：访问临界资源的那段代码\n内核程序临界区一般是用来访问某种内核数据结构的，比如进程的就绪队列（由各就绪进程的PCB组成）\n假设就绪队列被上锁，进程还没有退出就绪队列（还没解锁）就进行进程调度，但是进程调度相关的程序也需要访问就绪队列，但此时就绪队列被锁住了，因此又无法顺利进行进程调度\n内核程序临界区访问的临界资源如果不尽快释放的话，极有可能影响到操作系统内核的其他管理工作，因此在访问内核程序临界区期间不能进行调度与切换\n\n\n有的系统中，只允许进程主动放弃处理机\n有的系统中，进程可以主动放弃处理机，当有更紧急的任务需要处理时，也会强行剥夺处理机（被动放弃）\n进程调度的方式\n非剥夺调度方式，又称非抢占方式，即只允许进程主动放弃处理机，在运行过程中即便有更紧迫的任务到达，当前进程依然会继续使用处理机，直到该进程终止或主动要求进入阻塞态\n实现简单，系统开销小但是无法及时处理紧急任务，适合于早期的批处理系统\n\n\n剥夺调度方式，又称抢占方式，可由操作系统剥夺当前进程的CPU使用权，当一个进程正在处理机上执行时，如果有一个更重要或更紧急的进程需要使用处理机，则立即暂停正在执行的进程，将处理机分配给更重要紧迫的那个进程\n可以优先处理更紧急的进程，也可实现让各进程按时间片轮流执行的功能（通过时钟中断），适合于分时操作系统、实时操作系统\n\n\n\n进程的切换与过程“狭义的进程调度”：从就绪队列中选中一个要运行的进程（这个进程可以是刚刚被暂停执行的进程，也可能是另一个进程，后一种情况就需要进程切换）\n进程切换：一个进程让出处理机，由另一个进程占用处理机的过程\n“广义的进程调度”：包含了选择一个进程和进程切换两个步骤\n进程切换的过程主要完成了：\n\n对原来运行进程各种数据的保存\n对新的进程各种数据的恢复（如程序计数器、程序状态字、各种数据寄存器等处理机现场信息，这些信息一般保存在进程控制块）\n\n注意：进程切换、调度是有代价的，因此如果过于频繁的进行进程调度、切换，必然会使整个系统的效率降低，使系统大部分时间都花在了进程切换上，而真正用于执行进程的时间减少，并不是调度越频繁，并发度就越高\n","categories":["计算机理论"],"tags":["操作系统原理-操作系统原理笔记"]},{"title":"操作系统的体系结构","url":"/2020/06/30/%E8%AE%A1%E7%AE%97%E6%9C%BA%E7%90%86%E8%AE%BA/%E6%93%8D%E4%BD%9C%E7%B3%BB%E7%BB%9F%E5%8E%9F%E7%90%86/%E6%93%8D%E4%BD%9C%E7%B3%BB%E7%BB%9F%E5%8E%9F%E7%90%86%E7%AC%94%E8%AE%B0/1.7_%E6%93%8D%E4%BD%9C%E7%B3%BB%E7%BB%9F%E7%9A%84%E4%BD%93%E7%B3%BB%E7%BB%93%E6%9E%84/","content":"操作系统：\n\n非内核功能（GUI）\n内核（时钟管理、中断处理、原语(设备驱动、CPU切换等)、进程管理、存储器管理、设备管理等）\n\n原语是一种特殊的程序，具有原子性，也就是说，这段程序的运行必须一气呵成，不可被“中断”\n操作系统的内核内核是操作系统最基本、最核心的部分，实现操作系统内核功能的那些程序就是内核程序\n\n现在，应用程序想要请求操作系统的服务，这个服务的处理同时涉及到进程管理、存储管理、设备管理（变态的过程是有成本的，要消耗不少时间，频繁的变态会降低系统性能）：\n大内核&#x2F;单内核&#x2F;宏内核（Linux、UNIX）将操作系统的主要功能模块都作为系统内核，运行在核心态\n优点：高性能\n缺点：内核代码庞大，结构混乱，难以维护\n\n微内核（Windows NT）只把最基本的功能保留在内核\n优点：内核功能少，结构清晰，方便维护\n缺点：需要频繁的在核心态和用户态之间切换，性能低\n\n","categories":["计算机理论"],"tags":["操作系统原理-操作系统原理笔记"]},{"title":"进程的概念、组成、特征","url":"/2020/06/30/%E8%AE%A1%E7%AE%97%E6%9C%BA%E7%90%86%E8%AE%BA/%E6%93%8D%E4%BD%9C%E7%B3%BB%E7%BB%9F%E5%8E%9F%E7%90%86/%E6%93%8D%E4%BD%9C%E7%B3%BB%E7%BB%9F%E5%8E%9F%E7%90%86%E7%AC%94%E8%AE%B0/2.1_%E8%BF%9B%E7%A8%8B%E7%9A%84%E6%A6%82%E5%BF%B5%E3%80%81%E7%BB%84%E6%88%90%E3%80%81%E7%89%B9%E5%BE%81/","content":"进程的概念程序：是静态的，就是个存放在磁盘里的可执行文件，就是一系列的指令集合\n进程（Process）：是动态的，是程序的一次执行过程，同一个程序多次执行会对应多个进程\n进程是进程实体的运行过程，是系统进行资源分配和调度的一个独立单位（一个进程被调度，就是指操作系统决定让这个进程上CPU运行）\n进程的组成：PCB、程序段、数据段操作系统是进程的管理者，当进程被创建时，操作系统会为该进程分配一个唯一的、不重复的“身份证号”：PID（Process ID，进程ID）\n\n操作系统要记录PID、进程所属用户ID（UID）：基本的进程描述信息，可以让操作系统区分各个进程\n还要记录给进程分配了哪些资源（分配了多少内存、正在使用哪些I&#x2F;O设备、正在使用哪些文件）：可用于实现操作系统对资源的管理\n还要记录进程的运行情况（CPU使用时间、磁盘使用情况、网络流量使用情况、进程当前的状态：就绪态&#x2F;阻塞态&#x2F;运行态）：可用于实现操作系统对进程的控制、调度\n处理机相关信息：PSW、PC等各种寄存器的值，用于实现进程切换\n\n这些信息都被保存在一个数据结构PCB（Process Control Block）中，即进程控制块，操作系统需要对各个并发运行的进程进行管理，但凡管理时所需要的信息，都会被放在PCB中\nPCB是进程存在的唯一标志，当进程被创建时，操作系统为其创建PCB，当进程结束时，会回收其PCB\n程序段：程序的代码（指令序列）\n数据段：运行过程中产生的各种数据（如程序中定义的变量）\nPCB是给操作系统用的，程序段和数据段是给进程自己用的，与进程自身的运行逻辑有关\n一个进程实体（进程映像）由PCB、程序段、数据段组成，进程是动态的，进程实体（进程映像）是静态的，进程实体反映了进程在某一时刻的状态\n\n进程的特征程序是静态的，进程是动态的，相比于程序，进程拥有以下特征：\n\n动态性：进程是程序的一次执行过程，是动态的产生、变化和消亡的，动态性是进程最基本的特征\n并发性：内存中有多个进程实体，各进程可并发执行\n独立性：进程是能独立运行、独立获得资源、独立接受调度的基本单位\n异步性：各进程按各自独立的、不可预知的速度向前推进，操作系统要提供“进程同步机制”来解决异步问题\n结构性：每个进程都会配置一个PCB，结构上看，进程由程序段、数据段、PCB组成\n\n","categories":["计算机理论"],"tags":["操作系统原理-操作系统原理笔记"]},{"title":"进程通信","url":"/2020/06/30/%E8%AE%A1%E7%AE%97%E6%9C%BA%E7%90%86%E8%AE%BA/%E6%93%8D%E4%BD%9C%E7%B3%BB%E7%BB%9F%E5%8E%9F%E7%90%86/%E6%93%8D%E4%BD%9C%E7%B3%BB%E7%BB%9F%E5%8E%9F%E7%90%86%E7%AC%94%E8%AE%B0/2.4_%E8%BF%9B%E7%A8%8B%E9%80%9A%E4%BF%A1/","content":"什么是进程通信顾名思义，进程通信就是指进程之间的信息交换\n进程是分配系统资源的单位（包括内存地址空间），因此各进程拥有的内存地址空间相互独立，为了保证安全，一个进程不能直接访问另一个进程的地址空间，但是进程之间的信息交换又是必须实现的。为了保证进程间的安全通信，操作系统提供了一些方法\n共享存储基于数据结构的共享、基于存储区的共享\n消息传递进程间的数据交换以结构化的消息为单位，进程通过操作系统提供的“发送消息&#x2F;接收消息”两个原语进行数据交换\n\n直接通信方式发送进程要发送的消息直接挂到接收进程的消息缓冲队列上（通过发送消息&#x2F;接收消息原语）\n间接通信方式消息要先发送到中间实体（信箱）中，因此也称“信箱通信方式”（计网中的电子邮件系统）\n管道通信“管道”是指用于连接读写进程的一个共享文件，又名pipe文件。其实就是在内存中开辟一个大小固定的缓冲区\n\n\n管道只能采用半双工通信，某一时间段内只能实现单向的传输。如果要实现双向同时通信，则需要设置两个管道\n各进程要互斥的访问管道\n数据以字符流的形式写入管道，当管道写满时，写进程的write()系统调用将被阻塞，等待读进程将数据取走。当读进程将数据全部取走后，管道变空，此时读进程的read()系统调用将被阻塞\n如果没写满，就不允许读。如果没读空，就不允许写\n数据一旦被读出，就从管道中被抛弃，这就意味着读进程最多只能有一个，否则可能会有读错数据的情况\n\n","categories":["计算机理论"],"tags":["操作系统原理-操作系统原理笔记"]},{"title":"调度算法","url":"/2020/06/30/%E8%AE%A1%E7%AE%97%E6%9C%BA%E7%90%86%E8%AE%BA/%E6%93%8D%E4%BD%9C%E7%B3%BB%E7%BB%9F%E5%8E%9F%E7%90%86/%E6%93%8D%E4%BD%9C%E7%B3%BB%E7%BB%9F%E5%8E%9F%E7%90%86%E7%AC%94%E8%AE%B0/2.9_%E8%B0%83%E5%BA%A6%E7%AE%97%E6%B3%95/","content":"饥饿：某进程&#x2F;作业长期得不到服务\n先来先服务FCFS按照作业&#x2F;进程到达的先后顺序进行服务，事实上就是等待时间越久的越优先得到服务\n用于作业调度时，考虑的是哪个作业先到达后备队列（外存中）；用于进程调度时，考虑的是哪个进程先到达就绪队列（内存中）\n非抢占式算法\n优点：公平、算法实现简单\n缺点：排在长作业（进程）后面的短作业需要等待很长时间，带权周转时间很大，对短作业来说用户体验不好，即FCFS算法对长作业有利，对短作业不利\n不会导致饥饿\n最短作业优先SJF追求最少的平均等待时间、最少的平均周转时间、最少的平均带权周转时间\n最短的作业&#x2F;进程优先得到服务（所谓最短是指要求服务时间最短），每次调度时选择当前已到达的且运行时间最短的作业&#x2F;进程\n既可用于作业调度，也可用于进程调度，用于进程调度时称为“短进程优先算法SPF”\nSJF和SPF是非抢占式的算法，但是也有抢占式的版本：最短剩余时间优先算法SRTN\n最短剩余时间优先算法：每当有进程加入就绪队列改变时就需要调度，如果新到达的进程剩余时间比当前运行的进程剩余时间更短，则由新进程抢占处理机，当前运行进程重新回到就绪队列。另外，当一个进程完成时也需要调度\n优点：“最短的”平均等待时间、平均周转时间\n缺点：不公平，对短作业有利，对长作业不利。作业&#x2F;进程的运行时间是由用户提供的，并不一定真实，不一定能做到真正的短作业优先\n可能产生饥饿现象，如果源源不断的有短作业&#x2F;进程到来，可能使长作业&#x2F;进程长时间得不到服务，产生饥饿现象，如果一直得不到服务，则称为饿死\n平均等待时间、平均周转时间、平均带权周转时间由小到大：SRTN、SJF&#x2F;SPF、FCFS\n最高响应比优先HRRN\n在每次调度时先计算各个作业&#x2F;进程的响应比，选择响应比最高的作业&#x2F;进程为其服务\n响应比 &#x3D; （等待时间+要求服务时间）&#x2F; 要求服务时间【响应比 &gt;&#x3D; 1】\n即可用于作业调度，也可用于进程调度\n非抢占式的算法，因此只有当前运行的作业&#x2F;进程主动放弃处理机时，才需要调度，才需要计算响应比\n综合考虑了等待时间和运行时间（要求服务时间），等待时间相同时，要求服务时间短的优先（SJF的优点），要求服务时间相同时，等待时间长的优先（FCFS的优点），对于长作业来说，随着等待时间越来越久，其响应比也会越来越大，从而避免了长作业饥饿的问题\n⭐️以上三种算法主要关心对用户的公平性、平均周转时间、平均等待时间等评价系统整体性能的指标，但是不关心“响应时间”，也并不区分任务的紧急程度，因此对于用户来说，交互性很糟糕，因此这三种算法一般适合用于早期的批处理系统，当然，FCFS算法也常结合其他的算法来使用，在现在也扮演着很重要的角色\n时间片轮转RR公平的、轮流的为各个进程服务，让每个进程在一定时间间隔内都可以得到响应\n按照各进程到达就绪队列的顺序，轮流让各个进程执行一个时间片（如100ms），若进程未在一个时间片内执行完，则剥夺处理机，将进程重新放到就绪队列队尾重新排队\n用于进程调度（只有作业放入内存建立了相应的进程后，才能被分配处理机时间片）\n若进程未能在时间片内运行完，将被强行剥夺处理机使用权，因此时间片轮转调度算法属于抢占式的算法，由时钟装置发出时钟中断来通知CPU时间片已到\n如果时间片太大，使得每个进程都可以在一个时间片内就完成，则时间片轮转调度算法退化为先来先服务调度算法，并且会增大进程响应时间，因此时间片不能太大\n另一方面，进程调度、切换是有时间代价的（保存、恢复运行环境），因此如果时间片太小，会导致进程切换过于频繁，系统会花大量的时间来处理进程切换，从而导致实际用于进程执行的时间比例减少，可见时间片也不能太小\n优点：公平、响应快、适用于分时操作系统\n缺点：由于高频率的进程切换，因此有一定的开销；不区分任务的紧急程度\n不会导致饥饿\n优先级调度随着计算机的发展，特别是实时操作系统的出现，越来越多的应用场景需要根据任务的紧急程度来决定处理顺序\n每个作业&#x2F;进程有各自的优先级，调度时选择优先级最高的作业&#x2F;进程\n既可用于作业调度，也可用于进程调度，甚至还会用于I&#x2F;O调度中\n抢占式、非抢占式都有，非抢占式只需在进程主动放弃处理机时进行调度即可，而抢占式还需在就绪队列变化时，检查是否会发生抢占\n\n优点：用优先级区分紧急程度、重要程度，适用于实时操作系统。可灵活的调整对各种作业&#x2F;进程的偏好程度\n缺点：若源源不断的有高优先级进程到来，则可能导致饥饿\n多级反馈队列\n对其他调度算法的折中权衡\n设置多级就绪队列，各级队列优先级从高到低，时间片从小到大；新进程到达时先进入第1级队列，按FCFS原则排队等待被分配时间片，若用完时间片进程还不结束，则进程进入下一级队列队尾，如果此时已经是在最下级的队列，则重新放回该队列队尾；只有第k级队列为空时，才会为k+1级队头的进程分配时间片\n用于进程调度\n抢占式的算法，在k级队列的进程运行过程中，若更上级的队列（1～k-1级）中进入了一个新进程，则由于新进程处于优先级更高的队列中，因此新进程会抢占处理机，原来运行的进程放回k级队列队尾\n\n\n优点：\n\n对各类型进程相对公平（FCFS的优点）\n每个新到达的进程都可以很快就得到响应（RR的优点）\n短进程只用较少的时间就可完成（SPF的优点）\n不必实现估计进程的运行时间（避免用户作假）\n可灵活的调整对各类进程的偏好程度，比如CPU密集型进程、I&#x2F;O密集型进程（可以将因I&#x2F;O而阻塞的进程重新放回原队列，而不放回下一级队列，这样I&#x2F;O型进程就可以保持较高优先级）\n\n会导致饥饿，如果源源不断的有短进程到达的话，这种进程在第一级队列中就可以被处理完，已经被降级的进程就有可能导致饥饿\n⭐️比起早期的批处理操作系统来说，由于计算机造价大幅降低，因此之后出现的交互式操作系统（包括分时操作系统、实时操作系统等）更注重系统的响应时间、公平性、平衡性等指标。而以上这三种算法恰好也能较好的满足交互式系统的需求。因此这三种算法适合用于交互式系统（比如UNIX使用的就是多级反馈队列调度算法）\n","categories":["计算机理论"],"tags":["操作系统原理-操作系统原理笔记"]},{"title":"调度算法的评价指标","url":"/2020/06/30/%E8%AE%A1%E7%AE%97%E6%9C%BA%E7%90%86%E8%AE%BA/%E6%93%8D%E4%BD%9C%E7%B3%BB%E7%BB%9F%E5%8E%9F%E7%90%86/%E6%93%8D%E4%BD%9C%E7%B3%BB%E7%BB%9F%E5%8E%9F%E7%90%86%E7%AC%94%E8%AE%B0/2.8_%E8%B0%83%E5%BA%A6%E7%AE%97%E6%B3%95%E7%9A%84%E8%AF%84%E4%BB%B7%E6%8C%87%E6%A0%87/","content":"CPU利用率由于早期的CPU造价极其昂贵，因此人们会希望让CPU尽可能多的工作\nCPU利用率：指CPU“忙碌”的时间占总时间的比例\n系统吞吐量对于计算机来说，希望能用尽可能少的时间处理完尽可能多的作业\n系统吞吐量：单位时间内完成作业的数量（总共完成了多少道作业&#x2F;总共花了多少时间）\n周转时间周转时间对于计算机的用户来说，他很关心自己的作业从提交到完成花了多少时间\n周转时间：是指从作业被提交给系统开始，到作业完成为止的这段时间间隔，它包括四个部分，作业在外存后备队列上等待作业调度（高级调度）的时间、进程在就绪队列上等待进程调度（低级调度）的时间、进程在CPU上执行的时间、进程等待I&#x2F;O操作完成的时间。后三项在一个作业的整个处理过程中，可能发生多次\n（作业）周转时间 &#x3D; 作业完成时间 - 作业提交时间（对于用户来说，更关心自己的单个作业的周转时间）\n平均周转时间平均周转时间 &#x3D; 各作业周转时间之和 &#x2F; 作业数（对于操作系统来说，更关心系统的整体表现，因此更关心所有作业周转时间的平均值）\n带权周转时间有的作业运行时间短，有的作业运行时间长，因此在周转时间相同的情况下，运行时间不同的作业，给用户的感觉肯定是不一样的\n带权周转时间 &#x3D; 作业周转时间 &#x2F; 作业实际运行的时间\n带权周转时间必然 &gt;&#x3D; 1，带权周转时间与周转时间都是越小越好\n对于周转时间相同的两个作业，实际运行时间长的作业在相同时间内被服务的时间更多，带权周转时间更小，用户满意度更高\n对于实际运行时间相同的两个作业，周转时间短的带权周转时间更小，用户满意度更高\n平均带权周转时间平均带权周转时间 &#x3D; 各作业带权周转时间之和 &#x2F; 作业数\n等待时间：周转时间 - 运行时间（如果有I&#x2F;O操作的过程，还要减去I&#x2F;O操作的时间）计算机的用户希望自己的作业尽可能少的等待处理机\n等待时间，指进程&#x2F;作业处于等待处理机状态时间之和，等待时间越长，用户满意度越低\n对于进程来说，等待时间就是指进程建立后等待被服务的时间之和，在等待I&#x2F;O完成的期间其实进程也是在被服务的，所以不计入等待时间\n对于作业来说，不仅要考虑建立进程后的等待时间，还要加上作业在外存后备队列中等待的时间\n\n一个作业总共需要被CPU服务多久、被I&#x2F;O设备服务多久一般是确定不变的，因此调度算法其实只会影响作业&#x2F;进程的等待时间\n与前面的指标类似，也有“平均等待时间”来评价整体性能\n响应时间对于计算机用户来说，会希望自己的提交的请求（比如通过键盘输入了一个调试命令）尽早的开始被系统服务、回应\n响应时间，指从用户提交请求到首次产生响应所用的时间\n","categories":["计算机理论"],"tags":["操作系统原理-操作系统原理笔记"]},{"title":"内存管理的概念","url":"/2020/06/30/%E8%AE%A1%E7%AE%97%E6%9C%BA%E7%90%86%E8%AE%BA/%E6%93%8D%E4%BD%9C%E7%B3%BB%E7%BB%9F%E5%8E%9F%E7%90%86/%E6%93%8D%E4%BD%9C%E7%B3%BB%E7%BB%9F%E5%8E%9F%E7%90%86%E7%AC%94%E8%AE%B0/3.2_%E5%86%85%E5%AD%98%E7%AE%A1%E7%90%86%E7%9A%84%E6%A6%82%E5%BF%B5/","content":"操作系统作为系统资源的管理者，当然也需要对内存进行管理\n\n操作系统负责内存空间的分配与回收\n\n\n操作系统要怎么记录哪些内存区域已经被分配出去了，哪些又还空闲？\n内存中很多位置都可以存放，那新来的进程应该放在哪里？\n当进程运行结束之后，如何将进程占用的内存空间回收？\n\n\n\n操作系统需要提供某种技术从逻辑上对内存空间进行扩充（虚拟性）\n\n\n操作系统需要提供地址转换功能，负责程序的逻辑地址与物理地址的转换\n\n为了使编程更方便，程序员写程序时应该只需要关注指令、数据的逻辑地址。而逻辑地址到物理地址的转换（这个过程称为地址重定位）应该由操作系统负责，这样就保证了程序员写程序时不需要关注物理内存的实际情况（三种装入方式）\n\n\n操作系统需要提供内存保护功能，保证各进程在各自存储空间内运行，互不干扰\n\n\n\n\n","categories":["计算机理论"],"tags":["操作系统原理-操作系统原理笔记"]},{"title":"内存空间的分配与回收","url":"/2020/06/30/%E8%AE%A1%E7%AE%97%E6%9C%BA%E7%90%86%E8%AE%BA/%E6%93%8D%E4%BD%9C%E7%B3%BB%E7%BB%9F%E5%8E%9F%E7%90%86/%E6%93%8D%E4%BD%9C%E7%B3%BB%E7%BB%9F%E5%8E%9F%E7%90%86%E7%AC%94%E8%AE%B0/3.3_%E5%86%85%E5%AD%98%E7%A9%BA%E9%97%B4%E7%9A%84%E5%88%86%E9%85%8D%E4%B8%8E%E5%9B%9E%E6%94%B6/","content":"连续分配管理方式连续分配：指为用户进程分配的必须是一个连续的内存空间\n单一连续分配在单一连续分配方式中，内存被分为系统区和用户区。\n系统区通常位于内存的低地址部分，用于存放操作系统相关数据；用户区用于存放用户进程相关数据，内存中只能有一道用户程序，用户程序独占整个用户区空间\n\n优点：实现简单，无外部碎片，可以采用覆盖技术扩充内存，不一定需要采取内存保护（MS-DOS）\n缺点：只能用于单用户、单任务的操作系统中，有内部碎片，存储器利用率极低（分配给某进程的内存区域中，如果有些部分没有用上，就是“内部碎片”）\n固定分区分配\n\n动态分区分配动态分区分配又称为可变分区分配，这种分配方式不会预先划分内存分区，而是在进程装入内存时，根据进程的大小动态的建立分区，并使分区的大小正好适合进程的需要。因此系统分区的大小和数目是可变的\n假设某计算机内存大小为64MB，系统区8MB，用户区共56MB\n\n\n\n系统要用什么样的数据结构记录内存的使用情况？\n\n\n当很多个空闲分区都能满足需求时，应该选择哪个分区进行分配？\n\n\n如何进行分区的分配与回收操作？（假设系统采用的数据结构是“空闲分区表”）\n1）如何分配？\n\n\n2）如何回收？（总之，相邻的空闲分区要合并）\n\n\n\n\n\n\n\n动态分区分配没有内部碎片，但是有外部碎片\n内部碎片：分配给某进程的内存区域中，如果有些部分没有用上\n外部碎片；是指内存中的某些空闲分区由于太小而难以利用\n如果内存中空闲空间的总和本来可以满足某进程的要求，但由于进程需要的是一整块连续的内存空间，因此这些“碎片”不能满足进程的需求。可以通过紧凑（拼凑）技术来解决外部碎片\n\n\n动态分区分配算法在动态分区分配方式中，当很多个空闲分区都能满足需求时，应该选择哪个分区进行分配？\n\n\n首次适应算法（First Fit）\n\n\n最佳适应算法（Best Fit）\n\n\n最坏适应算法（Worst Fit）\n\n\n邻近适应算法（Next Fit）\n\n\n\n⭐️首次适应算法和邻近适应算法比最佳适应算法和最坏适应算法好的一点：不用每次都更新空闲分区链&#x2F;表的排列顺序，减少开销\n❗️综合来看，四种算法中，首次适应算法的效果反而更好\n\n\n非连续分配管理方式非连续分配：为用户进程分配的可以是一些分散的内存空间\n基本分页存储管理什么是分页存储将内存空间分为一个个大小相等的分区，每个分区就是一个“页框”（页框、页帧、内存块、物理块、物理页面），每个页框有一个编号，即“页框号”，页框号从0开始\n将进程的逻辑地址空间也分为与页框大小相等的一个个部分，每个部分称为一个“页”或“页面”。每个页面也有一个编号，即“页号”，页号也是从0开始\n操作系统以页框为单位为各个进程分配内存空间。进程的每个页面分别放入一个页框中。也就是说，进程的页面与内存的页框有一一对应的关系，各个页面不必连续存放，可以放到不相邻的各个页框中\n\n页表为了能知道进程的每个页面在内存中存放的位置，操作系统要为每个进程建立一张页表，页表通常存在PCB（进程控制块）中\n\n\n\n每个页表项多大，占几个字节？\n\n页表项连续存放，因此页号可以是隐含的，不占存储空间（类比数组）\n假设页表中的各页表项从内存地址为X的地方开始连续存放，如何找到页号为i的页表项：X + 3*i\n\n由于页号是隐含的，因此每个页表项占3B，存储整个页表至少需要3*(n+1)B\n注意；页表记录的只是内存块号，而不是内存块的其实地址：J号内存块的起始地址 &#x3D; J * 内存块大小\n\n如何通过页表实现逻辑地址到物理地址的转换？（逻辑地址结构可拆分为页号P和页内偏移量W）\n\n\n\n\n\n\n\n\n\n基本地址变换机构（用于实现逻辑地址到物理地址转换的一组硬件机构）基本地址变换机构可以借助进程的页表将逻辑地址转换为物理地址\n通常会在系统中设置一个页表寄存器PTR，存放页表在内存中的起始地址F和页表长度M。进程未执行时，页表的始址和页表长度放在进程控制块PCB中，当进程被调度时，操作系统内核会把它们放到页表寄存器中\n注意：假设页面大小是2的整数幂，设页面大小为L，逻辑地址A到物理地址E的变换过程如下：\nCPU第一次访问内存：查页表\nCPU第二次访问内存：访问目标内存单元\n\n\n\n对页表项大小的进一步探讨：\n\n具有快表的地址变换机构（是基本地址变换机构的改进版本）什么是快表TLB快表，又称联想寄存器TLB，是一种访问速度比内存快很多的高速缓存，用来存放最近访问的一部分页表项的副本，可以加速地址变换的速度，与此对应，内存中的页表常称为慢表\n❗️TLB不是内存\n❗️TLB和普通Cache的区别：TLB中只有一部分页表项的副本，而普通Cache中可能会有其他各种数据的副本\n\n引入快表后，地址的变换过程刚开始快表是为空的，当访问完慢表后，会把最近使用过的页表项放入快表中，下次若快表命中就不需要再访问内存了：\n\n❗️快表中存放的是页表的一部分副本，因为TLB造价比内存高\n\n\n\n局部性原理\n两级页表单极页表存在什么问题，如何解决？1）页表必须连续存放，因此当页表很大时，需要占用很多个连续的页框\n\n2）根据局部性原理可知：很多时候，进程在一段时间内只需要访问某几个页面就可以正常运行了。因此没必要让整个页表都常驻内存\n第一个问题的解决方法：\n\n两级页表的原理，逻辑地址结构（一级页号、二级页号、页内偏移量）\n\n如何实现地址变换？\n第二个问题的解决方法：可以在需要访问页面时才把页面调入内存（虚拟存储技术），可以在页表项中增加一个标志位，用于表示该页面是否已经调入内存\n\n两级页表问题需要注意的几个细节？\n若采用多级页表机制，则各级页表的大小不能超过一个页面，若两级页表不够，可以分更多级\n\n\n两级页表的访存次数分析（假设没有快表机构）（N级页表访问一个逻辑地址需要N+1次访存）\n\n第一次访存：访问内存中的页目录表\n第二次访存：访问内存中的二级页表\n第三次访存：访问目标内存单元\n\n\n\n基本分段存储管理与“分页”最大的区别就是离散分配时所分配地址空间的基本单位不同\n什么是分段进程的地址空间：按照程序自身的逻辑关系划分为若干个段，每个段都有一个段名（在低级语言中，程序员使用段名来编程），每段从0开始编址\n内存分配规则：以段为单位进行分配，每个段在内存中占据连续空间，但各段之间可以不相邻\n\n\n什么是段表程序分多个段，各段离散的装入内存，为了保证程序能正常运行，就必须能从物理内存中找到各个逻辑段的存放位置。为此，需为每个进程建立一张段映射表，简称“段表”\n\n如何实现地址变换\n\n分段、分页管理的对比\n页是信息的物理单位，分页的主要目的是为了实现离散分配，提高内存利用率。分页仅仅是系统管理上的需要，完全是系统行为，对用户是不可见的\n段是信息的逻辑单位，分段的主要目的是更好的满足用户需求，一个段通常包含着一组属于一个逻辑模块的信息。分段对用户是可见的，用户编程时需要显式的给出段名\n\n页的大小固定且由系统决定，段的长度却不固定，决定于用户编写的程序\n\n分页的用户进程地址空间是一维的，程序员只需给出一个记忆符即可表示一个地址\n分段的用户进程地址空间是二维的，程序员在标识一个地址时，既要给出段名，也要给出段内地址\n\n\n分段比分页更容易实现信息的共享和保护\n不能被修改的代码称为纯代码或可重入代码（不属于临界资源），这样的代码是可以共享的。可修改的代码是不能共享的（比如有一个代码段中有很多变量，各进程并发的同时访问可能造成数据不一致）\n\n\n\n访问一个逻辑地址需要几次访存？\n分页（单级页表）：第一次访存查内存中的页表，第二次访存访问目标内存单元，总共两次访存\n分段：第一次访存查内存中的段表，第二次访存访问目标内存单元，总共两次访存。与分页系统类似，分段系统中也可以引入快表机构，将近期访问过的段表项放到快表中，这样可以少一次访问，加快地址变换速度\n\n\n段页式存储管理分页、分段的优缺点分页管理：\n\n优点：内存空间利用率高，不会产生外部碎片，只会有少量的页内碎片\n缺点：不方便按照逻辑模块实现信息的共享和保护\n\n分段管理：\n\n优点：很方便按照逻辑模块实现信息的共享和保护\n缺点：如果段长过大，为其分配很大的连续空间会很不方便。另外，段式管理会产生外部碎片（分段管理中产生的外部碎片也可以用“紧凑”来解决，只是需要付出较大的时间代价）\n\n分段 + 分页 &#x3D; 段页式管理\n段页式管理的逻辑地址结构\n段表、页表一个进程对应一个段表，一个进程对应多个页表\n\n地址变换\n","categories":["计算机理论"],"tags":["操作系统原理-操作系统原理笔记"]},{"title":"页面分配策略","url":"/2020/06/30/%E8%AE%A1%E7%AE%97%E6%9C%BA%E7%90%86%E8%AE%BA/%E6%93%8D%E4%BD%9C%E7%B3%BB%E7%BB%9F%E5%8E%9F%E7%90%86/%E6%93%8D%E4%BD%9C%E7%B3%BB%E7%BB%9F%E5%8E%9F%E7%90%86%E7%AC%94%E8%AE%B0/3.5_%E9%A1%B5%E9%9D%A2%E5%88%86%E9%85%8D%E7%AD%96%E7%95%A5/","content":"驻留集驻留集：指请求分页存储管理中给进程分配的物理块（内存块）的集合，在采用了虚拟存储技术的系统中，驻留集大小一般小于进程的总大小\n假设某进程共有100个页面，则该进程的驻留集大小为100时进程可以全部放入内存，运行期间不可能再发生缺页。若驻留集大小为1，则进程运行期间必定会极频繁的缺页\n若驻留集太小，会导致缺页频繁，系统要花大量的时间来处理缺页，实际用于进程推进的时间很少\n若驻留集太大，又会导致多道程序并发度下降，资源利用率降低。所以应该选择一个合适的驻留集大小\n页面分配、置换策略固定分配：操作系统为每个进程分配一组固定数目的物理块，在进程运行期间不再改变，即驻留集大小不变\n可变分配：先为每个进程分配一定数目的物理块，在进程运行期间，可根据情况做适当的增加或减少，即驻留集大小可变\n局部置换：发生缺页时只能选进程自己的物理块进行置换\n全局置换：可以将操作系统保留的空闲物理块分配给缺页进程，也可以将别的进程持有的物理块置换到外存，再分配给缺页进程\n⭐️没有固定分配的全局置换：全局置换意味着一个进程拥有的物理块数量必然会改变，因此不可能是固定分配\n固定分配局部置换\n可变分配全局置换系统会锁定一些页面，这些页面中的内容不能置换出外存（如重要的内核数据可以设为“锁定”）\n\n可变分配局部置换（该策略最好）\n可变分配全局置换：只要缺页就给分配新物理块\n可变分配局部置换：要根据发生缺页的频率来动态的增加或减少进程的物理块\n何时调入页面\n从何处调入页面\n系统拥有足够的对换区空间：页面的调入、调出都是在内存与对换区之间进行，这样可以保证页面的调入、调出速度很快。在进程运行前，需将进程相关的数据从文件区复制到对换区\n\n\n系统缺少足够的对换区空间：凡是不会被修改的数据都直接从文件区调入，由于这些页面不会被修改，因此换出时不必写回磁盘，下次需要时再从文件区调入即可。对于可能被修改的部分，换出时需写回磁盘对换区，下次需要时再从对换区调入\n\n\nUNIX方式：运行之前进程有关的数据全部放在文件区，故未使用过的页面，都可从文件区调入。若被使用过的页面需要换出，则写回对换区，下次需要时从对换区调入\n\n\n\n抖动（颠簸）现象\n工作集根据工作集来分配驻留集：\n\n","categories":["计算机理论"],"tags":["操作系统原理-操作系统原理笔记"]},{"title":"内存空间的扩充","url":"/2020/06/30/%E8%AE%A1%E7%AE%97%E6%9C%BA%E7%90%86%E8%AE%BA/%E6%93%8D%E4%BD%9C%E7%B3%BB%E7%BB%9F%E5%8E%9F%E7%90%86/%E6%93%8D%E4%BD%9C%E7%B3%BB%E7%BB%9F%E5%8E%9F%E7%90%86%E7%AC%94%E8%AE%B0/3.4_%E5%86%85%E5%AD%98%E7%A9%BA%E9%97%B4%E7%9A%84%E6%89%A9%E5%85%85/","content":"内存空间的扩充在传统存储管理方式的基础上引入了交换技术、覆盖技术，使得内存利用率有所提升，并且能从逻辑上扩充内存容量\n覆盖技术早期的计算机内存很小，比如IBM推出的第一台PC机最大只支持1MB大小的内存。因此经常会出现内存大小不够的情况\n后来人们引入了覆盖技术，用来解决“程序大小超过物理内存总和”的问题\n\n覆盖技术的思想：将程序分为多个段（多个模块），常用的段常驻内存，不常用的段在需要时调入内存\n内存中分为一个“固定区”和若干个“覆盖区”\n需要常驻内存的段放在“固定区”中，调入后就不再调出（除非运行结束）\n不常用的段放在“覆盖区”，需要用到时调入内存，用不到时调出内存\n\n\n交换技术交换（对换）技术的设计思想：内存空间紧张时，系统将内存中某些进程暂时换出外存，把外存中某些已具备运行条件的进程换入内存（进程在内存与磁盘间动态调度）\n虽然不常用的进程被调出内存了，但是该进程的PCB还在内存中保存着：\n\n\n\n\n应该在外存（磁盘）的什么位置保存被换出的进程？\n什么时候应该交换？\n应该换出哪些进程？\n\n\n\n覆盖与交换的区别：\n\n覆盖是在同一程序或进程中的\n交换是在不同进程（或作业）之间的\n\n虚拟存储技术传统存储管理方式的特征、缺点\n局部性原理时间局部性：现在访问的指令、数据在不久后很可能会被再次访问\n空间局部性：现在访问的内存单元周围的内存空间，很可能在不久后会被访问\n高速缓存技术：使用频繁的数据放到更高速的存储器中\n虚拟内存的定义和特征\n虚拟内存的三个主要特征：\n\n多次性：无需在作业运行时一次性全部装入内存，而是允许被分成多次调入内存\n对换性：在作业运行时无需一直常驻内存，而是允许在作业运行过程中，将作业换入、换出\n虚拟性：从逻辑上扩充了内存的容量，使用户看到的内存容量，远大于实际的容量\n\n如何实现虚拟内存技术虚拟内存技术，允许一个作业分多次调入内存，如果采用连续分配方式，会不方便实现。因此虚拟内存的实现需要建立在离散分配的内存管理方式基础上\n\n请求分页管理方式页表机制\n缺页中断机构如果内存中有空闲块：修改内存号为a，状态位为1\n\n如果内存中没有空闲块：将c换出内存，将x号块放进c号块\n\n缺页中断是因为当前执行的指令想要访问的目标页面未调入内存而产生的，因此属于内中断\n\n一条指令在执行期间，可能产生多次缺页中断：将逻辑地址A中的数据复制到逻辑地址B，而A、B属于不同的页面，则有可能产生两次中断\n地址变换机构\n\n在具有快表机构的请求分页系统中，访问一个逻辑地址时，若发生缺页，则地址变换步骤是\n\n查快表（未命中）\n查慢表（发现未调入内存）\n调页（调入的页面对应的表项不仅会加入慢表，也会加入快表中）\n查快表（命中）\n访问目标内存单元\n\n\n页面置换算法页面的换入、换出需要磁盘I&#x2F;O，会有较大的开销，因此好的页面置换算法应该追求更少的缺页率\n最佳置换算法OPT（性能最好）每次选择淘汰的页面将是以后永不使用，或者在最长时间内不再被访问的页面，这样可以保证最低的缺页率\n\n最佳置换算法可以保证最低的缺页率，但实际上，只有在进程执行的过程中才能知道接下来会访问到的是哪个页面。操作系统无法提前预判页面访问序列。因此，最佳置换算法是无法实现的\n先进先出置换算法FIFO每次选择淘汰的页面是最早进入内存的页面\n\n\n最近最久未使用置换算法LRU该算法性能最接近最佳置换算法：\n\n时钟置换算法CLOCK（NRU）\n实现简单，算法开销小，但未考虑页面是否被修改过\n改进型的时钟置换算法NRU第一优先级：最近没访问，且没修改的页面\n第二优先级：最近没访问，但修改过的页面\n第三优先级：最近访问过，但没修改的页面\n第四优先级：最近访问过，且修改过的页面\n\n算法开销较小，性能也不错\n","categories":["计算机理论"],"tags":["操作系统原理-操作系统原理笔记"]},{"title":"初识文件管理","url":"/2020/06/30/%E8%AE%A1%E7%AE%97%E6%9C%BA%E7%90%86%E8%AE%BA/%E6%93%8D%E4%BD%9C%E7%B3%BB%E7%BB%9F%E5%8E%9F%E7%90%86/%E6%93%8D%E4%BD%9C%E7%B3%BB%E7%BB%9F%E5%8E%9F%E7%90%86%E7%AC%94%E8%AE%B0/4.1_%E5%88%9D%E8%AF%86%E6%96%87%E4%BB%B6%E7%AE%A1%E7%90%86/","content":"文件就是一组有意义的信息&#x2F;数据集合\n\n\n计算机中存放了各种各样的文件，一个文件有哪些属性？\n\n文件名：由创建文件的用户决定文件名，主要是为了方便用户找到文件，同一目录下不允许有重名文件\n标识符：一个系统内的各文件标识符唯一，对用户来说毫无可读性，因此标识符只是操作系统用于区分各个文件的一种内部名称\n类型：指明文件的类型\n位置：文件存放的路径（让用户使用）、在外存中的地址（操作系统使用，对用户不可见）\n大小：指明文件大小\n创建时间、上次修改时间\n文件所有者信息\n保护信息：对文件进行保护的访问控制信息\n\n\n文件内部的数据应该怎样组织起来？（文件的逻辑结构）\n\n无结构文件：如文本文件，由一些二进制或字符流组成，又称“流式文件”\n\n有结构文件：如数据库表，由一组相似的记录组成，又称“记录式文件”，记录是一组相关数据项的集合，数据项是文件系统中最基本的数据单位\n\n\n\n\n文件之间又应该怎么组织起来？\n\n\n从下往上看，OS应提供哪些功能，才能方便用户、应用程序使用文件？\n\n可以创建文件：点击新建后，图形化交互进程在背后调用了“create系统调用”\n可以删除文件：点了删除之后，图形化交互进程通过操作系统提供的删除文件功能，即delete系统调用，将文件数据从外存中删除\n可以读文件：将文件数据读入内存，才能让CPU处理，双击后，记事本应用程序通过操作系统提供的读文件功能，即read系统调用，将文件数据从外存读入内存，并显示在屏幕上\n可以写文件：将更改过的文件数据写回外存，我们在记事本应用程序中编辑文件内容，点击保存后，记事本应用程序通过操作系统提供的写文件功能，即write系统调用，将文件数据从内存写回外存\n打开文件：open系统调用\n关闭文件：close系统调用\n\n❗️读&#x2F;写文件之前，需要“打开文件”，读&#x2F;写文件结束之后，需要“关闭文件”\n可用几个基本操作完成更复杂的操作，比如复制文件，先创建一个新的空文件，再把源文件读入内存，再将内存中的数据写到新文件中\n\n从上往下看，文件数据应该怎么存放在外存（磁盘）上？（文件的物理结构）\n\n\n操作系统又应该怎么管理空闲磁盘块？\n\n其他需要由操作系统实现的文件管理功能\n\n文件共享：使多个用户可以共享使用一个文件\n文件保护：如何保证不同的用户对文件有不同的操作权限\n\n\n\n\n","categories":["计算机理论"],"tags":["操作系统原理-操作系统原理笔记"]},{"title":"进程的状态与转换","url":"/2020/06/30/%E8%AE%A1%E7%AE%97%E6%9C%BA%E7%90%86%E8%AE%BA/%E6%93%8D%E4%BD%9C%E7%B3%BB%E7%BB%9F%E5%8E%9F%E7%90%86/%E6%93%8D%E4%BD%9C%E7%B3%BB%E7%BB%9F%E5%8E%9F%E7%90%86%E7%AC%94%E8%AE%B0/2.2_%E8%BF%9B%E7%A8%8B%E7%9A%84%E7%8A%B6%E6%80%81%E4%B8%8E%E8%BD%AC%E6%8D%A2/","content":"进程的状态创建状态：进程正在被创建时，它的状态是“创建态”，在这个阶段操作系统会为进程分配资源、初始化PCB\n就绪状态：当进程创建完成后，便进入了“就绪态”，处于就绪态的进程已经具备运行条件，但由于没有空闲CPU，就暂时不能运行\n运行状态：如果一个进程此时在CPU上运行，那么这个进程处于“运行态”，CPU会执行该进程对应的程序（执行指令序列）\n阻塞状态（等待态）：在进程运行过程中，可能会请求等待某个事件的发生（如等待某种系统资源的分配，或者等待其他进程的响应），在这个事件发生之前，进程无法继续往下执行，此时操作系统会让这个进程下CPU，并让它进入“阻塞态”，如果等待的某个事件发生了，进程就会由“阻塞态”变为“就绪态”，当CPU空闲时，会选择一个“就绪态”进程上CPU运行\n终止状态：一个进程可以执行exit系统调用，请求操作系统终止该进程，此时该进程会进入“终止态”，操作系统会让该进程下CPU，并回收内存空间等资源，最后还要回收该进程的PCB，当终止进程的工作完成之后，这个进程就彻底消失了（进程运行结束，或运行过程中遇到不可修复的错误）\n状态间的转换就绪态 -&gt; 运行态\n运行态 -&gt; 就绪态（时间片到，或处理机被抢占）\n运行态 -&gt; 阻塞态\n阻塞态 -&gt; 就绪态\n\n注意：不能由阻塞态直接转换为运行态，也不能由就绪态直接转换为阻塞态，因为进入阻塞态是进程主动请求的，必然需要进程在运行时才能发出这种请求\n三种基本状态：就绪态、运行态、阻塞态，进程的整个生命周期中大部分时间都处于三种基本状态\n单核CPU情况下，同一时刻只会有一个进程处于运行态，多核CPU情况下，可能有多个进程处于运行态\n进程PCB中，会有一个变量state来表示进程的当前状态：如1表示创建态、2表示就绪态、3表示运行态…为了对同一状态下的各个进程进行统一的管理，操作系统会将各个进程的PCB组织起来\n进程的组织方式（各个进程PCB的组织方式）链接方式很多操作系统还会根据阻塞原因不同，再分为多个阻塞队列\n\n索引方式\n","categories":["计算机理论"],"tags":["操作系统原理-操作系统原理笔记"]},{"title":"文件的逻辑结构","url":"/2020/06/30/%E8%AE%A1%E7%AE%97%E6%9C%BA%E7%90%86%E8%AE%BA/%E6%93%8D%E4%BD%9C%E7%B3%BB%E7%BB%9F%E5%8E%9F%E7%90%86/%E6%93%8D%E4%BD%9C%E7%B3%BB%E7%BB%9F%E5%8E%9F%E7%90%86%E7%AC%94%E8%AE%B0/4.2_%E6%96%87%E4%BB%B6%E7%9A%84%E9%80%BB%E8%BE%91%E7%BB%93%E6%9E%84/","content":"所谓的“逻辑结构”，就是指在用户看来，文件内部的数据应该是如何组织起来的。而“物理结构”指的是在操作系统看来，文件的数据是如何存放在外存中的（类比于数据结构中的“逻辑结构”、“物理结构”）\n无结构文件文件内部的数据就是一系列二进制流或字符流组成，又称“流式文件”\n文件内部的数据其实就是一系列字符流，没有明显的结构特性。因此也不用探讨无结构文件的“逻辑结构”问题\n有结构文件由一组相似的记录组成，又称“记录式文件”，每条记录由若干个数据项组成，一般来说，每条记录有一个数据项可作为关键字（作为识别不同记录的ID）\n根据各条记录的长度（占用的存储空间）是否相等，又可分为定长记录和可变长记录两种\n\n\n根据有结构文件中的各条记录在逻辑上如何组织，可以分为三类：\n顺序文件文件中的记录一个接一个的顺序排列（逻辑上），记录可以是定长的或可变长的。各个记录在物理上可以是顺序存储或链式存储\n\n\n串结构：记录之间的顺序与关键字无关，通常按照记录存入的时间决定记录的顺序\n顺序结构：记录之间的顺序按关键字顺序排列\n\n\n假设已经知道了文件的起始地址，也就是第一个记录存放的位置\n\n能否快速找到第i个记录对应的地址？（即能否实现随机存取）\n\n能否快速找到某个关键字对应的记录存放的位置？\n\n顺序文件的缺点是增加&#x2F;删除一个记录比较困难，如果是串结构则相对简单\n\n\n\n索引文件对于可变长记录文件，要找到第i个记录，必须先顺序的查找前i-1个记录，但是很多应用场景中又必须使用可变长记录，如何解决这个问题？\n\n解决了顺序文件不方便增&#x2F;删记录的问题，同时让不定长记录的文件实现了随机存取，但索引表可能占用很多空间\n索引顺序文件（多级索引顺序文件）索引文件的缺点：每个记录对应一个索引表项，因此索引表可能会很大，比如文件的每个记录平均只占8B，而每个索引表项占32个字节，那么索引表都要比文件内容本身大4倍，这样对存储空间的利用率就太低了\n\n\n\n","categories":["计算机理论"],"tags":["操作系统原理-操作系统原理笔记"]},{"title":"文件的物理结构(文件分配方式)","url":"/2020/06/30/%E8%AE%A1%E7%AE%97%E6%9C%BA%E7%90%86%E8%AE%BA/%E6%93%8D%E4%BD%9C%E7%B3%BB%E7%BB%9F%E5%8E%9F%E7%90%86/%E6%93%8D%E4%BD%9C%E7%B3%BB%E7%BB%9F%E5%8E%9F%E7%90%86%E7%AC%94%E8%AE%B0/4.4_%E6%96%87%E4%BB%B6%E7%9A%84%E7%89%A9%E7%90%86%E7%BB%93%E6%9E%84(%E6%96%87%E4%BB%B6%E5%88%86%E9%85%8D%E6%96%B9%E5%BC%8F)/","content":"操作系统需要对磁盘块进行哪些管理：\n\n对非空闲磁盘块的管理（存放了文件数据的磁盘块）：“文件的物理结构&#x2F;文件分配方式要探讨的问题”\n对空闲磁盘块的管理：“文件存储空间管理要探讨的问题”\n\n类似于内存分页，磁盘中的存储单元也会被分为一个个“块&#x2F;磁盘块&#x2F;物理块”，很多操作系统中，磁盘块的大小与内存块、页面的大小相同\n\n\n连续分配\n连续分配的优点：\n\n连续分配支持顺序访问和直接访问（即随机访问）\n\n读取某个磁盘块时，需要移动磁头，访问的两个磁盘块相隔越远，移动磁头所需时间就越长，连续分配的文件在顺序读&#x2F;写时速度最快\n\n\n\n连续分配的缺点：\n\n\n\n\n链接分配链接分配采取离散分配的方式，可以为文件分配离散的磁盘块，分为隐式链接和显式链接两种\n隐式链接\n是否方便拓展文件：若此时要拓展文件，则可以随便找一个空闲磁盘块，挂到文件的磁盘块链尾，并修改文件的的FCB\n结论：采用隐式链接的链接分配方式，很方便文件拓展，另外，所有的空闲磁盘块都可以被利用，不会有碎片问题，外存利用率高\n显式链接\n\n缺点：文件分配表需要占用一定的存储空间\n索引分配\n\n\n链接方案\n多层索引\n采用K层索引结构，且顶级索引表未调入内存，则访问一个数据块只需要K+1次读磁盘操作\n缺点：即使是小文件，访问一个数据块依然需要K+1次读磁盘\n混合索引\n优点：对于小文件来说，访问一个数据块所需的读磁盘次数更少\n总结：\n\n","categories":["计算机理论"],"tags":["操作系统原理-操作系统原理笔记"]},{"title":"文件的基本操作","url":"/2020/06/30/%E8%AE%A1%E7%AE%97%E6%9C%BA%E7%90%86%E8%AE%BA/%E6%93%8D%E4%BD%9C%E7%B3%BB%E7%BB%9F%E5%8E%9F%E7%90%86/%E6%93%8D%E4%BD%9C%E7%B3%BB%E7%BB%9F%E5%8E%9F%E7%90%86%E7%AC%94%E8%AE%B0/4.6_%E6%96%87%E4%BB%B6%E7%9A%84%E5%9F%BA%E6%9C%AC%E6%93%8D%E4%BD%9C/","content":"向上提供的几个最基本的功能：\n\n创建文件（create系统调用）：可以创建文件，点击新建后，图形化交互进程在背后调用了create系统调用\n\n\n删除文件（delete系统调用）：可以删除文件，点了删除之后，图形化交互进程通过操作系统提供的删除文件功能，即delete系统调用，将文件数据从外存中删除\n\n\n打开文件（open系统调用）\n❗️打开文件时并不会把文件数据直接读入内存，只是将目录项中的信息复制到内存中的打开文件表中，并将打开文件表的索引号返回给用户\n索引号也称“文件描述符”\n\n每个进程有自己的打开文件表，系统中也有一张总的打开文件表：\n\n\n关闭文件（close系统调用）\n\n\n读文件（read系统调用）：可以读文件，将文件数据读入内存，才能让CPU处理，双击后，记事本应用程序通过操作系统提供的读文件功能，即read系统调用，将文件数据从外存读入内存，并显示在屏幕上\n❗️读&#x2F;写文件用文件描述符即可指明文件，不再需要用到“文件名”\n\n\n写文件（write系统调用）：可以写文件，将更改过的文件数据写回外存，，我们在记事本应用程序中编辑文件内容，点击保存后，记事本应用程序通过操作系统提供的写文件功能，即write系统调用，将文件数据从内存写回外存\n\n\n\n","categories":["计算机理论"],"tags":["操作系统原理-操作系统原理笔记"]},{"title":"文件共享","url":"/2020/06/30/%E8%AE%A1%E7%AE%97%E6%9C%BA%E7%90%86%E8%AE%BA/%E6%93%8D%E4%BD%9C%E7%B3%BB%E7%BB%9F%E5%8E%9F%E7%90%86/%E6%93%8D%E4%BD%9C%E7%B3%BB%E7%BB%9F%E5%8E%9F%E7%90%86%E7%AC%94%E8%AE%B0/4.7_%E6%96%87%E4%BB%B6%E5%85%B1%E4%BA%AB/","content":"操作系统为用户提供文件共享功能，可以让多个用户共享的使用同一个文件\n多个用户共享同一个文件，意味着系统中只有一份文件数据，并且只要某个用户修改了该文件的数据，其他用户也可以看到文件数据的变化\n如果是多个用户都复制了同一个文件，那么系统中会有好几份文件数据，其中一个用户修改了自己的那份文件数据，对其他用户的文件数据并没有影响\n基于索引结点的共享方式（硬链接）各个用户的目录项指向同一个索引结点：\n\n若count &gt; 0，说明还有别的用户要使用该文件，暂时不能把文件数据删除，否则会导致指针悬空\n当count &#x3D; 0时，系统负责删除文件\n基于符号链的共享方式（软链接、符号链接）\n即使软链接指向的共享文件已被删除，Link型文件依然存在，只是通过Link型文件中的路径去查找共享文件会失败（找不到对应目录项）\n由于用软链接的方式访问共享文件时要查询多级目录，会有多次磁盘I&#x2F;O，因此用软链接访问共享文件的速度要比硬链接更慢\n","categories":["计算机理论"],"tags":["操作系统原理-操作系统原理笔记"]},{"title":"文件系统的层次结构","url":"/2020/06/30/%E8%AE%A1%E7%AE%97%E6%9C%BA%E7%90%86%E8%AE%BA/%E6%93%8D%E4%BD%9C%E7%B3%BB%E7%BB%9F%E5%8E%9F%E7%90%86/%E6%93%8D%E4%BD%9C%E7%B3%BB%E7%BB%9F%E5%8E%9F%E7%90%86%E7%AC%94%E8%AE%B0/4.9_%E6%96%87%E4%BB%B6%E7%B3%BB%E7%BB%9F%E7%9A%84%E5%B1%82%E6%AC%A1%E7%BB%93%E6%9E%84/","content":"\n","categories":["计算机理论"],"tags":["操作系统原理-操作系统原理笔记"]},{"title":"文件保护","url":"/2020/06/30/%E8%AE%A1%E7%AE%97%E6%9C%BA%E7%90%86%E8%AE%BA/%E6%93%8D%E4%BD%9C%E7%B3%BB%E7%BB%9F%E5%8E%9F%E7%90%86/%E6%93%8D%E4%BD%9C%E7%B3%BB%E7%BB%9F%E5%8E%9F%E7%90%86%E7%AC%94%E8%AE%B0/4.8_%E6%96%87%E4%BB%B6%E4%BF%9D%E6%8A%A4/","content":"操作系统需要保护文件数据的安全\n口令保护\n加密保护\n优点：保密性强，不需要在系统中存储密码\n缺点：编码&#x2F;译码，或者说加密&#x2F;解密要花费一定时间\n访问控制\n\n实现灵活，可以实现复杂的文件保护功能\n如果对某个目录进行了访问权限的控制，那也要对目录下的所有文件进行相同的访问权限控制\n","categories":["计算机理论"],"tags":["操作系统原理-操作系统原理笔记"]},{"title":"文件目录","url":"/2020/06/30/%E8%AE%A1%E7%AE%97%E6%9C%BA%E7%90%86%E8%AE%BA/%E6%93%8D%E4%BD%9C%E7%B3%BB%E7%BB%9F%E5%8E%9F%E7%90%86/%E6%93%8D%E4%BD%9C%E7%B3%BB%E7%BB%9F%E5%8E%9F%E7%90%86%E7%AC%94%E8%AE%B0/4.3_%E6%96%87%E4%BB%B6%E7%9B%AE%E5%BD%95/","content":"\n文件之间的组织结构清晰，易于查找\n编程时也可以很方便的用文件路径找到一个文件，用户可以轻松实现“按名存取”\n\n从操作系统的角度来看，这些目录结构应该是如何实现的？\n文件控制块（实现文件目录的关键数据结构）\n\nFCB实现了文件名和文件之间的映射，使用户（用户程序）可以实现“按名存取”\n需要对目录进行哪些操作：\n\n搜索：当用户要使用一个文件时，系统要根据文件名搜索目录，找到该文件对应的目录项\n创建文件：创建一个新文件时，需要在其所属的目录中增加一个目录项\n删除文件：当删除一个文件时，需要在目录中删除相应的目录项\n显示目录：用户可以请求显示目录的内容，如显示该目录中的所有文件及相应属性\n修改目录：某些文件属性保存在目录中，因此这些属性变化时需要修改相应的目录项（如文件重命名）\n\n目录结构单级目录结构早期操作系统并不支持多级目录，整个系统中只建立一张目录表，每个文件占一个目录项\n\n两级目录结构\n多级目录结构（树形目录结构）\n\n树形目录结构可以很方便的对文件进行分类，层次结构清晰，也能够更有效的进行文件的管理和保护。但是，树形结构不便于实现文件的共享。为此，提出了“无环图目录结构”\n无环图目录结构\n❗️只有共享计数器减为0时，才删除结点\n❗️共享文件不同于复制文件，在共享文件中，由于各用户指向的是同一个文件，因此只要其中一个用户修改了文件数据，那么所有用户都可以看到文件数据的变化\n索引结点（对文件控制块的优化）\n由于目录项长度减小，因此每个磁盘块可以存放更多个目录项，因此检索文件时磁盘I&#x2F;O的次数就少了很多\n当找到文件名对应的目录项时，才需要将索引结点调入内存，索引结点中记录了文件的各种信息，包括文件在外存中的存放位置，根据“存放位置”即可找到文件\n存放在外存中的索引结点称为“磁盘索引结点”，当索引结点放入内存后称为“内存索引结点”，相比之下内存索引结点中需要增加一些信息，比如文件是否被修改、此时有几个进程正在访问该文件等\n","categories":["计算机理论"],"tags":["操作系统原理-操作系统原理笔记"]},{"title":"设备的分配与回收","url":"/2020/06/30/%E8%AE%A1%E7%AE%97%E6%9C%BA%E7%90%86%E8%AE%BA/%E6%93%8D%E4%BD%9C%E7%B3%BB%E7%BB%9F%E5%8E%9F%E7%90%86/%E6%93%8D%E4%BD%9C%E7%B3%BB%E7%BB%9F%E5%8E%9F%E7%90%86%E7%AC%94%E8%AE%B0/5.10_%E8%AE%BE%E5%A4%87%E7%9A%84%E5%88%86%E9%85%8D%E4%B8%8E%E5%9B%9E%E6%94%B6/","content":"设备分配时应考虑的因素\n设备的固有属性\n\n独占设备：一个时段只能分配给一个进程（打印机）\n共享设备：可同时分配给多个进程使用（磁盘），各个进程往往是宏观上同时共享使用设备，而微观上交替使用\n虚拟设备：采用SPOOLing技术将独占设备改造成虚拟的共享设备，可同时分配给多个进程使用（共享打印机）\n\n\n设备分配算法：先来先服务、优先级高者优先、短任务优先。。\n\n设备分配中的安全性\n\n\n\n静态分配与动态分配静态分配：进程运行前为其分配全部所需资源，运行结束后归还资源（破坏了“请求和保持”条件，不会发生死锁）\n动态分配：进程运行过程中动态申请设备资源\n设备分配管理中的数据结构设备、控制器、通道之间的关系：一个通道可控制多个设备控制器，每个设备控制器可控制多个设备\n\n设备控制表DCT：系统为每个设备配置一张DCT，用于记录设备情况\n\n控制器控制表COCT：每个设备控制器都会对应一张COCT，操作系统根据COCT的信息对控制器进行操作和管理\n\n通道控制表CHCT：每个通道都会对应一张CHCT，操作系统根据CHCT的信息对通道进行操作和管理\n\n系统设备表SDT：记录了系统中全部设备的情况，每个设备对应一个表目\n\n设备分配的步骤\n只有设备、控制器、通道三者都分配成功时，这次设备分配才算成功，之后便可启动I&#x2F;O设备进行数据传送\n设备分配步骤的改进方法\n改进方法：建立逻辑设备名与物理设备名的映射机制，用户编程时只需提供逻辑设备名\n\n\n","categories":["计算机理论"],"tags":["操作系统原理-操作系统原理笔记"]},{"title":"缓冲区管理","url":"/2020/06/30/%E8%AE%A1%E7%AE%97%E6%9C%BA%E7%90%86%E8%AE%BA/%E6%93%8D%E4%BD%9C%E7%B3%BB%E7%BB%9F%E5%8E%9F%E7%90%86/%E6%93%8D%E4%BD%9C%E7%B3%BB%E7%BB%9F%E5%8E%9F%E7%90%86%E7%AC%94%E8%AE%B0/5.11_%E7%BC%93%E5%86%B2%E5%8C%BA%E7%AE%A1%E7%90%86/","content":"什么是缓冲区？有什么作用？缓冲区是一个存储区域，可以由专门的硬件寄存器组成，也可利用内存作为缓冲区\n使用硬件作为缓冲区的成本较高，容量也较小，一般仅用在对速度要求非常高的场合（如存储器管理中所用的联想寄存器，由于对页表的访问频率极高，因此使用速度很快的联想寄存器来存放页表项的副本）\n一般情况下，更多的是利用内存作为缓冲区，“设备独立性软件”的缓冲区管理就是要组织管理好这些缓冲区\n缓冲区的作用：（内存作为缓冲区）\n\n缓和CPU与I&#x2F;O设备之间速度不匹配的矛盾\n\n减少对CPU的中断频率，放宽对CPU中断相应时间的限制\n\n解决数据粒度不匹配的问题：如输出进程每次可以生成一块数据，但I&#x2F;O设备每次只能输出一个字符\n\n提高CPU与I&#x2F;O设备之间的并行性\n\n\n\n单缓冲\n\n\n双缓冲\n\n使用单&#x2F;双缓冲在通信时的区别：\n两台机器之间通信时，可以配置缓冲区用于数据的发送和接收，若两个相互通信的机器只设置单缓冲区，在任一时刻只能实现数据的单向传输，若两个相互通信的机器设置双缓冲区，则同一时刻可以实现双向的数据传输\n\n\n管道通信中的“管道”其实就是缓冲区，要实现数据的双向传输，必须设置两个管道\n循环缓冲将多个大小相等的缓冲区链接成一个循环队列\n\n缓冲池\n\n输入进程请求输入数据：从空缓冲队列中取出一块作为收容输入数据的工作缓冲区，充满数据后将缓冲区挂到输入队列队尾\n计算进程想要取得一块输入数据：从输入队列中取得一块充满输入数据的缓冲区作为“提取输入数据的工作缓冲区”，缓冲区读空后挂到空缓冲区队列\n计算进程想要将准备好的数据冲入缓冲区：从空缓冲队列中取出一块作为“收容输出数据的工作缓冲区”，数据充满后将缓冲区挂到输出队列队尾\n输出进程请求输出数据：从输出队列中取得一块充满输出数据的缓冲区作为“提取输出数据的工作缓冲区”，缓冲区读空后挂到空缓冲区队列\n\n","categories":["计算机理论"],"tags":["操作系统原理-操作系统原理笔记"]},{"title":"磁盘的结构","url":"/2020/06/30/%E8%AE%A1%E7%AE%97%E6%9C%BA%E7%90%86%E8%AE%BA/%E6%93%8D%E4%BD%9C%E7%B3%BB%E7%BB%9F%E5%8E%9F%E7%90%86/%E6%93%8D%E4%BD%9C%E7%B3%BB%E7%BB%9F%E5%8E%9F%E7%90%86%E7%AC%94%E8%AE%B0/5.1_%E7%A3%81%E7%9B%98%E7%9A%84%E7%BB%93%E6%9E%84/","content":"磁盘、磁道、扇区的概念磁盘的表面由一些磁性物质组成，可以用这些磁性物质来记录二进制数据\n磁盘的盘面被划分成一个个磁道，这样的一个圈就是一个磁道\n\n如何在磁盘中读&#x2F;写数据需要把“磁头”移动到想要读&#x2F;写的扇区所在的磁道，磁盘会转起来，让目标扇区从磁头下面划过，才能完成对扇区的读&#x2F;写操作\n盘面、柱面的概念\n磁盘的物理地址可用（柱面号，盘面号，扇区号）来定位任意一个磁盘块，在文件的物理结构中，我们经常提到文件数据存放在外存中的几号块，这个块号就可以转换成（柱面号，盘面号，扇区号）的地址形式\n可根据该地址读取一个块：\n\n根据柱面号移动磁臂，让磁头指向指定柱面\n激活指定盘面对应的磁头\n磁盘旋转的过程中，指定的扇区会从磁头下面划过，这样就完成了对指定扇区的读&#x2F;写\n\n磁盘的分类磁头可以移动的称为活动头磁盘。磁臂可以来回伸缩来带动磁头定位磁道，每个盘面只有一个磁头\n\n磁头不可移动的称为固定头磁盘，这种磁盘中每个磁道有一个磁头\n\n盘片可以更换的称为可换盘磁盘，盘片不可更换的称为固定盘磁盘\n","categories":["计算机理论"],"tags":["操作系统原理-操作系统原理笔记"]},{"title":"磁盘调度算法","url":"/2020/06/30/%E8%AE%A1%E7%AE%97%E6%9C%BA%E7%90%86%E8%AE%BA/%E6%93%8D%E4%BD%9C%E7%B3%BB%E7%BB%9F%E5%8E%9F%E7%90%86/%E6%93%8D%E4%BD%9C%E7%B3%BB%E7%BB%9F%E5%8E%9F%E7%90%86%E7%AC%94%E8%AE%B0/5.2_%E7%A3%81%E7%9B%98%E8%B0%83%E5%BA%A6%E7%AE%97%E6%B3%95/","content":"一次磁盘读&#x2F;写操作需要的时间寻找时间：（磁盘调度算法影响的指标）\n\n\n\n延迟时间：\n\n\n\n传输时间：\n\n\n\n\n延迟时间和传输时间都与磁盘转速相关，且为线性相关。而转速是硬件的固有属性，因此操作系统也无法优化延迟时间和传输时间\n但是操作系统的磁盘调度算法会直接影响寻道时间\n磁盘调度算法先来先服务FCFS根据进程请求访问磁盘的先后顺序进行调度\n\n最短寻找时间优先SSTF\n扫描算法SCAN\nLOOK调度算法（解决SCAN算法的第一个缺点）\n循环扫描算法C-SCAN（解决SCAN算法的第二个缺点）\nC-LOOK调度算法（解决C-SCAN算法的缺点）\n","categories":["计算机理论"],"tags":["操作系统原理-操作系统原理笔记"]},{"title":"减少延迟时间的方法","url":"/2020/06/30/%E8%AE%A1%E7%AE%97%E6%9C%BA%E7%90%86%E8%AE%BA/%E6%93%8D%E4%BD%9C%E7%B3%BB%E7%BB%9F%E5%8E%9F%E7%90%86/%E6%93%8D%E4%BD%9C%E7%B3%BB%E7%BB%9F%E5%8E%9F%E7%90%86%E7%AC%94%E8%AE%B0/5.3_%E5%87%8F%E5%B0%91%E5%BB%B6%E8%BF%9F%E6%97%B6%E9%97%B4%E7%9A%84%E6%96%B9%E6%B3%95/","content":"\n方法1：交替编号若采用交替编号的策略，即让逻辑上相邻的扇区在物理上有一定的间隔，可以使读取连续的逻辑扇区所需要的延迟时间更小\n\n磁盘地址结构的设计为什么磁盘的物理地址是（柱面号，盘面号，扇区号），而不是（盘面号，柱面号，扇区号）？\n\n\n\n\n读取地址连续的磁盘块时，采用（柱面号，盘面号，扇区号）的地址结构可以减少磁头移动消耗的时间\n方法2：错位命名\n\n","categories":["计算机理论"],"tags":["操作系统原理-操作系统原理笔记"]},{"title":"磁盘的管理","url":"/2020/06/30/%E8%AE%A1%E7%AE%97%E6%9C%BA%E7%90%86%E8%AE%BA/%E6%93%8D%E4%BD%9C%E7%B3%BB%E7%BB%9F%E5%8E%9F%E7%90%86/%E6%93%8D%E4%BD%9C%E7%B3%BB%E7%BB%9F%E5%8E%9F%E7%90%86%E7%AC%94%E8%AE%B0/5.4_%E7%A3%81%E7%9B%98%E7%9A%84%E7%AE%A1%E7%90%86/","content":"磁盘初始化\n引导块计算机开机时需要进行一系列初始化的工作，这些初始化的工作是通过执行初始化程序（自举程序）完成的\n初始化程序可以放在ROM（只读存储器）中，ROM中的数据在出厂时就写入了，并且以后不能再修改（ROM一般是出厂时就集成在主板上的）\n问题：万一需要更新自举程序，将会很不方便，因为ROM中的数据无法更改\nROM中只存放很小的“自举装入程序”，完整的自举程序放在磁盘的启动块（即引导块&#x2F;启动分区）上，启动块位于磁盘的固定位置，拥有启动分区的磁盘称为启动磁盘或系统磁盘（C:盘）\n开机时计算机先运行“自举装入程序”，通过执行该程序就可以找到引导块，并将完整的“自举程序”读入内存，完成初始化\n坏块的管理坏了、无法正常使用的扇区就是“坏块”，这属于硬件故障，操作系统是无法修复的。应该将坏块标记出来，以免错误的使用到它\n\n","categories":["计算机理论"],"tags":["操作系统原理-操作系统原理笔记"]},{"title":"I-O控制器","url":"/2020/06/30/%E8%AE%A1%E7%AE%97%E6%9C%BA%E7%90%86%E8%AE%BA/%E6%93%8D%E4%BD%9C%E7%B3%BB%E7%BB%9F%E5%8E%9F%E7%90%86/%E6%93%8D%E4%BD%9C%E7%B3%BB%E7%BB%9F%E5%8E%9F%E7%90%86%E7%AC%94%E8%AE%B0/5.6_I-O%E6%8E%A7%E5%88%B6%E5%99%A8/","content":"I&#x2F;O设备：\n\n机械部件\n电子部件（I&#x2F;O控制器或称设备控制器）\n\nI&#x2F;O设备的机械部件主要用来执行具体I&#x2F;O操作，如我们看得见摸得着的鼠标&#x2F;键盘的按钮、显示器的LED屏、移动硬盘的磁臂、磁盘盘面\nI&#x2F;O设备的电子部件通常是一块插入主板扩充槽的印刷电路板\nI&#x2F;O控制器（用于实现对I&#x2F;O设备的控制）CPU无法直接控制I&#x2F;O设备的机械部件，因此I&#x2F;O设备还要有一个电子部件作为CPU和I&#x2F;O设备机械部件之间的中介，用于实现CPU对设备的控制，这个电子部件就是I&#x2F;O控制器，又称设备控制器，CPU可控制I&#x2F;O控制器，又由I&#x2F;O控制器来控制设备的机械部件\nI&#x2F;O控制器的功能\n接受和识别CPU发出的命令：如CPU发来的read&#x2F;write命令，I&#x2F;O控制器中会有相应的控制寄存器来存放命令和参数\n向CPU报告设备的状态：I&#x2F;O控制器中会有相应的状态寄存器，用于记录I&#x2F;O设备的当前状态，如1表示空闲，0表示忙碌\n数据交换：I&#x2F;O控制器会设置相应的数据寄存器，输出时，数据寄存器用于暂存CPU发来的数据，之后再由控制器传送设备。输入时，数据寄存器用于暂存设备发来的数据，之后CPU从数据寄存器中取走数据\n地址识别：类似于内存的地址，为了区分设备控制器中的各个寄存器，也需要给各个寄存器设置一个特定的地址，I&#x2F;O控制器通过CPU提供的地址来判断CPU要读&#x2F;写的是哪个寄存器（由I&#x2F;O逻辑实现）\n\nI&#x2F;O控制器的组成\n注意：\n\n一个I&#x2F;O控制器可能会对应多个设备\n\n数据寄存器、控制寄存器、状态寄存器可能有多个（如每个控制&#x2F;状态寄存器对应一个具体的设备），且这些寄存器都要有相应的地址，才能方便CPU操作。有的计算机会让这些寄存器占用内存地址的一部分，称为内存映像I&#x2F;O，另一些计算机则采用I&#x2F;O专用地址，即寄存器独立编址\n\n\n\n","categories":["计算机理论"],"tags":["操作系统原理-操作系统原理笔记"]},{"title":"I-O控制方式","url":"/2020/06/30/%E8%AE%A1%E7%AE%97%E6%9C%BA%E7%90%86%E8%AE%BA/%E6%93%8D%E4%BD%9C%E7%B3%BB%E7%BB%9F%E5%8E%9F%E7%90%86/%E6%93%8D%E4%BD%9C%E7%B3%BB%E7%BB%9F%E5%8E%9F%E7%90%86%E7%AC%94%E8%AE%B0/5.7_I-O%E6%8E%A7%E5%88%B6%E6%96%B9%E5%BC%8F/","content":"用什么样的方式来控制I&#x2F;O设备的数据读&#x2F;写\n程序直接控制方式完成一次读&#x2F;写操作的流程（以读操作为例）\n\n\nCPU干预的频率：很频繁，I&#x2F;O操作开始之前、完成之后需要CPU介入，并且在等待I&#x2F;O完成的过程中CPU需要不断的轮询检查\n数据传送的单位：每次读&#x2F;写一个字\n数据的流向：（每个字的读&#x2F;写都需要CPU的帮助）\n\n读操作（数据输入）：I&#x2F;O设备 -&gt; CPU寄存器 -&gt; 内存\n写操作（数据输出）：内存 -&gt; CPU寄存器 -&gt; I&#x2F;O设备\n\n主要缺点和主要优点：\n\n优点：实现简单，在读&#x2F;写指令之后，加上实现循环检查的一系列指令即可（因此才称为程序直接控制方式）\n缺点：CPU和I&#x2F;O设备只能串行工作，CPU需要一直轮询检查，长期处于“忙等”状态，CPU利用率低\n\n中断驱动方式\nCPU干预的频率：每次I&#x2F;O操作开始之前、完成之后需要CPU介入，等待I&#x2F;O完成的过程中CPU可以切换到别的进程执行\n数据传送的单位：每次读&#x2F;写一个字\n数据的流向：（每个字的读&#x2F;写都需要CPU的帮助）\n\n读操作（数据输入）：I&#x2F;O设备 -&gt; CPU寄存器 -&gt; 内存\n写操作（数据输出）：内存 -&gt; CPU寄存器 -&gt; I&#x2F;O设备\n\n主要缺点和主要优点：\n\n优点：与程序直接控制方式相比，在中断驱动方式中，I&#x2F;O控制器会通过中断信号主动报告I&#x2F;O已完成，CPU不再需要不停的轮询，CPU和I&#x2F;O设备可并行的工作，CPU利用率得到明显提升\n缺点：每个字在I&#x2F;O设备与内存之间的传输，都需要经过CPU，而频繁的中断处理会消耗较多的CPU时间\n\nDMA方式\n\nCPU干预的频率：仅在传送一个或多个数据块的开始和结束时，才需要CPU干预\n数据传送的单位：每次读&#x2F;写一个或多个块（注意：每次读写的只能是连续的多个块，且这些块读入内存后在内存中也必须是连续的）\n数据的流向：（不再需要经过CPU）\n\n读操作（数据输入）：I&#x2F;O设备 -&gt; 内存\n写操作（数据输出）：内存 -&gt; I&#x2F;O设备\n\n主要缺点和主要优点：\n\n优点：数据传输以块为单位，CPU介入频率进一步降低，数据的传输不再需要先经过CPU再写入内存，数据传输效率进一步增加，CPU和I&#x2F;O设备的并行性得到提升\n缺点：CPU每发出一条I&#x2F;O指令，只能读&#x2F;写一个或多个连续的数据块，如果要读&#x2F;写多个离散存储的数据块，或者要将数据分别写到不同的内存区域时，CPU要分别发出多条I&#x2F;O指令，进行多次中断处理才能完成\n\n通道控制方式\n与CPU相比，通道可以执行的指令很单一，并且通道程序是放在主机内存中的，也就是说通道与CPU共享内存\n\n总结：\n\n","categories":["计算机理论"],"tags":["操作系统原理-操作系统原理笔记"]},{"title":"I-O设备的基本概念和分类","url":"/2020/06/30/%E8%AE%A1%E7%AE%97%E6%9C%BA%E7%90%86%E8%AE%BA/%E6%93%8D%E4%BD%9C%E7%B3%BB%E7%BB%9F%E5%8E%9F%E7%90%86/%E6%93%8D%E4%BD%9C%E7%B3%BB%E7%BB%9F%E5%8E%9F%E7%90%86%E7%AC%94%E8%AE%B0/5.5_I-O%E8%AE%BE%E5%A4%87%E7%9A%84%E5%9F%BA%E6%9C%AC%E6%A6%82%E5%BF%B5%E5%92%8C%E5%88%86%E7%B1%BB/","content":"什么是I&#x2F;O设备I&#x2F;O就是输入&#x2F;输出（Input&#x2F;Output）\nI&#x2F;O设备就是可以将数据输入到计算机，或者可以接收计算机输出数据的外部设备，属于计算机中的硬件部件\n鼠标、键盘：典型的输入型设备\n显示器：输出型设备\n移动硬盘：既可输入又可输出的设备\nUNIX系统将外部设备抽象为一种特殊的文件，用户可以使用与文件操作相同的方式对外部设备进行操作【write操作：向外部设备写出数据，read操作：从外部设备读入数据】\n按使用特性分类人机交互类外部设备：鼠标、键盘、打印机（数据传输速度慢）\n存储设备：移动硬盘、光盘（数据传输速度快）\n网络通信设备：调制解调器（数据传输速度介于上述二者之间）\n按传输速率分类低速设备：鼠标、键盘，传输速率为每秒几个到几百字节\n中速设备：激光打印机，传输速率为每秒数千至上万个字节\n高速设备：磁盘，传输速率为每秒数千字节至千兆字节\n按信息交换的单位分类块设备：磁盘，数据传输的基本单位是块（传输速率较高，可寻址，即对它可随机的读&#x2F;写任一块）\n字符设备：鼠标、键盘，数据传输的基本单位是字符（传输速率较慢，不可寻址，在输入&#x2F;输出时常采用中断驱动方式）\n中断驱动方式：I&#x2F;O控制方式的一种\n","categories":["计算机理论"],"tags":["操作系统原理-操作系统原理笔记"]},{"title":"I-O软件层次结构","url":"/2020/06/30/%E8%AE%A1%E7%AE%97%E6%9C%BA%E7%90%86%E8%AE%BA/%E6%93%8D%E4%BD%9C%E7%B3%BB%E7%BB%9F%E5%8E%9F%E7%90%86/%E6%93%8D%E4%BD%9C%E7%B3%BB%E7%BB%9F%E5%8E%9F%E7%90%86%E7%AC%94%E8%AE%B0/5.8_I-O%E8%BD%AF%E4%BB%B6%E5%B1%82%E6%AC%A1%E7%BB%93%E6%9E%84/","content":"\n用户层软件\n设备独立性软件设备独立性软件又称设备无关性软件，与设备的硬件特性无关的功能几乎都在这一层实现\n主要实现的功能：\n\n向上层提供统一的调用接口（如read&#x2F;write系统调用）\n\n设备的保护，原理类似于文件保护，设备被看作是一种特殊的文件，不同用户对各个文件的访问权限是不一样的，同理，对设备的访问权限也不一样\n\n差错处理：设备独立性软件需要对一些设备的错误进行处理\n\n设备的分配与回收\n\n数据缓冲区管理，可以通过缓冲技术屏蔽设备之间数据交换单位大小和传输速度的差异\n\n建立逻辑设备名到物理设备名的映射关系，根据设备类型选择调用相应的驱动程序\n\n\n\n为什么不同的I&#x2F;O设备需要有不同的驱动程序处理？\n各式各样的设备，外形不同，其内部的电子部件（I&#x2F;O控制器）也有可能不同，不同设备的内部硬件特性也不同，这些特性只有厂家才知道，因此厂家需提供与设备相对应的驱动程序，CPU执行驱动程序的指令序列，来完成设置设备寄存器，检查设备状态等工作\n\n\n设备驱动程序\n驱动程序一般会以一个独立进程的方式存在\n⭐️直接涉及到硬件具体细节、且与中断无关的操作肯定是在设备驱动程序层完成的；没有涉及硬件的、对各种设备都需要进行的管理工作都是在设备独立性软件层完成的\n中断处理程序当I&#x2F;O任务完成时，I&#x2F;O控制器会发送一个中断信号，系统会根据中断信号类型找到相应的中断处理程序并执行，中断处理程序的处理流程如下：\n\n⭐️设备独立性软件和用户层软件都不会和硬件打交道，设备驱动程序和中断处理程序会和硬件打交道\n硬件执行I&#x2F;O操作，有机械部件、电子部件组成\nI&#x2F;O核心子系统的功能用户层软件实现：假脱机技术（SPOOLing技术）\n假脱机技术（SPOOLing技术）需要请求“磁盘设备”的设备独立性软件的服务，因此一般来说假脱机技术是在用户层软件实现的\n设备独立性软件实现：I&#x2F;O调度、设备保护、设备分配与回收、缓冲区管理（缓冲与高速缓存）\n\n\n","categories":["计算机理论"],"tags":["操作系统原理-操作系统原理笔记"]},{"title":"假脱机技术SPOOLing","url":"/2020/06/30/%E8%AE%A1%E7%AE%97%E6%9C%BA%E7%90%86%E8%AE%BA/%E6%93%8D%E4%BD%9C%E7%B3%BB%E7%BB%9F%E5%8E%9F%E7%90%86/%E6%93%8D%E4%BD%9C%E7%B3%BB%E7%BB%9F%E5%8E%9F%E7%90%86%E7%AC%94%E8%AE%B0/5.9_%E5%81%87%E8%84%B1%E6%9C%BA%E6%8A%80%E6%9C%AFSPOOLing/","content":"什么是脱机技术，脱机技术可以解决什么问题手工操作阶段：主机直接从I&#x2F;O设备获得数据，由于设备速度慢，主机速度很快，人机速度矛盾明显，主机要浪费很多时间来等待设备\n批处理阶段引入了脱机输入&#x2F;输出技术（外围控制机+磁带）：脱离主机的控制进行的输入&#x2F;输出操作\n引入脱机技术后，缓解了CPU与慢速I&#x2F;O设备的速度矛盾。另一方面，即使CPU在忙碌，也可以提前将数据输入到磁带，即使慢速的输出设备正在忙碌，也可以提前将数据输出到磁带\n假脱机技术的实现原理假脱机技术又称SPOOLing技术，是用软件的方式模拟脱机技术\n输入井和输出井在磁盘上开辟出两个存储区域：输入井和输出井\n“输入井”模拟脱机输入时的磁带，用于收容I&#x2F;O设备输入的数据\n“输出井”模拟脱机输出时的磁带，用于收容用户进程输出的数据\n输入进程和输出进程要实现SPOOLing技术，必须要有多道程序技术的支持，系统会建立“输入进程”和“输出进程”\n\n输入缓冲区和输出缓冲区注意，输入缓冲区和输出缓冲区是在内存中的缓冲区\n在输入进程的控制下，输入缓冲区用于暂存从输入设备输入的数据，之后再转存到输入井中\n在输出进程的控制下，输出缓冲区用于暂存从输出井送来的数据，之后再传送到输出设备上\n共享打印机的原理分析\n\n虽然系统中只有一台打印机，但每个进程提出打印请求时，系统都会在输出井中为其分配一个存储区（相当于分配了一个逻辑设备），使每个用户进程都觉得自己在独占一台打印机，从而实现对打印机的共享\nSPOOLing技术可以把一台物理设备虚拟成逻辑上的多台设备，可将独占式设备改造成共享设备\n","categories":["计算机理论"],"tags":["操作系统原理-操作系统原理笔记"]},{"title":"内存的基础知识","url":"/2020/06/30/%E8%AE%A1%E7%AE%97%E6%9C%BA%E7%90%86%E8%AE%BA/%E6%93%8D%E4%BD%9C%E7%B3%BB%E7%BB%9F%E5%8E%9F%E7%90%86/%E6%93%8D%E4%BD%9C%E7%B3%BB%E7%BB%9F%E5%8E%9F%E7%90%86%E7%AC%94%E8%AE%B0/3.1_%E5%86%85%E5%AD%98%E7%9A%84%E5%9F%BA%E7%A1%80%E7%9F%A5%E8%AF%86/","content":"什么是内存，有何作用内存可存放数据，程序执行前需要先放到内存中才能被CPU处理：缓和CPU与硬盘之间的速度矛盾\n在多道程序环境下，系统中会有多个程序并发执行，也就是说会有多个程序的数据需要同时放到内存中。那么，如何区分各个程序的数据是放在什么地方的呢？\n方案：给内存的存储单元编地址\n内存中有一个一个的“小房间”，每个小房间就是一个存储单元，内存地址从0开始，每个地址对应一个存储单元\n如果计算机按“字节编址”，则每个存储单元大小为1字节，即1B，即8个二进制位；如果字长为16位的计算机“按字编址”，则每个存储单元大小为1个字，每个字的大小为16个二进制位\n1B &#x3D; 8bit；1KB &#x3D; 2^10^B；1M &#x3D; 2^10^KB；1GB &#x3D; 2^10^MB\n一台手机有4GB内存，是指该内存中可以存放（4 * 2^30^）个字节，如果是按字节编址的话，也就是有2^32^个“小房间”，所以地址需要用32个二进制位\n进程运行的基本原理指令的工作原理（逻辑地址 VS 物理地址）指令的工作基于“地址”，每个地址对应一个数据的存储单元\n我们写的代码要翻译成CPU能识别的指令，这些指令会告诉CPU应该去内存的哪个地址读&#x2F;写数据，这个数据应该做什么样的处理。这个例子中，我们默认让这个进程的相关内容从地址#0开始连续存放，指令中的地址参数直接给出了变量x的实际存放地址（物理地址）\n\n如果这个进程不是从地址#0开始存放的，会影响指令的正常执行吗？\n\n如何实现地址转换如何将指令中的逻辑地址转换为物理地址？\n三种装入方式：\n\n绝对装入（换个电脑装入模块就作废了）（编译时）（单道程序阶段，此时还没产生操作系统，由编译器实现）\n\n\n可重定位装入（静态重定位）（装入内存时）（用于早期的多道批处理）\n\n\n动态运行时装入（动态重定位）（程序运行时）（现代）\n\n\n\n从写程序到程序运行的过程\n链接的三种方式：\n\n静态链接：在程序运行之前，先将各目标模块及它们所需的库函数连接成一个完整的可执行文件（装入模块），之后不再拆开\n装入时动态链接：将各目标模块装入内存时，边装入边链接的链接方式\n运行时动态链接：在程序执行中需要该目标模块时，才对它进行链接。其优点是便于修改和更新，便于实现对目标模块的共享（用不到的模块不需要装入内存）\n\n","categories":["计算机理论"],"tags":["操作系统原理-操作系统原理笔记"]},{"title":"数据结构和算法的基本概念","url":"/2019/03/15/%E8%AE%A1%E7%AE%97%E6%9C%BA%E7%90%86%E8%AE%BA/%E6%95%B0%E6%8D%AE%E7%BB%93%E6%9E%84/%E6%95%B0%E6%8D%AE%E7%BB%93%E6%9E%84%E7%AC%94%E8%AE%B0/1.1_%E6%95%B0%E6%8D%AE%E7%BB%93%E6%9E%84%E5%92%8C%E7%AE%97%E6%B3%95%E7%9A%84%E5%9F%BA%E6%9C%AC%E6%A6%82%E5%BF%B5/","content":"数据：数据是信息的载体，是描述客观事物属性的数、字符及所有能输入到计算机中并被计算机程序识别和处理的符号的集合，数据是计算机程序加工的原料\n数据元素和数据项：数据元素是数据的基本单位，通常作为一个整体进行考虑和处理；一个数据元素可由若干数据项组成，数据项是构成数据元素的不可分割的最小单位\n结构：各个元素之间的关系\n数据结构：是相互之间存在一种或多种特定关系的数据元素的集合数据对象：是具有相同性质的数据元素的集合，是数据的一个子集\n数据结构的三要素：\n\n逻辑结构：数据元素之间的逻辑关系是什么【集合、线性结构、树形结构、图状结构(网状结构)】\n物理结构(存储结构)：各个数据元素在内存中如何存储，如何用计算机表示数据元素的逻辑关系【顺序存储、链式存储、索引存储、散列存储】\n数据的运算：施加在数据上的运算包括运算的定义和实现，运算的定义是针对逻辑结构的，指出运算的功能；运算的实现是针对存储结构的，指出运算的具体操作步骤\n\n线性结构：1）顺序存储：把逻辑上相邻的元素存储在物理位置上也相邻的存储单元中，元素之间的关系由存储单元的邻接关系来体现2）链式存储：逻辑上相邻的元素在物理位置上可以不相邻，借助指示元素存储地址的指针来表示元素之间的逻辑关系3）索引存储：在存储元素信息的同时，还建立附加的索引表，索引表的每项称为索引项，索引项的一般形式是（关键字，地址）4）散列存储：根据元素的关键字直接计算出该元素的存储地址，又称哈希存储\n数据类型：一个值的集合和定义在此集合上的一组操作的总称1）原子类型【bool、int】2）结构类型【struct】\n抽象数据类型（ADT）：是抽象数据组织及与之相关的操作\n程序&#x3D;数据结构+算法\n算法的特性：1）有穷性：一个算法必须总在执行有穷步之后结束，且每一步都可在有穷时间内完成【算法必须是有穷的，而程序可以是无穷的】2）确定性：算法中每条指令必须有确切的含义，对于相同的输入只能得出相同的输出3）可行性：算法中描述的操作都可以通过已经实现的基本运算执行有限次来实现4）输入和输出\n好算法的特质：1）正确性：算法应能够正确的解决求解问题2）可读性：算法应具有良好的可读性，以帮助人们理解3）健壮性：输入非法数据时，算法能适当的做出反应或进行处理，而不会产生莫名其妙的输出结果4）高效率与低存储量需求\n","categories":["计算机理论"],"tags":["数据结构-数据结构笔记"]},{"title":"算法的时间复杂度和空间复杂度","url":"/2019/03/15/%E8%AE%A1%E7%AE%97%E6%9C%BA%E7%90%86%E8%AE%BA/%E6%95%B0%E6%8D%AE%E7%BB%93%E6%9E%84/%E6%95%B0%E6%8D%AE%E7%BB%93%E6%9E%84%E7%AC%94%E8%AE%B0/1.2_%E7%AE%97%E6%B3%95%E7%9A%84%E6%97%B6%E9%97%B4%E5%A4%8D%E6%9D%82%E5%BA%A6%E5%92%8C%E7%A9%BA%E9%97%B4%E5%A4%8D%E6%9D%82%E5%BA%A6/","content":"算法时间复杂度和空间复杂度如何评估算法时间开销：让算法先运行，事后统计运行时间？【存在问题：和机器性能有关；和编程语言有关，越高级的语言执行效率越低；和编译程序产生的机器指令质量有关；有些算法是不能事后再统计的(导弹控制算法)】\n算法时间复杂度：事前预估算法时间开销T(n)与问题规模n的关系1）最坏时间复杂度2）平均时间复杂度3）最好时间复杂度\nO(1)&lt;O(log2n)&lt;O(n)&lt;O(nlog2n)&lt;O(n^2)&lt;O(n^3)&lt;O(2^n)&lt;O(n!)&lt;O(n^n)\n测试算法效率(时钟打点)问题：\n源代码：\n//clock():捕捉从程序开始运行到clock()被调用时所耗费的时间。这个时间单位是clock tick，即“时钟打点”//常数CLK_TCK:机器时钟每秒所走的时钟打点数//让被测函数重复运行充分多次，使得测出的总的时钟打点间隔充分长，最后计算被测函数平均每次运行的时间即可#include&lt;stdio.h&gt;#include&lt;time.h&gt;#include&lt;math.h&gt;#define MAXN 10#define MAXK 1e7//被测函数最大重复调用次数clock_t start,stop;//clock_t是clock()函数返回的变量类型double duration;//记录被测函数运行时间，以秒为单位double f1(int n,double a[],double x)&#123;    int i;    double p=a[0];    for(i=1;i&lt;=n;i++)&#123;        p += (a[i]*pow(x,i));    &#125;    return p;&#125;double f2(int n,double a[],double x)&#123;    int i;    double p=a[0];    for(i=1;i&lt;=n;i++)&#123;        p+=(a[i]*pow(x,i));    &#125;    return p;&#125;int main()&#123;    int i,CLK_TCK;    double a[MAXN];//存储多项式的系数    for(i=0;i&lt;MAXN;i++)&#123;        a[i]=(double)i;    &#125;        //不在测试范围内的准备工作写在clock()调用之前        start=clock();//开始计时    for(i=0;i&lt;MAXK;i++)&#123;        f1(MAXN-1,a,1.1);//把被测函数加在这里    &#125;    stop=clock();//停止计时    duration=((double)(stop-start))/CLK_TCK/MAXK;//计算函数单次运行时间    printf(&quot;ticks1=%f\\n&quot;,(double)(stop-start));    printf(&quot;duration1=%6.2e\\n&quot;,duration);        //其他不在测试范围的处理写在后面，例如输出duration的值        start=clock();//开始计时    for(i=0;i&lt;MAXK;i++)&#123;        f2(MAXN-1,a,1.1);//把被测函数加在这里    &#125;    stop=clock();//停止计时    duration=((double)(stop-start))/CLK_TCK/MAXK;//计算函数单次运行时间    printf(&quot;ticks2=%f\\n&quot;,(double)(stop-start));    printf(&quot;duration2=%6.2e\\n&quot;,duration);    return 0;&#125;\n","categories":["计算机理论"],"tags":["数据结构-数据结构笔记"]},{"title":"静态链表","url":"/2019/03/15/%E8%AE%A1%E7%AE%97%E6%9C%BA%E7%90%86%E8%AE%BA/%E6%95%B0%E6%8D%AE%E7%BB%93%E6%9E%84/%E6%95%B0%E6%8D%AE%E7%BB%93%E6%9E%84%E7%AC%94%E8%AE%B0/2.11_%E9%9D%99%E6%80%81%E9%93%BE%E8%A1%A8/","content":"静态链表：用数组的方式实现的链表\n优点：增、删操作不需要大量移动元素缺点：不能随机存取，只能从头结点开始依次往后查找；容量固定不可变\n适用场景：不支持指针的低级语言；数据元素数量固定不变的场景(如操作系统的文件分配表FAT)\n\n#include&lt;stdio.h&gt;#include&lt;stdbool.h&gt;#include&lt;stdlib.h&gt;#define MaxSize 10  //静态链表的最大长度//用代码定义一个静态链表struct Node&#123;    int data;  //存储数据元素    int next;  //下一个元素的数组下标&#125;;//初始化静态链表：把a[0]的next设为-1，把其他结点的next设为一个特殊值用来表示结点空闲，如-2//查找：从头结点出发挨个往后遍历结点（O(n)）//插入位序为i的结点：1.找到一个空的结点，存入数据元素【如何判断结点为空？通过特殊值来判断】 2.从头结点出发找到位序为i-1的结点 3.修改i-1号结点的next 4.修改新结点的next//删除某个结点：1.从头结点出发找到前驱结点 2.修改前驱结点的游标 3.被删除结点的next设为特殊值int main()&#123;        struct Node a[MaxSize];  //数组a作为静态链表        //...后续代码&#125;","categories":["计算机理论"],"tags":["数据结构-数据结构笔记"]},{"title":"顺序表和链表的比较","url":"/2019/03/15/%E8%AE%A1%E7%AE%97%E6%9C%BA%E7%90%86%E8%AE%BA/%E6%95%B0%E6%8D%AE%E7%BB%93%E6%9E%84/%E6%95%B0%E6%8D%AE%E7%BB%93%E6%9E%84%E7%AC%94%E8%AE%B0/2.12_%E9%A1%BA%E5%BA%8F%E8%A1%A8%E5%92%8C%E9%93%BE%E8%A1%A8%E7%9A%84%E6%AF%94%E8%BE%83/","content":"逻辑结构：都属于线性表，都是线性结构\n存储结构：\n\n顺序表：顺序存储，优点是支持随机存取，存储密度高；缺点是大片连续空间分配不方便，改变容量不方便\n链表：链式存储，优点是离散的小空间分配方便，改变容量方便；缺点是不可随机存取，存储密度低\n\n使用场景：\n\n链表：表长难以预估，经常要增加&#x2F;删除元素\n顺序表：表长可预估，查询(搜索)操作较多\n\n","categories":["计算机理论"],"tags":["数据结构-数据结构笔记"]},{"title":"循环链表","url":"/2019/03/15/%E8%AE%A1%E7%AE%97%E6%9C%BA%E7%90%86%E8%AE%BA/%E6%95%B0%E6%8D%AE%E7%BB%93%E6%9E%84/%E6%95%B0%E6%8D%AE%E7%BB%93%E6%9E%84%E7%AC%94%E8%AE%B0/2.10_%E5%BE%AA%E7%8E%AF%E9%93%BE%E8%A1%A8/","content":"单链表：表尾结点的next指针指向NULL，从一个结点出发只能找到后续的各个结点循环单链表：表尾结点的next指针指向头结点，从一个结点出发可以找到其他任何一个结点\n#include&lt;stdio.h&gt;#include&lt;stdbool.h&gt;#include&lt;stdlib.h&gt;typedef struct LNode&#123;    int data;  //数据域    struct LNode *next;  //指针域&#125;LNode,*LinkList;  //LinkList等价于LNode *//初始化一个循环单链表bool InitList(LinkList *L)&#123;    (*L)=(LNode *)malloc(sizeof(LNode));  //分配一个头结点    if((*L) == NULL)&#123;        return false;  //内存不足，分配失败    &#125;    (*L)-&gt;next=(*L);  //头结点next指针指向头结点    return true;&#125;//判断循环单链表是否为空bool Empty(LinkList *L)&#123;    if((*L)-&gt;next == (*L))&#123;        return true;    &#125;    else&#123;        return false;    &#125;&#125;//判断结点p是否为循环单链表的表尾结点bool isTail(LinkList *L,LNode *p)&#123;    if(p-&gt;next == (*L))&#123;        return true;    &#125;    else&#123;        return false;    &#125;&#125;int main()&#123;        LinkList L;    InitList(&amp;L);  //初始化双链表        //...后续代码&#125;\n\n双链表：表头结点的prior指向NULL，表尾结点的next指向NULL循环双链表：表头结点的prior指向表尾结点，表尾结点的next指向头结点\n#include&lt;stdio.h&gt;#include&lt;stdbool.h&gt;#include&lt;stdlib.h&gt;typedef struct DNode&#123;    int data;  //数据域    struct DNode *prior,*next;  //指针域&#125;DNode,*DLinklist;  //DLinklist等价于DNode *//初始化空的循环双链表bool InitDLinkList(DLinklist *L)&#123;    (*L)=(DNode *)malloc(sizeof(DNode));  //分配一个头结点    if((*L) == NULL)&#123;  //内存不足，分配失败        return false;    &#125;        (*L)-&gt;prior=(*L);  //头结点的prior指向头结点    (*L)-&gt;next=(*L);  //头结点的next指向头结点    return true;&#125;//判断循环双链表是否为空(带头结点)bool Empty(DLinklist *L)&#123;    if((*L)-&gt;next == (*L))&#123;        return true;    &#125;    else&#123;        return false;    &#125;&#125;//判断结点p是否为循环双链表的表尾结点bool isTail(DLinklist *L,DNode *p)&#123;    if(p-&gt;next == (*L))&#123;        return true;    &#125;    else&#123;        return false;    &#125;&#125;int main()&#123;        DLinklist L;    InitDLinkList(&amp;L);  //初始化循环双链表        //...后续代码&#125;\n","categories":["计算机理论"],"tags":["数据结构-数据结构笔记"]},{"title":"顺序表的插入和删除","url":"/2019/03/15/%E8%AE%A1%E7%AE%97%E6%9C%BA%E7%90%86%E8%AE%BA/%E6%95%B0%E6%8D%AE%E7%BB%93%E6%9E%84/%E6%95%B0%E6%8D%AE%E7%BB%93%E6%9E%84%E7%AC%94%E8%AE%B0/2.3_%E9%A1%BA%E5%BA%8F%E8%A1%A8%E7%9A%84%E6%8F%92%E5%85%A5%E5%92%8C%E5%88%A0%E9%99%A4/","content":"顺序表的插入(最好O(1),最坏O(n),平均O(n))\n//顺序表的插入#include &lt;stdio.h&gt;#include&lt;stdbool.h&gt; //可以使用bool了#define MaxSize 10  //定义最大长度typedef struct&#123;    int data[MaxSize];  //用静态的“数组”存放数据元素    int length;  //顺序表的当前长度&#125;SqList;  //顺序表的类型定义//基本操作：初始化一个顺序表void InitList(SqList *L)&#123;    for(int i=0;i&lt;MaxSize;i++)&#123;        L-&gt;data[i]=0;  //将所有数据元素设置为默认初始值    &#125;    L-&gt;length=0;  //顺序表初始长度为0&#125;//i的取值：[1,length+1]，因为顺序表是连续排列的bool ListInsert(SqList *L,int i,int e)&#123;        if(i&lt;1 || i&gt;L-&gt;length+1)&#123;  //判断i的范围是否有效        return false;    &#125;    if(L-&gt;length &gt;= MaxSize)&#123;  //当前存储空间已满，不能插入        return false;    &#125;        for(int j=L-&gt;length;j&gt;=i;j--)&#123;  //将第i个元素及之后的元素后移        L-&gt;data[i]=L-&gt;data[j-1];    &#125;    L-&gt;data[i-1]=e;  //在位置i处放入e    L-&gt;length++;  //长度加1        return true;&#125;int main()&#123;        SqList L;  //声明一个顺序表    InitList(&amp;L);  //初始化顺序表        //...此处插入几个元素    bool b=ListInsert(&amp;L, 3, 4);  //在位置3处放入4    return 0;&#125;\n\n顺序表的删除(最好O(1),最坏O(n),平均O(n))\n//顺序表的删除#include &lt;stdio.h&gt;#include&lt;stdbool.h&gt; //可以使用bool了#define MaxSize 10  //定义最大长度typedef struct&#123;    int data[MaxSize];  //用静态的“数组”存放数据元素    int length;  //顺序表的当前长度&#125;SqList;  //顺序表的类型定义//基本操作：初始化一个顺序表void InitList(SqList *L)&#123;    for(int i=0;i&lt;MaxSize;i++)&#123;        L-&gt;data[i]=0;  //将所有数据元素设置为默认初始值    &#125;    L-&gt;length=0;  //顺序表初始长度为0&#125;bool ListDelete(SqList *L,int i,int *e)&#123;        if(i&lt;1 || i&gt;L-&gt;length)&#123;  //判断i的范围是否有效        return false;    &#125;        *e=L-&gt;data[i-1];  //将被删除的元素赋值给e        for(int j=i;j&lt;L-&gt;length;j++)&#123;  //将第i个位置后的元素前移        L-&gt;data[j-1]=L-&gt;data[j];    &#125;    L-&gt;length--;  //线性表长度减1        return true;&#125;int main()&#123;        SqList L;  //声明一个顺序表    InitList(&amp;L);  //初始化顺序表        //...此处插入几个元素    int e=-1;  //用变量e把删除的元素“带回来”    if(ListDelete(&amp;L, 3, &amp;e))&#123;        printf(&quot;已删除第3个元素，删除元素值为%d\\n&quot;,e);    &#125;    else&#123;        printf(&quot;位序i不合法，删除失败\\n&quot;);    &#125;    return 0;&#125;\n","categories":["计算机理论"],"tags":["数据结构-数据结构笔记"]},{"title":"文件存储空间管理","url":"/2020/06/30/%E8%AE%A1%E7%AE%97%E6%9C%BA%E7%90%86%E8%AE%BA/%E6%93%8D%E4%BD%9C%E7%B3%BB%E7%BB%9F%E5%8E%9F%E7%90%86/%E6%93%8D%E4%BD%9C%E7%B3%BB%E7%BB%9F%E5%8E%9F%E7%90%86%E7%AC%94%E8%AE%B0/4.5_%E6%96%87%E4%BB%B6%E5%AD%98%E5%82%A8%E7%A9%BA%E9%97%B4%E7%AE%A1%E7%90%86/","content":"存储空间的划分与初始化目录区包含文件目录、空闲表、位示图、超级块等用于文件管理的数据\n\n几种管理方法空闲表法（适用于“连续分配方式”）\n\n如何分配磁盘块，与内存管理中的动态分区分配很类似，为一个文件分配连续的存储空间。同样可采用首次适应、最佳适应、最坏适应等算法来决定要为文件分配哪个区间\n如何回收磁盘块：与内存管理中的动态分区分配很类似，当回收某个存储区时需要有四种情况：回收区的前后都没有相邻空闲区、回收区的前后都是空闲区、回收区前面是空闲区、回收区后面是空闲区，总之，回收时需要注意表项的合并问题\n空闲链表法空闲盘块链以盘块为单位组成一条空闲链\n\n\n空闲盘区链以盘区为单位组成一条空闲链\n\n\n位示图法（连续分配、离散分配都适用）\n\n成组链接法（理解即可）空闲表法、空闲链表法不适用于大型文件系统，因为空闲表或空闲链表可能过大\nUNIX系统中采用了成组链接法对磁盘空闲块进行管理，适合大型文件系统\n\n\n\n\n","categories":["计算机理论"],"tags":["操作系统原理-操作系统原理笔记"]},{"title":"单链表的定义","url":"/2019/03/15/%E8%AE%A1%E7%AE%97%E6%9C%BA%E7%90%86%E8%AE%BA/%E6%95%B0%E6%8D%AE%E7%BB%93%E6%9E%84/%E6%95%B0%E6%8D%AE%E7%BB%93%E6%9E%84%E7%AC%94%E8%AE%B0/2.5_%E5%8D%95%E9%93%BE%E8%A1%A8%E7%9A%84%E5%AE%9A%E4%B9%89/","content":"单链表：用链式存储的方式实现线性表，每个结点除了存放数据元素外，还要存储指向下个节点的指针\n单链表的特点：\n\n不要求大片连续空间，改变容量方便\n不可随机存取，要耗费一定空间存放指针\n\n\n#include&lt;stdio.h&gt;#include&lt;stdbool.h&gt;#include&lt;stdlib.h&gt;typedef struct LNode&#123;  //LNode:结点    int data;  //数据域：每个结点存放一个数据元素    struct LNode *next;  //指针域：指针指向下一个结点&#125;LNode,*LinkList;  //typedef struct LNode *LinkList;  要表示一个单链表时，只需声明一个头指针L，指向单链表的第一个结点//初始化一个空的链表(不带头结点)//bool InitList(LinkList *L)&#123;//    (*L)=NULL;  //空表，暂时还没有任何结点，防止脏数据//    return true;//&#125;//判断单链表是否为空(不带头结点)//bool Empty(LinkList *L)&#123;//    if((*L) == NULL)&#123;//        return true;//    &#125;//    else&#123;//        return false;//    &#125;//&#125;//这里LNode *和LinkList是等价的，LinkList强调这是一个单链表，LNode *强调这是一个结点//LNode * GetElem(LinkList L,int i)&#123;//    int j=1;//    LNode *p=L-&gt;next;//    if(i == 0)&#123;//        return L;//    &#125;//    if(i&lt;1)&#123;//        return NULL;//    &#125;//    while(p != NULL &amp;&amp; j&lt;i)&#123;//        p=p-&gt;next;//        j++;//    &#125;//    return p;//&#125;//初始化一个单链表(带头结点)bool InitList(LinkList *L)&#123;    (*L)=(LNode *)malloc(sizeof(LNode));  //分配一个头结点,并使得头指针*L指向这个头结点    if((*L) == NULL)&#123;  //内存不足，分配失败        return false;    &#125;    (*L)-&gt;data=0;  //头结点不存储数据    (*L)-&gt;next=NULL;  //头结点之后暂时还没有结点    return true;&#125;//判断单链表是否为空(带头结点)bool Empty(LinkList *L)&#123;    if((*L)-&gt;next == NULL)&#123;        return true;    &#125;    else&#123;        return false;    &#125;&#125;int main()&#123;        LinkList L;  //等价于LNode *L;  声明一个指向单链表的第一个结点的指针，注意此处并没有创建一个结点    InitList(&amp;L);  //初始化一个空表        //...后续代码&#125;\n\n不带头结点写代码更麻烦，带头结点写代码更方便\n","categories":["计算机理论"],"tags":["数据结构-数据结构笔记"]},{"title":"线性表的定义和基本操作","url":"/2019/03/15/%E8%AE%A1%E7%AE%97%E6%9C%BA%E7%90%86%E8%AE%BA/%E6%95%B0%E6%8D%AE%E7%BB%93%E6%9E%84/%E6%95%B0%E6%8D%AE%E7%BB%93%E6%9E%84%E7%AC%94%E8%AE%B0/2.1_%E7%BA%BF%E6%80%A7%E8%A1%A8%E7%9A%84%E5%AE%9A%E4%B9%89%E5%92%8C%E5%9F%BA%E6%9C%AC%E6%93%8D%E4%BD%9C/","content":"线性表：是具有相同数据类型的n(n&gt;&#x3D;0)个数据元素的有限序列，其中n为表长，当n&#x3D;0时线性表是一个空表【位序从1开始，数组下标从0开始】\n线性表的基本操作：\n\nInitList(&amp;L)：初始化表，构造一个空的线性表L，分配内存空间\n\nDestroyList(&amp;L)：销毁操作，销毁线性表，并释放线性表L所占用的内存空间\n\nListInsert(&amp;L,i,e)：插入操作，在表L中的第i个位置上插入指定元素e\n\nListDelete(&amp;L,i,&amp;e)：删除操作，删除表L中第i个位置的元素，并用e返回删除元素的值\n\nLocateElem(L,e)：按值查找操作，在表L中查找具有给定关键字值的元素\n\nGetElem(L,i)：按位查找操作，获取表L中第i个位置的元素的值\n\nLength(L)：求表长，返回线性表L的长度，即L中数据元素的个数\n\nPrintList(L)：输出操作，按前后顺序输出线性表L的所有元素值\n\nEmpty(L)：判空操作，若L为空表，则返回true，否则返回false\n\n\n","categories":["计算机理论"],"tags":["数据结构-数据结构笔记"]},{"title":"单链表的查找","url":"/2019/03/15/%E8%AE%A1%E7%AE%97%E6%9C%BA%E7%90%86%E8%AE%BA/%E6%95%B0%E6%8D%AE%E7%BB%93%E6%9E%84/%E6%95%B0%E6%8D%AE%E7%BB%93%E6%9E%84%E7%AC%94%E8%AE%B0/2.7_%E5%8D%95%E9%93%BE%E8%A1%A8%E7%9A%84%E6%9F%A5%E6%89%BE/","content":"单链表的按位查找(带头结点)：获取表L中第i个位置的元素的值，平均时间复杂度O(n)\n#include&lt;stdio.h&gt;#include&lt;stdbool.h&gt;#include&lt;stdlib.h&gt;typedef struct LNode&#123;  //LNode:结点    int data;  //数据域：每个结点存放一个数据元素    struct LNode *next;  //指针域：指针指向下一个结点&#125;LNode,*LinkList;  //typedef struct LNode *LinkList;  要表示一个单链表时，只需声明一个头指针L，指向单链表的第一个结点//初始化一个单链表(带头结点)bool InitList(LinkList *L)&#123;    (*L)=(LNode *)malloc(sizeof(LNode));  //分配一个头结点,并使得头指针*L指向这个头结点    if((*L) == NULL)&#123;  //内存不足，分配失败        return false;    &#125;    (*L)-&gt;data=0;  //头结点不存储数据    (*L)-&gt;next=NULL;  //头结点之后暂时还没有结点    return true;&#125;//按位查找，返回第i个元素(带头结点)LNode * GetElem(LinkList *L,int i)&#123;    if(i&lt;0)&#123;        return NULL;    &#125;        LNode *p;  //指针p指向当前扫描到的结点    int j=0;  //当前p指向的是第几个结点    p=*L;  //L指向头结点，头结点是第0个结点（不存数据）    while(p != NULL &amp;&amp; j&lt;i)&#123;  //循环找到第i个结点        p=p-&gt;next;        j++;    &#125;    return p;&#125;int main()&#123;        LinkList L;  //等价于LNode *L;  声明一个指向单链表的第一个结点的指针，注意此处并没有创建一个结点    InitList(&amp;L);  //初始化一个空表        //...后续代码        LNode * a=GetElem(&amp;L, 3);&#125;\n\n单链表的按值查找(带头结点)：在表L中查找具有给定关键字值的元素,平均时间复杂度O(n)\n#include&lt;stdio.h&gt;#include&lt;stdbool.h&gt;#include&lt;stdlib.h&gt;typedef struct LNode&#123;  //LNode:结点    int data;  //数据域：每个结点存放一个数据元素    struct LNode *next;  //指针域：指针指向下一个结点&#125;LNode,*LinkList;  //typedef struct LNode *LinkList;  要表示一个单链表时，只需声明一个头指针L，指向单链表的第一个结点//初始化一个单链表(带头结点)bool InitList(LinkList *L)&#123;    (*L)=(LNode *)malloc(sizeof(LNode));  //分配一个头结点,并使得头指针*L指向这个头结点    if((*L) == NULL)&#123;  //内存不足，分配失败        return false;    &#125;    (*L)-&gt;data=0;  //头结点不存储数据    (*L)-&gt;next=NULL;  //头结点之后暂时还没有结点    return true;&#125;//按值查找，找到数据域==e的结点(带头结点)LNode * LocateElem(LinkList *L,int e)&#123;        LNode *p =(*L)-&gt;next;        //从第1个结点开始查找数据域为e的结点    while(p != NULL &amp;&amp; p-&gt;data != e)&#123;        p=p-&gt;next;    &#125;        return p;  //找到后返回该结点指针，否则返回NULL&#125;//求表的长度（时间复杂度O(n)）int Length(LinkList *L)&#123;    int len=0;  //统计表长    LNode *p=*L;    while(p-&gt;next != NULL)&#123;        p=p-&gt;next;        len++;    &#125;    return len;&#125;int main()&#123;        LinkList L;  //等价于LNode *L;  声明一个指向单链表的第一个结点的指针，注意此处并没有创建一个结点    InitList(&amp;L);  //初始化一个空表        //...后续代码        LNode * a=LocateElem(&amp;L, 3);  //找到数据域为3的结点，并返回        int b=Length(&amp;L);  //返回表的长度&#125;\n","categories":["计算机理论"],"tags":["数据结构-数据结构笔记"]},{"title":"单链表的建立","url":"/2019/03/15/%E8%AE%A1%E7%AE%97%E6%9C%BA%E7%90%86%E8%AE%BA/%E6%95%B0%E6%8D%AE%E7%BB%93%E6%9E%84/%E6%95%B0%E6%8D%AE%E7%BB%93%E6%9E%84%E7%AC%94%E8%AE%B0/2.8_%E5%8D%95%E9%93%BE%E8%A1%A8%E7%9A%84%E5%BB%BA%E7%AB%8B/","content":"如果给你很多个数据元素，要把它们存到一个空单链表里？\n尾插法(带头结点)，时间复杂度为O(n)：将数据元素一个一个的插入到单链表的尾部\n#include&lt;stdio.h&gt;#include&lt;stdbool.h&gt;#include&lt;stdlib.h&gt;typedef struct LNode&#123;  //LNode:结点    int data;  //数据域：每个结点存放一个数据元素    struct LNode *next;  //指针域：指针指向下一个结点&#125;LNode,*LinkList;  //typedef struct LNode *LinkList;  要表示一个单链表时，只需声明一个头指针L，指向单链表的第一个结点//初始化一个单链表(带头结点)bool InitList(LinkList *L)&#123;    (*L)=(LNode *)malloc(sizeof(LNode));  //分配一个头结点,并使得头指针*L指向这个头结点    if((*L) == NULL)&#123;  //内存不足，分配失败        return false;    &#125;    (*L)-&gt;data=0;  //头结点不存储数据    (*L)-&gt;next=NULL;  //头结点之后暂时还没有结点    return true;&#125;//尾插法建立单链表LinkList List_TailInsert(LinkList *L)&#123;    int x;    LNode *s,*r=*L;  //r为表尾指针    scanf(&quot;%d\\n&quot;,&amp;x);  //输入结点的值        while(x != 9999)&#123;  //输入9999表示结束        s=(LNode *)malloc(sizeof(LNode));        s-&gt;data=x;        r-&gt;next=s;        r=s;  //r指向新的表尾结点，永远保持r指向最后一个结点        scanf(&quot;%d\\n&quot;,&amp;x);    &#125;    r-&gt;next=NULL;  //尾结点指针置空    return *L;&#125;int main()&#123;        LinkList L;  //等价于LNode *L;  声明一个指向单链表的第一个结点的指针，注意此处并没有创建一个结点    InitList(&amp;L);  //初始化一个空表        LinkList a=List_TailInsert(&amp;L);        //...后续代码&#125;\n\n头插法(带头结点)：将数据元素一个一个的插入到头结点之后(逆向建立单链表)，注意是每一个数据元素都放到头结点后一个的位置\n#include&lt;stdio.h&gt;#include&lt;stdbool.h&gt;#include&lt;stdlib.h&gt;typedef struct LNode&#123;  //LNode:结点    int data;  //数据域：每个结点存放一个数据元素    struct LNode *next;  //指针域：指针指向下一个结点&#125;LNode,*LinkList;  //typedef struct LNode *LinkList;  要表示一个单链表时，只需声明一个头指针L，指向单链表的第一个结点//初始化一个单链表(带头结点)bool InitList(LinkList *L)&#123;    (*L)=(LNode *)malloc(sizeof(LNode));  //分配一个头结点,并使得头指针*L指向这个头结点    if((*L) == NULL)&#123;  //内存不足，分配失败        return false;    &#125;    (*L)-&gt;data=0;  //头结点不存储数据    (*L)-&gt;next=NULL;  //头结点之后暂时还没有结点    return true;&#125;//头插法建立单链表LinkList List_HeadInsert(LinkList *L)&#123;    int x;    LNode *s;    scanf(&quot;%d\\n&quot;,&amp;x);  //输入结点的值        while(x != 9999)&#123;  //输入9999表示结束        s=(LNode *)malloc(sizeof(LNode));        s-&gt;data=x;        s-&gt;next=(*L)-&gt;next;  //s-&gt;next指向NULL        (*L)-&gt;next=s;  //将新结点插入表中，L为头指针        scanf(&quot;%d\\n&quot;,&amp;x);    &#125;    return *L;&#125;int main()&#123;        LinkList L;  //等价于LNode *L;  声明一个指向单链表的第一个结点的指针，注意此处并没有创建一个结点    InitList(&amp;L);  //初始化一个空表        LinkList a=List_HeadInsert(&amp;L);        //...后续代码&#125;\n","categories":["计算机理论"],"tags":["数据结构-数据结构笔记"]},{"title":"顺序表的查找","url":"/2019/03/15/%E8%AE%A1%E7%AE%97%E6%9C%BA%E7%90%86%E8%AE%BA/%E6%95%B0%E6%8D%AE%E7%BB%93%E6%9E%84/%E6%95%B0%E6%8D%AE%E7%BB%93%E6%9E%84%E7%AC%94%E8%AE%B0/2.4_%E9%A1%BA%E5%BA%8F%E8%A1%A8%E7%9A%84%E6%9F%A5%E6%89%BE/","content":"顺序表的按位查找(时间复杂度：O(1))GetElem(L,i)：按位查找操作，获取表L中第i个位置的元素的值\n静态分配：\n//顺序表的按位查找（静态分配）#include &lt;stdio.h&gt;#define MaxSize 10  //定义最大长度typedef struct&#123;    int data[MaxSize];  //用静态的“数组”存放数据元素    int length;  //顺序表的当前长度&#125;SqList;  //顺序表的类型定义//基本操作：初始化一个顺序表void InitList(SqList *L)&#123;    for(int i=0;i&lt;MaxSize;i++)&#123;        L-&gt;data[i]=0;  //将所有数据元素设置为默认初始值    &#125;    L-&gt;length=0;  //顺序表初始长度为0&#125;int GetElem(SqList *L,int i)&#123;        return L-&gt;data[i-1];&#125;int main()&#123;        SqList L;  //声明一个顺序表    InitList(&amp;L);  //初始化顺序表        //...此处插入几个元素        int num=GetElem(&amp;L, 3); //查找表L中第3个位置的元素的值        return 0;&#125;\n\n动态分配：\n//顺序表的按位查找（动态分配）#include &lt;stdio.h&gt;#include &lt;stdlib.h&gt;#define InitSize 10  //默认的最大长度typedef struct&#123;    int *data;  //指示动态分配数组的指针    int MaxSize;  //顺序表的最大容量    int length;  //顺序表的当前长度&#125;SeqList;void InitList(SeqList *L)&#123;    //用malloc函数申请一片连续的存储空间    L-&gt;data=(int *)malloc(InitSize*sizeof(int));    L-&gt;length=0;    L-&gt;MaxSize=InitSize;&#125;int GetElem(SeqList *L,int i)&#123;        return L-&gt;data[i-1];&#125;int main()&#123;    SeqList L;  //声明一个顺序表    InitList(&amp;L);  //初始化顺序表    //...往顺序表加入几个元素        int num=GetElem(&amp;L, 3);  //查找表L中第3个位置的元素的值    return 0;&#125;\n\n顺序表的按值查找(最好O(1),最坏O(n),平均O(n))LocateElem(L,e)：按值查找操作，在表L中查找具有给定关键字值的元素\n\n//顺序表的按值查找#include &lt;stdio.h&gt;#include &lt;stdlib.h&gt;#define InitSize 10  //默认的最大长度typedef struct&#123;    int *data;  //指示动态分配数组的指针    int MaxSize;  //顺序表的最大容量    int length;  //顺序表的当前长度&#125;SeqList;void InitList(SeqList *L)&#123;    //用malloc函数申请一片连续的存储空间    L-&gt;data=(int *)malloc(InitSize*sizeof(int));    L-&gt;length=0;    L-&gt;MaxSize=InitSize;&#125;//在顺序表L中查找第一个元素值等于e的元素，并返回其位序int LocateElem(SeqList *L,int e)&#123;        for(int i=0;i&lt;L-&gt;length;i++)&#123;        if(L-&gt;data[i] == e)&#123;            return i+1;  //数组下标为i的元素值等于e，返回其位序i+1        &#125;    &#125;    return 0;  //退出循环，说明查找失败&#125;int main()&#123;    SeqList L;  //声明一个顺序表    InitList(&amp;L);  //初始化顺序表    //...往顺序表加入几个元素        int num=LocateElem(&amp;L, 3);  //查找表L中第3个位置的元素的值    return 0;&#125;\n","categories":["计算机理论"],"tags":["数据结构-数据结构笔记"]},{"title":"顺序表的定义","url":"/2019/03/15/%E8%AE%A1%E7%AE%97%E6%9C%BA%E7%90%86%E8%AE%BA/%E6%95%B0%E6%8D%AE%E7%BB%93%E6%9E%84/%E6%95%B0%E6%8D%AE%E7%BB%93%E6%9E%84%E7%AC%94%E8%AE%B0/2.2_%E9%A1%BA%E5%BA%8F%E8%A1%A8%E7%9A%84%E5%AE%9A%E4%B9%89/","content":"顺序表：用顺序存储的方式实现线性表，每个结点中只存放数据元素\n顺序表的特点：\n\n随机访问，即可以在O(1)时间内找到第i个元素\n存储密度高，每个节点只存储数据元素\n拓展容量不方便（即便采用动态分配的方式实现，拓展长度的时间复杂度也比较高）\n插入、删除操作不方便，需要移动大量元素\n\n顺序表的实现（静态分配）：\n//顺序表的静态分配#include &lt;stdio.h&gt;#define MaxSize 10  //定义最大长度typedef struct&#123;    int data[MaxSize];  //用静态的“数组”存放数据元素    int length;  //顺序表的当前长度&#125;SqList;  //顺序表的类型定义//基本操作：初始化一个顺序表void InitList(SqList *L)&#123;    for(int i=0;i&lt;MaxSize;i++)&#123;        L-&gt;data[i]=0;  //将所有数据元素设置为默认初始值    &#125;    L-&gt;length=0;  //顺序表初始长度为0&#125;int main()&#123;        SqList L;  //声明一个顺序表    InitList(&amp;L);  //初始化顺序表        //...未完待续，后续操作    return 0;&#125;\n\n顺序表的实现（动态分配）：\n//顺序表的动态分配#include &lt;stdio.h&gt;#include &lt;stdlib.h&gt;#define InitSize 10  //默认的最大长度typedef struct&#123;    int *data;  //指示动态分配数组的指针    int MaxSize;  //顺序表的最大容量    int length;  //顺序表的当前长度&#125;SeqList;void InitList(SeqList *L)&#123;    //用malloc函数申请一片连续的存储空间    L-&gt;data=(int *)malloc(InitSize*sizeof(int));    L-&gt;length=0;    L-&gt;MaxSize=InitSize;&#125;//增加动态数组的长度void IncreaseSize(SeqList *L,int len)&#123;    int *p=L-&gt;data;    L-&gt;data=(int *)malloc((L-&gt;MaxSize+len)*sizeof(int));    for(int i=0;i&lt;L-&gt;length;i++)&#123;        L-&gt;data[i]=p[i];  //将数据复制到新区域    &#125;    L-&gt;MaxSize=L-&gt;MaxSize+len;  //顺序表最大长度增加len    free(p);  //释放原来的内存空间&#125;int main()&#123;    SeqList L;  //声明一个顺序表    InitList(&amp;L);  //初始化顺序表    //往顺序表加入几个元素，加满    IncreaseSize(&amp;L,5);    return 0;&#125;\n","categories":["计算机理论"],"tags":["数据结构-数据结构笔记"]},{"title":"单链表的插入和删除","url":"/2019/03/15/%E8%AE%A1%E7%AE%97%E6%9C%BA%E7%90%86%E8%AE%BA/%E6%95%B0%E6%8D%AE%E7%BB%93%E6%9E%84/%E6%95%B0%E6%8D%AE%E7%BB%93%E6%9E%84%E7%AC%94%E8%AE%B0/2.6_%E5%8D%95%E9%93%BE%E8%A1%A8%E7%9A%84%E6%8F%92%E5%85%A5%E5%92%8C%E5%88%A0%E9%99%A4/","content":"单链表的插入按位序插入（带头结点）：在表L中的第i个位置上插入指定元素e（最好O(1),最坏O(n),平均O(n)）\n\n#include&lt;stdio.h&gt;#include&lt;stdbool.h&gt;#include&lt;stdlib.h&gt;typedef struct LNode&#123;  //LNode:结点    int data;  //数据域：每个结点存放一个数据元素    struct LNode *next;  //指针域：指针指向下一个结点&#125;LNode,*LinkList;  //typedef struct LNode *LinkList;  要表示一个单链表时，只需声明一个头指针L，指向单链表的第一个结点//初始化一个单链表(带头结点)bool InitList(LinkList *L)&#123;    (*L)=(LNode *)malloc(sizeof(LNode));  //分配一个头结点,并使得头指针*L指向这个头结点    if((*L) == NULL)&#123;  //内存不足，分配失败        return false;    &#125;    (*L)-&gt;data=0;  //头结点不存储数据    (*L)-&gt;next=NULL;  //头结点之后暂时还没有结点    return true;&#125;//在第i个位置插入元素e(带头结点)bool ListInsert(LinkList *L,int i,int e)&#123;    if(i&lt;1)&#123;        return false;    &#125;    LNode *p;  //指针p指向当前扫描到的结点    int j=0;  //当前p指向的是第几个结点    p=*L;  //L指向头结点，头结点是第0个结点(不存数据)        while(p != NULL &amp;&amp; j&lt;i-1)&#123;  //循环找到第i-1个结点        p=p-&gt;next;        j++;    &#125;    if(p == NULL)&#123;  //i值不合法        return false;    &#125;        LNode *s=(LNode *)malloc(sizeof(LNode));    s-&gt;data=e;    s-&gt;next=p-&gt;next;  //这行代码跟下一行代码顺序不能调换    p-&gt;next=s;  //将结点s连到p之后        return true;  //插入成功&#125;int main()&#123;        LinkList L;  //等价于LNode *L;  声明一个指向单链表的第一个结点的指针，注意此处并没有创建一个结点    InitList(&amp;L);  //初始化一个空表        //...后续代码    if(ListInsert(&amp;L, 2, 3))&#123;  //在第2个位置插入元素3        printf(&quot;插入成功&quot;);    &#125;    else&#123;        printf(&quot;插入失败&quot;);    &#125;&#125;\n\n按位序插入(不带头结点)：因为不存在“第0个”结点，因此i&#x3D;1时需要特殊处理\n\n#include&lt;stdio.h&gt;#include&lt;stdbool.h&gt;#include&lt;stdlib.h&gt;typedef struct LNode&#123;  //LNode:结点    int data;  //数据域：每个结点存放一个数据元素    struct LNode *next;  //指针域：指针指向下一个结点&#125;LNode,*LinkList;  //typedef struct LNode *LinkList;  要表示一个单链表时，只需声明一个头指针L，指向单链表的第一个结点//初始化一个空的链表(不带头结点)bool InitList(LinkList *L)&#123;    (*L)=NULL;  //空表，暂时还没有任何结点，防止脏数据    return true;&#125;//在第i个位置插入元素e(不带头结点)bool ListInsert(LinkList *L,int i,int e)&#123;    if(i&lt;1)&#123;        return false;    &#125;        //如果不带头结点，则插入、删除第1个元素时，需要更改头指针L    if(i == 1)&#123;  //插入第1个结点的操作与其他结点操作不同        LNode *s = (LNode *)malloc(sizeof(LNode));        s-&gt;data=e;        s-&gt;next=*L;        *L=s;  //头指针指向新结点        return true;    &#125;        LNode *p;  //指针p指向当前扫描到的结点    int j=0;  //当前p指向的是第几个结点    p=*L;  //L指向头结点，头结点是第0个结点(不存数据)        while(p != NULL &amp;&amp; j&lt;i-1)&#123;  //循环找到第i-1个结点        p=p-&gt;next;        j++;    &#125;    if(p == NULL)&#123;  //i值不合法        return false;    &#125;        LNode *s=(LNode *)malloc(sizeof(LNode));    s-&gt;data=e;    s-&gt;next=p-&gt;next;  //这行代码跟下一行代码顺序不能调换    p-&gt;next=s;  //将结点s连到p之后        return true;  //插入成功&#125;int main()&#123;        LinkList L;  //等价于LNode *L;  声明一个指向单链表的第一个结点的指针，注意此处并没有创建一个结点    InitList(&amp;L);  //初始化一个空表        //...后续代码    if(ListInsert(&amp;L, 2, 3))&#123;  //在第2个位置插入元素3        printf(&quot;插入成功&quot;);    &#125;    else&#123;        printf(&quot;插入失败&quot;);    &#125;&#125;\n\n指定结点的后插操作（O(1)）：\n\n#include&lt;stdio.h&gt;#include&lt;stdbool.h&gt;#include&lt;stdlib.h&gt;typedef struct LNode&#123;  //LNode:结点    int data;  //数据域：每个结点存放一个数据元素    struct LNode *next;  //指针域：指针指向下一个结点&#125;LNode,*LinkList;  //typedef struct LNode *LinkList;  要表示一个单链表时，只需声明一个头指针L，指向单链表的第一个结点//初始化一个单链表(带头结点)bool InitList(LinkList *L)&#123;    (*L)=(LNode *)malloc(sizeof(LNode));  //分配一个头结点,并使得头指针*L指向这个头结点    if((*L) == NULL)&#123;  //内存不足，分配失败        return false;    &#125;    (*L)-&gt;data=0;  //头结点不存储数据    (*L)-&gt;next=NULL;  //头结点之后暂时还没有结点    return true;&#125;//后插操作：在p结点之后插入元素e(带头结点)bool InsertNextNode(LNode *p,int e)&#123;        if(p == NULL)&#123;  //i值不合法        return false;    &#125;        LNode *s=(LNode *)malloc(sizeof(LNode));        if(s == NULL)&#123;  //内存分配失败，某些情况下有可能分配失败（如内存不足）        return false;    &#125;        s-&gt;data=e;  //用结点s保存数据元素e    s-&gt;next=p-&gt;next;  //这行代码跟下一行代码顺序不能调换    p-&gt;next=s;  //将结点s连到p之后        return true;  //插入成功&#125;int main()&#123;        LinkList L;  //等价于LNode *L;  声明一个指向单链表的第一个结点的指针，注意此处并没有创建一个结点    InitList(&amp;L);  //初始化一个空表        //...后续代码    if(InsertNextNode(L, 3))&#123;  //在p结点位置后插入元素3        printf(&quot;插入成功&quot;);    &#125;    else&#123;        printf(&quot;插入失败&quot;);    &#125;&#125;\n\n指定结点的前插操作：在p结点之前插入元素e（O(1)）\n\n#include&lt;stdio.h&gt;#include&lt;stdbool.h&gt;#include&lt;stdlib.h&gt;typedef struct LNode&#123;  //LNode:结点    int data;  //数据域：每个结点存放一个数据元素    struct LNode *next;  //指针域：指针指向下一个结点&#125;LNode,*LinkList;  //typedef struct LNode *LinkList;  要表示一个单链表时，只需声明一个头指针L，指向单链表的第一个结点//初始化一个单链表(带头结点)bool InitList(LinkList *L)&#123;    (*L)=(LNode *)malloc(sizeof(LNode));  //分配一个头结点,并使得头指针*L指向这个头结点    if((*L) == NULL)&#123;  //内存不足，分配失败        return false;    &#125;    (*L)-&gt;data=0;  //头结点不存储数据    (*L)-&gt;next=NULL;  //头结点之后暂时还没有结点    return true;&#125;//前插操作：在p结点之前插入元素e(带头结点)bool InsertPriorNode(LNode *p,int e)&#123;        if(p == NULL)&#123;  //i值不合法        return false;    &#125;        LNode *s=(LNode *)malloc(sizeof(LNode));        if(s == NULL)&#123;  //内存分配失败，某些情况下有可能分配失败（如内存不足）        return false;    &#125;        s-&gt;next=p-&gt;next;    p-&gt;next=s;  //新结点s连到p之后    s-&gt;data=p-&gt;data;  //将p中元素复制到s中    p-&gt;data=e;  //p中元素覆盖为e        return true;  //插入成功&#125;int main()&#123;        LinkList L;  //等价于LNode *L;  声明一个指向单链表的第一个结点的指针，注意此处并没有创建一个结点    InitList(&amp;L);  //初始化一个空表        //...后续代码    if(InsertPriorNode(L, 3))&#123;  //在p结点位置前插入元素3        printf(&quot;插入成功&quot;);    &#125;    else&#123;        printf(&quot;插入失败&quot;);    &#125;&#125;\n\n单链表的删除按位序删除(带头结点，最坏、平均O(n),最好O(1))：删除表L中第i个位置的元素，并用e返回删除元素的值（找到第i-1个结点，并将其指针指向第i+1个结点，并释放第i个结点）\n\n#include&lt;stdio.h&gt;#include&lt;stdbool.h&gt;#include&lt;stdlib.h&gt;typedef struct LNode&#123;  //LNode:结点    int data;  //数据域：每个结点存放一个数据元素    struct LNode *next;  //指针域：指针指向下一个结点&#125;LNode,*LinkList;  //typedef struct LNode *LinkList;  要表示一个单链表时，只需声明一个头指针L，指向单链表的第一个结点//初始化一个单链表(带头结点)bool InitList(LinkList *L)&#123;    (*L)=(LNode *)malloc(sizeof(LNode));  //分配一个头结点,并使得头指针*L指向这个头结点    if((*L) == NULL)&#123;  //内存不足，分配失败        return false;    &#125;    (*L)-&gt;data=0;  //头结点不存储数据    (*L)-&gt;next=NULL;  //头结点之后暂时还没有结点    return true;&#125;//按位序删除(带头结点)bool ListDelete(LinkList *L,int i,int *e)&#123;        if(i&lt;1)&#123;        return false;    &#125;    LNode *p;  //指针p指向当前扫描到的结点    int j=0;  //当前p指向的是第几个结点    p=*L;  //L指向头结点，头结点是第0个结点(不存数据)        while(p != NULL &amp;&amp; j&lt;i-1)&#123;  //循环找到第i-1个结点        p=p-&gt;next;        j++;    &#125;    if(p == NULL)&#123;  //i值不合法        return false;    &#125;        if(p-&gt;next == NULL)&#123;  //在第i-1个结点之后已无其他结点        return false;    &#125;        LNode *q=p-&gt;next;  //令q指向被删除结点    *e=q-&gt;data;  //用e返回元素的值    p-&gt;next=q-&gt;next;  //将*q结点从链中断开    free(q);  //释放结点的存储空间        return true;  //删除成功&#125;int main()&#123;        LinkList L;  //等价于LNode *L;  声明一个指向单链表的第一个结点的指针，注意此处并没有创建一个结点    InitList(&amp;L);  //初始化一个空表        //...后续代码    int e=-1;  //用变量e把删除的元素“带回来”    if(ListDelete(&amp;L, 2, &amp;e))&#123;        printf(&quot;已删除第2个元素，删除元素值为%d\\n&quot;,e);    &#125;    else&#123;        printf(&quot;删除失败\\n&quot;);    &#125;&#125;\n\n指定结点的删除（O(1)）：\n\n#include&lt;stdio.h&gt;#include&lt;stdbool.h&gt;#include&lt;stdlib.h&gt;typedef struct LNode&#123;  //LNode:结点    int data;  //数据域：每个结点存放一个数据元素    struct LNode *next;  //指针域：指针指向下一个结点&#125;LNode,*LinkList;  //typedef struct LNode *LinkList;  要表示一个单链表时，只需声明一个头指针L，指向单链表的第一个结点//初始化一个单链表(带头结点)bool InitList(LinkList *L)&#123;    (*L)=(LNode *)malloc(sizeof(LNode));  //分配一个头结点,并使得头指针*L指向这个头结点    if((*L) == NULL)&#123;  //内存不足，分配失败        return false;    &#125;    (*L)-&gt;data=0;  //头结点不存储数据    (*L)-&gt;next=NULL;  //头结点之后暂时还没有结点    return true;&#125;//删除指定结点p(带头结点)//如果p是最后一个结点，这段代码就有点问题了，解决办法只能从表头开始依次寻找p的前驱，时间复杂度为O(n)//单链表的局限性：无法逆向检索，有时候不太方便bool DeleteNode(LNode *p)&#123;        if(p == NULL)&#123;        return false;    &#125;        LNode *q=p-&gt;next;  //令q指向*p的后继结点    p-&gt;data=p-&gt;next-&gt;data;  //和后继结点交换数据域    p-&gt;next=q-&gt;next;  //将*q结点从链中“断开”    free(q);  //释放后继结点的存储空间        return true;  //删除成功&#125;int main()&#123;        LinkList L;  //等价于LNode *L;  声明一个指向单链表的第一个结点的指针，注意此处并没有创建一个结点    InitList(&amp;L);  //初始化一个空表        //...后续代码        if(DeleteNode(L))&#123;        printf(&quot;删除成功\\n&quot;);    &#125;    else&#123;        printf(&quot;删除失败\\n&quot;);    &#125;&#125;\n","categories":["计算机理论"],"tags":["数据结构-数据结构笔记"]},{"title":"队列的应用","url":"/2019/03/15/%E8%AE%A1%E7%AE%97%E6%9C%BA%E7%90%86%E8%AE%BA/%E6%95%B0%E6%8D%AE%E7%BB%93%E6%9E%84/%E6%95%B0%E6%8D%AE%E7%BB%93%E6%9E%84%E7%AC%94%E8%AE%B0/3.11_%E9%98%9F%E5%88%97%E7%9A%84%E5%BA%94%E7%94%A8/","content":"队列的应用：\n\n树的层次遍历\n图的广度优先遍历\n队列在操作系统中的应用：多个进程争抢着使用有限的系统资源时，FCFS（First Come First Service，先来先服务）是一种常用策略\n打印数据缓冲区：打印机缓冲区用“队列”组织打印数据，可缓解主机与打印机速度不匹配的问题【先来先打印】\n\n","categories":["计算机理论"],"tags":["数据结构-数据结构笔记"]},{"title":"栈在递归中的应用","url":"/2019/03/15/%E8%AE%A1%E7%AE%97%E6%9C%BA%E7%90%86%E8%AE%BA/%E6%95%B0%E6%8D%AE%E7%BB%93%E6%9E%84/%E6%95%B0%E6%8D%AE%E7%BB%93%E6%9E%84%E7%AC%94%E8%AE%B0/3.10_%E6%A0%88%E5%9C%A8%E9%80%92%E5%BD%92%E4%B8%AD%E7%9A%84%E5%BA%94%E7%94%A8/","content":"递归函数调用的特点：最后被调用的函数最先执行结束(LIFO)\n函数调用时，需要用一个栈存储：调用返回地址、实参、局部变量\n适合用“递归”算法解决：可以把原始问题转换为属性相同，但规模较小的问题\n递归调用时，函数调用栈可称为“递归工作栈”，每进入一层递归，就将递归调用所需信息压入栈顶，每退出一层递归，就从栈顶弹出相应信息【缺点：效率低，太多层递归可能会导致栈溢出，可能包含很多重复计算】\n\n","categories":["计算机理论"],"tags":["数据结构-数据结构笔记"]},{"title":"特殊矩阵的压缩存储","url":"/2019/03/15/%E8%AE%A1%E7%AE%97%E6%9C%BA%E7%90%86%E8%AE%BA/%E6%95%B0%E6%8D%AE%E7%BB%93%E6%9E%84/%E6%95%B0%E6%8D%AE%E7%BB%93%E6%9E%84%E7%AC%94%E8%AE%B0/3.12_%E7%89%B9%E6%AE%8A%E7%9F%A9%E9%98%B5%E7%9A%84%E5%8E%8B%E7%BC%A9%E5%AD%98%E5%82%A8/","content":"普通矩阵的存储：可用二维数组存储【描述矩阵元素时，行、列号通常从1开始，而描述数组时通常下标从0开始】\n特殊矩阵（某些特殊矩阵可以压缩存储空间）：\n\n对称矩阵\n\n三角矩阵\n\n三对角矩阵\n\n稀疏矩阵\n\n\n","categories":["计算机理论"],"tags":["数据结构-数据结构笔记"]},{"title":"栈的基本概念","url":"/2019/03/15/%E8%AE%A1%E7%AE%97%E6%9C%BA%E7%90%86%E8%AE%BA/%E6%95%B0%E6%8D%AE%E7%BB%93%E6%9E%84/%E6%95%B0%E6%8D%AE%E7%BB%93%E6%9E%84%E7%AC%94%E8%AE%B0/3.1_%E6%A0%88%E7%9A%84%E5%9F%BA%E6%9C%AC%E6%A6%82%E5%BF%B5/","content":"栈(Stack)是只允许在一端进行插入或删除操作的线性表【空栈、栈顶：允许插入和删除的一端、栈底：不允许插入和删除的一端】\n特点：后进先出【Last In First Out(LIFO)】\n栈的基本操作：\n\nInitStack(&amp;S)：初始化栈，构造一个空栈S，分配内存空间\n\nDestroyStack(&amp;L)：销毁栈，销毁并释放栈S所占用的内存空间\n\nPush(&amp;S,x)：进栈，若栈S未满，则将x加入使之成为新栈顶\n\nPop(&amp;S,&amp;x)：出栈，若栈S非空，则弹出栈顶元素，并用x返回【删除栈顶元素】\n\nGetTop(S,&amp;x)：读栈顶元素，若栈S非空，则用x返回栈顶元素【不删除栈顶元素，查栈的使用场景中大多只访问栈顶元素】\n\nStackEmpty(S)：判读一个栈S是否为空，若S为空，则返回true，否则返回false\n\n\n","categories":["计算机理论"],"tags":["数据结构-数据结构笔记"]},{"title":"队列的基本概念","url":"/2019/03/15/%E8%AE%A1%E7%AE%97%E6%9C%BA%E7%90%86%E8%AE%BA/%E6%95%B0%E6%8D%AE%E7%BB%93%E6%9E%84/%E6%95%B0%E6%8D%AE%E7%BB%93%E6%9E%84%E7%AC%94%E8%AE%B0/3.4_%E9%98%9F%E5%88%97%E7%9A%84%E5%9F%BA%E6%9C%AC%E6%A6%82%E5%BF%B5/","content":"队列的定义：是只允许在一端进行插入，在另一端删除的线性表【空队列、队头：允许删除的一端、队尾：允许插入的一端】\n特点：先进入队列的元素先出队【First In First Out(FIFO)】\n队列的基本操作：\n\nInitQueue(&amp;Q)：初始化队列，构造一个空队列Q\n\nDestroyQueue(&amp;Q)：销毁队列，销毁并释放队列Q所占用的内存空间\n\nEnQueue(&amp;Q,x)：入队，若队列Q未满，则将x加入使之成为新队尾\n\nDeQueue(&amp;Q,&amp;x)：出队，若队列Q非空，则删除队头元素，并用x返回【删除队头元素】\n\nGetHead(Q,&amp;x)：读队头元素，若队列Q非空，则用x返回队头元素【不删除队头元素，查队列的使用场景中大多只访问队头元素】\n\nQueueEmpty(Q)：判断一个队列是否为空，若Q为空，则返回true，否则返回false\n\n\n","categories":["计算机理论"],"tags":["数据结构-数据结构笔记"]},{"title":"双链表","url":"/2019/03/15/%E8%AE%A1%E7%AE%97%E6%9C%BA%E7%90%86%E8%AE%BA/%E6%95%B0%E6%8D%AE%E7%BB%93%E6%9E%84/%E6%95%B0%E6%8D%AE%E7%BB%93%E6%9E%84%E7%AC%94%E8%AE%B0/2.9_%E5%8F%8C%E9%93%BE%E8%A1%A8/","content":"单链表：无法逆向检索，有时候不太方便双链表：可进可退，但存储密度要更低一点\n双链表的初始化、插入、删除(带头结点)：\n#include&lt;stdio.h&gt;#include&lt;stdbool.h&gt;#include&lt;stdlib.h&gt;typedef struct DNode&#123;    int data;  //数据域    struct DNode *prior,*next;  //指针域&#125;DNode,*DLinklist;  //DLinklist等价于DNode *//初始化双链表bool InitDLinkList(DLinklist *L)&#123;    (*L)=(DNode *)malloc(sizeof(DNode));  //分配一个头结点    if((*L) == NULL)&#123;  //内存不足，分配失败        return false;    &#125;        (*L)-&gt;prior=NULL;  //头结点的prior永远指向NULL    (*L)-&gt;next=NULL;  //头结点之后暂时还没有结点    return true;&#125;//判断双链表是否为空(带头结点)bool Empty(DLinklist *L)&#123;    if((*L)-&gt;next == NULL)&#123;        return true;    &#125;    else&#123;        return false;    &#125;&#125;//双链表的插入//在p结点之后插入s结点//如果要按位序插入，只需要从头结点找到这个位序的前驱结点，然后对这个前驱结点进行后插操作//前插操作也是找到该结点的前驱结点，然后对这个前驱结点进行后插操作bool InsertNextDNode(DNode *p,DNode *s)&#123;    if(p == NULL || s == NULL)&#123;  //非法参数        return false;    &#125;        s-&gt;next=p-&gt;next;  //将结点*s插入到结点*p之后    if(p-&gt;next != NULL)&#123;  //如果p结点有后继结点[如果是循环双链表，没有这个条件判断也是正确的]        p-&gt;next-&gt;prior=s;    &#125;    s-&gt;prior=p;    p-&gt;next=s;    return true;&#125;//双链表的删除//删除p结点的后继结点bool DeleteNextDNode(DNode *p)&#123;    if(p == NULL)&#123;        return false;    &#125;    DNode *q=p-&gt;next;  //找到p的后继结点q    if(q == NULL)&#123;        return false;  //p没有后继    &#125;        p-&gt;next=q-&gt;next;    if(q-&gt;next != NULL)&#123;  //q结点不是最后一个结点        q-&gt;next-&gt;prior=p;    &#125;    free(q);  //释放结点空间    return true;&#125;//销毁一个双链表void DestoryList(DLinklist *L)&#123;    //循环释放各个数据结点    while((*L)-&gt;next != NULL)&#123;        DeleteNextDNode(*L);    &#125;    free(L);  //释放头结点    L=NULL;  //头指针指向NULL&#125;int main()&#123;        DLinklist L;    InitDLinkList(&amp;L);  //初始化双链表        //...后续代码&#125;\n\n双链表的遍历[双链表不可随机存取，按位查找，按值查找操作都只能用遍历的方式实现，时间复杂度O(n)]\n//后向遍历while(p != NULL)&#123;    p=p-&gt;next;&#125;//前向遍历while(p != NULL)&#123;    p=p-&gt;prior;&#125;//前向遍历，跳过头结点while(p-&gt;prior != NULL)&#123;    p=p-&gt;prior;&#125;","categories":["计算机理论"],"tags":["数据结构-数据结构笔记"]},{"title":"栈的链式存储实现","url":"/2019/03/15/%E8%AE%A1%E7%AE%97%E6%9C%BA%E7%90%86%E8%AE%BA/%E6%95%B0%E6%8D%AE%E7%BB%93%E6%9E%84/%E6%95%B0%E6%8D%AE%E7%BB%93%E6%9E%84%E7%AC%94%E8%AE%B0/3.3_%E6%A0%88%E7%9A%84%E9%93%BE%E5%BC%8F%E5%AD%98%E5%82%A8%E5%AE%9E%E7%8E%B0/","content":"进栈操作：头插法建立单链表(对头结点的后插操作)\n出栈操作：单链表的删除操作(对头结点的后删操作)\n//链栈的定义(带头结点的初始化，不带头结点的初始化)typedef struct Linknode&#123;   int data;  //数据域   struct Linknode *next;  //指针域&#125;*Listack;\n\n","categories":["计算机理论"],"tags":["数据结构-数据结构笔记"]},{"title":"队列的顺序实现","url":"/2019/03/15/%E8%AE%A1%E7%AE%97%E6%9C%BA%E7%90%86%E8%AE%BA/%E6%95%B0%E6%8D%AE%E7%BB%93%E6%9E%84/%E6%95%B0%E6%8D%AE%E7%BB%93%E6%9E%84%E7%AC%94%E8%AE%B0/3.5_%E9%98%9F%E5%88%97%E7%9A%84%E9%A1%BA%E5%BA%8F%E5%AE%9E%E7%8E%B0/","content":"\n#include&lt;stdio.h&gt;#include&lt;stdbool.h&gt;#include&lt;stdlib.h&gt;#define MaxSize 10  //定义队列中元素的最大个数//队列的顺序实现【front指向队头元素，rear指向队尾元素的后一个位置；还有一种情况是rear指向队尾元素】typedef struct&#123;    int data[MaxSize];  //用静态数组存放队列元素    int front,rear;  //队头指针和队尾指针        //int size;  //第二种判断队列已满/已空的方法，定义一个size：队列当前长度    //int tag;  //第三种判断队列已满/已空的方法：最近进行的是删除还是插入&#125;SqQueue;//初始化队列void InitQueue(SqQueue *Q)&#123;    Q-&gt;front=Q-&gt;rear=0;  //初始时队头、队尾指针指向0        //Q-&gt;size=0;  //第二种判断队列已满/已空的方法，插入成功size++，删除成功size--,队空条件:size==0，队满条件：size==MaxSize        //Q-&gt;tag=0;  //第三种判断队列已满/已空的方法：每次删除操作成功时，都令tag=0,每次插入操作成功时都令tag=1；只有删除操作，才可能导致队空，只有插入操作，才可能导致队满；队空条件：front==rear &amp;&amp; tag==0，队满条件：front==rear &amp;&amp; tag==1&#125;//判断队列是否为空bool QueueEmpty(SqQueue *Q)&#123;    if(Q-&gt;rear==Q-&gt;front)&#123;  //队空条件        return true;    &#125;    else&#123;        return false;    &#125;&#125;//循环队列：入队操作bool EnQueue(SqQueue *Q,int x)&#123;    if((Q-&gt;rear+1)%MaxSize == Q-&gt;front)&#123;  //队列已满的条件：队尾指针的再下一个位置是队头，代价：牺牲一个存储单元        return false;  //队满则报错    &#125;    Q-&gt;data[Q-&gt;rear]=x;  //新元素插入队尾    Q-&gt;rear=(Q-&gt;rear+1)%MaxSize;  //队尾指针+1取模,用模运算将存储空间在逻辑上变成了“环状”        //这是rear指向队尾元素的情况    //Q-&gt;rear=(Q-&gt;rear+1)%MaxSize;    //Q-&gt;data[Q-&gt;rear]=x;    return true;&#125;//循环队列：出队操作//出队：删除一个队头元素，并用x返回bool DeQueue(SqQueue *Q,int *x)&#123;    if(Q-&gt;rear==Q-&gt;front)&#123;        return false;  //队空则报错    &#125;    (*x)=Q-&gt;data[Q-&gt;front];    Q-&gt;front=(Q-&gt;front+1)%MaxSize;  //队头指针后移    return true;&#125;//获取队头元素的值，用x返回bool GetHead(SqQueue *Q,int *x)&#123;    if(Q-&gt;rear==Q-&gt;front)&#123;        return false;    &#125;    (*x)=Q-&gt;data[Q-&gt;front];    return true;&#125;//队列元素个数：(rear+MaxSize-front)%MaxSizeint main()&#123;    SqQueue Q;  //声明一个队列，顺序存储        InitQueue(&amp;Q);        //...后续操作&#125;","categories":["计算机理论"],"tags":["数据结构-数据结构笔记"]},{"title":"双端队列","url":"/2019/03/15/%E8%AE%A1%E7%AE%97%E6%9C%BA%E7%90%86%E8%AE%BA/%E6%95%B0%E6%8D%AE%E7%BB%93%E6%9E%84/%E6%95%B0%E6%8D%AE%E7%BB%93%E6%9E%84%E7%AC%94%E8%AE%B0/3.7_%E5%8F%8C%E7%AB%AF%E9%98%9F%E5%88%97/","content":"双端队列：只允许从两端插入、两端删除的线性表【若只使用其中一端的插入、删除操作，则效果等同于栈】\n输入受限的双端队列：只允许从一端插入、两端删除的线性表\n输出受限的双端队列：只允许从两端插入、一端删除的线性表\n在栈中合法的输出序列，在双端队列中必定合法\n","categories":["计算机理论"],"tags":["数据结构-数据结构笔记"]},{"title":"栈在表达式求值中的应用","url":"/2019/03/15/%E8%AE%A1%E7%AE%97%E6%9C%BA%E7%90%86%E8%AE%BA/%E6%95%B0%E6%8D%AE%E7%BB%93%E6%9E%84/%E6%95%B0%E6%8D%AE%E7%BB%93%E6%9E%84%E7%AC%94%E8%AE%B0/3.9_%E6%A0%88%E5%9C%A8%E8%A1%A8%E8%BE%BE%E5%BC%8F%E6%B1%82%E5%80%BC%E4%B8%AD%E7%9A%84%E5%BA%94%E7%94%A8/","content":"\n可以不用界限符也能无歧义的表达运算顺序？【逆波兰表达式&#x3D;后缀表达式，波兰表达式&#x3D;前缀表达式】\n\n中缀表达式转后缀表达式：初始化一个栈，用于保存暂时还不能确定运算顺序的运算符从左到右处理各个元素，直到末尾，可能遇到三种情况：1.遇到操作数，直接加入后缀表达式2.遇到界限符，遇到“(”直接入栈，遇到“)”则依次弹出栈内运算符并加入后缀表达式，直到弹出”(“为止，注意：”(“不加入后缀表达式3.遇到运算符，依次弹出栈中优先级高于或等于当前运算符的所有运算符，并加入后缀表达式，若碰到“(”或栈空则停止，之后再把当前运算符入栈按上述方法处理完所有字符后，将栈中剩余运算符依次弹出，并加入后缀表达式\n用栈实现后缀表达式的计算：【栈是用于存放当前暂时还不能确定运算次序的操作数】1.从左到右扫描下一个元素，直到处理完所有元素2.若扫描到操作数则压入栈，并回到1；否则执行33.若扫描到运算符，则弹出两个栈顶元素，执行相应运算[注意先出栈的是右操作数]，运算结果压回栈底，回到1若表达式合法，则最后栈中只会留下一个元素，就是最终结果\n用栈实现中缀表达式的计算：（中缀转后缀+后缀表达式求值，两个算法的结合）初始化两个栈，操作数栈和运算符栈若扫描到操作数，压入操作数栈若扫描到运算符或界限符，则按照“中缀转后缀”相同相同的逻辑压入运算符栈（期间也会弹出运算符，每当弹出一个运算符时，就需要再弹出两个操作数栈的栈顶元素并执行相应运算，运算结果再压回操作数栈）\n用栈实现前缀表达式的计算：1.从右往左扫描下一个元素，直到处理完所有元素2.若扫描到操作数则压入栈，并回到1，否则执行33.若扫描到运算符，则弹出两个栈顶元素，执行相应运算[先出栈的是左操作数]，运算结果压回栈底，回到1\n","categories":["计算机理论"],"tags":["数据结构-数据结构笔记"]},{"title":"栈的顺序存储实现","url":"/2019/03/15/%E8%AE%A1%E7%AE%97%E6%9C%BA%E7%90%86%E8%AE%BA/%E6%95%B0%E6%8D%AE%E7%BB%93%E6%9E%84/%E6%95%B0%E6%8D%AE%E7%BB%93%E6%9E%84%E7%AC%94%E8%AE%B0/3.2_%E6%A0%88%E7%9A%84%E9%A1%BA%E5%BA%8F%E5%AD%98%E5%82%A8%E5%AE%9E%E7%8E%B0/","content":"顺序栈的缺点：栈的大小不可变\n#include&lt;stdio.h&gt;#include&lt;stdbool.h&gt;#include&lt;stdlib.h&gt;#define MaxSize 10  //定义栈中元素的最大个数//顺序栈的定义typedef struct&#123;    int data[MaxSize];  //静态数组存放栈中元素    int top;  //栈顶指针，top指向当前栈顶元素&#125;SqStack;  //Sq：sequence，顺序//初始化栈void InitStack(SqStack *S)&#123;    S-&gt;top=-1;  //初始化栈顶指针&#125;//判断栈空bool StackEmpty(SqStack *S)&#123;    if(S-&gt;top == -1)&#123;        return true;  //栈空    &#125;    else&#123;        return false;  //不空    &#125;&#125;//进栈操作bool Push(SqStack *S,int x)&#123;    if(S-&gt;top==MaxSize-1)&#123;        return false;  //栈满，报错    &#125;    S-&gt;top=S-&gt;top+1;  //指针先+1    S-&gt;data[S-&gt;top]=x;  //新元素入栈        return true;&#125;//出栈操作,并用x返回bool Pop(SqStack *S,int *x)&#123;    if(S-&gt;top==-1)&#123;        return false;  //栈空，报错    &#125;    (*x)=S-&gt;data[S-&gt;top];  //栈顶元素先出栈    S-&gt;top=S-&gt;top-1;  //指针再-1，数据还残留在内存中，只是逻辑上被删除了    return true;&#125;//读栈顶元素操作bool GetTop(SqStack *S,int *x)&#123;    if(S-&gt;top==-1)&#123;        return false;  //栈空，报错    &#125;    (*x)=S-&gt;data[S-&gt;top];  //x记录栈顶元素    return true;&#125;int main()&#123;    SqStack S;  //声明一个顺序栈(分配空间)    InitStack(&amp;S);        //...后续操作&#125;\n\n共享栈：\n#include&lt;stdio.h&gt;#include&lt;stdbool.h&gt;#include&lt;stdlib.h&gt;#define MaxSize 10  //定义栈中元素的最大个数//共享栈：两个栈共享同一片空间typedef struct&#123;    int data[MaxSize];  //静态数组存放栈中元素    int top0;  //0号栈顶指针    int top1;  //1号栈顶指针&#125;ShStack;//初始化栈void InitStack(ShStack *S)&#123;    S-&gt;top0=-1;  //初始化栈顶指针    S-&gt;top1=MaxSize;&#125;//栈满条件：top0+1==top1int main()&#123;    ShStack S;  //声明一个顺序栈(分配空间)    InitStack(&amp;S);        //...后续操作&#125;\n","categories":["计算机理论"],"tags":["数据结构-数据结构笔记"]},{"title":"队列的链式实现","url":"/2019/03/15/%E8%AE%A1%E7%AE%97%E6%9C%BA%E7%90%86%E8%AE%BA/%E6%95%B0%E6%8D%AE%E7%BB%93%E6%9E%84/%E6%95%B0%E6%8D%AE%E7%BB%93%E6%9E%84%E7%AC%94%E8%AE%B0/3.6_%E9%98%9F%E5%88%97%E7%9A%84%E9%93%BE%E5%BC%8F%E5%AE%9E%E7%8E%B0/","content":"顺序存储：预分配的空间耗尽时队满链式存储：一般不会队满，除非内存不足\n\n#include&lt;stdio.h&gt;#include&lt;stdbool.h&gt;#include&lt;stdlib.h&gt;//队列的链式实现(带头结点和不带头结点)typedef struct LinkNode&#123;  //链式队列结点    int data;    struct LinkNode *next;&#125;LinkNode;typedef struct&#123;  //链式队列    LinkNode *front,*rear;  //队列的队头和队尾指针        //int length;  //求队列的长度&#125;LinkQueue;//初始化队列(带头结点)void InitQueue(LinkQueue *Q)&#123;    //初始时，front、rear都指向头结点    Q-&gt;front=Q-&gt;rear=(LinkNode *)malloc(sizeof(LinkNode));    Q-&gt;front-&gt;next=NULL;&#125;//判断队列是否为空bool IsEmpty(LinkQueue *Q)&#123;    if(Q-&gt;front==Q-&gt;rear)&#123;        return true;    &#125;    else&#123;        return false;    &#125;&#125;//初始化(不带头结点)//void InitQueue(LinkQueue *Q)&#123;//    //初始时，front、rear都指向NULL//    Q-&gt;front=NULL;//    Q-&gt;rear=NULL;//&#125;//判断队列是否为空(不带头结点)//bool IsEmpty(LinkQueue *Q)&#123;//    if(Q-&gt;front==NULL)&#123;//        return true;//    &#125;//    else&#123;//        return false;//    &#125;//&#125;//新元素入队(带头结点)void EnQueue(LinkQueue *Q,int x)&#123;    LinkNode *s=(LinkNode *)malloc(sizeof(LinkNode));    s-&gt;data=x;    s-&gt;next=NULL;    Q-&gt;rear-&gt;next=s;  //新结点插入到rear之后    Q-&gt;rear=s;  //修改表尾指针&#125;//新元素入队(不带头结点)//void EnQueue(LinkQueue *Q,int x)&#123;//    LinkNode *s=(LinkNode *)malloc(sizeof(LinkNode));//    s-&gt;data=x;//    s-&gt;next=NULL;//    if(Q-&gt;front == NULL)&#123;  //在空队列中插入第一个元素//        Q-&gt;front=s;  //修改队头队尾指针//        Q-&gt;rear=s;  //不带头结点的队列，第一个元素入队时需要特别处理//    &#125;else&#123;//        Q-&gt;rear-&gt;next=s;  //新结点插入到rear之后//        Q-&gt;rear=s;  //修改rear指针//    &#125;//&#125;//队头元素出队(带头结点)bool DeQueue(LinkQueue *Q,int *x)&#123;    if(Q-&gt;front==Q-&gt;rear)&#123;        return false;  //空队    &#125;    LinkNode *p=Q-&gt;front-&gt;next;    *x=p-&gt;data;  //用变量x返回队头元素    Q-&gt;front-&gt;next=p-&gt;next;  //修改头结点的next指针    if(Q-&gt;rear==p)&#123;  //此次是最后一个结点出队        Q-&gt;rear=Q-&gt;front;  //修改rear指针    &#125;    free(p);  //释放结点空间    return true;&#125;//队头元素出队(不带头结点)//bool DeQueue(LinkQueue *Q,int *x)&#123;//    if(Q-&gt;front==NULL)&#123;//        return false;  //空队//    &#125;//    LinkNode *p=Q-&gt;front;  //p指向此次出队的结点//    *x=p-&gt;data;  //用变量x返回队头元素//    Q-&gt;front=p-&gt;next;  //修改front指针//    if(Q-&gt;rear==p)&#123;  //此次是最后一个结点出队//        Q-&gt;front=NULL;  //front指向NULL//        Q-&gt;rear=NULL;  //rear指向NULL//    &#125;//    free(p);  //释放结点空间//    return true;//&#125;int main()&#123;    LinkQueue Q;  //声明一个队列    InitQueue(&amp;Q);  //初始化队列        //...后续操作&#125;\n","categories":["计算机理论"],"tags":["数据结构-数据结构笔记"]},{"title":"串的定义和基本操作","url":"/2019/03/15/%E8%AE%A1%E7%AE%97%E6%9C%BA%E7%90%86%E8%AE%BA/%E6%95%B0%E6%8D%AE%E7%BB%93%E6%9E%84/%E6%95%B0%E6%8D%AE%E7%BB%93%E6%9E%84%E7%AC%94%E8%AE%B0/4.1_%E4%B8%B2%E7%9A%84%E5%AE%9A%E4%B9%89%E5%92%8C%E5%9F%BA%E6%9C%AC%E6%93%8D%E4%BD%9C/","content":"串：即字符串(String)，是由零个或多个字符组成的有限序列，串中字符的个数n称为串的长度，n&#x3D;0时的串称为空串\nS=&quot;Hello World!&quot;，有的地方用双引号(Java、C)，有的地方用单引号(Python)，注意里面包含空格，空格也是字符\n子串：串中任意个连续的字符组成的子序列主串：包含子串的串字符在主串中的位置：字符在串中的序号子串在主串中的位置：子串的第一个字符在主串中的位置【注意位序从1开始，而不是从0开始】\n空串：M&#x3D;””空格串：N&#x3D;”  “，[每个空格字符占1B]\n串是一种特殊的线性表，数据元素之间呈线性关系，串的数据对象限定为字符集(如中文字符、英文字符、数字字符、标点字符)\n串的基本操作。如增删改查等通常以子串为操作对象\n串的基本操作：\n\nStrAssign(&amp;T,chars)：赋值操作，把串T赋值为chars\n\nStrCopy(&amp;T,S)：复制操作，由串S复制得到串T\n\nStrEmpty(S)：判空操作，若S为空串，则返回true，否则返回False\n\nStrLength(S)：求串长，返回串S的元素个数\n\nClearString(&amp;S)：清空操作，将S清为空串\n\nDestroyString(&amp;S)：销毁串，将串S销毁(回收存储空间)\n\nConcat(&amp;T,S1,S2)：串联接，用T返回由S1和S2联接而成的新串【问题：存储空间扩展？】\n\nSubString(&amp;Sub,S,pos,len)：求子串，用Sub返回串S的第pos个字符起长度为len的子串\n\nIndex(S,T)：定位操作，若主串S中存在与串T值相同的子串，则返回它在主串S中第一次出现的位置；否则函数值为0\n\nStrCompare(S,T)：比较操作，若S&gt;T，则返回值&gt;0；若S&#x3D;T，则返回值&#x3D;0；若S&lt;T，则返回值&lt;0【从第一个字符开始往后依次对比，先出现更大字符的串就更大；长串的前缀与短串相同时，长串更大；只有两个串完全相同时才相等】\n\n\n字符集：英文字符(ASCII字符)、中英文(Unicode字符集，UIF-8,UIF-16)\n","categories":["计算机理论"],"tags":["数据结构-数据结构笔记"]},{"title":"串的朴素模式匹配算法","url":"/2019/03/15/%E8%AE%A1%E7%AE%97%E6%9C%BA%E7%90%86%E8%AE%BA/%E6%95%B0%E6%8D%AE%E7%BB%93%E6%9E%84/%E6%95%B0%E6%8D%AE%E7%BB%93%E6%9E%84%E7%AC%94%E8%AE%B0/4.3_%E4%B8%B2%E7%9A%84%E6%9C%B4%E7%B4%A0%E6%A8%A1%E5%BC%8F%E5%8C%B9%E9%85%8D%E7%AE%97%E6%B3%95/","content":"一定是主串中存在的才叫“子串”\n模式串：想尝试在主串中找到的串，未必存在\n串的模式匹配：在主串中找到与模式串相同的子串，并返回其所在位置【就是定位操作】\n朴素模式匹配算法：\n【比较好的情况：每个子串的第一个字符就与模式串不匹配，若模式串长度为m，主串长度为n，则匹配成功的最好时间复杂度：O(m)，匹配失败的最好时间复杂度：O(n-m+1)&#x3D;O(n-m)&#x3D;O(n)】\n【若模式串长度为m，主串长度为n，则直接匹配成功&#x2F;匹配失败最多需要(n-m+1)*m次比较，最坏时间复杂度：O(nm)，这种情况就是每个子串的前m-1个字符都和模式串匹配，只有第m个字符不匹配，所以指针需要回溯重新来匹配】\n\n#include&lt;stdio.h&gt;#include&lt;stdlib.h&gt;#include&lt;stdbool.h&gt;#define MAXIEN 255  //预定义最大串长为255typedef struct&#123;    char ch[MAXIEN];  //每个分量存储一个字符    int length;  //串的实际长度&#125;SString;//只要有一个字符不同，就可以停止检查当前子串，所有对应位置的字符都相同，则匹配成功，返回kint Index(SString *S,SString *T)&#123;    int k=1;  //k记录当前检查的子串起始位置    int i=k,j=1;    while(i&lt;=S-&gt;length &amp;&amp; j&lt;=S-&gt;length)&#123;        if(S-&gt;ch[i] == T-&gt;ch[i])&#123;            ++i;            ++j;  //继续比较后继字符        &#125;        else&#123;            k++;  //检查下一个子串            i=k;            j=1;        &#125;    &#125;    if(j&lt;T-&gt;length)&#123;        return k;    &#125;else&#123;        return 0;    &#125;&#125;int main()&#123;    SString S;&#125;\n","categories":["计算机理论"],"tags":["数据结构-数据结构笔记"]},{"title":"树的基本概念","url":"/2019/03/15/%E8%AE%A1%E7%AE%97%E6%9C%BA%E7%90%86%E8%AE%BA/%E6%95%B0%E6%8D%AE%E7%BB%93%E6%9E%84/%E6%95%B0%E6%8D%AE%E7%BB%93%E6%9E%84%E7%AC%94%E8%AE%B0/5.1_%E6%A0%91%E7%9A%84%E5%9F%BA%E6%9C%AC%E6%A6%82%E5%BF%B5/","content":"树是n(n&gt;&#x3D;0)个结点的有限集合，n&#x3D;0时，称为空树\n而任意非空树应满足：\n\n有且仅有一个特定的称为根的结点\n当n&gt;1时，其余结点可分为m(m&gt;0)个互不相交的有限集合，其中每一个集合本身又是一棵树，称为根结点的子树\n\n基本术语：\n祖先结点和子孙结点、双亲结点和孩子结点、兄弟结点\n树中一个结点的子结点的个数称为该结点的度；树中各结点度的最大值称为树的度\n度大于0的结点称为分支结点度为0的结点称为叶子结点\n结点的层数【自顶向下】结点的高度【自底向上】结点的深度【自顶向下】树的高度(深度)是树中结点的最大层数树中每一层结点个数的最大值称为树的宽度\n路径：树中两个结点之间的路径是由这两个结点之间所经过的结点序列构成的【树中的分支是有向的，即从双亲结点指向孩子结点，所以路径一定是自上而下的】\n路径长度：路径上所经历边的个数\n有序树：树中任意结点的子结点之间有顺序关系无序树：树中任意结点的子结点之间没有顺序关系，也叫自由树\n树的性质：\n\nn个结点的树中只有n-1条边\n树中的结点数等于所有结点的度数+1\n度为m的树中第i层上至多有m^(i-1)个结点(i&gt;&#x3D;1)\n高度为h的m叉树至多有(m^h-1)&#x2F;(m-1)个结点\n具有n个结点的m叉树的最小高度为\n\n森林：m(m&gt;&#x3D;0)棵互不相交的树的集合\n","categories":["计算机理论"],"tags":["数据结构-数据结构笔记"]},{"title":"二叉树的概念","url":"/2019/03/15/%E8%AE%A1%E7%AE%97%E6%9C%BA%E7%90%86%E8%AE%BA/%E6%95%B0%E6%8D%AE%E7%BB%93%E6%9E%84/%E6%95%B0%E6%8D%AE%E7%BB%93%E6%9E%84%E7%AC%94%E8%AE%B0/5.2_%E4%BA%8C%E5%8F%89%E6%A0%91%E7%9A%84%E6%A6%82%E5%BF%B5/","content":"二叉树是n(n&gt;&#x3D;0)个结点的有限集合1）n&#x3D;0时，二叉树为空2）n&gt;0时，由根结点和两个互不相交的被称为根的左子树和右子树组成，左子树和右子树也分别是一棵二叉树\n特点：\n\n每个结点最多有两颗子树，所以二叉树中不存在度大于2的结点\n二叉树的左右子树不能任意颠倒，如果某结点只有一棵子树，一定要指明它是左子树还是右子树\n\n二叉树 VS 度为2的有序树：1）二叉树可以为空，而度为2的有序树至少有三个结点2）二叉树的孩子结点始终有左右之分，而度为2的有序树的孩子结点次序是相对的\n斜树：所有结点都只有左子树的二叉树称为左斜树，所有结点都只有右子树的二叉树称为右斜树\n\n每一层只有一个结点\n斜树的结点个数与其深度相同\n\n满二叉树：一棵高度为h，且含有2^h-1个结点的二叉树为满二叉树【在一棵二叉树中，所有分支结点都存在左子树和右子树，并且所有叶子都在同一层上】\n\n叶子只能出现在最下一层\n只有度为0和度为2的结点\n\n完全二叉树：设一个高度为h、有n个结点的二叉树，当且仅当其每个结点都与高度为h的满二叉树中编号1～n的结点一一对应时，称为完全二叉树\n\n深度为k的完全二叉树在k-1层是满二叉树\n叶子结点只能出现在最下两层，且最下层的叶子结点都集中在左侧连续的位置\n如果有度为1的结点，只可能有一个，且该结点只有左孩子\n\n完全二叉树的性质：\n二叉排序树：一棵二叉树，若树非空则具有如下性质：对任意结点若存在左子树或右子树，则其左子树上所有结点的关键字均小于该结点，右子树上所有结点的关键字均大于该结点\n平衡二叉树：树上任意结点的左子树和右子树的高度差不超过1\n二叉树的性质：\n","categories":["计算机理论"],"tags":["数据结构-数据结构笔记"]},{"title":"哈夫曼树","url":"/2019/03/15/%E8%AE%A1%E7%AE%97%E6%9C%BA%E7%90%86%E8%AE%BA/%E6%95%B0%E6%8D%AE%E7%BB%93%E6%9E%84/%E6%95%B0%E6%8D%AE%E7%BB%93%E6%9E%84%E7%AC%94%E8%AE%B0/5.10_%E5%93%88%E5%A4%AB%E6%9B%BC%E6%A0%91/","content":"路径长度：路径上所经历边的个数结点的权：结点被赋予的数值\n树的带权路径长度：WPL，树中所有叶结点的带权路径长度之和\n哈夫曼树：也称最优二叉树，含有n个带权叶子结点带权路径长度最小的二叉树\n哈夫曼树的构造算法：1）将n个结点作为n棵仅含有一个根结点的二叉树，构造森林F2）生成一个新结点，并从F中找出根结点权值最小的两棵树作为它的左右子树，且新结点的权值为两棵子树根结点的权值之和3）从F中删除这两棵树，并将新生成的树加入到F中4）重复2，3步骤，直到F中只有一棵树为止\n哈夫曼树的性质：1）每个初始结点都会成为叶结点，双支结点都为新生成的结点2）权值越大离根结点越近，反之权值越小离根结点越远3）哈夫曼树中没有结点的度为14）n个叶子结点的哈夫曼树的结点总数为2n-1，其中度为2的结点数为n-1\n\n","categories":["计算机理论"],"tags":["数据结构-数据结构笔记"]},{"title":"栈在括号匹配中的应用","url":"/2019/03/15/%E8%AE%A1%E7%AE%97%E6%9C%BA%E7%90%86%E8%AE%BA/%E6%95%B0%E6%8D%AE%E7%BB%93%E6%9E%84/%E6%95%B0%E6%8D%AE%E7%BB%93%E6%9E%84%E7%AC%94%E8%AE%B0/3.8_%E6%A0%88%E5%9C%A8%E6%8B%AC%E5%8F%B7%E5%8C%B9%E9%85%8D%E4%B8%AD%E7%9A%84%E5%BA%94%E7%94%A8/","content":"括号匹配问题：\n遇到左括号就入栈，遇到右括号就消耗一个左括号\n\n\n#include&lt;stdio.h&gt;#include&lt;stdbool.h&gt;#include&lt;stdlib.h&gt;//万一存满了，可以用链栈#define MaxSize 10  //定义栈中元素的最大个数typedef struct&#123;    char data[MaxSize];  //静态数组存放栈中元素    int top;  //栈顶指针&#125;SqStack;//初始化栈void InitStack(SqStack *S)&#123;    S-&gt;top=-1;  //初始化栈顶指针&#125;//判断栈空bool StackEmpty(SqStack *S)&#123;    if(S-&gt;top == -1)&#123;        return true;  //栈空    &#125;    else&#123;        return false;  //不空    &#125;&#125;//新元素入栈bool Push(SqStack *S,char x)&#123;    if(S-&gt;top==MaxSize-1)&#123;        return false;  //栈满，报错    &#125;    S-&gt;top=S-&gt;top+1;  //指针先+1    S-&gt;data[S-&gt;top]=x;  //新元素入栈        return true;&#125;//栈顶元素出栈，用x返回bool Pop(SqStack *S,char *x)&#123;    if(S-&gt;top==-1)&#123;        return false;  //栈空，报错    &#125;    (*x)=S-&gt;data[S-&gt;top];  //栈顶元素先出栈    S-&gt;top=S-&gt;top-1;  //指针再-1，数据还残留在内存中，只是逻辑上被删除了    return true;&#125;bool bracketCheck(char str[],int length)&#123;    SqStack S;    InitStack(&amp;S);  //初始化一个栈    for(int i=0;i&lt;length;i++)&#123;        if(str[i]==&#x27;(&#x27; || str[i]==&#x27;[&#x27; || str[i]==&#x27;&#123;&#x27;)&#123;            Push(&amp;S,str[i]);  //扫描到左括号，入栈        &#125;else&#123;            if(StackEmpty(&amp;S))&#123;  //扫描到右括号，且当前栈空                return false;  //匹配失败            &#125;                        char topElem;            Pop(&amp;S,&amp;topElem);  //栈顶元素出栈            if(str[i]==&#x27;)&#x27; &amp;&amp; topElem != &#x27;)&#x27;)&#123;                return false;            &#125;            if(str[i]==&#x27;]&#x27; &amp;&amp; topElem != &#x27;[&#x27;)&#123;                return false;            &#125;            if(str[i]==&#x27;&#125;&#x27; &amp;&amp; topElem != &#x27;&#123;&#x27;)&#123;                return false;            &#125;        &#125;    &#125;    return StackEmpty(&amp;S);  //检索完全部括号后，栈空说明匹配成功&#125;","categories":["计算机理论"],"tags":["数据结构-数据结构笔记"]},{"title":"线索二叉树","url":"/2019/03/15/%E8%AE%A1%E7%AE%97%E6%9C%BA%E7%90%86%E8%AE%BA/%E6%95%B0%E6%8D%AE%E7%BB%93%E6%9E%84/%E6%95%B0%E6%8D%AE%E7%BB%93%E6%9E%84%E7%AC%94%E8%AE%B0/5.5_%E7%BA%BF%E7%B4%A2%E4%BA%8C%E5%8F%89%E6%A0%91/","content":"线索化：若无左子树，则将左指针指向其前驱结点；若无右子树，则将右指针指向其后继结点\n","categories":["计算机理论"],"tags":["数据结构-数据结构笔记"]},{"title":"树的存储结构","url":"/2019/03/15/%E8%AE%A1%E7%AE%97%E6%9C%BA%E7%90%86%E8%AE%BA/%E6%95%B0%E6%8D%AE%E7%BB%93%E6%9E%84/%E6%95%B0%E6%8D%AE%E7%BB%93%E6%9E%84%E7%AC%94%E8%AE%B0/5.6_%E6%A0%91%E7%9A%84%E5%AD%98%E5%82%A8%E7%BB%93%E6%9E%84/","content":"双亲表示法：采用一组连续的存储空间来存储每个结点，同时在每个结点中增设一个伪指针，指示双亲结点在数组中的位置，根结点的下标为0，其伪指针域为-1\n#define MAX_TREE_SIZE 100typedef struct&#123;    int data;    int parent;&#125;PINode;typedef struct&#123;    PINode nodes[MAX_TREE_SIZE];    int n;&#125;PTree;\n\n\n孩子表示法：将每个结点的孩子结点都用单链表连接起来形成一个线性结构，n个结点具有n个孩子链表\n#define MAX_TREE_SIZE 100typedef struct&#123;    int child;    struct CNode *next;&#125;CNode;typedef struct&#123;    int data;    struct CNode *child;&#125;PNode;typedef struct&#123;    PNode nodes[MAX_TREE_SIZE];    int n;&#125;CTree;\n\n\n孩子兄弟表示法：\ntypedef struct CSNode&#123;    int data;    struct CSNode *firstchild,*nextsibling;&#125;CSNode,CSTRee;\n\n双亲表示法：寻找结点的双亲结点效率高，寻找结点的孩子结点效率低孩子表示法：寻找结点的孩子结点效率高，寻找结点的双亲结点效率低孩子兄弟表示法：寻找结点的孩子结点效率高，方便实现树转换为二叉树，寻找双亲结点的效率低\n","categories":["计算机理论"],"tags":["数据结构-数据结构笔记"]},{"title":"KMP算法","url":"/2019/03/15/%E8%AE%A1%E7%AE%97%E6%9C%BA%E7%90%86%E8%AE%BA/%E6%95%B0%E6%8D%AE%E7%BB%93%E6%9E%84/%E6%95%B0%E6%8D%AE%E7%BB%93%E6%9E%84%E7%AC%94%E8%AE%B0/4.4_KMP%E7%AE%97%E6%B3%95/","content":"朴素模式匹配算法的缺点：当某些子串与模式串能部分匹配时，主串的扫描指针i经常回溯，导致时间开销增加\n改进思路：主串指针不回溯，只有模式串指针回溯\n\n求模式串的next数组：当模式串的第j个字符匹配失败时，令模式串跳到next[j]再继续匹配\n串的前缀：包含第一个字符，且不包含最后一个字符的子串串的后缀：包含最后一个字符，且不包含第一个字符的子串\n手写求next：\n\n#include&lt;stdio.h&gt;#include&lt;stdlib.h&gt;#include&lt;stdbool.h&gt;#define MAXIEN 255  //预定义最大串长为255typedef struct&#123;    char ch[MAXIEN];  //每个分量存储一个字符    int length;  //串的实际长度&#125;SString;//求模式串T的next数组void get_next(SString *T,int next[])&#123;    int i=1,j=0;    next[1]=0;    while(i&lt;T-&gt;length)&#123;        if(j==0 || T-&gt;ch[i] == T-&gt;ch[j])&#123;            ++i;            ++j;            //若pi=pj，则next[j+1]=next[j]+1            next[i]=j;        &#125;        else&#123;            //否则令j=next[j]，循环继续            j=next[j];        &#125;    &#125;&#125;//KMP算法代码【平均时间复杂度O(n+m)】int Index_KMP(SString *S,SString *T)&#123;    int i=1,j=1;    int next[T-&gt;length+1];    get_next(T, next);  //求模式串的next数组    while(i&lt;=S-&gt;length &amp;&amp; j&lt;=T-&gt;length)&#123;        if(j==0 || S-&gt;ch[i] == T-&gt;ch[i])&#123;            ++i;            ++j;  //继续比较后继字符        &#125;else&#123;            j=next[j];  //模式串向右移动        &#125;    &#125;    if(j&gt;T-&gt;length)&#123;        return i-T-&gt;length;  //匹配成功    &#125;else&#123;        return 0;    &#125;&#125;int main()&#123;    SString S;&#125;\n\nKMP算法存在的问题：多进行了一次无意义的对比\nKMP算法进一步优化：nextval数组\n","categories":["计算机理论"],"tags":["数据结构-数据结构笔记"]},{"title":"二叉树的存储结构","url":"/2019/03/15/%E8%AE%A1%E7%AE%97%E6%9C%BA%E7%90%86%E8%AE%BA/%E6%95%B0%E6%8D%AE%E7%BB%93%E6%9E%84/%E6%95%B0%E6%8D%AE%E7%BB%93%E6%9E%84%E7%AC%94%E8%AE%B0/5.3_%E4%BA%8C%E5%8F%89%E6%A0%91%E7%9A%84%E5%AD%98%E5%82%A8%E7%BB%93%E6%9E%84/","content":"二叉树的顺序存储：用一组连续的存储单元依次自上而下、自左至右存储完全二叉树上的结点元素\n二叉树的链式存储：用链表来存放一棵二叉树，二叉树中每个结点用链表的一个链结点来存储\n","categories":["计算机理论"],"tags":["数据结构-数据结构笔记"]},{"title":"二叉树的遍历","url":"/2019/03/15/%E8%AE%A1%E7%AE%97%E6%9C%BA%E7%90%86%E8%AE%BA/%E6%95%B0%E6%8D%AE%E7%BB%93%E6%9E%84/%E6%95%B0%E6%8D%AE%E7%BB%93%E6%9E%84%E7%AC%94%E8%AE%B0/5.4_%E4%BA%8C%E5%8F%89%E6%A0%91%E7%9A%84%E9%81%8D%E5%8E%86/","content":"二叉树的遍历：按某条搜索路径访问树中的每个结点，树的每个结点均被访问一次，而且只访问一次\n先序遍历(递归实现)：\n中序遍历(递归实现)：\n中序遍历非递归算法：\n后序遍历(递归实现)：\n层次遍历：\n由遍历序列构造二叉树：\n","categories":["计算机理论"],"tags":["数据结构-数据结构笔记"]},{"title":"平衡二叉树","url":"/2019/03/15/%E8%AE%A1%E7%AE%97%E6%9C%BA%E7%90%86%E8%AE%BA/%E6%95%B0%E6%8D%AE%E7%BB%93%E6%9E%84/%E6%95%B0%E6%8D%AE%E7%BB%93%E6%9E%84%E7%AC%94%E8%AE%B0/5.9_%E5%B9%B3%E8%A1%A1%E4%BA%8C%E5%8F%89%E6%A0%91/","content":"平衡二叉树：AVL，任意结点的平衡因子的绝对值不超过1（平衡因子：左子树高度-右子树高度）\n\n平衡二叉树的判断：利用递归的后续遍历过程1）判断左子树是一棵平衡二叉树2）判断右子树是一棵平衡二叉树3）判断以该结点为根的二叉树为平衡二叉树【判断条件：若左子树和右子树均为平衡二叉树，且左子树与右子树高度差的绝对值小于等于1，则平衡】\n平衡二叉树的插入：\n1）LL平衡旋转(右单旋转)原因：在结点A的左孩子的左子树上插入了新结点调整方法：右旋操作，将A的左孩子B代替A，将A结点称为B的右子树根结点，而B的原右子树则作为A的左子树\n2）RR平衡旋转(左单旋转)原因：在结点A的右孩子的右子树上插入了新结点调整方法：左旋操作，将A的右孩子B代替A，将A结点称为B的左子树根结点，而B的原左子树则作为A的右子树\n3）LR平衡旋转(先左后右双旋转)原因：在结点A的左孩子的右子树上插入了新结点调整方法：先左旋后右旋操作，将A的左孩子B的右孩子结点C代替B，然后再将C结点向上代替A的位置\n4）RL平衡旋转(先右后左双旋转)原因：在结点A的右孩子的左子树上插入了新结点调整方法：先右旋后左旋操作，将A的右孩子B的左孩子结点C代替B，然后再将C结点向上代替A的位置\t\t\t\t\t\t\t\t\t\t\t\t\t\t\t\t\t\t\t\t\t\t\t\t\t\t\t\t\t\t\t\t\t\t\t\t\t\t\t\t\t\t\t\t\t\t\t\t\t\t\t\t\t\t\t\t\t\t\t\t\t\t\t\t\t\t\t\t\t\t\t\t\t\t\t\t\t\t\t\t\t\t\t\t\t\t\t\t\t\t\t\t\t\t\t\t\t\t\t\t\t\t\t\t\t\t\t\t\t\t\t\t\t\t\t\t\t\t\t\t\t\t\t\t\t\t\t\t\t\t\t\t\t\t\t\t\t\t\t\t\t\t\t\t\t\t\t\t\t\t\t\t\t\t\t\t\t\t\t\t\t\t\t\t\t\t\t\t\t\t\t\t\t\t\t\t\t\t\t\t\t\t\t\t\t\t\t\t\t\t\t\t\t\t\t\t\t\t\t\t\t\t\t\t\t\t\t\t\t\t\t\t\t\t\t\t\t\t\t\t\t\t\t\t\t\t\t\t\t\t\t\t\t\t\t\t\t\t\t\t\t\t\t\t\t\t\t\t\t\t\t\t\t\t\t\t\t\t\t\t\t\t\t\t\t\t\t\t\t\t\t\t\t\t\t\t\t\t\t\t\t\t\t\t\t\t\t\t\t\t\t\t\t\t\t\t\t\t\t\t\t\t\t\t\t\t\t\t\t\t\t\t\t\t\t\t\t\t\t\t\t\t\t\t\t\t\t\t\t\t\t\t\t\t\t\t\t\t\t\t\t\t\t\t\t\t\t\t\t\t\t\t\t\t\t\t\t\t\t\t\t\t\t\t\t\t\t\t\t\t\t\t\t\t\t\t\t\t\t\t\t\t\t\t\t\t\t\t\t\t\t\t\t\t\t\t\t\t\t\t\t\t\t\t\t\t\t\t\t\t\t\t\t\t\t\t\t\t\t\t\t\t\t\t\t\t\t\t\t\t\t\t\t\t\t\t\t\t\t\t\t\t\t\t\t\t\t\t\t\t\t\t\t\t\t\t\t\t\t\t\t\t\t\t\t\t\t\t\t\t\t\t\t\t\t\t\t\t\t\t\t\t\t\t\t\t\t\t\t\t\t\t\t\t\t\t\t\t\t\t\t\t\t\t\t\t\t\t\t\t\t\t\t\t\t\t\t\t\t\t\t\t\t\t\t\t\t\t\t\t\t\t\t\t\t\t\t\t\t\t\t\t\t\t\t\t\t\t\t\t\t\t\t\t\t\t\t\t\t\t\t\t\t\t\t\t\t\t\t\t\t\t\t\t\t\t\t\t\t\t\t\t\t\t\t\t\t\t\t\t\t\t\t\t\t\t\t\t\t\t\t\t\t\t\t\t\t\t\t\t\t\t\t\t\t\t\t\t\t\t\t\t\t\t\t\t\t\t\t\t\t\t\t\t\t\t\t\t\t\t\t\t\t\t\t\t\t\t\t\t\t\t\t\t\t\t\t\t\t\t\t\t\t\t\t\t\t\t\t\t\t\t\t\t\t\t\t\t\t\t\t\t\t\t\t\t\t\t\t\t\t\t\t\t\t\t\t\t\t\t\t\t\t\t\t\t\t\t\t\t\t\t\t\t\t\t\t\t\t\t\t\t\t\t\t\t\t\t\t\t\t\t\t\t\t\t\t\t\t\t\t\t\t\t\t\t\t\t\t\t\t\t\t\t\t\t\t\t\t\t\t\t\t\t\t\t\t\t\t\t\t\t\t\t\t\t\t\t\t\t\t\t\t\t\t\t\t\t\t\t\t\t\t\t\t\t\t\t\t\t\t\t\t\t\t\t\t\t\t\t\t\t\t\t\t\t\t\t\t\t\t\t\t\t\t\t\t\t\t\t\t\t\t\t\t\t\t\t\t\t\t\t\t\t\t\t\t\t\t\t\t\t\t\t\t\t\t\t\t\t\t\t\t\t\t\t\t\t\t\t\t\t\t\t\t\t\t\t\t\t\t\t\t\t\t\t\t\t\t\t\t\t\t\t\t\t\t\t\t\t\t\t\t\t\t\t\t\t\t\t\t\t\t\t\t\t\t\t\t\t\t\t\t\t\t\t\t\t\t\t\t\t\t\t\t\t\t\t\t\t\t\t\t\t\t\t\t\t\t\t\t\t\t\t\t\t\t\t\t\t\t\t\n","categories":["计算机理论"],"tags":["数据结构-数据结构笔记"]},{"title":"最短路径","url":"/2019/03/15/%E8%AE%A1%E7%AE%97%E6%9C%BA%E7%90%86%E8%AE%BA/%E6%95%B0%E6%8D%AE%E7%BB%93%E6%9E%84/%E6%95%B0%E6%8D%AE%E7%BB%93%E6%9E%84%E7%AC%94%E8%AE%B0/6.10_%E6%9C%80%E7%9F%AD%E8%B7%AF%E5%BE%84/","content":"最短路径：两个顶点之间带权路径长度最短的路径为最短路径\n在带权图当中，把从一个顶点v到另一个顶点u所经历的边的权值之和称为路径的带权路径长度\nDijkstra算法：带权图单源最短路径\n时间复杂度：O(|V|^2)\nDijkstra算法并不适用于含有负权边的图\nFloyd算法：各顶点之间的最短路径\n时间复杂度：O(|V|^3)\n","categories":["计算机理论"],"tags":["数据结构-数据结构笔记"]},{"title":"二叉排序树","url":"/2019/03/15/%E8%AE%A1%E7%AE%97%E6%9C%BA%E7%90%86%E8%AE%BA/%E6%95%B0%E6%8D%AE%E7%BB%93%E6%9E%84/%E6%95%B0%E6%8D%AE%E7%BB%93%E6%9E%84%E7%AC%94%E8%AE%B0/5.8_%E4%BA%8C%E5%8F%89%E6%8E%92%E5%BA%8F%E6%A0%91/","content":"二叉排序树：BST，也称二叉查找树\n二叉排序树或者为空树，或者为非空树，当为非空树时有如下特点：1）若左子树非空，则左子树上所有结点关键字值均小于根结点的关键字2）若右子树非空，则右子树上所有结点关键字值均大于根结点的关键字3）左、右子树本身也分别是一棵二叉排序树\n二叉排序树的查找：二叉树非空时，查找根结点，若相等则查找成功；若不等，则当小于根结点值时查找左子树，当大于根结点的值时，查找右子树，当查找到叶结点仍没查找到相应的值，则查找失败\n二叉排序树的插入：若二叉排序树为空，则直接插入结点；若二叉排序树非空，当值小于根结点时，插入左子树；当值大于根结点时，插入右子树；当值等于根结点时不进行插入\n构造二叉排序树：读入一个元素并建立结点，若二叉树为空将其作为根结点；若二叉排序树非空，当值小于根结点时，插入左子树；当值大于根结点时，插入右子树；当值等于根结点时不进行插入\n二叉排序树的删除：1）若被删除结点z是叶子结点，则直接删除2）若被删除结点z只有一棵子树，则让z的子树成为z父结点的子树，代替z结点3）若被删除结点z有两棵子树，则让z的‘中序序列直接后继’代替z，并删去直接后继结点\n在二叉排序树中删除并插入某结点，得到的二叉排序树与原来不一定相同\n二叉排序树的查找效率：\n","categories":["计算机理论"],"tags":["数据结构-数据结构笔记"]},{"title":"关键路径","url":"/2019/03/15/%E8%AE%A1%E7%AE%97%E6%9C%BA%E7%90%86%E8%AE%BA/%E6%95%B0%E6%8D%AE%E7%BB%93%E6%9E%84/%E6%95%B0%E6%8D%AE%E7%BB%93%E6%9E%84%E7%AC%94%E8%AE%B0/6.12_%E5%85%B3%E9%94%AE%E8%B7%AF%E5%BE%84/","content":"在一个表示工程的带权有向图中，用顶点表示事件，用有向边表示活动，边上的权值表示活动的持续时间，称这样的有向图为边表示活动的网，简称AOE网\n在AOE网中，所有活动都完成才能到达终点，因此完成整个工程所必须花费的时间(即最短工期)应该为源点到终点的最大路径长度，具有最大路径长度的路径称为关键路径，关键路径上的活动称为关键活动\n缩短关键活动时间可以加快整个工程，但缩短到一定大小时关键路径会发生改变\n当网中关键路径不唯一时，只有加快的关键活动或关键活动组合包括在所有的关键路径上才能缩短工期\n","categories":["计算机理论"],"tags":["数据结构-数据结构笔记"]},{"title":"拓扑排序","url":"/2019/03/15/%E8%AE%A1%E7%AE%97%E6%9C%BA%E7%90%86%E8%AE%BA/%E6%95%B0%E6%8D%AE%E7%BB%93%E6%9E%84/%E6%95%B0%E6%8D%AE%E7%BB%93%E6%9E%84%E7%AC%94%E8%AE%B0/6.11_%E6%8B%93%E6%89%91%E6%8E%92%E5%BA%8F/","content":"有向无环图：不存在环的有向图，简称DAG图\n在一个表示工程的有向图中，用顶点表示活动，用弧表示活动之间的优先关系，称这样的有向图为顶点表示活动的网，简称AOV网\n在AOV网中，不能出现回路\n若从顶点vi到vj有一条路径，则在顶点序列中顶点vi必在vj之前，对一个有向图构造拓扑序列的过程称为拓扑排序\n基本思想：1）从AOV网中选择一个没有前驱的顶点并输出2）从AOV网中删去该顶点以及所有以该顶点为尾的弧3）重复上述两步，直到全部顶点都被输出，或AOV网中不存在没有前驱的顶点\n算法结束时没有访问所有顶点，则存在以剩下顶点组成的环\n拓扑排序的结果不一定唯一\n时间复杂度：O(|V|+|E|)\n若邻接矩阵为三角矩阵，则存在拓扑排序，反之不一定成立\n","categories":["计算机理论"],"tags":["数据结构-数据结构笔记"]},{"title":"图的基本概念","url":"/2019/03/15/%E8%AE%A1%E7%AE%97%E6%9C%BA%E7%90%86%E8%AE%BA/%E6%95%B0%E6%8D%AE%E7%BB%93%E6%9E%84/%E6%95%B0%E6%8D%AE%E7%BB%93%E6%9E%84%E7%AC%94%E8%AE%B0/6.1_%E5%9B%BE%E7%9A%84%E5%9F%BA%E6%9C%AC%E6%A6%82%E5%BF%B5/","content":"图G由顶点集V和边集E组成，记为G&#x3D;(V,E)，其中V(G)表示图G中顶点的有限非空集；E(G)表示图G中顶点之间的关系(边)集合|V|表示图G中顶点的个数，也称图G的阶；|E|表示图G中边的条数\n无向图和有向图：\n简单图和多重图：\n在图中，权通常是对边赋予的有意义的数值量，边上带权的图称为带权图或网图：\n完全图：\n稠密图、稀疏图\n顶点的度：以该顶点为一个端点的边的数目\n无向图顶点v的度为以v为端点的边的个数，记为TD(v)；n顶点、e条边的无向图中度的总数为2e\n有向图：出度指以v为起点的有向边的条数，记OD(v)；入度指以v为终点的有向边的条数，记ID(v)；TD(v)&#x3D;OD(v)+ID(v)；n顶点、e条边的有向图中出度、入度为e\n有向树：一个顶点的入度为0，其余顶点的入度均为1的有向图\n路径：图中顶点v到顶点w的顶点序列，序列中顶点不重复的路径称为简单路径\n路径长度：路径上边的数目，若该路径最短则称其为距离\n回路：第一个顶点和最后一个顶点相同的路径\n除了第一个顶点和最后一个顶点之外，其余顶点不重复出现的回路称为简单回路\n子图：设有两个图G&#x3D;(V,E)和G’&#x3D;(V’,E’)，若V’是V的子集，且E’是E的子集，则称G’为G的子图；且若V(G)&#x3D;V(G’)则称G’为G的生成子图\n无向图只有连通：若从顶点v到顶点w有路径存在，则称v和w是连通【连通图：任意两个结点之间都是连通的】【连通分量：极大连通子图】\n有向图只有强连通：若从顶点v到顶点w和顶点w到顶点v都有路径存在，则称v和w是强连通【强连通图：任意两个结点之间都是强连通的】【强连通分量：极大强连通子图】\n对于G的一个(强)连通子图G’，如果不存在G的另一个(强)连通子图G’’，使得G’属于G’’，则称G’为G的(强)连通分量\n极小连通子图：连通子图且包含的边最少\n生成树：连通图包含全部顶点的一个极小连通子图(n个顶点图的生成树有n-1条边)\n生成森林：非连通图所有连通分量的生成树组成连通森林\n","categories":["计算机理论"],"tags":["数据结构-数据结构笔记"]},{"title":"邻接矩阵法","url":"/2019/03/15/%E8%AE%A1%E7%AE%97%E6%9C%BA%E7%90%86%E8%AE%BA/%E6%95%B0%E6%8D%AE%E7%BB%93%E6%9E%84/%E6%95%B0%E6%8D%AE%E7%BB%93%E6%9E%84%E7%AC%94%E8%AE%B0/6.2_%E9%82%BB%E6%8E%A5%E7%9F%A9%E9%98%B5%E6%B3%95/","content":"图的邻接矩阵存储也称数组表示法，用一个一维数组存储图中的顶点，用一个二维数组存储图中的边，存储顶点之间邻接关系的二维数组称为邻接矩阵\n邻接矩阵的性质：1）邻接矩阵的空间复杂度为O(n^2)，适用于稠密图2）无向图的邻接矩阵为对称矩阵3）无向图中第i行(或第i列)非0元素(非正无穷)的个数为第i个顶点的度4）有向图中第i行(或第i列)非0元素(非正无穷)的个数为第i个顶点的出度(入度)\n\n","categories":["计算机理论"],"tags":["数据结构-数据结构笔记"]},{"title":"邻接表法","url":"/2019/03/15/%E8%AE%A1%E7%AE%97%E6%9C%BA%E7%90%86%E8%AE%BA/%E6%95%B0%E6%8D%AE%E7%BB%93%E6%9E%84/%E6%95%B0%E6%8D%AE%E7%BB%93%E6%9E%84%E7%AC%94%E8%AE%B0/6.3_%E9%82%BB%E6%8E%A5%E8%A1%A8%E6%B3%95/","content":"邻接矩阵法存储稀疏图会有许多空间浪费\n邻接表法：为每一个顶点建立一个单链表存放与它相邻的边\n邻接表的特点：1）若G为无向图，存储空间为O(|V|+2|E|)若G为有向图，存储空间为O(|V|+|E|)2）邻接表更加适用于稀疏图3）若G为无向图，则结点的度为该结点边表的长度若G为有向图，则结点的出度为该结点边表的长度，计算入度则要遍历整个邻接表4）邻接表不唯一，边表结点的顺序根据算法和输入的不同可能会不同\n","categories":["计算机理论"],"tags":["数据结构-数据结构笔记"]},{"title":"十字链表","url":"/2019/03/15/%E8%AE%A1%E7%AE%97%E6%9C%BA%E7%90%86%E8%AE%BA/%E6%95%B0%E6%8D%AE%E7%BB%93%E6%9E%84/%E6%95%B0%E6%8D%AE%E7%BB%93%E6%9E%84%E7%AC%94%E8%AE%B0/6.4_%E5%8D%81%E5%AD%97%E9%93%BE%E8%A1%A8/","content":"十字链表：有向图的一种链式存储结构\n","categories":["计算机理论"],"tags":["数据结构-数据结构笔记"]},{"title":"邻接多重表","url":"/2019/03/15/%E8%AE%A1%E7%AE%97%E6%9C%BA%E7%90%86%E8%AE%BA/%E6%95%B0%E6%8D%AE%E7%BB%93%E6%9E%84/%E6%95%B0%E6%8D%AE%E7%BB%93%E6%9E%84%E7%AC%94%E8%AE%B0/6.5_%E9%82%BB%E6%8E%A5%E5%A4%9A%E9%87%8D%E8%A1%A8/","content":"用邻接表存储无向图，每条边的两个顶点分别在该边所依附的两个顶点的边表中，这种重复存储给图的某些操作带来不便，例如对已访问过的边做标记，或者要删除图中某一条边等，都需要找到表示同一条边的两个边表结点。\n邻接多重表：主要用于存储无向图\n","categories":["计算机理论"],"tags":["数据结构-数据结构笔记"]},{"title":"图的基本操作","url":"/2019/03/15/%E8%AE%A1%E7%AE%97%E6%9C%BA%E7%90%86%E8%AE%BA/%E6%95%B0%E6%8D%AE%E7%BB%93%E6%9E%84/%E6%95%B0%E6%8D%AE%E7%BB%93%E6%9E%84%E7%AC%94%E8%AE%B0/6.6_%E5%9B%BE%E7%9A%84%E5%9F%BA%E6%9C%AC%E6%93%8D%E4%BD%9C/","content":"\nAdjacent(G,x,y)：判断图G是否存在边&lt;x,y&gt;或(x,y)【邻接矩阵效率高】\n\nNeighbors(G,x)：列出图G中与结点x邻接的边【无向图邻接表效率高，有向图邻接矩阵效率高】\n\nInsertVertex(G,x)：在图G中插入顶点x\n\nDeleteVertex(G,x)：从图G中删除顶点x\n\nAddEdge(G,x,y)：若无向边(x,y)或者有向边&lt;x,y&gt;不存在，则向图G中添加该边\n\nRemoveEdge(G,x,y)：若无向边(x,y)或者有向边&lt;x,y&gt;存在，则在图G中删除该边【邻接矩阵效率高】\n\nFirstNeighbor(G,x)：求图G中顶点x的第一个邻接点，若有则返回顶点号，若没有邻接点或图不存在x，则返回-1NextNeighbor(G,x)：假设图G中顶点y是顶点x的一个邻接点，返回除y之外顶点x的下一个邻接点的顶点号，若y是x的最后一个邻接点，则返回-1\n\nGet_edge_value(G,x,y)：获取图G中边(x,y)或&lt;x,y&gt;对应的权值vSet_edge_value(G,x,y)：设置图G中边(x,y)或&lt;x,y&gt;对应的权值为v\n\n\n","categories":["计算机理论"],"tags":["数据结构-数据结构笔记"]},{"title":"广度优先搜索","url":"/2019/03/15/%E8%AE%A1%E7%AE%97%E6%9C%BA%E7%90%86%E8%AE%BA/%E6%95%B0%E6%8D%AE%E7%BB%93%E6%9E%84/%E6%95%B0%E6%8D%AE%E7%BB%93%E6%9E%84%E7%AC%94%E8%AE%B0/6.7_%E5%B9%BF%E5%BA%A6%E4%BC%98%E5%85%88%E6%90%9C%E7%B4%A2/","content":"图的遍历：从图中某一顶点出发，按照某种搜索方法沿着图中的边对图中的所有顶点访问一次且仅访问一次\n广度优先搜索(BFS)：1）首先访问起始顶点v2）接着由v出发依次访问v的各个未被访问过的邻接顶点w1，w2…wi3）然后依次访问w1，w2…wi的所有未被访问过的邻接顶点4）从这些访问过的顶点出发，访问它们所有未被访问过的邻接顶点，以此类推\n\nBFS算法的性能分析：1）空间复杂度：O(|V|)2）时间复杂度：邻接矩阵法O(|V|^2)，邻接表法O(|V|+|E|)\n无权图单源最短路径问题：定义从顶点u到顶点v的最短路径d(u,v)为从u到v的任何路径中最少的边数，若从u到v没有通路，则d(u,v)&#x3D;正无穷\n广度优先生成树：在广度遍历过程中，我们可以得到一棵遍历树，称为广度优先生成树(生成森林)【邻接矩阵法的广度优先生成树唯一，邻接表法的不唯一】\n","categories":["计算机理论"],"tags":["数据结构-数据结构笔记"]},{"title":"深度优先搜索","url":"/2019/03/15/%E8%AE%A1%E7%AE%97%E6%9C%BA%E7%90%86%E8%AE%BA/%E6%95%B0%E6%8D%AE%E7%BB%93%E6%9E%84/%E6%95%B0%E6%8D%AE%E7%BB%93%E6%9E%84%E7%AC%94%E8%AE%B0/6.8_%E6%B7%B1%E5%BA%A6%E4%BC%98%E5%85%88%E6%90%9C%E7%B4%A2/","content":"深度优先搜索DFS：【与树的先序遍历类似】1）首先访问起始顶点v2）接着由v出发访问v的任意一个邻接且未被访问的邻接顶点wi3）然后再访问与wi邻接且未被访问的任意顶点yi4）若wi没有邻接且未被访问的顶点时，退回到它的上一层顶点v5）重复上述过程，直到所有顶点被访问为止\n借助递归(栈)+辅助标记数组来实现：【邻接矩阵法的DFS(BFS)序列唯一，邻接表法的不唯一】DFS序列：ACDEB\nDFS算法的性能分析：1）空间复杂度：O(|V|)2）时间复杂度：邻接矩阵法O(|V|^2)，邻接表法O(|V|+|E|)\n深度优先生成树：在深度遍历过程中，我们可以得到一棵遍历树，称为深度优先生成树（生成森林）【邻接矩阵法的深度优先生成树唯一，邻接表法的不唯一】\n遍历与连通性问题：1）在无向图中，在任意结点出发进行一次遍历(调用一次BFS或DFS)，若能访问全部结点，说明该无向图是连通的2）在无向图中，调用遍历函数(BFS或DFS)的次数为连通分量的个数有向图中上面两个结论都不成立：\n","categories":["计算机理论"],"tags":["数据结构-数据结构笔记"]},{"title":"最小生成树","url":"/2019/03/15/%E8%AE%A1%E7%AE%97%E6%9C%BA%E7%90%86%E8%AE%BA/%E6%95%B0%E6%8D%AE%E7%BB%93%E6%9E%84/%E6%95%B0%E6%8D%AE%E7%BB%93%E6%9E%84%E7%AC%94%E8%AE%B0/6.9_%E6%9C%80%E5%B0%8F%E7%94%9F%E6%88%90%E6%A0%91/","content":"生成树：连通图包含全部顶点的一个极小连通子图\n最小生成树：对于带权无向连通图G&#x3D;(V,E)，G的所有生成树当中边的权值之和最小的生成树为G的最小生成树（MST）\n性质：1）最小生成树不一定唯一，即最小生成树的树形不一定唯一，当带权无向连通图G的各边权值不等时或G只有结点数-1条边时，MST唯一2）最小生成树的权值是唯一的，且是最小3）最小生成树的边数为顶点数-1\nPrim算法：\n时间复杂度：O(|V|^2)，适用于稠密图\nKruskal算法：\n时间复杂度：O(|E|log|E|)，适用于稀疏图\n","categories":["计算机理论"],"tags":["数据结构-数据结构笔记"]},{"title":"查找的基本概念","url":"/2019/03/15/%E8%AE%A1%E7%AE%97%E6%9C%BA%E7%90%86%E8%AE%BA/%E6%95%B0%E6%8D%AE%E7%BB%93%E6%9E%84/%E6%95%B0%E6%8D%AE%E7%BB%93%E6%9E%84%E7%AC%94%E8%AE%B0/7.1_%E6%9F%A5%E6%89%BE%E7%9A%84%E5%9F%BA%E6%9C%AC%E6%A6%82%E5%BF%B5/","content":"查找：在数据集合中寻找满足某种条件的数据元素的过程，查找结果分为查找成功和查找失败\n查找表：用于查找的数据集合，由同一种数据类型(或记录)组成，可以是一个数组或链表等数据类型\n查找表的操作：1）查询某个特定的数据元素是否在查找表中2）检索满足条件的某个特定的数据元素的各种属性3）从查找表中插入一个数据元素4）从查找表中删除一个数据元素\n不涉及插入和删除操作的查找称为静态查找，涉及插入和删除操作的查找称为动态查找\n关键字：数据元素中唯一标识该元素的某个数据项的值，使用基于关键字的查找，查找结果应该是唯一的\n平均查找长度：查找时，关键字比较次数的平均值\n线性表：适用于静态查找，主要采用顺序查找技术、折半查找技术树表：适用于动态查找，主要采用二叉排序树、平衡二叉树、B树等查找技术散列表：静态查找和动态查找均适用，主要采用散列查找技术\n","categories":["计算机理论"],"tags":["数据结构-数据结构笔记"]},{"title":"顺序查找","url":"/2019/03/15/%E8%AE%A1%E7%AE%97%E6%9C%BA%E7%90%86%E8%AE%BA/%E6%95%B0%E6%8D%AE%E7%BB%93%E6%9E%84/%E6%95%B0%E6%8D%AE%E7%BB%93%E6%9E%84%E7%AC%94%E8%AE%B0/7.2_%E9%A1%BA%E5%BA%8F%E6%9F%A5%E6%89%BE/","content":"顺序查找：又称线性查找，主要用于在线性表中进行查找，从线性表的一端向另一端逐个将记录与给定值进行比较，若相等则查找成功，给出该记录在表中的位置；若整个表检测完仍未找到与给定值相等的记录，则查找失败，给出失败信息\n对无序线性表进行查找：\n对无序线性表进行顺序查找，查找失败时要遍历整个线性表\n查找成功的比较次数为(n+1)&#x2F;2，查找失败的比较次数为n+1【设置哨兵，哨兵就是待查值，存放在查找方向的尽头处，在查找过程中每次比较后，不用判断查找位置是否越界，从而提高了查找速度】\n对有序线性表进行查找：\n对关键字有序线性表进行顺序查找，查找失败时不一定要遍历整个线性表\n有序线性表查找失败的比较次数：n&#x2F;2+n&#x2F;(n+1)\n","categories":["计算机理论"],"tags":["数据结构-数据结构笔记"]},{"title":"折半查找","url":"/2019/03/15/%E8%AE%A1%E7%AE%97%E6%9C%BA%E7%90%86%E8%AE%BA/%E6%95%B0%E6%8D%AE%E7%BB%93%E6%9E%84/%E6%95%B0%E6%8D%AE%E7%BB%93%E6%9E%84%E7%AC%94%E8%AE%B0/7.3_%E6%8A%98%E5%8D%8A%E6%9F%A5%E6%89%BE/","content":"折半查找：又称二分查找，仅适用于有序的顺序表\n算法思想：1）首先将给定值key与表中中间位置元素的关键字比较2）若相等，则返回该元素的位置；若不等，则在前半部分或者是后半部分进行查找3）查找序列升序时，若key小于中间元素，则查找前半部分；若key大于中间元素，则查找后半部分4）重复该过程，直到找到查找的元素为止，或查找失败\n注意low&lt;&#x3D;high：\n折半查找的判定树：\n查找成功的平均比较次数：[log2(n+1)]-1，折半查找的时间复杂度为O(log2n)\n顺序查找适用于顺序存储和链式存储，序列有序无序皆可；折半查找只适用于顺序存储，且要求序列一定有序\n","categories":["计算机理论"],"tags":["数据结构-数据结构笔记"]},{"title":"B树","url":"/2019/03/15/%E8%AE%A1%E7%AE%97%E6%9C%BA%E7%90%86%E8%AE%BA/%E6%95%B0%E6%8D%AE%E7%BB%93%E6%9E%84/%E6%95%B0%E6%8D%AE%E7%BB%93%E6%9E%84%E7%AC%94%E8%AE%B0/7.5_B%E6%A0%91/","content":"B树的定义：\n查找：B树的查找类似于二叉排序树的查找，不同的是B树的每个结点是多关键码的有序表，在到达某个结点时，先在有序表中查找，若找到则查找成功；否则按照指针到相应的子树中查找，到达空指针(即外部结点)时，查找失败\n在B树上的查找过程是一个顺指针查找结点和在结点中查找关键码交叉进行的过程。由于B树通常存储在磁盘上，则前一个查找操作是在磁盘上进行，而后一个查找操作是在内存中进行，即在磁盘上找到某结点后，先将结点的信息读入内存,然后再查找等于k的关键码。显然,在磁盘上进行一次查找比在内存中进行一次查找耗费的时间多得多，因此，在磁盘上进行查找的次数，即待查关键码所在结点在B树的层数，是决定B树查找效率的首要因素。\n插入：\n删除：\n","categories":["计算机理论"],"tags":["数据结构-数据结构笔记"]},{"title":"B+树","url":"/2019/03/15/%E8%AE%A1%E7%AE%97%E6%9C%BA%E7%90%86%E8%AE%BA/%E6%95%B0%E6%8D%AE%E7%BB%93%E6%9E%84/%E6%95%B0%E6%8D%AE%E7%BB%93%E6%9E%84%E7%AC%94%E8%AE%B0/7.6_B+%E6%A0%91/","content":"B+树的定义：\n","categories":["计算机理论"],"tags":["数据结构-数据结构笔记"]},{"title":"散列表的基本概念","url":"/2019/03/15/%E8%AE%A1%E7%AE%97%E6%9C%BA%E7%90%86%E8%AE%BA/%E6%95%B0%E6%8D%AE%E7%BB%93%E6%9E%84/%E6%95%B0%E6%8D%AE%E7%BB%93%E6%9E%84%E7%AC%94%E8%AE%B0/7.7_%E6%95%A3%E5%88%97%E8%A1%A8%E7%9A%84%E5%9F%BA%E6%9C%AC%E6%A6%82%E5%BF%B5/","content":"散列函数：一个把查找表中的关键字映射成该关键字对应的地址的函数\n散列表：根据关键字而直接进行访问的数据结构，它建立了关键字与存储地址之间的一种直接映射关系\n在散列技术中，由于记录的定位主要基于散列函数的计算,不需要进行关键码的多次比较，所以，一般情况下,散列技术的查找速度要比基于比较的查找技术的查找速度快。但是，散列技术-般不适用于多个记录有相同关键码的情况，也不适用于范围查找。散列技术最适合回答的问题是:如果有的话，哪个记录的关键码等于待查值。\n冲突(碰撞)：散列函数可能会把多个不同的关键字映射到同一地址下的情况，同一地址下的多个关键字称为同义词\n","categories":["计算机理论"],"tags":["数据结构-数据结构笔记"]},{"title":"串的存储结构","url":"/2019/03/15/%E8%AE%A1%E7%AE%97%E6%9C%BA%E7%90%86%E8%AE%BA/%E6%95%B0%E6%8D%AE%E7%BB%93%E6%9E%84/%E6%95%B0%E6%8D%AE%E7%BB%93%E6%9E%84%E7%AC%94%E8%AE%B0/4.2_%E4%B8%B2%E7%9A%84%E5%AD%98%E5%82%A8%E7%BB%93%E6%9E%84/","content":"串的顺序存储：【默认使用方案四】\n\n#include&lt;stdio.h&gt;#include&lt;stdlib.h&gt;#define MAXIEN 255  //预定义最大串长为255//静态数组实现(定长顺序存储)typedef struct&#123;    char ch[MAXIEN];  //每个分量存储一个字符    int length;  //串的实际长度&#125;SString;//动态数组实现(堆分配存储)typedef struct&#123;    char *ch;  //按串长分配存储区，ch指向串的基地址    int length;  //串的长度&#125;HString;//初始化动态数组void Init(HString *S)&#123;        S-&gt;ch=(char *)malloc(MAXIEN * sizeof(char));  //用完需要手动free    S-&gt;length=0;&#125;int main()&#123;        HString S;    Init(&amp;S);&#125;\n\n串的基本操作实现：\n#include&lt;stdio.h&gt;#include&lt;stdlib.h&gt;#include&lt;stdbool.h&gt;#define MAXIEN 255  //预定义最大串长为255//静态数组实现(定长顺序存储)typedef struct&#123;    char ch[MAXIEN];  //每个分量存储一个字符    int length;  //串的实际长度&#125;SString;//基本操作的实现//1.求子串：用Sub返回串S的第pos个字符起长度为len的子串bool SubString(SString *Sub,SString *S,int pos,int len)&#123;    //子串范围越界    if(pos+len-1 &gt; S-&gt;length)&#123;        return false;    &#125;    for(int i=pos-1;i&lt;pos+len-1;i++)&#123;        Sub-&gt;ch[i-pos+1]=S-&gt;ch[i];    &#125;    Sub-&gt;length=len;    return true;&#125;//2.比较操作：若S&gt;T，则返回值&gt;0；若S=T，则返回值=0；若S&lt;T，则返回值&lt;0int StrCompare(SString *S,SString *T)&#123;    for(int i=1;i&lt;=S-&gt;length &amp;&amp; i&lt;=T-&gt;length;i++)&#123;        if(S-&gt;ch[i] != T-&gt;ch[i])&#123;            return S-&gt;ch[i]-T-&gt;ch[i];        &#125;    &#125;    //扫描过的所有字符都相同，则长度长的串更大    return S-&gt;length-T-&gt;length;&#125;//求串长，返回串S的元素个数[未完成代码]int StrLength(SString *S)&#123;    return 0;&#125;//3.定位操作，若主串S中存在与串T值相同的子串，则返回它在主串S中第一次出现的位置，否则函数值为0int Index(SString *S,SString *T)&#123;    int i=1,n=StrLength(S),m=StrLength(T);    SString sub;  //用于暂存字符串    while(i&lt;=n-m+1)&#123;        SubString(&amp;sub, S, i, m);        if(StrCompare(&amp;sub, T) != 0)&#123;            ++i;        &#125;else&#123;            return i;  //返回子串在主串中的位置        &#125;    &#125;    return 0;  //S中不存在与T相等的子串&#125;int main()&#123;    SString S=&#123;&quot;hello world!&quot;,12&#125;;        SString Sub=&#123;&quot;&quot;,0&#125;;  //初始化时清空数组    if(SubString(&amp;Sub, &amp;S, 3, 5))&#123;        printf(&quot;%s\\n&quot;,Sub.ch);    &#125;&#125;\n\n串的链式存储：\n","categories":["计算机理论"],"tags":["数据结构-数据结构笔记"]},{"title":"散列函数的设计和冲突处理","url":"/2019/03/15/%E8%AE%A1%E7%AE%97%E6%9C%BA%E7%90%86%E8%AE%BA/%E6%95%B0%E6%8D%AE%E7%BB%93%E6%9E%84/%E6%95%B0%E6%8D%AE%E7%BB%93%E6%9E%84%E7%AC%94%E8%AE%B0/7.8_%E6%95%A3%E5%88%97%E5%87%BD%E6%95%B0%E7%9A%84%E8%AE%BE%E8%AE%A1%E5%92%8C%E5%86%B2%E7%AA%81%E5%A4%84%E7%90%86/","content":"散列函数的设计：\n设计散列函数一般遵循以下基本原则:1）计算简单。散列函数不应该有很大的计算量，否则会降低查找效率;2）函数值(即散列地址)分布均匀中，希望散列函数能够把记录以相同的概率“散列”到散列表的所有地址空间中，这样才能保证存储空间的有效利用,并减少冲突。\n\n冲突处理：\n","categories":["计算机理论"],"tags":["数据结构-数据结构笔记"]},{"title":"内部排序算法的比较及应用","url":"/2019/03/15/%E8%AE%A1%E7%AE%97%E6%9C%BA%E7%90%86%E8%AE%BA/%E6%95%B0%E6%8D%AE%E7%BB%93%E6%9E%84/%E6%95%B0%E6%8D%AE%E7%BB%93%E6%9E%84%E7%AC%94%E8%AE%B0/8.11_%E5%86%85%E9%83%A8%E6%8E%92%E5%BA%8F%E7%AE%97%E6%B3%95%E7%9A%84%E6%AF%94%E8%BE%83%E5%8F%8A%E5%BA%94%E7%94%A8/","content":"冒泡排序、直接选择排序、快速排序、堆排序：一趟排序可以确定一个元素的位置\n应用：\n","categories":["计算机理论"],"tags":["数据结构-数据结构笔记"]},{"title":"外部排序的方法","url":"/2019/03/15/%E8%AE%A1%E7%AE%97%E6%9C%BA%E7%90%86%E8%AE%BA/%E6%95%B0%E6%8D%AE%E7%BB%93%E6%9E%84/%E6%95%B0%E6%8D%AE%E7%BB%93%E6%9E%84%E7%AC%94%E8%AE%B0/8.12_%E5%A4%96%E9%83%A8%E6%8E%92%E5%BA%8F%E7%9A%84%E6%96%B9%E6%B3%95/","content":"外部排序通常采用归并排序的方法\n首先根据缓冲区的大小将外存上含有n个记录的文件分成若干长度为h的子文件，依次读入内存并利用有限的内部排序算法对它们进行排序，并将排序后得到的有序子文件重新写回外存，通常称这些有序子文件为归并段或顺串\n然后对这些归并段进行逐趟归并，使归并段逐渐由小到大直至得到整个有序文件\n外部排序的总时间：内部排序所需时间+外存信息读写时间+内部归并所需时间如果变成4路归并：\n","categories":["计算机理论"],"tags":["数据结构-数据结构笔记"]},{"title":"败者树","url":"/2019/03/15/%E8%AE%A1%E7%AE%97%E6%9C%BA%E7%90%86%E8%AE%BA/%E6%95%B0%E6%8D%AE%E7%BB%93%E6%9E%84/%E6%95%B0%E6%8D%AE%E7%BB%93%E6%9E%84%E7%AC%94%E8%AE%B0/8.13_%E8%B4%A5%E8%80%85%E6%A0%91/","content":"\n失败树：树形选择排序的一种变体，可视为一棵完全二叉树\n每个叶结点存放各归并段在归并过程中当前参加比较的记录，内部结点用来记忆左右子树中的‘失败者’，胜利者向上继续进行比较，直到根结点\n","categories":["计算机理论"],"tags":["数据结构-数据结构笔记"]},{"title":"置换-选择排序","url":"/2019/03/15/%E8%AE%A1%E7%AE%97%E6%9C%BA%E7%90%86%E8%AE%BA/%E6%95%B0%E6%8D%AE%E7%BB%93%E6%9E%84/%E6%95%B0%E6%8D%AE%E7%BB%93%E6%9E%84%E7%AC%94%E8%AE%B0/8.14_%E7%BD%AE%E6%8D%A2-%E9%80%89%E6%8B%A9%E6%8E%92%E5%BA%8F/","content":"置换-选择排序：\n","categories":["计算机理论"],"tags":["数据结构-数据结构笔记"]},{"title":"最佳归并树","url":"/2019/03/15/%E8%AE%A1%E7%AE%97%E6%9C%BA%E7%90%86%E8%AE%BA/%E6%95%B0%E6%8D%AE%E7%BB%93%E6%9E%84/%E6%95%B0%E6%8D%AE%E7%BB%93%E6%9E%84%E7%AC%94%E8%AE%B0/8.15_%E6%9C%80%E4%BD%B3%E5%BD%92%E5%B9%B6%E6%A0%91/","content":"m路归并排序可用一棵m叉树描述\n归并树：用来描述m归并，并只有度为0和度为m的结点的严格m叉树\n带权路径长度之和为归并过程中的总读记录数：\n用哈夫曼树构造的叫最佳归并树：\n\n","categories":["计算机理论"],"tags":["数据结构-数据结构笔记"]},{"title":"基数排序","url":"/2019/03/15/%E8%AE%A1%E7%AE%97%E6%9C%BA%E7%90%86%E8%AE%BA/%E6%95%B0%E6%8D%AE%E7%BB%93%E6%9E%84/%E6%95%B0%E6%8D%AE%E7%BB%93%E6%9E%84%E7%AC%94%E8%AE%B0/8.10_%E5%9F%BA%E6%95%B0%E6%8E%92%E5%BA%8F/","content":"基数排序：不基于比较，借助“分配”和“收集”两种操作对单逻辑关键字进行排序，分为最高位优先(MSD)和最低位优先(LSD)\n以r为基数的最低位优先基数排序的过程(稳定的算法)：【时间复杂度为O(d(n+r))】【空间复杂度为O(r)】\n","categories":["计算机理论"],"tags":["数据结构-数据结构笔记"]},{"title":"排序的基本概念","url":"/2019/03/15/%E8%AE%A1%E7%AE%97%E6%9C%BA%E7%90%86%E8%AE%BA/%E6%95%B0%E6%8D%AE%E7%BB%93%E6%9E%84/%E6%95%B0%E6%8D%AE%E7%BB%93%E6%9E%84%E7%AC%94%E8%AE%B0/8.1_%E6%8E%92%E5%BA%8F%E7%9A%84%E5%9F%BA%E6%9C%AC%E6%A6%82%E5%BF%B5/","content":"排序：重新排列表中的元素，使表中的元素满足按关键字递增或递减\n算法的稳定性：若待排序表中有两个元素Ri和Rj，其对应的关键字Ki&#x3D;Kj，且在排序前Ri在Rj前面，若使用某排序算法后，Ri仍然在Rj前面，则称这个排序算法是稳定的，否则称排序算法不稳定\n算法的稳定性是算法的性质，并不能衡量一个算法的优劣\n时空复杂度决定内部排序算法的性能\n内部排序：指在排序期间元素全部存放在内存中的排序\n外部排序：指在排序期间元素无法全部同时存放在内存中，必须在排序的过程中根据要求不断的在内、外存之间进行移动\n","categories":["计算机理论"],"tags":["数据结构-数据结构笔记"]},{"title":"直接插入排序","url":"/2019/03/15/%E8%AE%A1%E7%AE%97%E6%9C%BA%E7%90%86%E8%AE%BA/%E6%95%B0%E6%8D%AE%E7%BB%93%E6%9E%84/%E6%95%B0%E6%8D%AE%E7%BB%93%E6%9E%84%E7%AC%94%E8%AE%B0/8.2_%E7%9B%B4%E6%8E%A5%E6%8F%92%E5%85%A5%E6%8E%92%E5%BA%8F/","content":"插入排序：每次将一个待排序的序列插入到一个前面已排好序的子序列当中\n直接插入排序(稳定的算法)：【空间复杂度为O(1)】【最好时间复杂度为O(n)，最坏、平均复杂度为O(n^2)】适用于顺序存储和链式存储\n","categories":["计算机理论"],"tags":["数据结构-数据结构笔记"]},{"title":"树和森林","url":"/2019/03/15/%E8%AE%A1%E7%AE%97%E6%9C%BA%E7%90%86%E8%AE%BA/%E6%95%B0%E6%8D%AE%E7%BB%93%E6%9E%84/%E6%95%B0%E6%8D%AE%E7%BB%93%E6%9E%84%E7%AC%94%E8%AE%B0/5.7_%E6%A0%91%E5%92%8C%E6%A3%AE%E6%9E%97/","content":"树与二叉树的转换：左孩子右兄弟\n森林与二叉树的转换：\n树的遍历：按照某种方式访问树中的每个结点，且仅访问一次\n\n先根遍历：若树非空，则先访问根结点，再按从左到右的顺序遍历根结点的每棵子树\n后根遍历：若树非空，则先按从左到右的顺序遍历根结点的每棵子树，再访问根结点\n层次遍历\n\n森林的遍历：\n\n先序遍历：若森林非空，则访问森林中第一棵树的根结点，先序遍历第一棵树的子树森林，先序遍历除去第一棵树之后剩余的树构成的子树森林\n后序遍历：若森林非空，则后序遍历第一棵树的根结点的子树森林，访问第一棵树的根结点，后序遍历除去第一棵树之后剩余的树构成的子树森林\n\n","categories":["计算机理论"],"tags":["数据结构-数据结构笔记"]},{"title":"折半插入排序","url":"/2019/03/15/%E8%AE%A1%E7%AE%97%E6%9C%BA%E7%90%86%E8%AE%BA/%E6%95%B0%E6%8D%AE%E7%BB%93%E6%9E%84/%E6%95%B0%E6%8D%AE%E7%BB%93%E6%9E%84%E7%AC%94%E8%AE%B0/8.3_%E6%8A%98%E5%8D%8A%E6%8F%92%E5%85%A5%E6%8E%92%E5%BA%8F/","content":"折半插入排序(稳定的算法)：【时间复杂度为O(n^2)】【空间复杂度为O(1)】只适用于顺序存储\n","categories":["计算机理论"],"tags":["数据结构-数据结构笔记"]},{"title":"希尔排序","url":"/2019/03/15/%E8%AE%A1%E7%AE%97%E6%9C%BA%E7%90%86%E8%AE%BA/%E6%95%B0%E6%8D%AE%E7%BB%93%E6%9E%84/%E6%95%B0%E6%8D%AE%E7%BB%93%E6%9E%84%E7%AC%94%E8%AE%B0/8.4_%E5%B8%8C%E5%B0%94%E6%8E%92%E5%BA%8F/","content":"希尔排序(不稳定算法)：缩小增量排序【最坏时间复杂度为O(n^2)，空间复杂度为O(1)】只适用于顺序存储\n基本思想：先将排序表分割成d个形如L[i,i+d,i+2d,…,i+kd]的特殊子表，分别进行直接插入排序，当整个表中的元素已呈“基本有序时”，再对全体记录进行一次直接插入排序【d1&#x3D;n&#x2F;2(取下界),d(i+1)&#x3D;(di)&#x2F;2(取下界)，直到最后一个dk&#x3D;1】\n","categories":["计算机理论"],"tags":["数据结构-数据结构笔记"]},{"title":"快速排序","url":"/2019/03/15/%E8%AE%A1%E7%AE%97%E6%9C%BA%E7%90%86%E8%AE%BA/%E6%95%B0%E6%8D%AE%E7%BB%93%E6%9E%84/%E6%95%B0%E6%8D%AE%E7%BB%93%E6%9E%84%E7%AC%94%E8%AE%B0/8.6_%E5%BF%AB%E9%80%9F%E6%8E%92%E5%BA%8F/","content":"快速排序(不稳定的算法)：【时间复杂度为O(high-low+1)】【最好、平均空间复杂度为O(log2(n))、最坏空间复杂度O(n)】【最好、平均时间复杂度为O(nlog2(n))、最坏时间复杂度为O(n^2)】\n初始基本有序或逆序的情况下时间、空间复杂度最坏\n适用于顺序存储(链式存储)\nPartition基本思路：初始化标记low为划分部分第一个元素的位置，high为最后一个元素的位置，然后不断的移动两标记并交换元素：1）high向前移动找到第一个比pivot小的元素2）low向后移动找到第一个比pivot大的元素3）交换当前两个位置的元素4）继续移动标记，执行1、2、3过程，直到low大于等于high为止\n","categories":["计算机理论"],"tags":["数据结构-数据结构笔记"]},{"title":"直接选择排序","url":"/2019/03/15/%E8%AE%A1%E7%AE%97%E6%9C%BA%E7%90%86%E8%AE%BA/%E6%95%B0%E6%8D%AE%E7%BB%93%E6%9E%84/%E6%95%B0%E6%8D%AE%E7%BB%93%E6%9E%84%E7%AC%94%E8%AE%B0/8.7_%E7%9B%B4%E6%8E%A5%E9%80%89%E6%8B%A9%E6%8E%92%E5%BA%8F/","content":"选择排序(不稳定的算法)：【时间复杂度为O(n^2)】【空间复杂度为O(1)】\n时间复杂度与初始序列无关\n适用于顺序存储和链式存储\n","categories":["计算机理论"],"tags":["数据结构-数据结构笔记"]},{"title":"堆排序","url":"/2019/03/15/%E8%AE%A1%E7%AE%97%E6%9C%BA%E7%90%86%E8%AE%BA/%E6%95%B0%E6%8D%AE%E7%BB%93%E6%9E%84/%E6%95%B0%E6%8D%AE%E7%BB%93%E6%9E%84%E7%AC%94%E8%AE%B0/8.8_%E5%A0%86%E6%8E%92%E5%BA%8F/","content":"堆：n个关键字序列L[1…n]称为堆，当且仅当该序列满足：(1&lt;&#x3D;i&lt;&#x3D;(n&#x2F;2)(取下界))1）若L(i)&lt;&#x3D;L(2i)且L(i)&lt;&#x3D;L(2i+1)，则称该堆为小根堆2）若L(i)&gt;&#x3D;L(2i)且L(i)&gt;&#x3D;L(2i+1)，则称该堆为大根堆\n在排序过程中将L[1…n]视为一棵完全二叉树的顺序存储结构\n堆的初始化(以大根堆为例)：\n堆排序(不稳定的算法)：不断的输出栈顶元素，并向下调整【时间复杂度为O(nlog2(n))】【空间复杂度为O(1)】\n适用于顺序存储(链式存储)\n堆的插入：将新结点放置在末端然后进行向上调整\n","categories":["计算机理论"],"tags":["数据结构-数据结构笔记"]},{"title":"冒泡排序","url":"/2019/03/15/%E8%AE%A1%E7%AE%97%E6%9C%BA%E7%90%86%E8%AE%BA/%E6%95%B0%E6%8D%AE%E7%BB%93%E6%9E%84/%E6%95%B0%E6%8D%AE%E7%BB%93%E6%9E%84%E7%AC%94%E8%AE%B0/8.5_%E5%86%92%E6%B3%A1%E6%8E%92%E5%BA%8F/","content":"冒泡排序(稳定的算法)：假设待排序表长为n，从前往后(从后往前)两两比较相邻元素的值，若为逆序(即A[i-1]&gt;A[i])，则交换他们直到序列比较结束【一次冒泡会将一个元素放置到它最终的位置上】\n适用于顺序存储和链式存储\n最好时间复杂度为O(n)，最坏、平均时间复杂度为O(n^2)，空间复杂度为O(1)：\n","categories":["计算机理论"],"tags":["数据结构-数据结构笔记"]},{"title":"归并排序","url":"/2019/03/15/%E8%AE%A1%E7%AE%97%E6%9C%BA%E7%90%86%E8%AE%BA/%E6%95%B0%E6%8D%AE%E7%BB%93%E6%9E%84/%E6%95%B0%E6%8D%AE%E7%BB%93%E6%9E%84%E7%AC%94%E8%AE%B0/8.9_%E5%BD%92%E5%B9%B6%E6%8E%92%E5%BA%8F/","content":"2路归并排序：\n合并两个有序线性表：\n归并排序(稳定的算法)：【时间复杂度O(nlog2(n))】【空间复杂度为O(n)】\n适用于顺序存储和链式存储\n","categories":["计算机理论"],"tags":["数据结构-数据结构笔记"]},{"title":"概念、功能、组成、分类","url":"/2020/05/31/%E8%AE%A1%E7%AE%97%E6%9C%BA%E7%90%86%E8%AE%BA/%E8%AE%A1%E7%AE%97%E6%9C%BA%E7%BD%91%E7%BB%9C%E5%8E%9F%E7%90%86/%E8%AE%A1%E7%AE%97%E6%9C%BA%E7%BD%91%E7%BB%9C%E5%8E%9F%E7%90%86%E7%AC%94%E8%AE%B0/1.1_%E6%A6%82%E5%BF%B5%E3%80%81%E5%8A%9F%E8%83%BD%E3%80%81%E7%BB%84%E6%88%90%E3%80%81%E5%88%86%E7%B1%BB/","content":"概念、功能、组成、分类：\n计算机网络：是一个将分散的、具有独立功能的计算机系统，通过通信设备与线路连接起来，由功能完善的软件实现资源共享和信息传递的系统\n计算机网络是互连的【互联互通、通信链路】、自治的【无主从关系】计算机集合\n计算机网络的功能：1）数据通信（连通性）2）资源共享（硬件、软件、数据）3）分布式处理：多台计算机各自承担同一工作任务的不同部分（Hadoop平台）4）提高可靠性5）负载均衡（各计算机之间更亲密）\n计算机网络的组成：1）按组成部分分类：硬件、软件、协议2）按工作方式分类：边缘部分（用户直接使用：C&#x2F;S方式、P2P方式）、核心部分（为边缘部分服务）3）按功能组成分类：通信子网（实现数据通信）、资源子网（实现资源共享&#x2F;数据处理）\n计算机网络的分类：1）按分布范围分：广域网（WAN、使用交换技术）、城域网（MAN）、局域网（LAN、使用广播技术）、个人区域网（PAN）2）按使用者分：公用网、专用网3）按交换技术分：电路交换、报文交换、分组交换4）按拓扑结构分：总线型、星型、环型、网状型（常用于广域网）5）按传输技术分：广播式网络（共享公共通信信道）、点对点网络（使用分组存储转发和路由选择机制）\n","categories":["计算机理论"],"tags":["计算机网络原理-计算机网络原理笔记"]},{"title":"分块查找","url":"/2019/03/15/%E8%AE%A1%E7%AE%97%E6%9C%BA%E7%90%86%E8%AE%BA/%E6%95%B0%E6%8D%AE%E7%BB%93%E6%9E%84/%E6%95%B0%E6%8D%AE%E7%BB%93%E6%9E%84%E7%AC%94%E8%AE%B0/7.4_%E5%88%86%E5%9D%97%E6%9F%A5%E6%89%BE/","content":"分块查找：又称索引顺序查找，其查找性能介于折半查找和顺序查找之间\n分块查找的使用前提是将线性表进行分块，并使其分块有序，所谓分块有序是指将线性表划分为若干块，每一块内不要求有序(即块内无序)，但要求第二块中所有记录的关键码均大于第一块中所有记录的关键码，第三块中所有记录的关键码均大于第二块中所有记录的关键码，以此类推(即块间有序)\n分块查找还需要建立一个索引表，每块对应一个索引项，各索引项按关键码有序排序\n分块查找需要分两步进行：第一步在索引表中确定待查关键码所在的块；第二步在相应块中查找待查关键码。由于索引表是按关键码有序排列，可使用顺序查找，也可使用折半查找；在块内进行查找时，由于块内是无序的，只能使用顺序查找\n","categories":["计算机理论"],"tags":["数据结构-数据结构笔记"]},{"title":"标准化","url":"/2020/05/31/%E8%AE%A1%E7%AE%97%E6%9C%BA%E7%90%86%E8%AE%BA/%E8%AE%A1%E7%AE%97%E6%9C%BA%E7%BD%91%E7%BB%9C%E5%8E%9F%E7%90%86/%E8%AE%A1%E7%AE%97%E6%9C%BA%E7%BD%91%E7%BB%9C%E5%8E%9F%E7%90%86%E7%AC%94%E8%AE%B0/1.2_%E6%A0%87%E5%87%86%E5%8C%96/","content":"标准化：\n要实现不同厂商的硬、软件之间相互连通，必须遵守统一的标准\n标准的分类：1）法定标准（由权威机构制定的正式的、合法的标准：OSI）2）事实标准（某些公司的产品在竞争中占据了主流，时间长了，这些产品中的协议和技术就成了标准：TCP&#x2F;IP）\nRFC（Request For Comments）：因特网标准的形式\nRFC要上升为因特网正式标准的四个阶段：1）因特网草案：这个阶段还不是RFC文档2）建议标准：从这个阶段开始成为RFC文档3）因特网标准\n标准化工作的相关组织：1）国际标准化组织ISO：OSI参考模型、HDLC协议2）国际电信联盟ITU：制定通信规则3）国际电气电子工程师协会IEEE：学术机构、IEEE802系列标准、5G4）Internet工程任务组IETF：负责因特网相关标准的制定\n","categories":["计算机理论"],"tags":["计算机网络原理-计算机网络原理笔记"]},{"title":"7层OSI参考模型","url":"/2020/05/31/%E8%AE%A1%E7%AE%97%E6%9C%BA%E7%90%86%E8%AE%BA/%E8%AE%A1%E7%AE%97%E6%9C%BA%E7%BD%91%E7%BB%9C%E5%8E%9F%E7%90%86/%E8%AE%A1%E7%AE%97%E6%9C%BA%E7%BD%91%E7%BB%9C%E5%8E%9F%E7%90%86%E7%AC%94%E8%AE%B0/1.6_7%E5%B1%82OSI%E5%8F%82%E8%80%83%E6%A8%A1%E5%9E%8B/","content":"7层OSI参考模型：\n为了支持异构网络系统的互联互通，国际标准化组织ISO于1984年提出开放系统互连（OSI）参考模型\n应用层：用户与网络的界面，所有能和用户交互产生网络流量的程序【文件传输(FTP)、电子邮件(SMTP)、万维网(HTTP)】\n表示层：用于处理在两个通信系统中交换信息的表示方式（语法和语义）【功能：数据格式变换、数据加密解密、数据压缩和恢复】【主要协议：JPEG、ASCII】\n会话层：向表示层实体&#x2F;用户进程提供建立连接并在连接上有序的传输数据，这是会话，也是建立同步(SYN)【功能：建立、管理、终止会话；使用校验点可使会话在通信失效时从校验点&#x2F;同步点继续恢复通信，实现数据同步，适用于传输大文件】【主要协议：ADSP、ASP】\n传输层：负责主机中两个进程的通信，即端到端的通信，传输单位是报文段或用户数据段【功能：可靠传输、不可靠传输；差错控制；流量控制；复用分用(复用：多个应用层进程可同时使用下面运输层的服务；分用：运输层把收到的信息分别交付给上面应用层中相应的进程)】【主要协议：TCP、UDP】\n网络层：主要任务是把分组从源端传到目的端，为分组交换网上的不同主机提供通信服务，网络层传输单位是数据报【功能：路由选择、最佳路径；流量控制；差错控制；拥塞控制(若所有结点都来不及接受分组，而要丢弃大量分组的话，网络就处于拥塞状态。因此要采取一定措施，缓解这种拥塞)】【主要协议：IP、IPX、ICMP、IGMP、ARP、RARP、OSPF】\n数据链路层：主要任务是把网络层传下来的数据报组装成帧，数据链路层&#x2F;链路层的传输单位是帧【功能：成帧(定义帧的开始和结束)；差错控制(帧错+位错)；流量控制；访问(接入)控制(控制对信道的访问)】【主要协议：SDLC、HDLC、PPP、STP】\n物理层：主要任务是在物理媒体上实现比特流的透明传输，物理层传输单位是比特(透明传输：指不管所传数据是什么样的比特组合，都应当能够在链路上传送)【功能：定义接口特性；定义传输模式(单工、半双工、双工)；定义传输速率；比特同步；比特编码】【主要协议：Rj45、802.3】\n","categories":["计算机理论"],"tags":["计算机网络原理-计算机网络原理笔记"]},{"title":"速率、带宽、吞吐量","url":"/2020/05/31/%E8%AE%A1%E7%AE%97%E6%9C%BA%E7%90%86%E8%AE%BA/%E8%AE%A1%E7%AE%97%E6%9C%BA%E7%BD%91%E7%BB%9C%E5%8E%9F%E7%90%86/%E8%AE%A1%E7%AE%97%E6%9C%BA%E7%BD%91%E7%BB%9C%E5%8E%9F%E7%90%86%E7%AC%94%E8%AE%B0/1.3_%E9%80%9F%E7%8E%87%E3%80%81%E5%B8%A6%E5%AE%BD%E3%80%81%E5%90%9E%E5%90%90%E9%87%8F/","content":"速率、带宽、吞吐量：\n速率：即数据率、数据传输率、比特率，连接在计算机网络上的主机在数字信道上传送数据位数的速率（b&#x2F;s、kb&#x2F;s、Mb&#x2F;s、Gb&#x2F;s、Tb&#x2F;s）\n带宽：原本指某个信号具有的频带宽度，即最高频率与最低频率之差，单位是赫兹（Hz）；计算机网络中，带宽用来表示网络的通信线路传送数据的能力，通常是指单位时间内从网络中的某一点到另一点所能通过的最高数据率（b&#x2F;s、kb&#x2F;s、Mb&#x2F;s、Gb&#x2F;s、Tb&#x2F;s），网络设备所支持的最高速度\n吞吐量：表示在单位时间内通过某个网络（或信道、接口）的数据量（b&#x2F;s、kb&#x2F;s、Mb&#x2F;s、Gb&#x2F;s、Tb&#x2F;s），吞吐量受网络的带宽或网络的额定速率的限制\n","categories":["计算机理论"],"tags":["计算机网络原理-计算机网络原理笔记"]},{"title":"时延、时延带宽积、往返时间RTT、利用率","url":"/2020/05/31/%E8%AE%A1%E7%AE%97%E6%9C%BA%E7%90%86%E8%AE%BA/%E8%AE%A1%E7%AE%97%E6%9C%BA%E7%BD%91%E7%BB%9C%E5%8E%9F%E7%90%86/%E8%AE%A1%E7%AE%97%E6%9C%BA%E7%BD%91%E7%BB%9C%E5%8E%9F%E7%90%86%E7%AC%94%E8%AE%B0/1.4_%E6%97%B6%E5%BB%B6%E3%80%81%E6%97%B6%E5%BB%B6%E5%B8%A6%E5%AE%BD%E7%A7%AF%E3%80%81%E5%BE%80%E8%BF%94%E6%97%B6%E9%97%B4RTT%E3%80%81%E5%88%A9%E7%94%A8%E7%8E%87/","content":"时延、时延带宽积、往返时间RTT、利用率\n时延：指数据（报文&#x2F;分组&#x2F;比特流）从网络（或链路）的一端传送到另一端所需的时间，也叫延迟或迟延，单位是s\n1）发送时延（传输时延）：从发送分组的第一个比特算起，到该分组的最后一个比特发送完毕所需的时间【计算公式：数据长度&#x2F;信道带宽（发送速率）】2）传播时延：取决于电磁波传播速度和链路长度【公式：信道长度&#x2F;电磁波在信道上的传播速率】3）排队时延：等待输出&#x2F;入链路可用4）处理时延：检错、找出口\n高速链路只是提高了信道带宽，减小了发送时延，但是传播时延和传播速率是不变的\n时延带宽积（bit）：传播时延（s）*带宽（b&#x2F;s），又称为以比特为单位的链路长度，即“某段链路现在有多少比特”\n往返时延RTT：从发送方发送数据开始，到发送方收到接收方的确认（接收方收到数据后立即发送确认），总共经过的时延；RTT越大，在收到确认之前，可以发送的数据越多\nRTT包括：往返传播时延&#x3D;传播时延*2、末端处理时间【不包括发送时延】\n利用率：信道利用率【有数据通过时间&#x2F;有+无数据通过时间】、网络利用率（信道利用率加权平均值）\n","categories":["计算机理论"],"tags":["计算机网络原理-计算机网络原理笔记"]},{"title":"分层结构、协议、接口、服务","url":"/2020/05/31/%E8%AE%A1%E7%AE%97%E6%9C%BA%E7%90%86%E8%AE%BA/%E8%AE%A1%E7%AE%97%E6%9C%BA%E7%BD%91%E7%BB%9C%E5%8E%9F%E7%90%86/%E8%AE%A1%E7%AE%97%E6%9C%BA%E7%BD%91%E7%BB%9C%E5%8E%9F%E7%90%86%E7%AC%94%E8%AE%B0/1.5_%E5%88%86%E5%B1%82%E7%BB%93%E6%9E%84%E3%80%81%E5%8D%8F%E8%AE%AE%E3%80%81%E6%8E%A5%E5%8F%A3%E3%80%81%E6%9C%8D%E5%8A%A1/","content":"分层结构、协议、接口、服务：\n发送文件前要完成的工作：1）发起通信的计算机必须将数据通信的通路进行激活2）要告诉网络如何识别目的主机3）发起通信的计算机要查明目的主机是否开机，并且与网络连接正常4）发起通信的计算机要弄清楚，对方计算机中文件管理程序是否已经做好准备工作5）确保差错和意外可以解决\n分层的基本原则：1）各层之间相互独立，每层只实现一种相对独立的功能2）每层之间界面自然清晰，易于理解，相互交流尽可能少3）结构上可分割开，每层都采用最合适的技术来实现4）保持下层对上层的独立性，上层单向使用下层提供的服务5）整个分层结构应该能促进标准化工作\n1）网络体系结构是从功能上描述计算机网络结构2）计算机网络体系结构简称网络体系结构，是分层结构3）每层遵循某个&#x2F;些网络协议以完成本层功能4）计算机网络体系结构是计算机网络的各层及其协议的集合5）第n层在向n+1层提供服务时，此服务不仅包含第n层本身的功能，还包含由下层服务提供的功能6）仅仅在相邻层间有接口，且所提供服务的具体实现细节对上一层完全屏蔽7）体系结构是抽象的，而实现是指能运行的一些软件和硬件\n","categories":["计算机理论"],"tags":["计算机网络原理-计算机网络原理笔记"]},{"title":"4层TCP/IP参考模型","url":"/2020/05/31/%E8%AE%A1%E7%AE%97%E6%9C%BA%E7%90%86%E8%AE%BA/%E8%AE%A1%E7%AE%97%E6%9C%BA%E7%BD%91%E7%BB%9C%E5%8E%9F%E7%90%86/%E8%AE%A1%E7%AE%97%E6%9C%BA%E7%BD%91%E7%BB%9C%E5%8E%9F%E7%90%86%E7%AC%94%E8%AE%B0/1.7_4%E5%B1%82TCP:IP%E5%8F%82%E8%80%83%E6%A8%A1%E5%9E%8B/","content":"4层TCP&#x2F;IP参考模型：\n\nOSI参考模型与TCP&#x2F;IP参考模型：\n相同点：1）都分层2）基于独立的协议栈的概念3）可以实现异构网络互联\n不同点：\n","categories":["计算机理论"],"tags":["计算机网络原理-计算机网络原理笔记"]},{"title":"码元、波特、速率、带宽","url":"/2020/05/31/%E8%AE%A1%E7%AE%97%E6%9C%BA%E7%90%86%E8%AE%BA/%E8%AE%A1%E7%AE%97%E6%9C%BA%E7%BD%91%E7%BB%9C%E5%8E%9F%E7%90%86/%E8%AE%A1%E7%AE%97%E6%9C%BA%E7%BD%91%E7%BB%9C%E5%8E%9F%E7%90%86%E7%AC%94%E8%AE%B0/2.3_%E7%A0%81%E5%85%83%E3%80%81%E6%B3%A2%E7%89%B9%E3%80%81%E9%80%9F%E7%8E%87%E3%80%81%E5%B8%A6%E5%AE%BD/","content":"码元、波特、速率、带宽：\n码元是指用一个固定时长的信号波形（数字脉冲），代表不同离散数值的基本波形，是数字通信中数字信号的计量单位，这个时长内的信号称为k进制码元，而该时长称为码元宽度，当码元的离散状态有M个时（M大于2），此时码元为M进制码元；一码元可以携带多个比特的信息量，例如在使用二进制编码时，只有两种不同的码元，一种代表0状态，另一种代表1状态\n速率也叫数据率，是指数据的传输速率（注意区分传播速率），表示单位时间内传输的数据量，可以用码元传输速率和信息传输速率表示\n码元传输速率：别名码元速率、波形速率、调制速率、符号速率等，它表示单位时间内数字通信系统所传输的码元个数（也可称为脉冲个数或信号变化的次数），单位是波特（Baud），1波特表示数字通信系统每秒传输一个码元，这里的码元可以是多进制的，也可以是二进制的，但码元速率与进制数无关【1s传输多少个码元】\n信息传输速率：别名信息速率、比特率等，表示单位时间内数字通信系统传输的二进制码元个数（即比特数），单位是比特&#x2F;秒（b&#x2F;s）【1s传输多少个比特】\n关系：若一个码元携带n bit的信息量，则M Baud的码元传输速率所对应的信息传输速率为M*n bit&#x2F;s\n带宽：表示在单位时间内从网络中的某一点到另一点所能通过的“最高数据率”，常用来表示网络的通信线路所能传输数据的能力，单位是b&#x2F;s\n","categories":["计算机理论"],"tags":["计算机网络原理-计算机网络原理笔记"]},{"title":"5层参考模型","url":"/2020/05/31/%E8%AE%A1%E7%AE%97%E6%9C%BA%E7%90%86%E8%AE%BA/%E8%AE%A1%E7%AE%97%E6%9C%BA%E7%BD%91%E7%BB%9C%E5%8E%9F%E7%90%86/%E8%AE%A1%E7%AE%97%E6%9C%BA%E7%BD%91%E7%BB%9C%E5%8E%9F%E7%90%86%E7%AC%94%E8%AE%B0/1.8_5%E5%B1%82%E5%8F%82%E8%80%83%E6%A8%A1%E5%9E%8B/","content":"5层参考模型：\n\n5层参考模型的数据封装与解封装：\n","categories":["计算机理论"],"tags":["计算机网络原理-计算机网络原理笔记"]},{"title":"奈式准则和香农定理","url":"/2020/05/31/%E8%AE%A1%E7%AE%97%E6%9C%BA%E7%90%86%E8%AE%BA/%E8%AE%A1%E7%AE%97%E6%9C%BA%E7%BD%91%E7%BB%9C%E5%8E%9F%E7%90%86/%E8%AE%A1%E7%AE%97%E6%9C%BA%E7%BD%91%E7%BB%9C%E5%8E%9F%E7%90%86%E7%AC%94%E8%AE%B0/2.4_%E5%A5%88%E5%BC%8F%E5%87%86%E5%88%99%E5%92%8C%E9%A6%99%E5%86%9C%E5%AE%9A%E7%90%86/","content":"奈式准则和香农定理：\n失真：\n失真的一种现象：码间串扰（接收端收到的信号波形失去了码元之间清晰界限的现象）\n奈式准则（奈奎斯特定理）：在理想低通（无噪声，带宽受限）条件下，为了避免码间串扰，极限码元传输速率为2W Baud，W是信道带宽，单位是Hz【只有在这两个公式这带宽才用Hz】\n理想低通信道下的极限数据传输率&#x3D;2Wlog2V（b&#x2F;s）\n1）在任何信道中，码元传输的速率是有上限的，若传输速率超过此上限，就会出现严重的码间串扰问题，使接收端对码元的完全正确识别成为不可能2）信道的频带越宽（即能通过的信号高频分量越多），就可以用更高的速率进行码元的有效传输3）奈式准则给出了码元传输速率的限制，但并没有对信息传输速率给出限制4）由于码元的传输速率受奈式准则的制约，所以要提高数据的传输速率，就必须设法使每个码元能携带更多个比特的信息量，这就需要采用多元制的调制方法\n香农定理：\n噪声存在于所有的电子设备和通信信道中，由于噪声随机产生，它的瞬时值有时会很大，因此噪声会使接收端对码元的判决产生错误。但是噪声的影响是相对的，若信号较强，那么噪声影响相对较小。因此信噪比就很重要\n信噪比&#x3D;信号的平均功率&#x2F;噪声的平均功率，常记为S&#x2F;N，并用分贝（dB）作为度量单位，即：信噪比（dB）&#x3D;10log10(S&#x2F;N)【注意题目中有没有dB这个单位】\n香农定理：在带宽受限且有噪声的信道中，为了不产生误差，信息的数据传输速率有上限值\n信道的极限数据传输速率&#x3D;Wlog2(1+S&#x2F;N)(b&#x2F;s)\n1）信道的带宽或信道中的信噪比越大，则信息的极限传输速率就越高2）对一定的传输带宽和一定的信噪比，信息传输速率的上限就确定了3）只要信息的传输速率低于信道的极限传输速率，就一定能找到某种方法来实现无差错的传输4）香农定理得出的为极限信息传输速率，实际信道能达到的传输速率要比它低不少5）从香农定理可以看出，若信道带宽W或信噪比S&#x2F;N没有上限（不可能），那么信道的极限信息传输速率也就没有上限\n取最小值：\n","categories":["计算机理论"],"tags":["计算机网络原理-计算机网络原理笔记"]},{"title":"物理层传输介质","url":"/2020/05/31/%E8%AE%A1%E7%AE%97%E6%9C%BA%E7%90%86%E8%AE%BA/%E8%AE%A1%E7%AE%97%E6%9C%BA%E7%BD%91%E7%BB%9C%E5%8E%9F%E7%90%86/%E8%AE%A1%E7%AE%97%E6%9C%BA%E7%BD%91%E7%BB%9C%E5%8E%9F%E7%90%86%E7%AC%94%E8%AE%B0/2.6_%E7%89%A9%E7%90%86%E5%B1%82%E4%BC%A0%E8%BE%93%E4%BB%8B%E8%B4%A8/","content":"物理层传输介质：\n传输介质也称传输媒体&#x2F;传输媒介，它就是数据传输系统中在发送设备和接收设备之间的物理通路\n传输媒体并不是物理层，传输媒体在物理层的下面，因为物理层是体系结构的第一层，因此有时称传输媒体为0层。在传输媒体中传输的是信号但传输媒体并不知道所传输的信号代表什么意思，但物理层规定了电气特性，因此能够识别所传送的比特流\n传输介质：1）导向性传输介质：电磁波被导向沿着固体媒介(铜线&#x2F;光纤)传播2）非导向性传输介质：自由空间，介质可以是空气、真空、海水等\n导向性传输介质:\n1）双绞线2）同轴电缆3）光纤特点：传输损耗小，中继距离长，对远距离传输特别经济；抗雷电和电磁干扰性能好；无串音干扰，保密性好，也不易被窃听或截取数据；体积小，重量轻\n非导向性传输介质：\n","categories":["计算机理论"],"tags":["计算机网络原理-计算机网络原理笔记"]},{"title":"物理层设备","url":"/2020/05/31/%E8%AE%A1%E7%AE%97%E6%9C%BA%E7%90%86%E8%AE%BA/%E8%AE%A1%E7%AE%97%E6%9C%BA%E7%BD%91%E7%BB%9C%E5%8E%9F%E7%90%86/%E8%AE%A1%E7%AE%97%E6%9C%BA%E7%BD%91%E7%BB%9C%E5%8E%9F%E7%90%86%E7%AC%94%E8%AE%B0/2.7_%E7%89%A9%E7%90%86%E5%B1%82%E8%AE%BE%E5%A4%87/","content":"物理层设备：\n————————————————\n中继器：\n诞生原因：由于存在损耗，在线路上传输的信号功率会逐渐衰减，衰减到一定程度时将造成信号失真，因此会导致接收错误\n中继器的功能：对信号进行再生和还原，对衰减的信号进行放大，保持与原数据相同，以增加信号传输的距离，延长网络的长度【再生数字信号】\n中继器的两端：1）两端的网络部分是网段，而不是子网，适用于完全相同的两类网络的互连，且两个网段速率要相同2）中继器只将任何电缆段上的数据发送到另一段电缆上，它仅作用于信号的电气部分，并不管数据中是否有错误数据或不适于网段的数据3）两端可连相同媒体，也可连不同媒体4）中继器两端的网段一定要是同一个协议（中继器不会存储转发）\n5-4-3规则：网络标准中都对信号的延迟范围作了具体的规定，因而中继器只能在规定的范围内进行，否则会网络故障\n—————————————————\n集线器（多口中继器）：\n","categories":["计算机理论"],"tags":["计算机网络原理-计算机网络原理笔记"]},{"title":"物理层基本概念","url":"/2020/05/31/%E8%AE%A1%E7%AE%97%E6%9C%BA%E7%90%86%E8%AE%BA/%E8%AE%A1%E7%AE%97%E6%9C%BA%E7%BD%91%E7%BB%9C%E5%8E%9F%E7%90%86/%E8%AE%A1%E7%AE%97%E6%9C%BA%E7%BD%91%E7%BB%9C%E5%8E%9F%E7%90%86%E7%AC%94%E8%AE%B0/2.1_%E7%89%A9%E7%90%86%E5%B1%82%E5%9F%BA%E6%9C%AC%E6%A6%82%E5%BF%B5/","content":"物理层基本概念：\n物理层解决如何在连接各种计算机的传输媒体上传输数据比特流，而不是指具体的传输媒体\n物理层主要任务：确定与传输媒体接口有关的一些特性(定义标准)1）机械特性：定义物理连接的特性，规定物理连接时所采用的规格、接口形状、引线数目、引脚数量和排列情况2）电气特性：规定传输二进制位时，线路上信号的电压范围、阻抗匹配、传输速率和距离限制等3）功能特性：指明某条线上出现的某一电平表示何种意义，接口部件的信号线的用途4）规程特性：（过程特性）定义各条物理线路的工作规程和时序关系\n","categories":["计算机理论"],"tags":["计算机网络原理-计算机网络原理笔记"]},{"title":"局域网基本概念和体系结构","url":"/2020/05/31/%E8%AE%A1%E7%AE%97%E6%9C%BA%E7%90%86%E8%AE%BA/%E8%AE%A1%E7%AE%97%E6%9C%BA%E7%BD%91%E7%BB%9C%E5%8E%9F%E7%90%86/%E8%AE%A1%E7%AE%97%E6%9C%BA%E7%BD%91%E7%BB%9C%E5%8E%9F%E7%90%86%E7%AC%94%E8%AE%B0/3.11_%E5%B1%80%E5%9F%9F%E7%BD%91%E5%9F%BA%E6%9C%AC%E6%A6%82%E5%BF%B5%E5%92%8C%E4%BD%93%E7%B3%BB%E7%BB%93%E6%9E%84/","content":"局域网基本概念和体系结构：\n局域网：简称LAN，是指在某一区域内由多台计算机互联成的计算机组，使用广播信道\n特点：1）覆盖的地理范围较小，只在一个相对独立的局部范围内联，如一座或集中的建筑群内2）使用专门铺设的传输介质（双绞线、同轴电缆）进行联网，数据传输速率高（10Mb&#x2F;s～10Gb&#x2F;s）3）通信延迟时间短，误码率低，可靠性较高4）各站为平等关系，共享传输信道5）多采用分布式控制和广播式通信，能进行广播和组播\n决定局域网的主要要素为：网络拓扑、传输介质、介质访问控制方法\n局域网拓扑结构：\n局域网传输介质：1）有线局域网：双绞线、同轴电缆、光纤2）无线局域网：电磁波\n局域网介质访问控制方法：1）CSMA-CD：常用于总线型局域网，也用于树型网络2）令牌总线：常用于总线型局域网，也用于树型网络；它是把总线型或树型网络中的各个工作站按一定的顺序如按接口地址大小排列形成一个逻辑环，只有令牌持有者才能控制总线，才有发送信息的权力3）令牌环：用于环形局域网，如令牌环网\n局域网的分类：\nIEEE 802标准：1）IEEE 802.3:以太网2）IEEE 802.5:令牌环网3）IEEE 802.8:光纤4）IEEE 802.11:无线局域网\nMAC子层和LLC子层：\n","categories":["计算机理论"],"tags":["计算机网络原理-计算机网络原理笔记"]},{"title":"数据通信基础知识","url":"/2020/05/31/%E8%AE%A1%E7%AE%97%E6%9C%BA%E7%90%86%E8%AE%BA/%E8%AE%A1%E7%AE%97%E6%9C%BA%E7%BD%91%E7%BB%9C%E5%8E%9F%E7%90%86/%E8%AE%A1%E7%AE%97%E6%9C%BA%E7%BD%91%E7%BB%9C%E5%8E%9F%E7%90%86%E7%AC%94%E8%AE%B0/2.2_%E6%95%B0%E6%8D%AE%E9%80%9A%E4%BF%A1%E5%9F%BA%E7%A1%80%E7%9F%A5%E8%AF%86/","content":"数据通信基础知识：\n典型的数据通信模型：\n通信的目的是传送消息\n数据：传送信息的实体，通常是有意义的符号序列\n信号：数据的电气&#x2F;电磁的表现，是数据在传输过程中的存在形式【数字信号：代表消息的参数取值是离散的；模拟信号：代表消息的参数取值是连续的】\n信源：产生和发送数据的源头\n信宿：接收数据的终点\n信道：信号的传输媒介，一般用来表示向某一个方向传送信息的介质，因此一条通信线路往往包含一条发送信道和一条接收信道【按传输信号分：模拟信道(传送模拟信号)、数字信道(传送数字信号)；按传输介质分：无线信道、有线信道】\n三种通信方式：1）单工通信：只有一个方向的通信而没有反方向的交互，仅需要一条信道2）半双工通信：通信的双方都可以发送或接收信息，但任何一方都不能同时发送和接收，需要两条信道3）全双工通信：通信双方可以同时发送和接收信息，也需要两条信道\n两种数据传输方式：1）串形传输：速度慢，费用低，适合远距离2）并行传输：速度快，费用高，适合近距离，用于计算机内部数据传输\n","categories":["计算机理论"],"tags":["计算机网络原理-计算机网络原理笔记"]},{"title":"无线局域网","url":"/2020/05/31/%E8%AE%A1%E7%AE%97%E6%9C%BA%E7%90%86%E8%AE%BA/%E8%AE%A1%E7%AE%97%E6%9C%BA%E7%BD%91%E7%BB%9C%E5%8E%9F%E7%90%86/%E8%AE%A1%E7%AE%97%E6%9C%BA%E7%BD%91%E7%BB%9C%E5%8E%9F%E7%90%86%E7%AC%94%E8%AE%B0/3.13_%E6%97%A0%E7%BA%BF%E5%B1%80%E5%9F%9F%E7%BD%91/","content":"无线局域网：\nIEEE 802.11是无线局域网通用的标准，它是由IEEE所定义的无线网络通信的标准\n无线局域网的分类：1）有固定基础设施无线局域网2）无固定基础设施无线局域网的自组织网络\n","categories":["计算机理论"],"tags":["计算机网络原理-计算机网络原理笔记"]},{"title":"PPP协议和HDLC协议","url":"/2020/05/31/%E8%AE%A1%E7%AE%97%E6%9C%BA%E7%90%86%E8%AE%BA/%E8%AE%A1%E7%AE%97%E6%9C%BA%E7%BD%91%E7%BB%9C%E5%8E%9F%E7%90%86/%E8%AE%A1%E7%AE%97%E6%9C%BA%E7%BD%91%E7%BB%9C%E5%8E%9F%E7%90%86%E7%AC%94%E8%AE%B0/3.14_PPP%E5%8D%8F%E8%AE%AE%E5%92%8CHDLC%E5%8D%8F%E8%AE%AE/","content":"PPP协议和HDLC协议：\n广域网：WAN，通常跨接很大的物理范围，所覆盖的范围从几十公里到几千公里，它能连接多个城市或国家，或横跨几个洲并能提供远距离通信，形成国际性的远程网络\n广域网的通信子网主要使用分组交换技术，广域网的通信子网可以利用公用分组交换网、卫星通信网和无线分组交换网，它将分布在不同地区的局域网或计算机系统互连起来，达到资源共享的目的，如因特网（Internet）是世界范围内最大的广域网\n————————————\n点对点协议PPP是目前使用最广泛的数据链路层协议，用户使用拨号电话接入因特网时一般都使用PPP协议\nPPP协议只支持全双工链路\nPPP协议应满足的要求：1）简单：对于链路层的帧，无需纠错，无需序号，无需流量控制2）封装成帧：帧定界符3）透明传输：与帧定界符一样比特组合的数据应该如何处理：异步线路用字节填充，同步线路用比特填充4）多种网络层协议：封装的IP数据报可以采用多种协议5）多种类型链路：串行&#x2F;并行，同步&#x2F;异步，电&#x2F;光6）差错检测：错就丢弃7）检测连接状态：链路是否正常工作8）最大传送单元：数据部分最大长度MTU9）网络层地址协商：知道通信双方的网络层地址10）数据压缩协商\nPPP协议无需满足的要求：1）纠错2）流量控制3）序号4）支持多点线路\nPPP协议的三个组成部分：1）一个将IP数据报封装到串行链路（同步串行&#x2F;异步串行）的方法2）链路控制协议LCP：建立并维护数据链路连接（身份验证）3）网络控制协议NCP：PPP可支持多种网络层协议，每个不同的网络层协议都要一个相应的NCP来配置，为网络层协议建立和配置逻辑连接\nPPP协议的状态图：\nPPP协议的帧格式：\n———————————\nHDLC协议：高级数据链路控制，是一个在同步网上传输数据、面向比特的数据链路层协议，它是由国际标准化组织ISO根据IBM公司的SDLC协议扩展开发而成的\n数据报文可透明传输，用于实现透明传输的“0比特插入法”易于硬件实现\n采用全双工通信\n所有帧采用CRC检验，对信息帧进行顺序编号，可防止漏收或重份，传输可靠性高\nHDLC的站：\nHDLC的帧格式：\nPPP协议和HDLC协议：\n","categories":["计算机理论"],"tags":["计算机网络原理-计算机网络原理笔记"]},{"title":"编码与调制","url":"/2020/05/31/%E8%AE%A1%E7%AE%97%E6%9C%BA%E7%90%86%E8%AE%BA/%E8%AE%A1%E7%AE%97%E6%9C%BA%E7%BD%91%E7%BB%9C%E5%8E%9F%E7%90%86/%E8%AE%A1%E7%AE%97%E6%9C%BA%E7%BD%91%E7%BB%9C%E5%8E%9F%E7%90%86%E7%AC%94%E8%AE%B0/2.5_%E7%BC%96%E7%A0%81%E4%B8%8E%E8%B0%83%E5%88%B6/","content":"编码与调制：\n信道：信号的传输媒介，一般用来表示向某一个方向传送信息的介质，因此一条通信线路往往包含一条发送信道和一条接收信道【按传输信号分：模拟信道(传送模拟信号)、数字信道(传送数字信号)；按传输介质分：无线信道、有线信道】\n信道上传送的信号：1）基带信号：将数字信号1和0直接用两种不同的电压表示，再送到数字信道上去传输（基带传输）【来自信源的信号，像计算机输出的代表各种文字或图像文件的数据信号都属于基带信号，基带信号就是发出的直接表达了要传输的信息的信号，比如我们说话的声波就是基带信号】2）宽带信号：将基带信号进行调制后形成的频分复用模拟信号，再传送到模拟信道上去传输（宽带传输）【把基带信号经过载波调制后，把信号的频率范围搬移到较高的频段以便在信道中传输（即仅在一段频率范围内能够通过信道】\n在传输距离较近时，计算机网络采用基带传输方式（近距离衰减小，从而信号内容不易发生变化）在传输距离较远时，计算机网络采用宽带传输方式（远距离衰减大，即使信号变化大也能最后过滤出来基带信号）\n编码与调制：\n数字数据编码为数字信号：\n数字数据调制为模拟信号：数字数据调制技术在发送端将数字信号转换为模拟信号，而在接收端将模拟信号还原为数字信号，分别对应于调制解调器的调制和解调过程\n模拟数据编码为数字信号：\n模拟数据调制为模拟信号：\n","categories":["计算机理论"],"tags":["计算机网络原理-计算机网络原理笔记"]},{"title":"封装成帧和透明传输","url":"/2020/05/31/%E8%AE%A1%E7%AE%97%E6%9C%BA%E7%90%86%E8%AE%BA/%E8%AE%A1%E7%AE%97%E6%9C%BA%E7%BD%91%E7%BB%9C%E5%8E%9F%E7%90%86/%E8%AE%A1%E7%AE%97%E6%9C%BA%E7%BD%91%E7%BB%9C%E5%8E%9F%E7%90%86%E7%AC%94%E8%AE%B0/3.2_%E5%B0%81%E8%A3%85%E6%88%90%E5%B8%A7%E5%92%8C%E9%80%8F%E6%98%8E%E4%BC%A0%E8%BE%93/","content":"封装成帧和透明传输：\n封装成帧就是在一段数据的前后部分添加首部和尾部，这样就构成了一个帧。接收端在收到物理层上交的比特流后，就能根据首部和尾部的标记，从收到的比特流中识别帧的开始和结束\n首部和尾部包含许多的控制信息，他们的一个重要作用：帧定界（确定帧的界限）\n帧同步：接收方应当能从接收到的二进制比特流中区分出帧的起始和终止\n组帧的四种方法：字符计数法、字符（节）填充法、零比特填充法、违规编码法\n透明传输是指不管所传数据是什么样的比特组合，都应当能够在链路上传送。因此，链路层就“看不见”有什么妨碍数据传输的东西\n当所传数据中的比特组合恰巧与某一个控制信息完全一样时，就必须采取适当的措施，使收方不会将这样的数据误认为是某种控制信息。这样才能保证数据链路层的传输是透明的\n字符计数法：\n字符填充法：\n零比特填充法：\n违规编码法：\n","categories":["计算机理论"],"tags":["计算机网络原理-计算机网络原理笔记"]},{"title":"以太网","url":"/2020/05/31/%E8%AE%A1%E7%AE%97%E6%9C%BA%E7%90%86%E8%AE%BA/%E8%AE%A1%E7%AE%97%E6%9C%BA%E7%BD%91%E7%BB%9C%E5%8E%9F%E7%90%86/%E8%AE%A1%E7%AE%97%E6%9C%BA%E7%BD%91%E7%BB%9C%E5%8E%9F%E7%90%86%E7%AC%94%E8%AE%B0/3.12_%E4%BB%A5%E5%A4%AA%E7%BD%91/","content":"以太网：\n以太网(Ethernet)指的是由Xerox公司创建并由Xerox、Intel和DEC公司联合开发的基带总线局域网规范，是当今现有局域网采用的最通用的通信协议标准。以太网使用CSMA&#x2F;CD技术\n以太网在局域网各种技术中占统治性地位：1）造价低廉(以太网网卡不到一百块)2）是应用最广泛的局域网技术3）比令牌环网、ATM网便宜，简单4）满足网络速率要求：10Mb&#x2F;s～10Gb&#x2F;s\n以太网两个标准：1）DIX Ethernet V2:第一个局域网产品（以太网）规约2）IEEE 802.3:IEEE 802委员会802.3工作组制定的第一个IEEE的以太网标准（帧格式有一点改动）\n以太网提供无连接、不可靠的服务：1）无连接：发送方和接收方之间无“握手过程”2）不可靠：不对发送方的数据帧编号，接收方不向发送方进行确认，差错帧直接丢弃，差错纠正由高层负责\n以太网只实现无差错接收，不实现可靠传输\n以太网传输介质与拓扑结构的发展：\n10BASE-T以太网：10BASE-T是传送基带信号的双绞线以太网，T表示采用双绞线，现10BASE-T采用的是无屏蔽双绞线（UTP），传输速率是10Mb&#x2F;s1）物理上采用星型拓扑，逻辑上总线型，每段双绞线最长为100m2）采用曼彻斯特编码3）采用CSMA&#x2F;CD介质访问控制\n适配器与MAC地址：\n以太网MAC帧：\n高速以太网：\n","categories":["计算机理论"],"tags":["计算机网络原理-计算机网络原理笔记"]},{"title":"差错控制","url":"/2020/05/31/%E8%AE%A1%E7%AE%97%E6%9C%BA%E7%90%86%E8%AE%BA/%E8%AE%A1%E7%AE%97%E6%9C%BA%E7%BD%91%E7%BB%9C%E5%8E%9F%E7%90%86/%E8%AE%A1%E7%AE%97%E6%9C%BA%E7%BD%91%E7%BB%9C%E5%8E%9F%E7%90%86%E7%AC%94%E8%AE%B0/3.3_%E5%B7%AE%E9%94%99%E6%8E%A7%E5%88%B6/","content":"差错控制：\n概括来说，传输中的差错都是由于噪声引起的\n1）全局性：由于线路本身电气特性所产生的随机噪声(热噪声)，是信道固有的，随机存在的【解决办法：提高信噪比来减少或避免干扰(对传感器下手)】2）局部性：外界特定的短暂原因所造成的冲击噪声，是产生差错的主要原因【解决办法：通常利用编码技术来解决】\n检错编码：纠错编码：\n","categories":["计算机理论"],"tags":["计算机网络原理-计算机网络原理笔记"]},{"title":"流量控制与可靠传输机制","url":"/2020/05/31/%E8%AE%A1%E7%AE%97%E6%9C%BA%E7%90%86%E8%AE%BA/%E8%AE%A1%E7%AE%97%E6%9C%BA%E7%BD%91%E7%BB%9C%E5%8E%9F%E7%90%86/%E8%AE%A1%E7%AE%97%E6%9C%BA%E7%BD%91%E7%BB%9C%E5%8E%9F%E7%90%86%E7%AC%94%E8%AE%B0/3.4_%E6%B5%81%E9%87%8F%E6%8E%A7%E5%88%B6%E4%B8%8E%E5%8F%AF%E9%9D%A0%E4%BC%A0%E8%BE%93%E6%9C%BA%E5%88%B6/","content":"流量控制与可靠传输机制：\n数据链路层的流量控制：较高的发送速度和较低的接收能力的不匹配，会造成传输出错，因此流量控制也是数据链路层的一项重要工作\n数据链路层的流量控制是点对点的，而传输层的流量控制是端到端的\n数据链路层流量控制的手段：接收方收不下就不回复确认传输层流量控制的手段：接收端给发送端一个窗口公告\n流量控制的方法：1）停止-等待协议：每发送完一个帧就停止发送，等待对方的确认，在收到确认后再发送下一个帧2）滑动窗口协议：后退N帧协议(GBN)、选择重传协议(SR)\n停止-等待协议：发送窗口大小&#x3D;1，接收窗口大小&#x3D;1后退N帧协议(GBN)：发送窗口大小&gt;1，接收窗口大小&#x3D;1选择重传协议(SR)：发送窗口大小&gt;1，接收窗口大小&gt;1\n可靠传输、流量控制、滑动窗口：\n————————————\n停止等待协议：\n为什么要有停止等待协议：除了比特出差错，底层信道还会出现丢包问题，为了实现流量控制【丢包：物理线路故障、设备故障、病毒攻击、路由信息错误等原因，会导致数据包的丢失】\n研究停止等待协议的前提：1）虽然现在常用全双工通信方式，但为了讨论问题方便，仅考虑一方发送数据（发送方），一方接收数据（接收方）2）因为是在讨论可靠传输的原理，所以并不考虑数据是在哪一个层次上传送的\n停止等待协议的几种应用情况：1）无差错情况2）有差错情况\n停止等待协议的性能分析：简单、信道利用率太低\n信道利用率：发送方在一个发送周期内，有效的发送数据所需要的时间占整个发送周期的比率\n信道利用率&#x3D;(L&#x2F;C)&#x2F;TL：T内发送L比特数据C：发送方数据传输率T；发送周期，从开始发送数据，到收到第一个确认帧为止\n信道吞吐率：信道利用率*发送方的发送速率\n停止等待协议的弊端：\n流水线技术：必须增加序号范围、发送方需要缓存多个分组\n—————————————\n后退N帧协议(GBN)：\n后退N帧协议中的滑动窗口：\nGBN发送方必须响应的三件事：1）上层的调用：上层要发送数据时，发送方先检查发送窗口是否已满，如果未满，则产生一个帧并将其发送；如果窗口已满，发送方只需将数据返回给上层，暗示上层窗口已满。上层等一会再发送（实际实现中，发送方可以缓存这些数据，窗口不满时再发送帧）2）收到了一个ACK：GBN协议中，对n号帧的确认采用累计确认的方式，标明接收方已经收到n号帧和它之前的全部帧3）超时事件：协议的名字为后退N帧&#x2F;回退N帧，来源于出现丢失和时延过长帧时发送方的行为。就像在停等协议中一样，定时器将再次用于恢复数据帧或确认帧的丢失，如果出现超时，发送方重传所有已发送但未被确认的帧\nGBN接收方要做的事：1）如果正确收到n号帧，并且按序，那么接收方为n帧发送一个ACK，并将该帧中的数据部分交付给上层2）其余情况都丢弃帧，并为最近按序接收的帧重新发送ACK，接收方无需缓存任何失序帧，只需要维护一个信息：expectedseqnum（下一个按序接收的帧序号）【接收方只按序接收帧，不按序无情丢弃】【确认序列号最大的，按序到达的帧】滑动窗口长度：若采用n个比特对帧编号，那么发送窗口的尺寸WT应满足：1&lt;&#x3D;WT&lt;&#x3D;2^n-1，因为发送窗口尺寸过大，就会使得接收方无法区别新帧和旧帧\nGBN协议性能分析：1）因连续发送数据帧而提高了信道利用率2）在重传时必须把原来已经正确传送的数据帧重传，使得传送效率降低\n—————————————\n选择重传协议(SR)：\n解决GBN的弊端：可不可以只重传出错的帧？设置单个确认，同时加大接收窗口，设置接收缓存，缓存乱序到达的帧\n选择重传协议中的滑动窗口：\nSR发送方必须要响应的三件事：1）上层的调用：从上层收到数据后，SR发送方检查下一个可用于该帧的序号，如果序号位于发送窗口内，则发送数据帧，否则就像GBN一样，要么将数据缓存，要么返回给上层之后再传输2）收到了一个ACK：如果收到ACK，假如该帧序号在窗口内，则SR发送方将那个被确认的帧标记为已接收。如果该帧序号是窗口的下界（最左边第一个窗口对应的序号），则窗口向前移动到具有最小序号的未确认帧处，如果窗口移动了并且有序号在窗口内的未发送帧，则发送这些帧3)超时事件：每个帧都有自己的定时器，一个超时事件发生后只重传一个帧【只重传出错帧】\nSR接收方要做的事：窗口内的帧来者不拒滑动窗口的长度：发送窗口最好等于接收窗口（大了会溢出，小了没意义）【WTmax&#x3D;WRmax&#x3D;2^(n-1)】\n","categories":["计算机理论"],"tags":["计算机网络原理-计算机网络原理笔记"]},{"title":"信道划分介质访问控制","url":"/2020/05/31/%E8%AE%A1%E7%AE%97%E6%9C%BA%E7%90%86%E8%AE%BA/%E8%AE%A1%E7%AE%97%E6%9C%BA%E7%BD%91%E7%BB%9C%E5%8E%9F%E7%90%86/%E8%AE%A1%E7%AE%97%E6%9C%BA%E7%BD%91%E7%BB%9C%E5%8E%9F%E7%90%86%E7%AC%94%E8%AE%B0/3.5_%E4%BF%A1%E9%81%93%E5%88%92%E5%88%86%E4%BB%8B%E8%B4%A8%E8%AE%BF%E9%97%AE%E6%8E%A7%E5%88%B6/","content":"信道划分介质访问控制：\n传输数据使用的两种链路：1）点对点链路：两个相邻节点通过一个链路相连，没有第三者。【应用：PPP协议，常用于广域网】2）广播式链路：所有主机共享通信介质【应用：早期的总线以太网、无线局域网。常用于局域网】【典型拓扑结构：总线型、星型(逻辑总线型)】\n介质访问控制：采取一定的措施，使得两对节点之间的通信不会发生相互干扰的现象信道划分介质访问控制：将使用介质的每个设备与来自同一信道上的其他设备的通信隔离开，把时域和频域资源合理的分配给网络上的设备\n1）频分多路复用FDM\n2）时分多路复用TDM\n3）改进的时分复用—统计时分复用STDM\n4）波分多路复用WDM：波分多路复用就是光的频分多路复用，在一根光纤中传输多种不同波长（频率）的光信号，由于波长（频率）不同，所以各路光信号互不干扰，最后再用波长分解复用器将各路波长分解出来\n5）码分多路复用CDM：\n","categories":["计算机理论"],"tags":["计算机网络原理-计算机网络原理笔记"]},{"title":"数据链路层基本概念","url":"/2020/05/31/%E8%AE%A1%E7%AE%97%E6%9C%BA%E7%90%86%E8%AE%BA/%E8%AE%A1%E7%AE%97%E6%9C%BA%E7%BD%91%E7%BB%9C%E5%8E%9F%E7%90%86/%E8%AE%A1%E7%AE%97%E6%9C%BA%E7%BD%91%E7%BB%9C%E5%8E%9F%E7%90%86%E7%AC%94%E8%AE%B0/3.1_%E6%95%B0%E6%8D%AE%E9%93%BE%E8%B7%AF%E5%B1%82%E5%9F%BA%E6%9C%AC%E6%A6%82%E5%BF%B5/","content":"数据链路层基本概念：\n结点：主机、路由器\n链路：网络中两个结点之间的物理通道，链路的传输介质主要有双绞线、光纤和微波，分为有线链路、无线链路\n数据链路：网络中两个结点之间的逻辑通道，把实现控制数据传输协议的硬件和软件加到链路上就构成了数据链路\n帧：链路层的协议数据单元，封装网络层数据报\n数据链路层负责通过一条链路从一个结点向另一个物理链路直接相连的相邻结点传送数据报\n数据链路层功能概述：数据链路层在物理层提供服务的基础上向网络层提供服务，其最基本的服务是将源自网络层来的数据可靠的传输到相邻节点的目标机网络层。其主要作用是加强物理层传输原始比特流的功能，将物理层提供的可能出错的物理连接改造成为逻辑上无差错的数据链路，使之对网络层表现为一条无差错的链路\n1）为网络层提供服务：无确认无连接服务【通信质量好，有线传输链路】、有确认无连接服务、有确认面向连接服务【有连接一定有确认】【通信质量差的无线传输链路】2）链路管理，即连接的建立、维持、释放（用于面向连接的服务）3）组帧4）流量控制5）差错控制（帧错&#x2F;位错）\n","categories":["计算机理论"],"tags":["计算机网络原理-计算机网络原理笔记"]},{"title":"ALOHA协议","url":"/2020/05/31/%E8%AE%A1%E7%AE%97%E6%9C%BA%E7%90%86%E8%AE%BA/%E8%AE%A1%E7%AE%97%E6%9C%BA%E7%BD%91%E7%BB%9C%E5%8E%9F%E7%90%86/%E8%AE%A1%E7%AE%97%E6%9C%BA%E7%BD%91%E7%BB%9C%E5%8E%9F%E7%90%86%E7%AC%94%E8%AE%B0/3.6_ALOHA%E5%8D%8F%E8%AE%AE/","content":"ALOHA协议：\n1）纯ALOHA协议：不监听信道，不按时间槽发送，随机重发【想发就发】\n2）时隙ALOHA协议：把时间分成若干个相同的时间片，所有用户在时间片开始时刻同步接入网络信道，若发生冲突，则必须等到下一个时间片开始时刻再发送【控制想发就发的随意性】\n纯ALOHA协议比时隙ALOHA吞吐量更低，效率更低纯ALOHA想发就发，时隙ALOHA只有在时间片段开始时才能发\n","categories":["计算机理论"],"tags":["计算机网络原理-计算机网络原理笔记"]},{"title":"CSMA协议","url":"/2020/05/31/%E8%AE%A1%E7%AE%97%E6%9C%BA%E7%90%86%E8%AE%BA/%E8%AE%A1%E7%AE%97%E6%9C%BA%E7%BD%91%E7%BB%9C%E5%8E%9F%E7%90%86/%E8%AE%A1%E7%AE%97%E6%9C%BA%E7%BD%91%E7%BB%9C%E5%8E%9F%E7%90%86%E7%AC%94%E8%AE%B0/3.7_CSMA%E5%8D%8F%E8%AE%AE/","content":"CSMA协议：\n载波监听多路访问协议CSMA\nCS：载波监听，每一个站在发送数据之前要检测一下总线上是否有其他计算机在发送数据【当几个站同时在总线上发送数据时，总线上的信号电压摆动值将会增大(互相叠加)，当一个站检测到的信号电压摆动值超过一定门限值时，就认为总线上至少有两个站同时在发送数据，表明产生了碰撞，即发生了冲突】\nMA：多点接入，表示许多计算机以多点接入的方式连接在一根总线上\n协议思想：发送帧之前，监听信道\n监听结果：1）信道空闲：发送完整帧【1-坚持CSMA、非坚持CSMA、p-坚持CSMA】2）信道忙：推迟发送\n1-坚持CSMA：\n非坚持CSMA：\np-坚持CSMA：\n有没有什么办法可以减少资源浪费，一冲突就能发现呢？？\n","categories":["计算机理论"],"tags":["计算机网络原理-计算机网络原理笔记"]},{"title":"CSMA-CD协议","url":"/2020/05/31/%E8%AE%A1%E7%AE%97%E6%9C%BA%E7%90%86%E8%AE%BA/%E8%AE%A1%E7%AE%97%E6%9C%BA%E7%BD%91%E7%BB%9C%E5%8E%9F%E7%90%86/%E8%AE%A1%E7%AE%97%E6%9C%BA%E7%BD%91%E7%BB%9C%E5%8E%9F%E7%90%86%E7%AC%94%E8%AE%B0/3.8_CSMA-CD%E5%8D%8F%E8%AE%AE/","content":"CSMA-CD协议：\n载波监听多点接入&#x2F;碰撞检测CSMA&#x2F;CD\nCS：载波监听，每一个站在发送数据之前以及发送数据时都要检测一下总线上是否有其他计算机在发送数据\nMA：多点接入，表示许多计算机以多点接入的方式连接在一根总线上（总线型网络）\nCD：碰撞检测（冲突检测），“边发送边监听”，适配器边发送数据边检测信道上信号电压的变化情况，以便判断自己在发送数据时其他站是否也在发送数据（半双工网络）\n先听后发为什么还会冲突：因为电磁波在总线上总是以有限的速率传播的\n传播时延对载波监听的影响：\n如何确定碰撞后的重传时机：\n最小帧长问题：A站发了一个很短的帧，但发生了碰撞，不过帧在发送完毕后才检测到发生碰撞，没法停止发送，因为已经发完了。。。\n","categories":["计算机理论"],"tags":["计算机网络原理-计算机网络原理笔记"]},{"title":"RIP协议与距离向量算法","url":"/2020/05/31/%E8%AE%A1%E7%AE%97%E6%9C%BA%E7%90%86%E8%AE%BA/%E8%AE%A1%E7%AE%97%E6%9C%BA%E7%BD%91%E7%BB%9C%E5%8E%9F%E7%90%86/%E8%AE%A1%E7%AE%97%E6%9C%BA%E7%BD%91%E7%BB%9C%E5%8E%9F%E7%90%86%E7%AC%94%E8%AE%B0/4.11_RIP%E5%8D%8F%E8%AE%AE%E4%B8%8E%E8%B7%9D%E7%A6%BB%E5%90%91%E9%87%8F%E7%AE%97%E6%B3%95/","content":"RIP协议与距离向量算法：\nRIP是一种分布式的基于距离向量的路由选择协议，是因特网的协议标准，最大优点是简单\nRIP协议要求网络中每一个路由器都维护从它自己到其他每一个目的网络的唯一最佳距离记录（即一组距离）\n距离：通常为“跳数”，即从源端口到目的端口所经过的路由器个数，经过一个路由器跳数+1。特别的，从一路由器到直接连接的网络距离为1，RIP允许一条路由最多只能包含15个路由器，因此距离为16表示网络不可达\nRIP协议只适用于小互联网\nRIP协议：1）仅和相邻路由器交换信息2）路由器交换的信息是自己的路由表3）每30s交换一次路由信息，然后路由器根据新信息更新路由表，若超过180s没收到邻居路由器的通告，则判定邻居没了，并更新自己路由表；路由器刚开始工作时，只知道直接连接的网络的距离（距离为1），接着每一个路由器也只和数目非常有限的相邻路由器交换并更新路由信息；经过若干次更新后，所有路由器最终都会知道到达本自治系统任何一个网络的最短距离和下一跳路由器的地址，即“收敛”\n距离向量算法：\nRIP协议的报文格式：\nRIP的特点：当网络出现故障时，要经过比较长的时间（例如数分钟）才能将此信息传送到所有的路由，“慢收敛”\n","categories":["计算机理论"],"tags":["计算机网络原理-计算机网络原理笔记"]},{"title":"CSMA-CA协议","url":"/2020/05/31/%E8%AE%A1%E7%AE%97%E6%9C%BA%E7%90%86%E8%AE%BA/%E8%AE%A1%E7%AE%97%E6%9C%BA%E7%BD%91%E7%BB%9C%E5%8E%9F%E7%90%86/%E8%AE%A1%E7%AE%97%E6%9C%BA%E7%BD%91%E7%BB%9C%E5%8E%9F%E7%90%86%E7%AC%94%E8%AE%B0/3.9_CSMA-CA%E5%8D%8F%E8%AE%AE/","content":"CSMA-CA协议：\n载波监听多点接入&#x2F;碰撞避免CSMA&#x2F;CA\n为什么有了CSMA-CD后还要有CSMA-CA：CSMA-CA多用于无线局域网，无线局域网无法做到360度全面检测碰撞、隐蔽站(当A和C都检测不到信号，认为信道空闲时，同时像终端B发送数据帧，就会导致冲突)\nCSMA-CA协议工作原理：\nCSMA-CD与CSMA-CA：\n","categories":["计算机理论"],"tags":["计算机网络原理-计算机网络原理笔记"]},{"title":"OSPF协议与链路状态算法","url":"/2020/05/31/%E8%AE%A1%E7%AE%97%E6%9C%BA%E7%90%86%E8%AE%BA/%E8%AE%A1%E7%AE%97%E6%9C%BA%E7%BD%91%E7%BB%9C%E5%8E%9F%E7%90%86/%E8%AE%A1%E7%AE%97%E6%9C%BA%E7%BD%91%E7%BB%9C%E5%8E%9F%E7%90%86%E7%AC%94%E8%AE%B0/4.12_OSPF%E5%8D%8F%E8%AE%AE%E4%B8%8E%E9%93%BE%E8%B7%AF%E7%8A%B6%E6%80%81%E7%AE%97%E6%B3%95/","content":"OSPF协议与链路状态算法：\n开放最短路径优先OSPF协议：“开放”标明OSPF协议不是受某一家厂商控制，而是公开发表的；“最短路径优先”是因为使用了Dijkstra提出的最短路径算法SPF\nOSPF最主要的特征就是使用分布式的链路状态协议\n链路状态路由算法：\nOSPF的区域：\nOSPF分组：\nOSPF其他特点：1）每隔30min，要刷新一次数据库中的链路状态2）由于一个路由器的链路状态只涉及到与相连路由器的连通状态，因而与整个互联网的规模并无直接关系，因此当互联网规模很大时，OSPF协议要比距离向量协议RIP好很多3）OSPF不存在坏消息传的慢的问题，它的收敛速度很快\n","categories":["计算机理论"],"tags":["计算机网络原理-计算机网络原理笔记"]},{"title":"BGP协议","url":"/2020/05/31/%E8%AE%A1%E7%AE%97%E6%9C%BA%E7%90%86%E8%AE%BA/%E8%AE%A1%E7%AE%97%E6%9C%BA%E7%BD%91%E7%BB%9C%E5%8E%9F%E7%90%86/%E8%AE%A1%E7%AE%97%E6%9C%BA%E7%BD%91%E7%BB%9C%E5%8E%9F%E7%90%86%E7%AC%94%E8%AE%B0/4.13_BGP%E5%8D%8F%E8%AE%AE/","content":"BGP协议：\n1）和谁交换：与其他AS的邻站BGP发言人交换信息2）交换什么：交换的网络可达性的信息，即要到达某个网络所要经过的一系列AS3）多久交换：发生变化时更新有变化的部分\nBGP协议交换信息的过程：BGP所交换的网络可达性的信息就是要到达某个网络所要经过的一系列AS，当BGP发言人互相交换了网络可达性的信息后，各BGP发言人就根据所采用的策略从收到的路由信息中找出到达各AS的较好路由\nBGP协议报文格式：\nBGP协议特点：1）BGP支持CIDR，因此BGP的路由表也就应当包括目的网络前缀、下一跳路由器，以及到达该目的网络所要经过的各个自治系统序列2）在BGP刚刚运行时，BGP的邻站是交换整个的BGP路由表，但以后只需要在发生变化时更新有变化的部分，这样做对节省网络带宽和减少路由器的处理开销都有好处\nBGP-4的四种报文：\n三种路由协议比较：\n","categories":["计算机理论"],"tags":["计算机网络原理-计算机网络原理笔记"]},{"title":"移动IP","url":"/2020/05/31/%E8%AE%A1%E7%AE%97%E6%9C%BA%E7%90%86%E8%AE%BA/%E8%AE%A1%E7%AE%97%E6%9C%BA%E7%BD%91%E7%BB%9C%E5%8E%9F%E7%90%86/%E8%AE%A1%E7%AE%97%E6%9C%BA%E7%BD%91%E7%BB%9C%E5%8E%9F%E7%90%86%E7%AC%94%E8%AE%B0/4.15_%E7%A7%BB%E5%8A%A8IP/","content":"移动IP：\n移动IP技术是移动结点（计算机&#x2F;服务器等）以固定的网络IP地址，实现跨越不同网段的漫游功能，并保证了基于网络IP的网络权限在漫游过程中不发生任何改变\n移动结点：具有永久IP地址的移动设备\n归属代理（本地代理）：一个移动结点拥有的旧“居所”称为归属网络，在归属网络中代表移动结点执行移动管理功能的实体叫做归属代理\n外部代理（外地代理）：在外部网络中帮助移动结点完成移动管理功能的实体称为外部代理\n永久地址（归属地址&#x2F;主地址）：移动站点在归属网络中的原始地址\n转交地址（辅地址）：移动站点在外部网络使用的临时地址\n移动IP通信过程：\n","categories":["计算机理论"],"tags":["计算机网络原理-计算机网络原理笔记"]},{"title":"IP组播","url":"/2020/05/31/%E8%AE%A1%E7%AE%97%E6%9C%BA%E7%90%86%E8%AE%BA/%E8%AE%A1%E7%AE%97%E6%9C%BA%E7%BD%91%E7%BB%9C%E5%8E%9F%E7%90%86/%E8%AE%A1%E7%AE%97%E6%9C%BA%E7%BD%91%E7%BB%9C%E5%8E%9F%E7%90%86%E7%AC%94%E8%AE%B0/4.14_IP%E7%BB%84%E6%92%AD/","content":"IP组播：\nIP数据报的三种传输方式：1）单播：单播用于发送数据包到单个目的地，且每发送一份单播报文都使用一个单播IP地址作为目的地址，是一种点对点传输方式2）广播：广播是指发送数据包到同一广播域或子网内的所有设备的一种数据传输方式，是一种点对多点传输方式3）组播(多播)：当网络中的某些用户需要特定数据时，组播数据发送者仅发送一次数据，借助组播路由协议为组播数据包建立组播分发树，被传递的数据到达距离用户端尽可能近的节点后才开始复制和分发，是一种点对多点传输方式\nIP组播地址：\n硬件组播：\n——————————————————\n网际组管理协议IGMP：\nIGMP工作的两个阶段：1）某主机要加入组播组时，该主机向组播组的组播地址发送一个IGMP报文，声明自己要成为该组的成员；本地组播路由器收到IGMP报文后，要利用组播路由选择协议把这组成员关系发给因特网上的其他组播路由器2）本地组播路由器周期性探寻本地局域网上的主机，以便知道这些主机是否还是组播组的成员；只要有一个主机对某个组响应，那么组播路由器就认为这个组是活跃的，如果经过几次探寻后没有一个主机响应，组播路由器就认为本网络上没有此组播组的主机，因此就不再把这组的成员关系发给其他的组播路由器\n组播路由器知道的成员关系只是所连接的局域网中有无组播组的成员\n组播路由选择协议目的是找出以源主机为根节点的组播转发树\n构造树可以避免在路由器之间兜圈子\n对不同的多播组对应于不同的多播转发树；同一个多播组，对不同的源点也会有不同的多播转发树\n组播路由选择协议常使用的三种算法：1）基于链路状态的路由选择2）基于距离-向量的路由选择3）协议无关的组播（稀疏&#x2F;密集）\n","categories":["计算机理论"],"tags":["计算机网络原理-计算机网络原理笔记"]},{"title":"网络层设备","url":"/2020/05/31/%E8%AE%A1%E7%AE%97%E6%9C%BA%E7%90%86%E8%AE%BA/%E8%AE%A1%E7%AE%97%E6%9C%BA%E7%BD%91%E7%BB%9C%E5%8E%9F%E7%90%86/%E8%AE%A1%E7%AE%97%E6%9C%BA%E7%BD%91%E7%BB%9C%E5%8E%9F%E7%90%86%E7%AC%94%E8%AE%B0/4.16_%E7%BD%91%E7%BB%9C%E5%B1%82%E8%AE%BE%E5%A4%87/","content":"网络层设备：\n路由器：是一种具有多个输入端口和多个输出端口的专用计算机，其任务是转发分组\n输入端口对线路上收到的分组的处理：输入端口中的查找和转发功能在路由器的交换功能中是最重要的\n输出端口将交换结构传送来的分组发送到线路：若路由器处理分组的速率赶不上分组进入队列的速率，则队列的存储空间最终必定减少到零，这就使后面再进入队列的分组由于没有存储空间而只能被丢弃【路由器中的输入或输出队列产生溢出是造成分组丢失的重要原因】\n三层设备的区别：1）集线器：不能互联两个物理层不同的网段2）网桥：可以互联两个物理层和链路层不同的网段3）路由器：可以互联两个不同网络层协议的网段\n路由表与路由转发：\n","categories":["计算机理论"],"tags":["计算机网络原理-计算机网络原理笔记"]},{"title":"电路交换、报文交换、分组交换","url":"/2020/05/31/%E8%AE%A1%E7%AE%97%E6%9C%BA%E7%90%86%E8%AE%BA/%E8%AE%A1%E7%AE%97%E6%9C%BA%E7%BD%91%E7%BB%9C%E5%8E%9F%E7%90%86/%E8%AE%A1%E7%AE%97%E6%9C%BA%E7%BD%91%E7%BB%9C%E5%8E%9F%E7%90%86%E7%AC%94%E8%AE%B0/4.2_%E7%94%B5%E8%B7%AF%E4%BA%A4%E6%8D%A2%E3%80%81%E6%8A%A5%E6%96%87%E4%BA%A4%E6%8D%A2%E3%80%81%E5%88%86%E7%BB%84%E4%BA%A4%E6%8D%A2/","content":"电路交换、报文交换、分组交换：\n如何使数据通过网络核心(路由器)从源主机到目的主机？——数据交换\n为什么要数据交换：\n数据交换方式：1）电路交换2）报文交换3）分组交换：数据报方式、虚电路方式\n—————————————\n电路交换：电话网络(多路复用)\n电路交换的阶段：1）建立连接（呼叫&#x2F;电路建立）2）通信3）释放连接（拆除电路）\n特点：独占资源\n优点：通信时延小、有序传输、没有冲突、实时性强\n缺点：建立连接时间长、线路独占，使用效率低、灵活性差、无差错控制能力\n—————————————\n报文交换：\n报文：源应用发送的信息整体\n优点：1）无需建立连接2）存储转发，动态分配线路3）线路可靠性较高4）线路利用率较高5）多目标服务\n缺点：1）有存储转发时延2）报文大小不定，需要网络节点有较大缓存空间\n—————————————\n分组交换：\n分组：把大的数据块分割成小的数据块\n优点：1）无需建立连接2）存储转发，动态分配线路3）线路可靠性较高4）线路利用率较高5）相对于报文交换，存储管理更容易\n缺点：1）有存储转发时延2）需要传输额外的信息量3）乱序到目的主机时，要对分组排序重组\n\n————————————————\n数据报方式为网络层提供无连接服务【无连接服务：不事先为分组的传输确定传输路径，每个分组独立确定传输路径，不同分组传输路径可能不同】【每个分组携带源和目的地址】【路由器根据分组的目的地址转发分组：基于路由协议&#x2F;算法构建转发表；检索转发表；每个分组独立选路】\n虚电路方式为网络层提供连接服务【连接服务：首先为分组的传输确定传输路径(建立连接)，然后沿该路径(连接)传输系列分组，系列分组传输路径相同，传输结束后拆除连接】\n虚电路将数据报方式和电路交换方式结合，以发挥两者优点\n虚电路：一条源主机到目的主机类似于电路的路径（逻辑连接），路径上所有的结点都要维持这条虚电路的建立，都维持一张虚电路表，每一项纪录了一个打开的虚电路信息\n通信过程：1）建立连接（虚电路建立）：每个分组携带虚电路号，而非目的地址，源主机发送“呼叫请求”分组并收到“呼叫应答”分组后才算建立连接2）数据传输（全双工通信）3）释放连接（虚电路释放）：源主机发送“释放请求”分组以拆除虚电路\n\n","categories":["计算机理论"],"tags":["计算机网络原理-计算机网络原理笔记"]},{"title":"链路层设备","url":"/2020/05/31/%E8%AE%A1%E7%AE%97%E6%9C%BA%E7%90%86%E8%AE%BA/%E8%AE%A1%E7%AE%97%E6%9C%BA%E7%BD%91%E7%BB%9C%E5%8E%9F%E7%90%86/%E8%AE%A1%E7%AE%97%E6%9C%BA%E7%BD%91%E7%BB%9C%E5%8E%9F%E7%90%86%E7%AC%94%E8%AE%B0/3.15_%E9%93%BE%E8%B7%AF%E5%B1%82%E8%AE%BE%E5%A4%87/","content":"链路层设备：\n以太网物理上采用星型拓扑，逻辑上总线型，每段双绞线最长为100m\n物理层扩展以太网：\n链路层扩展以太网（网桥、交换机）：\n1）网桥\n网桥分类：1）透明网桥2）源路由网桥：在发送帧时，把详细的最佳路由信息（路由最少&#x2F;时间最短)放在帧的首部中【方法：源站以广播方式向欲通信的目的站发送一个发现帧，选择其中最佳的路由线路】\n2）多接口网桥—以太网交换机\n以太网交换机的两种交换方式：1）直通式交换机：查完目的地址(6B)就立刻转发；延迟小，可靠性低，无法支持具有不同速率的端口的交换2）存储转发式交换机：将帧放入高速缓存，并检查是否正确，正确则转发，错误则丢弃；延迟大，可靠性高，可以支持具有不同速率的端口的交换\n冲突域和广播域：\n","categories":["计算机理论"],"tags":["计算机网络原理-计算机网络原理笔记"]},{"title":"路由算法与路由协议概述","url":"/2020/05/31/%E8%AE%A1%E7%AE%97%E6%9C%BA%E7%90%86%E8%AE%BA/%E8%AE%A1%E7%AE%97%E6%9C%BA%E7%BD%91%E7%BB%9C%E5%8E%9F%E7%90%86/%E8%AE%A1%E7%AE%97%E6%9C%BA%E7%BD%91%E7%BB%9C%E5%8E%9F%E7%90%86%E7%AC%94%E8%AE%B0/4.10_%E8%B7%AF%E7%94%B1%E7%AE%97%E6%B3%95%E4%B8%8E%E8%B7%AF%E7%94%B1%E5%8D%8F%E8%AE%AE%E6%A6%82%E8%BF%B0/","content":"路由算法与路由协议概述：\n\n路由算法的分类：1）静态路由算法（非自适应路由算法）：管理员手工配置路由信息【简便、可靠，在负荷稳定、拓扑变化不大的网络中运行效果很好，广泛用于高度安全性的军事网络和较小的商业网络】【路由更新慢，不适用大型网络】2）动态路由算法（自适应路由算法）：路由期间彼此交换信息，按照路由算法优化出路由表项【路由更新快，适用大型网络，及时响应链路费用或网络拓扑变化】【算法复杂，增加网络负担】\n动态路由算法：1）全局性：链路状态路由算法：OSPF协议，所有路由器掌握完整的网络拓扑和链路费用信息2）分散性：距离向量路由算法：RIP协议，路由器只掌握物理相连的邻居及链路费用\n分层次的路由选择协议：\n","categories":["计算机理论"],"tags":["计算机网络原理-计算机网络原理笔记"]},{"title":"IP数据报格式","url":"/2020/05/31/%E8%AE%A1%E7%AE%97%E6%9C%BA%E7%90%86%E8%AE%BA/%E8%AE%A1%E7%AE%97%E6%9C%BA%E7%BD%91%E7%BB%9C%E5%8E%9F%E7%90%86/%E8%AE%A1%E7%AE%97%E6%9C%BA%E7%BD%91%E7%BB%9C%E5%8E%9F%E7%90%86%E7%AC%94%E8%AE%B0/4.3_IP%E6%95%B0%E6%8D%AE%E6%8A%A5%E6%A0%BC%E5%BC%8F/","content":"IP数据报格式：\nTCP&#x2F;IP协议栈：\n\n","categories":["计算机理论"],"tags":["计算机网络原理-计算机网络原理笔记"]},{"title":"轮询访问介质访问控制","url":"/2020/05/31/%E8%AE%A1%E7%AE%97%E6%9C%BA%E7%90%86%E8%AE%BA/%E8%AE%A1%E7%AE%97%E6%9C%BA%E7%BD%91%E7%BB%9C%E5%8E%9F%E7%90%86/%E8%AE%A1%E7%AE%97%E6%9C%BA%E7%BD%91%E7%BB%9C%E5%8E%9F%E7%90%86%E7%AC%94%E8%AE%B0/3.10_%E8%BD%AE%E8%AF%A2%E8%AE%BF%E9%97%AE%E4%BB%8B%E8%B4%A8%E8%AE%BF%E9%97%AE%E6%8E%A7%E5%88%B6/","content":"轮询访问介质访问控制：\n介质访问控制：1）信道划分介质访问控制协议：基于多路复用技术划分资源；网络负载重的时候共享信道效率高，且公平；网络负载轻的时候共享信道效率低2）随机访问MAC协议：用户根据意愿随机发送信息，发送信息时可独占信道带宽；网络负载重时产生冲突开销；网络负载轻时共享信道效率高，单个结点可利用信道全部带宽3）轮询访问MAC协议：既要不产生冲突，又要发送时占全部带宽\n轮询协议：主结点轮流邀请从属结点发送数据【问题：轮询开销、等待延迟、单点故障】\n令牌传递协议：\n","categories":["计算机理论"],"tags":["计算机网络原理-计算机网络原理笔记"]},{"title":"IP数据报分片","url":"/2020/05/31/%E8%AE%A1%E7%AE%97%E6%9C%BA%E7%90%86%E8%AE%BA/%E8%AE%A1%E7%AE%97%E6%9C%BA%E7%BD%91%E7%BB%9C%E5%8E%9F%E7%90%86/%E8%AE%A1%E7%AE%97%E6%9C%BA%E7%BD%91%E7%BB%9C%E5%8E%9F%E7%90%86%E7%AC%94%E8%AE%B0/4.4_IP%E6%95%B0%E6%8D%AE%E6%8A%A5%E5%88%86%E7%89%87/","content":"\n","categories":["计算机理论"],"tags":["计算机网络原理-计算机网络原理笔记"]},{"title":"ARP协议","url":"/2020/05/31/%E8%AE%A1%E7%AE%97%E6%9C%BA%E7%90%86%E8%AE%BA/%E8%AE%A1%E7%AE%97%E6%9C%BA%E7%BD%91%E7%BB%9C%E5%8E%9F%E7%90%86/%E8%AE%A1%E7%AE%97%E6%9C%BA%E7%BD%91%E7%BB%9C%E5%8E%9F%E7%90%86%E7%AC%94%E8%AE%B0/4.6_ARP%E5%8D%8F%E8%AE%AE/","content":"ARP协议：\n发送数据的过程：1）从主机1—&gt;主机32）从主机1—&gt;主机5\n由于在实际网络的链路上传送数据帧时，最终必须使用MAC地址\nARP协议：完成主机或路由器IP地址到MAC地址的映射（解决下一跳走哪的问题）\nARP协议使用过程：检查ARP高速缓存，有对应表项则写入MAC帧，没有则用目的MAC地址为FF-FF-FF-FF-FF-FF的帧封装并广播ARP请求分组，同一局域网中所有主机都能收到该请求。目的主机收到请求后就会向源主机单播一个ARP响应分组，源主机收到后将此映射写入ARP缓存（10～20min更新一次）\nARP协议的4种典型情况（ARP协议自动进行）：1）主机A发给本网络上的主机B：用ARP找到主机B的硬件地址2）主机A发给另一网络上的主机B：用ARP找到本网络上一个路由器（网关）的硬件地址3）路由器发给本网络的主机A：用ARP找到主机A的硬件地址4）路由器发给另一网络的主机B：用ARP找到本网络上的一个路由器的硬件地址\n","categories":["计算机理论"],"tags":["计算机网络原理-计算机网络原理笔记"]},{"title":"IPv4地址","url":"/2020/05/31/%E8%AE%A1%E7%AE%97%E6%9C%BA%E7%90%86%E8%AE%BA/%E8%AE%A1%E7%AE%97%E6%9C%BA%E7%BD%91%E7%BB%9C%E5%8E%9F%E7%90%86/%E8%AE%A1%E7%AE%97%E6%9C%BA%E7%BD%91%E7%BB%9C%E5%8E%9F%E7%90%86%E7%AC%94%E8%AE%B0/4.5_IPv4%E5%9C%B0%E5%9D%80/","content":"IPv4地址：\nIP编址的历史阶段：1）分类的IP地址2）子网的划分3）构成超网（无分类编址方法）\n——————————————————\n分类的IP地址：\nIP地址：全世界唯一的32位&#x2F;4字节标识符，标识路由器主机的接口【&lt;网络号&gt;&lt;主机号&gt;】\n\n特殊IP地址：\n私有IP地址：\n——————————————\n路由器对目的地址是私有IP地址的数据报一律不进行转发\n网络地址转换NAT：在专用网连接到因特网的路由器上安装NAT软件，安装了NAT软件的路由器叫NAT路由器，它至少有一个有效的外部全球IP地址\n—————————————\n子网划分和子网掩码：\n分类的IP地址的弱点：1）IP地址空间的利用率有时很低2）两级IP地址不够灵活\n\n子网掩码（相与：相同为1，不同为0）：\n使用子网时分组的转发：\n———————————————\n无分类编址CIDR：\n构成超网：将多个子网聚合成一个较大的子网，叫做构成超网，或路由聚合\n方法：将网络前缀缩短\n最长前缀匹配：使用CIDR时，查找路由表可能得到几个匹配结果，应选择具有最长网络前缀的路由，前缀越长，地址块越小，路由越具体\n","categories":["计算机理论"],"tags":["计算机网络原理-计算机网络原理笔记"]},{"title":"DHCP协议","url":"/2020/05/31/%E8%AE%A1%E7%AE%97%E6%9C%BA%E7%90%86%E8%AE%BA/%E8%AE%A1%E7%AE%97%E6%9C%BA%E7%BD%91%E7%BB%9C%E5%8E%9F%E7%90%86/%E8%AE%A1%E7%AE%97%E6%9C%BA%E7%BD%91%E7%BB%9C%E5%8E%9F%E7%90%86%E7%AC%94%E8%AE%B0/4.7_DHCP%E5%8D%8F%E8%AE%AE/","content":"DHCP协议：\n主机如何获得IP地址：1）静态配置：IP地址、子网掩码、默认网关2）动态配置：\nDHCP协议：\n","categories":["计算机理论"],"tags":["计算机网络原理-计算机网络原理笔记"]},{"title":"ICMP协议","url":"/2020/05/31/%E8%AE%A1%E7%AE%97%E6%9C%BA%E7%90%86%E8%AE%BA/%E8%AE%A1%E7%AE%97%E6%9C%BA%E7%BD%91%E7%BB%9C%E5%8E%9F%E7%90%86/%E8%AE%A1%E7%AE%97%E6%9C%BA%E7%BD%91%E7%BB%9C%E5%8E%9F%E7%90%86%E7%AC%94%E8%AE%B0/4.8_ICMP%E5%8D%8F%E8%AE%AE/","content":"ICMP协议：\nTCP&#x2F;IP协议栈：ICMP协议：为了更有效的转发IP数据报和提高交付成功的机会\n网际控制报文协议ICMP：ICMP协议支持主机或路由器：差错（或异常）报告、网络探询，发送特定ICMP报文【ICMP差错报文、ICMP询问报文】\nICMP差错报告报文：1）终点不可达：当路由器或主机不能交付数据报时就向源点发送终点不可达报文【无法交付】2）源点抑制：当路由器或主机由于拥塞而丢弃数据报时，就向源点发送源点抑制报文，使源点知道应当把数据报的发送速率放慢【拥塞丢数据】3）时间超过：当路由器收到生存时间TTL&#x3D;0的数据报时，除丢弃该数据报外，还要向源点发送时间超过报文。当终点在预先规定的时间内不能收到一个数据报的全部数据报片时，就把已收到的数据报片都丢弃，并向源点发送时间超过报文【TTL&#x3D;0】4）参数问题：当路由器或目的主机收到的数据报的首部中有的字段的值不正确时，就丢弃该数据报，并向源点发送参数问题报文【首部字段有问题】5）改变路由（重定向）：路由器把改变路由报文发送给主机，让主机知道下次应将数据报发送给另外的路由器（可通过更好的路由）【值得更好的路由】\n\n不应发送ICMP差错报文的情况：1）对ICMP差错报告报文不再发送ICMP差错报告报文2）对第一个分片的数据报片的所有后续数据报片都不发送ICMP差错报告报文3）对具有组播地址的数据报都不发送ICMP差错报告报文【广播是一对全部；组播是一对多，有选择性的】4）对具有特殊地址（如127.0.0.0或0.0.0.0）的数据报不发送ICMP差错报告报文\nICMP询问报文：1）回送请求和回答报文：主机或路由器向特定目的主机发出的询问，收到此报文的主机必须给源主机或路由器发送ICMP回送回答报文【测试目的站是否可达以及了解其相关状态】2）时间戳请求和回答报文：请某个主机或路由器回答当前的日期和时间【用来进行时钟同步和测量时间】3）掩码地址请求和回答报文4）路由器询问和通告报文\nICMP的应用：1）PING：测试两个主机之间的连通性，使用了ICMP回送请求和回答报文2）Traceroute：跟踪一个分组从源点到终点的路径，使用了ICMP时间超过差错报告报文\n","categories":["计算机理论"],"tags":["计算机网络原理-计算机网络原理笔记"]},{"title":"IPv6","url":"/2020/05/31/%E8%AE%A1%E7%AE%97%E6%9C%BA%E7%90%86%E8%AE%BA/%E8%AE%A1%E7%AE%97%E6%9C%BA%E7%BD%91%E7%BB%9C%E5%8E%9F%E7%90%86/%E8%AE%A1%E7%AE%97%E6%9C%BA%E7%BD%91%E7%BB%9C%E5%8E%9F%E7%90%86%E7%AC%94%E8%AE%B0/4.9_IPv6/","content":"IPv6：\n为什么有IPv6：1）32位IPv4地址空间已分配殆尽，CIDR、NAT治标不治本；IPv6从根本上解决了地址耗尽问题2）改进首部格式3）快速处理&#x2F;转发数据报4）支持QoS\nIPv6数据报格式：\nIPv6和IPv4：\nIPv6基本地址类型：1）单播：一对一通信，可做源地址+目的地址2）多播：一对多通信，可做目的地址3）任播：一对多中的一个通信，可做目的地址\nIPv6向IPv4过渡的策略：\n","categories":["计算机理论"],"tags":["计算机网络原理-计算机网络原理笔记"]},{"title":"传输层概述","url":"/2020/05/31/%E8%AE%A1%E7%AE%97%E6%9C%BA%E7%90%86%E8%AE%BA/%E8%AE%A1%E7%AE%97%E6%9C%BA%E7%BD%91%E7%BB%9C%E5%8E%9F%E7%90%86/%E8%AE%A1%E7%AE%97%E6%9C%BA%E7%BD%91%E7%BB%9C%E5%8E%9F%E7%90%86%E7%AC%94%E8%AE%B0/5.1_%E4%BC%A0%E8%BE%93%E5%B1%82%E6%A6%82%E8%BF%B0/","content":"传输层概述：\n传输层：只有主机才有的层次，为应用层提供通信服务，使用网络层的服务\n传输层的功能：1）传输层提供进程和进程之间的逻辑通信，网络层提供主机之间的逻辑通信2）复用和分用3）传输层对收到的报文进行差错检测4）传输层的两种协议\n1）面向连接的传输控制协议TCP：传送数据之前必须建立连接，数据传送结束后要释放连接，不提供广播或多播服务，由于TCP要提供可靠的面向连接的传输服务，因此不可避免增加了许多开销：确认、流量控制、计时器及连接管理等【可靠，面向连接，时延大，适用于大文件】2）无连接的用户数据报协议UDP：传送数据前不需要建立连接，收到UDP报文后也不需要给出任何确认【不可靠，无连接，时延小，适用于小文件】\n传输层的寻址与端口：\n复用：应用层所有的应用进程都可以通过传输层再传输到网络层分用：传输层从网络层收到数据后交付指明的应用进程\n端口是传输层的SAP，标识主机中的应用进程【逻辑端口&#x2F;软件端口】\n端口号只有本地意义，在因特网中不同计算机的相同端口是没有联系的\n端口号长度为16bit，能表示65536个不同的端口号在网络中采用发送方和接收方的套接字组合来识别端点，套接字唯一标识了网络中的一个主机和它上面的一个进程\n套接字Socket&#x3D;（主机IP地址，端口号）\n","categories":["计算机理论"],"tags":["计算机网络原理-计算机网络原理笔记"]},{"title":"UDP协议","url":"/2020/05/31/%E8%AE%A1%E7%AE%97%E6%9C%BA%E7%90%86%E8%AE%BA/%E8%AE%A1%E7%AE%97%E6%9C%BA%E7%BD%91%E7%BB%9C%E5%8E%9F%E7%90%86/%E8%AE%A1%E7%AE%97%E6%9C%BA%E7%BD%91%E7%BB%9C%E5%8E%9F%E7%90%86%E7%AC%94%E8%AE%B0/5.2_UDP%E5%8D%8F%E8%AE%AE/","content":"UDP协议：\n用户数据报协议UDP只在IP数据报服务之上增加了很少功能，即复用分用和差错检测功能\nUDP的主要特点：1）UDP是无连接的，减少开销和发送数据之前的时延2）UDP使用最大努力交付，即不保证可靠交付3）UDP是面向报文的，适合一次性传输少量数据的网络应用4）UDP无拥塞控制，适合很多实时应用5)UDP首部开销小，8B，TCP 20B\nUDP首部格式：\nUDP校验：\n","categories":["计算机理论"],"tags":["计算机网络原理-计算机网络原理笔记"]},{"title":"TCP协议","url":"/2020/05/31/%E8%AE%A1%E7%AE%97%E6%9C%BA%E7%90%86%E8%AE%BA/%E8%AE%A1%E7%AE%97%E6%9C%BA%E7%BD%91%E7%BB%9C%E5%8E%9F%E7%90%86/%E8%AE%A1%E7%AE%97%E6%9C%BA%E7%BD%91%E7%BB%9C%E5%8E%9F%E7%90%86%E7%AC%94%E8%AE%B0/5.3_TCP%E5%8D%8F%E8%AE%AE/","content":"TCP协议：\n——————————————\nTCP协议特点和TCP报文段格式TCP连接管理TCP可靠传输TCP流量控制TCP拥塞控制\n——————————————\nTCP协议的特点：1）TCP是面向连接（虚连接）的传输层协议2）每一条TCP连接只能有两个端点，每一条TCP连接只能是点对点的3）TCP提供可靠交付的服务，无差错、不丢失、不重复、按序到达【可靠有序，不丢不重】4）TCP提供全双工通信：【发送缓存：准备发送的数据、已发送但尚未收到确认的数据；接收缓存：按序到达但尚未被接受应用程序读取的数据、不按序到达的数据】5）TCP面向字节流：TCP把应用程序交下来的数据看成仅仅是一连串的无结构的字节流【流：流入到进程或从进程流出的字节序列】\nTCP报文段首部格式：——————————————————\nTCP连接管理：\nTCP连接传输三个阶段：1）连接建立2）数据传送3）连接释放\nTCP连接的建立采用客户服务器方式，主动发起连接建立的应用进程叫做客户，而被动等待连接建立的应用进程叫服务器\nTCP的连接建立(三次握手)：假设运行在一台主机（客户）上的一个进程想与另一台主机（服务器）上的一个进程建立一条连接，客户应用进程首先通知客户TCP，它想建立一个与服务器上某个进程之间的连接，客户中的TCP会用以下步骤与服务器中的TCP建立一条TCP连接：【seq：序号，ack：确认号】\nSYN洪泛攻击：【解决办法：SYN cookie】\nTCP的连接释放(四次挥手)：参与一条TCP连接的两个进程中的任何一个都能终止该连接，连接结束后，主机中的“资源”（缓存和变量）将被释放\n————————————————\nTCP可靠传输：\n网络层：提供尽最大努力交付，不可靠传输传输层：使用TCP实现可靠传输【如果使用UDP协议，则在应用层实现可靠传输】\n可靠：保证接收方进程从缓存区读出的字节流与发送方发出的字节流是完全一样的\nTCP实现可靠传输的机制：1）校验：与UDP校验一样，增加伪首部2）序号3）确认：TCP默认使用累计确认4）重传：确认重传不分家，TCP的发送方在规定的时间内没有收到确认就要重传已发送的报文段【超时重传，TCP采用自适应算法，动态改变重传时间RTTs(加权平均往返时间)】\n等太久了怎么办？？？\n—————————————————\nTCP流量控制：让发送方慢点，要让接收方来得及接收\nTCP利用滑动窗口机制实现流量控制\n在通信过程中，接收方根据自己接收缓存的大小，动态的调整发送方的发送窗口大小，即接收窗口rwnd（接收方设置确认报文段的窗口字段来将rwnd通知给发送方），发送方的发送窗口取接收窗口rwnd和拥塞窗口cwnd的最小值【接收窗口：接收方根据接受缓存设置的值，并告知给发送方，反映接收方容量；拥塞窗口：发送方根据自己估算的网络拥塞程度而设置的窗口值，反映网络当前容量】\n这个时候假设B给A发了一个非零的rwnd，但是在路上丢失了，主机A在等着B发送非零窗口，主机B在等着A的确认消息，两者相互等待，造成死锁\n解决方法：1）TCP为每一个连接设有一个持续计时器，只要TCP连接的一方收到对方的零窗口通知，就启动持续计时器2）若持续计时器设置的时间到期，就发送一个零窗口探测报文段，接收方收到探测报文段时给出现在的窗口值3）若窗口仍然是0，那么发送方就重新设置持续计时器\n————————————————\nTCP拥塞控制：防止过多的数据注入到网络中【全局性】\n出现拥塞的条件：对资源需求的总和&gt;可用资源【网络中有许多资源同时呈现供应不足—&gt;网络性能变坏—&gt;网络吞吐量将随输入负荷增大而下降】\n拥塞控制四种算法：1）慢开始、拥塞避免2）快重传、快恢复\n","categories":["计算机理论"],"tags":["计算机网络原理-计算机网络原理笔记"]},{"title":"电子邮件","url":"/2020/05/31/%E8%AE%A1%E7%AE%97%E6%9C%BA%E7%90%86%E8%AE%BA/%E8%AE%A1%E7%AE%97%E6%9C%BA%E7%BD%91%E7%BB%9C%E5%8E%9F%E7%90%86/%E8%AE%A1%E7%AE%97%E6%9C%BA%E7%BD%91%E7%BB%9C%E5%8E%9F%E7%90%86%E7%AC%94%E8%AE%B0/6.4_%E7%94%B5%E5%AD%90%E9%82%AE%E4%BB%B6/","content":"电子邮件：\n组成结构：\n——————————————————\n简单邮件传送协议SMTP【使用TCP连接、端口号为25、C&#x2F;S】【MIME】：1）SMTP规定了在两个相互通信的SMTP进程之间应如何交换信息2）负责发送邮件的SMTP进程就是SMTP客户，负责接收邮件的进程就是SMTP服务器3）SMTP规定了14条命令（几个字母）和21种应答信息（三位数字代码+简单文字说明）\nSMTP通信三个阶段：\nSMTP的缺点：1）SMTP不能传送可执行文件或者其他二进制对象2）SMTP仅限于传送7位ASCII码，不能传送其他非英语国家的文字3）SMTP服务器会拒绝超过一定长度的邮件\n———————————————————\n邮局协议POP3【TCP连接、端口号为110、C&#x2F;S】:POP3工作方式：下载并保留(在服务器)、下载并删除\n—————————————————\n网际报文存取协议IMAP：1）IMAP协议比POP协议复杂，当用户Pc上的IMAP客户程序打开IMAP服务器的邮箱时，用户可以看到邮箱的首部，若用户需要打开某个邮件，该邮件才上传到用户的计算机上2）IMAP可以让用户在不同的地方使用不同的计算机随时上网阅读处理邮件，还允许只读取邮件中的某一个部分（先看正文，有WI-FI的时候再下载附件）\n————————————————\n基于万维网的电子邮件（方便）：\n","categories":["计算机理论"],"tags":["计算机网络原理-计算机网络原理笔记"]},{"title":"文件传输协议FTP","url":"/2020/05/31/%E8%AE%A1%E7%AE%97%E6%9C%BA%E7%90%86%E8%AE%BA/%E8%AE%A1%E7%AE%97%E6%9C%BA%E7%BD%91%E7%BB%9C%E5%8E%9F%E7%90%86/%E8%AE%A1%E7%AE%97%E6%9C%BA%E7%BD%91%E7%BB%9C%E5%8E%9F%E7%90%86%E7%AC%94%E8%AE%B0/6.3_%E6%96%87%E4%BB%B6%E4%BC%A0%E8%BE%93%E5%8D%8F%E8%AE%AEFTP/","content":"文件传输协议FTP：\n文件传送协议：1）文件传送协议FTP(File Transfer Protocol)：提供不同种类主机系统（硬、软件体系等都可以不同）之间的文件传输能力【拷贝：上传、下载】2）简单文件传送协议TFTP\nFTP服务器和用户端：1）FTP是基于客户&#x2F;服务器（C&#x2F;S）的协议2）用户通过一个客户机程序连接至在远程计算机上运行的服务器程序3）依照FTP协议提供服务，进行文件传送的计算机就是FTP服务器4）连接FTP服务器，遵循FTP协议与服务器传送文件的电脑就是FTP客户端\nFTP工作原理：1）登陆：FTP地址、用户名、密码匿名登陆：2）FTP使用TCP实现可靠传输【FTP服务器进程：一个主进程、n个从属进程】【控制进程和数据传送进程都属于从属进程】\nFTP传输模式：1）文本模式：ASCII模式，以文本序列传输数据2）二进制模式：Binary模式，以二进制序列传输数据\n","categories":["计算机理论"],"tags":["计算机网络原理-计算机网络原理笔记"]},{"title":"域名解析系统DNS","url":"/2020/05/31/%E8%AE%A1%E7%AE%97%E6%9C%BA%E7%90%86%E8%AE%BA/%E8%AE%A1%E7%AE%97%E6%9C%BA%E7%BD%91%E7%BB%9C%E5%8E%9F%E7%90%86/%E8%AE%A1%E7%AE%97%E6%9C%BA%E7%BD%91%E7%BB%9C%E5%8E%9F%E7%90%86%E7%AC%94%E8%AE%B0/6.2_%E5%9F%9F%E5%90%8D%E8%A7%A3%E6%9E%90%E7%B3%BB%E7%BB%9FDNS/","content":"域名解析系统DNS：\n\n———————————————————\n\n","categories":["计算机理论"],"tags":["计算机网络原理-计算机网络原理笔记"]},{"title":"万维网和HTTP协议","url":"/2020/05/31/%E8%AE%A1%E7%AE%97%E6%9C%BA%E7%90%86%E8%AE%BA/%E8%AE%A1%E7%AE%97%E6%9C%BA%E7%BD%91%E7%BB%9C%E5%8E%9F%E7%90%86/%E8%AE%A1%E7%AE%97%E6%9C%BA%E7%BD%91%E7%BB%9C%E5%8E%9F%E7%90%86%E7%AC%94%E8%AE%B0/6.5_%E4%B8%87%E7%BB%B4%E7%BD%91%E5%92%8CHTTP%E5%8D%8F%E8%AE%AE/","content":"万维网和HTTP协议：\n万维网WWW（World Wide Web）是一个大规模的、联机式的信息储藏所&#x2F;资料空间，是无数个网络站点和网页的集合用户通过点击超链接（http://www.baidu.com)获取资源，这些资源通过超文本传输协议HTTP传送给使用者\n万维网以客户&#x2F;服务器方式工作，用户使用的浏览器就是万维网客户程序，万维网文档所驻留的主机运行服务器程序\n万维网使用超文本标记语言HTML，使得万维网页面设计者可以很方便的从一个界面的链接转到另一个界面，并能够在自己的屏幕上显示出来\n———————————————————\n超文本传输协议HTTP：HTTP协议定义了浏览器（万维网客户进程）怎样向万维网服务器请求万维网文档，以及服务器怎样把文档传送给浏览器\nHTTP协议的特点：1）HTTP协议是无状态的【但是在实际工作中，一些万维网站点常常希望能够识别用户（淘宝、Cookie），Cookie是存储在用户主机中的文本文件，记录一段时间内某用户（使用识别码识别，如“123456”）的访问记录、提供个性化服务】2）HTTP采用TCP作为运输层协议，但HTTP协议本身是无连接的（通信双方在交换HTTP报文之前不需要先建立HTTP连接）\nHTTP的连接方式：1）持久连接(Keep-alive)：非流水线、流水线2）非持久连接(Close)\nHTTP报文结构：\n","categories":["计算机理论"],"tags":["计算机网络原理-计算机网络原理笔记"]},{"title":"什么是计算机网络","url":"/2020/05/15/%E8%AE%A1%E7%AE%97%E6%9C%BA%E7%90%86%E8%AE%BA/%E8%AE%A1%E7%AE%97%E6%9C%BA%E7%BD%91%E7%BB%9C%E5%8E%9F%E7%90%86/%E8%AE%A1%E7%AE%97%E6%9C%BA%E7%BD%91%E7%BB%9C%E5%8E%9F%E7%90%86%E9%9D%A2%E8%AF%95%E9%A2%98/1.1_%E4%BB%80%E4%B9%88%E6%98%AF%E8%AE%A1%E7%AE%97%E6%9C%BA%E7%BD%91%E7%BB%9C/","content":"计算机网络是一个将分散的、具有独立功能的计算机系统，通过通信设备与线路连接起来，由功能完善的软件实现资源共享和信息传递的系统\n","categories":["计算机理论"],"tags":["计算机网络原理-计算机网络原理面试题"]},{"title":"IPv4地址","url":"/2020/05/15/%E8%AE%A1%E7%AE%97%E6%9C%BA%E7%90%86%E8%AE%BA/%E8%AE%A1%E7%AE%97%E6%9C%BA%E7%BD%91%E7%BB%9C%E5%8E%9F%E7%90%86/%E8%AE%A1%E7%AE%97%E6%9C%BA%E7%BD%91%E7%BB%9C%E5%8E%9F%E7%90%86%E9%9D%A2%E8%AF%95%E9%A2%98/4.1_IPv4%E5%9C%B0%E5%9D%80/","content":"IPv4编址的历史阶段：\nIP地址是指互联网协议地址，是IP协议提供的一种统一的地址格式，它为互联网上的每一个网络和每一台主机分配一个逻辑地址，以此来屏蔽物理地址的差异\n\n分类的IP地址：全世界唯一的32位&#x2F;4字节标识符，标识路由器主机的接口&lt;网络号&gt;&lt;主机号&gt;\n\n私有IP地址：\n\n路由器对目的地址是私有IP地址的数据报一律不进行转发\n网络地址转换NAT：在专用网连接到因特网的路由器上安装NAT软件，安装了NAT软件的路由器叫NAT路由器，它至少有一个有效的外部全球IP地址\n\n\n子网的划分\n\n\n构成超网（无分类编址方法）\n\n\n","categories":["计算机理论"],"tags":["计算机网络原理-计算机网络原理面试题"]},{"title":"IPv4数据报格式","url":"/2020/05/15/%E8%AE%A1%E7%AE%97%E6%9C%BA%E7%90%86%E8%AE%BA/%E8%AE%A1%E7%AE%97%E6%9C%BA%E7%BD%91%E7%BB%9C%E5%8E%9F%E7%90%86/%E8%AE%A1%E7%AE%97%E6%9C%BA%E7%BD%91%E7%BB%9C%E5%8E%9F%E7%90%86%E9%9D%A2%E8%AF%95%E9%A2%98/4.2_IPv4%E6%95%B0%E6%8D%AE%E6%8A%A5%E6%A0%BC%E5%BC%8F/","content":"\n\n\n","categories":["计算机理论"],"tags":["计算机网络原理-计算机网络原理面试题"]},{"title":"计算机网络的各层协议及作用","url":"/2020/05/15/%E8%AE%A1%E7%AE%97%E6%9C%BA%E7%90%86%E8%AE%BA/%E8%AE%A1%E7%AE%97%E6%9C%BA%E7%BD%91%E7%BB%9C%E5%8E%9F%E7%90%86/%E8%AE%A1%E7%AE%97%E6%9C%BA%E7%BD%91%E7%BB%9C%E5%8E%9F%E7%90%86%E9%9D%A2%E8%AF%95%E9%A2%98/1.2_%E8%AE%A1%E7%AE%97%E6%9C%BA%E7%BD%91%E7%BB%9C%E7%9A%84%E5%90%84%E5%B1%82%E5%8D%8F%E8%AE%AE%E5%8F%8A%E4%BD%9C%E7%94%A8/","content":"计算机网络体系可以大致分为以下三种，OSI七层模型、TCP&#x2F;IP四层模型和五层模型。\n\nOSI七层模型：大而全，但是比较复杂、而且是先有了理论模型，没有实际应用。\nTCP&#x2F;IP四层模型：是由实际应用发展总结出来的，从实质上讲，TCP&#x2F;IP只有最上面三层，最下面一层没有什么具体内容，TCP&#x2F;IP参考模型没有真正描述这一层的实现。\n五层模型：五层模型只出现在计算机网络教学过程中，这是对七层模型和四层模型的一个折中，既简洁又能将概念阐述清楚。\n\n\n应用层：用户与网络的界面，所有能和用户交互产生网络流量的程序【文件传输FTP、简单文件传送协议TFTP、电子邮件SMTP、万维网HTTP】\n表示层：用于处理在两个通信系统中交换信息的表示方式，比如数据格式变换、数据加密解密、数据压缩和恢复【主要协议：JPEG、ASCII】\n会话层：向表示层实体&#x2F;用户进程提供建立连接并在连接上有序的传输数据【主要协议：ADSP、ASP】\n传输层：负责主机中两个进程的通信，即端到端的通信，传输单位是报文段【主要协议：TCP、UDP】\n网络层：主要任务是把分组从源端传到目的端，为分组交换网上的不同主机提供通信服务，网络层传输单位是数据报【主要协议：IP、ARP、DHCP、ICMP、IGMP】【设备：路由器】\n\n路由选择：RIP、OSPF、BGP\n分组转发（电路交换、报文交换、分组交换）\n异构网络互联\n拥塞控制：若所有结点都来不及接受分组，而要丢弃大量分组的话，网络就处于拥塞状态，因此要采取一定措施，缓解这种拥塞\n\n数据链路层：主要任务是把网络层传下来的数据报组装成帧，数据链路层&#x2F;链路层的传输单位是帧【主要协议：自动重传请求协议ARQ】【设备：网桥、交换机】\n物理层：主要任务是在物理媒体上实现比特流的透明传输，物理层传输单位是比特【主要协议：Rj45、802.3】【设备：中继器、集线器(多口中继器)】\n","categories":["计算机理论"],"tags":["计算机网络原理-计算机网络原理面试题"]},{"title":"网络应用模型","url":"/2020/05/31/%E8%AE%A1%E7%AE%97%E6%9C%BA%E7%90%86%E8%AE%BA/%E8%AE%A1%E7%AE%97%E6%9C%BA%E7%BD%91%E7%BB%9C%E5%8E%9F%E7%90%86/%E8%AE%A1%E7%AE%97%E6%9C%BA%E7%BD%91%E7%BB%9C%E5%8E%9F%E7%90%86%E7%AC%94%E8%AE%B0/6.1_%E7%BD%91%E7%BB%9C%E5%BA%94%E7%94%A8%E6%A8%A1%E5%9E%8B/","content":"网络应用模型：\n应用层对应用程序的通信提供服务\n应用层的功能：1）文件传输、访问和管理2）电子邮件3）虚拟终端4）查询服务和远程作业登录\n应用层的重要协议：1）FTP、TFTP2）SMTP、POP3、IMAP3）HTTP\n网络应用模型：1）客户&#x2F;服务器模型（Client&#x2F;Server）2）P2P模型（Peer-to-Peer）\n—————————\n服务器：提供计算服务的设备【永久提供服务、永久性访问地址&#x2F;域名】\n客户机：请求计算服务的主机1）与服务器通信，使用服务器提供的服务2）间歇性接入网络3）可能使用动态IP地址4）不与其他客户机直接通信\n应用：Web、文件传输FTP、远程登录、电子邮件\n—————————\nP2P模型：1）不存在永远在线的服务器2）每个主机既可以提供服务，也可以请求服务3）任意端系统&#x2F;节点之间可以直接通讯4）节点间歇性接入网络5）节点可能改变IP地址6）可扩展性好7)网络健壮性强\n","categories":["计算机理论"],"tags":["计算机网络原理-计算机网络原理笔记"]},{"title":"网络层功能概述","url":"/2020/05/31/%E8%AE%A1%E7%AE%97%E6%9C%BA%E7%90%86%E8%AE%BA/%E8%AE%A1%E7%AE%97%E6%9C%BA%E7%BD%91%E7%BB%9C%E5%8E%9F%E7%90%86/%E8%AE%A1%E7%AE%97%E6%9C%BA%E7%BD%91%E7%BB%9C%E5%8E%9F%E7%90%86%E7%AC%94%E8%AE%B0/4.1_%E7%BD%91%E7%BB%9C%E5%B1%82%E5%8A%9F%E8%83%BD%E6%A6%82%E8%BF%B0/","content":"网络层功能概述：\n网络层主要任务是把分组从源端传到目的端，为分组交换网上的不同主机提供通信服务\n网络层传输单位是数据报\n功能：1）路由选择与分组转发(最佳路径)2）异构网络互联3）拥塞控制：若所有结点都来不及接受分组，而要丢弃大量分组的话，网络就处于拥塞状态，因此要采取一定措施，缓解这种拥塞【开环控制(静)、闭环控制(动)】\n","categories":["计算机理论"],"tags":["计算机网络原理-计算机网络原理笔记"]},{"title":"DHCP协议","url":"/2020/05/15/%E8%AE%A1%E7%AE%97%E6%9C%BA%E7%90%86%E8%AE%BA/%E8%AE%A1%E7%AE%97%E6%9C%BA%E7%BD%91%E7%BB%9C%E5%8E%9F%E7%90%86/%E8%AE%A1%E7%AE%97%E6%9C%BA%E7%BD%91%E7%BB%9C%E5%8E%9F%E7%90%86%E9%9D%A2%E8%AF%95%E9%A2%98/4.4_DHCP%E5%8D%8F%E8%AE%AE/","content":"\n","categories":["计算机理论"],"tags":["计算机网络原理-计算机网络原理面试题"]},{"title":"IPv6","url":"/2020/05/15/%E8%AE%A1%E7%AE%97%E6%9C%BA%E7%90%86%E8%AE%BA/%E8%AE%A1%E7%AE%97%E6%9C%BA%E7%BD%91%E7%BB%9C%E5%8E%9F%E7%90%86/%E8%AE%A1%E7%AE%97%E6%9C%BA%E7%BD%91%E7%BB%9C%E5%8E%9F%E7%90%86%E9%9D%A2%E8%AF%95%E9%A2%98/4.7_IPv6/","content":"为什么有IPv6：1）32位IPv4地址空间已分配殆尽，CIDR、NAT治标不治本；IPv6从根本上解决了地址耗尽问题2）改进首部格式3）快速处理&#x2F;转发数据报4）支持QoS\nIPv6数据报格式：\n\n","categories":["计算机理论"],"tags":["计算机网络原理-计算机网络原理面试题"]},{"title":"ARP协议的工作过程","url":"/2020/05/15/%E8%AE%A1%E7%AE%97%E6%9C%BA%E7%90%86%E8%AE%BA/%E8%AE%A1%E7%AE%97%E6%9C%BA%E7%BD%91%E7%BB%9C%E5%8E%9F%E7%90%86/%E8%AE%A1%E7%AE%97%E6%9C%BA%E7%BD%91%E7%BB%9C%E5%8E%9F%E7%90%86%E9%9D%A2%E8%AF%95%E9%A2%98/4.3_ARP%E5%8D%8F%E8%AE%AE%E7%9A%84%E5%B7%A5%E4%BD%9C%E8%BF%87%E7%A8%8B/","content":"由于在实际网络的链路上传送数据帧时，最终必须使用MAC地址\nARP协议：完成主机或路由器IP地址到MAC地址的映射（解决下一跳走哪的问题）\nARP协议使用过程：\n\n","categories":["计算机理论"],"tags":["计算机网络原理-计算机网络原理面试题"]},{"title":"ICMP协议","url":"/2020/05/15/%E8%AE%A1%E7%AE%97%E6%9C%BA%E7%90%86%E8%AE%BA/%E8%AE%A1%E7%AE%97%E6%9C%BA%E7%BD%91%E7%BB%9C%E5%8E%9F%E7%90%86/%E8%AE%A1%E7%AE%97%E6%9C%BA%E7%BD%91%E7%BB%9C%E5%8E%9F%E7%90%86%E9%9D%A2%E8%AF%95%E9%A2%98/4.5_ICMP%E5%8D%8F%E8%AE%AE/","content":"ICMP协议：为了更有效的转发IP数据报和提高交付成功的机会\nICMP差错报告报文：1）终点不可达：当路由器或主机不能交付数据报时就向源点发送终点不可达报文【无法交付】2）源点抑制：当路由器或主机由于拥塞而丢弃数据报时，就向源点发送源点抑制报文，使源点知道应当把数据报的发送速率放慢【拥塞丢数据】3）时间超过：当路由器收到生存时间TTL&#x3D;0的数据报时，除丢弃该数据报外，还要向源点发送时间超过报文。当终点在预先规定的时间内不能收到一个数据报的全部数据报片时，就把已收到的数据报片都丢弃，并向源点发送时间超过报文【TTL&#x3D;0】4）参数问题：当路由器或目的主机收到的数据报的首部中有的字段的值不正确时，就丢弃该数据报，并向源点发送参数问题报文【首部字段有问题】5）改变路由（重定向）：路由器把改变路由报文发送给主机，让主机知道下次应将数据报发送给另外的路由器（可通过更好的路由）【值得更好的路由】\nICMP询问报文：1）回送请求和回答报文：主机或路由器向特定目的主机发出的询问，收到此报文的主机必须给源主机或路由器发送ICMP回送回答报文【测试目的站是否可达以及了解其相关状态】2）时间戳请求和回答报文：请某个主机或路由器回答当前的日期和时间【用来进行时钟同步和测量时间】3）掩码地址请求和回答报文4）路由器询问和通告报文\n","categories":["计算机理论"],"tags":["计算机网络原理-计算机网络原理面试题"]},{"title":"服务器收到客户端的SYN后，为什么还要传回SYN","url":"/2020/05/15/%E8%AE%A1%E7%AE%97%E6%9C%BA%E7%90%86%E8%AE%BA/%E8%AE%A1%E7%AE%97%E6%9C%BA%E7%BD%91%E7%BB%9C%E5%8E%9F%E7%90%86/%E8%AE%A1%E7%AE%97%E6%9C%BA%E7%BD%91%E7%BB%9C%E5%8E%9F%E7%90%86%E9%9D%A2%E8%AF%95%E9%A2%98/5.11_%E6%9C%8D%E5%8A%A1%E5%99%A8%E6%94%B6%E5%88%B0%E5%AE%A2%E6%88%B7%E7%AB%AF%E7%9A%84SYN%E5%90%8E%EF%BC%8C%E4%B8%BA%E4%BB%80%E4%B9%88%E8%BF%98%E8%A6%81%E4%BC%A0%E5%9B%9ESYN/","content":"接收端传回发送端所发送的SYN是为了告诉发送端，我接收到的信息确实就是你所发送的信号了。\n","categories":["计算机理论"],"tags":["计算机网络原理-计算机网络原理面试题"]},{"title":"详细介绍一下TCP的三次握手机制","url":"/2020/05/15/%E8%AE%A1%E7%AE%97%E6%9C%BA%E7%90%86%E8%AE%BA/%E8%AE%A1%E7%AE%97%E6%9C%BA%E7%BD%91%E7%BB%9C%E5%8E%9F%E7%90%86/%E8%AE%A1%E7%AE%97%E6%9C%BA%E7%BD%91%E7%BB%9C%E5%8E%9F%E7%90%86%E9%9D%A2%E8%AF%95%E9%A2%98/5.10_%E8%AF%A6%E7%BB%86%E4%BB%8B%E7%BB%8D%E4%B8%80%E4%B8%8BTCP%E7%9A%84%E4%B8%89%E6%AC%A1%E6%8F%A1%E6%89%8B%E6%9C%BA%E5%88%B6/","content":"\n三次握手机制：\n\n第一次握手：客户端请求建立连接，向服务端发送一个同步报文（SYN&#x3D;1），同时选择一个随机数 seq &#x3D; x 作为初始序列号，并进入SYN_SENT状态，等待服务器确认。\n第二次握手：服务端收到连接请求报文后，如果同意建立连接，则向客户端发送同步确认报文（SYN&#x3D;1，ACK&#x3D;1），确认号为 ack &#x3D; x + 1，同时选择一个随机数 seq &#x3D; y 作为初始序列号，此时服务器进入SYN_RECV状态。\n第三次握手：客户端收到服务端的确认后，向服务端发送一个确认报文（ACK&#x3D;1），确认号为 ack &#x3D; y + 1，序列号为 seq &#x3D; x + 1，客户端和服务器进入ESTABLISHED状态，完成三次握手。\n\n理想状态下，TCP连接一旦建立，在通信双方中的任何一方主动关闭连接之前，TCP 连接都将被一直保持下去。\n","categories":["计算机理论"],"tags":["计算机网络原理-计算机网络原理面试题"]},{"title":"传了SYN，为什么还要传ACK","url":"/2020/05/15/%E8%AE%A1%E7%AE%97%E6%9C%BA%E7%90%86%E8%AE%BA/%E8%AE%A1%E7%AE%97%E6%9C%BA%E7%BD%91%E7%BB%9C%E5%8E%9F%E7%90%86/%E8%AE%A1%E7%AE%97%E6%9C%BA%E7%BD%91%E7%BB%9C%E5%8E%9F%E7%90%86%E9%9D%A2%E8%AF%95%E9%A2%98/5.12_%E4%BC%A0%E4%BA%86SYN%EF%BC%8C%E4%B8%BA%E4%BB%80%E4%B9%88%E8%BF%98%E8%A6%81%E4%BC%A0ACK/","content":"双方通信无误必须是两者互相发送信息都无误，传了SYN证明发送方到接收方的通道没有问题，但是接收方到发送方的通道还需要ACK信号来进行验证\n","categories":["计算机理论"],"tags":["计算机网络原理-计算机网络原理面试题"]},{"title":"为什么客户端的TIME-WAIT状态必须等待2MSL","url":"/2020/05/15/%E8%AE%A1%E7%AE%97%E6%9C%BA%E7%90%86%E8%AE%BA/%E8%AE%A1%E7%AE%97%E6%9C%BA%E7%BD%91%E7%BB%9C%E5%8E%9F%E7%90%86/%E8%AE%A1%E7%AE%97%E6%9C%BA%E7%BD%91%E7%BB%9C%E5%8E%9F%E7%90%86%E9%9D%A2%E8%AF%95%E9%A2%98/5.14_%E4%B8%BA%E4%BB%80%E4%B9%88%E5%AE%A2%E6%88%B7%E7%AB%AF%E7%9A%84TIME-WAIT%E7%8A%B6%E6%80%81%E5%BF%85%E9%A1%BB%E7%AD%89%E5%BE%852MSL/","content":"主要有两个原因：\n\n确保 ACK 报文能够到达服务端，从而使服务端正常关闭连接。\n第四次挥手时，客户端第四次挥手的 ACK 报文不一定会到达服务端。服务端会超时重传 FIN&#x2F;ACK 报文，此时如果客户端已经断开了连接，那么就无法响应服务端的二次请求，这样服务端迟迟收不到 FIN&#x2F;ACK 报文的确认，就无法正常断开连接。\nMSL 是报文段在网络上存活的最长时间。客户端等待 2MSL 时间，即「客户端 ACK 报文 1MSL 超时 + 服务端 FIN 报文 1MSL 传输」，就能够收到服务端重传的 FIN&#x2F;ACK 报文，然后客户端重传一次 ACK 报文，并重新启动 2MSL 计时器。如此保证服务端能够正常关闭。\n如果服务端重发的 FIN 没有成功地在 2MSL 时间里传给客户端，服务端则会继续超时重试直到断开连接。\n\n防止已失效的连接请求报文段出现在之后的连接中。\nTCP 要求在 2MSL 内不使用相同的序列号。客户端在发送完最后一个 ACK 报文段后，再经过时间 2MSL，就可以保证本连接持续的时间内产生的所有报文段都从网络中消失。这样就可以使下一个连接中不会出现这种旧的连接请求报文段。或者即使收到这些过时的报文，也可以不处理它。\n\n\n","categories":["计算机理论"],"tags":["计算机网络原理-计算机网络原理面试题"]},{"title":"TIME-WAIT是服务器端的状态还是客户端的状态","url":"/2020/05/15/%E8%AE%A1%E7%AE%97%E6%9C%BA%E7%90%86%E8%AE%BA/%E8%AE%A1%E7%AE%97%E6%9C%BA%E7%BD%91%E7%BB%9C%E5%8E%9F%E7%90%86/%E8%AE%A1%E7%AE%97%E6%9C%BA%E7%BD%91%E7%BB%9C%E5%8E%9F%E7%90%86%E9%9D%A2%E8%AF%95%E9%A2%98/5.15_TIME-WAIT%E6%98%AF%E6%9C%8D%E5%8A%A1%E5%99%A8%E7%AB%AF%E7%9A%84%E7%8A%B6%E6%80%81%E8%BF%98%E6%98%AF%E5%AE%A2%E6%88%B7%E7%AB%AF%E7%9A%84%E7%8A%B6%E6%80%81/","content":"TIME_WAIT 是主动断开连接的一方会进入的状态，一般情况下，都是客户端所处的状态；服务器端一般设置不主动关闭连接。TIME_WAIT 需要等待 2MSL，在大量短连接的情况下，TIME_WAIT会太多，这也会消耗很多系统资源。\n","categories":["计算机理论"],"tags":["计算机网络原理-计算机网络原理面试题"]},{"title":"如果已经建立了连接，但是客户端出现故障了怎么办","url":"/2020/05/15/%E8%AE%A1%E7%AE%97%E6%9C%BA%E7%90%86%E8%AE%BA/%E8%AE%A1%E7%AE%97%E6%9C%BA%E7%BD%91%E7%BB%9C%E5%8E%9F%E7%90%86/%E8%AE%A1%E7%AE%97%E6%9C%BA%E7%BD%91%E7%BB%9C%E5%8E%9F%E7%90%86%E9%9D%A2%E8%AF%95%E9%A2%98/5.17_%E5%A6%82%E6%9E%9C%E5%B7%B2%E7%BB%8F%E5%BB%BA%E7%AB%8B%E4%BA%86%E8%BF%9E%E6%8E%A5%EF%BC%8C%E4%BD%86%E6%98%AF%E5%AE%A2%E6%88%B7%E7%AB%AF%E5%87%BA%E7%8E%B0%E6%95%85%E9%9A%9C%E4%BA%86%E6%80%8E%E4%B9%88%E5%8A%9E/","content":"TCP 设有一个保活计时器。服务器每收到一次客户端的数据，都会重新复位这个计时器，时间通常是设置为 2 小时。若 2 小时还没有收到客户端的任何数据，服务器就开始重试：每隔 75 分钟发送一个探测报文段，若一连发送 10 个探测报文后客户端依然没有回应，那么服务器就认为连接已经断开了。\n","categories":["计算机理论"],"tags":["计算机网络原理-计算机网络原理面试题"]},{"title":"为什么需要三次握手，而不是两次","url":"/2020/05/15/%E8%AE%A1%E7%AE%97%E6%9C%BA%E7%90%86%E8%AE%BA/%E8%AE%A1%E7%AE%97%E6%9C%BA%E7%BD%91%E7%BB%9C%E5%8E%9F%E7%90%86/%E8%AE%A1%E7%AE%97%E6%9C%BA%E7%BD%91%E7%BB%9C%E5%8E%9F%E7%90%86%E9%9D%A2%E8%AF%95%E9%A2%98/5.18_%E4%B8%BA%E4%BB%80%E4%B9%88%E9%9C%80%E8%A6%81%E4%B8%89%E6%AC%A1%E6%8F%A1%E6%89%8B%EF%BC%8C%E8%80%8C%E4%B8%8D%E6%98%AF%E4%B8%A4%E6%AC%A1/","content":"主要有三个原因：\n\n防止已过期的连接请求报文突然又传送到服务器，因而产生错误和资源浪费。\n在双方两次握手即可建立连接的情况下，假设客户端发送 A 报文段请求建立连接，由于网络原因造成 A 暂时无法到达服务器，服务器接收不到请求报文段就不会返回确认报文段。\n客户端在长时间得不到应答的情况下重新发送请求报文段 B，这次 B 顺利到达服务器，服务器随即返回确认报文并进入 ESTABLISHED 状态，客户端在收到 确认报文后也进入 ESTABLISHED 状态，双方建立连接并传输数据，之后正常断开连接。\n此时姗姗来迟的 A 报文段才到达服务器，服务器随即返回确认报文并进入 ESTABLISHED 状态，但是已经进入 CLOSED 状态的客户端无法再接受确认报文段，更无法进入 ESTABLISHED 状态，这将导致服务器长时间单方面等待，造成资源浪费。\n\n三次握手才能让双方均确认自己和对方的发送和接收能力都正常。\n第一次握手：客户端只是发送处请求报文段，什么都无法确认，而服务器可以确认自己的接收能力和对方的发送能力正常；\n第二次握手：客户端可以确认自己发送能力和接收能力正常，对方发送能力和接收能力正常；\n第三次握手：服务器可以确认自己发送能力和接收能力正常，对方发送能力和接收能力正常；\n可见三次握手才能让双方都确认自己和对方的发送和接收能力全部正常，这样就可以愉快地进行通信了。\n\n告知对方自己的初始序号值，并确认收到对方的初始序号值。\nTCP 实现了可靠的数据传输，原因之一就是 TCP 报文段中维护了序号字段和确认序号字段，通过这两个字段双方都可以知道在自己发出的数据中，哪些是已经被对方确认接收的。这两个字段的值会在初始序号值得基础递增，如果是两次握手，只有发起方的初始序号可以得到确认，而另一方的初始序号则得不到确认。\n\n\n","categories":["计算机理论"],"tags":["计算机网络原理-计算机网络原理面试题"]},{"title":"TIME-WAIT状态过多会产生什么后果","url":"/2020/05/15/%E8%AE%A1%E7%AE%97%E6%9C%BA%E7%90%86%E8%AE%BA/%E8%AE%A1%E7%AE%97%E6%9C%BA%E7%BD%91%E7%BB%9C%E5%8E%9F%E7%90%86/%E8%AE%A1%E7%AE%97%E6%9C%BA%E7%BD%91%E7%BB%9C%E5%8E%9F%E7%90%86%E9%9D%A2%E8%AF%95%E9%A2%98/5.16_TIME-WAIT%E7%8A%B6%E6%80%81%E8%BF%87%E5%A4%9A%E4%BC%9A%E4%BA%A7%E7%94%9F%E4%BB%80%E4%B9%88%E5%90%8E%E6%9E%9C/","content":"从服务器来讲，短时间内关闭了大量的Client连接，就会造成服务器上出现大量的TIME_WAIT连接，严重消耗着服务器的资源，此时部分客户端就会显示连接不上。\n从客户端来讲，客户端TIME_WAIT过多，就会导致端口资源被占用，因为端口就65536个，被占满就会导致无法创建新的连接。\n","categories":["计算机理论"],"tags":["计算机网络原理-计算机网络原理面试题"]},{"title":"TCP和UDP的区别","url":"/2020/05/15/%E8%AE%A1%E7%AE%97%E6%9C%BA%E7%90%86%E8%AE%BA/%E8%AE%A1%E7%AE%97%E6%9C%BA%E7%BD%91%E7%BB%9C%E5%8E%9F%E7%90%86/%E8%AE%A1%E7%AE%97%E6%9C%BA%E7%BD%91%E7%BB%9C%E5%8E%9F%E7%90%86%E9%9D%A2%E8%AF%95%E9%A2%98/5.1_TCP%E5%92%8CUDP%E7%9A%84%E5%8C%BA%E5%88%AB/","content":"\n\n\n\nUDP\nTCP\n\n\n\n是否连接\n无连接\n面向连接\n\n\n是否可靠\n不可靠传输，不使用流量控制和拥塞控制\n可靠传输，使用流量控制和拥塞控制\n\n\n是否有序\n无序\n有序，消息在传输过程中可能会乱序，TCP 会重新排序\n\n\n传输速度\n快\n慢\n\n\n连接对象个数\n支持一对一，一对多，多对一和多对多交互通信\n只能是一对一通信\n\n\n传输方式\n面向报文\n面向字节流\n\n\n首部开销\n首部开销小，仅8字节\n首部最小20字节，最大60字节\n\n\n适用场景\n适用于实时应用（IP电话、视频会议、直播等）\n适用于要求可靠传输的应用，例如文件传输\n\n\n总结：TCP 用于在传输层有必要实现可靠传输的情况，UDP 用于对高速传输和实时性有较高要求的通信。TCP 和 UDP 应该根据应用目的按需使用。\n\nTCP连接管理\nTCP可靠传输\nTCP流量控制\nTCP拥塞控制\n\n","categories":["计算机理论"],"tags":["计算机网络原理-计算机网络原理面试题"]},{"title":"IPv4和IPv6的区别","url":"/2020/05/15/%E8%AE%A1%E7%AE%97%E6%9C%BA%E7%90%86%E8%AE%BA/%E8%AE%A1%E7%AE%97%E6%9C%BA%E7%BD%91%E7%BB%9C%E5%8E%9F%E7%90%86/%E8%AE%A1%E7%AE%97%E6%9C%BA%E7%BD%91%E7%BB%9C%E5%8E%9F%E7%90%86%E9%9D%A2%E8%AF%95%E9%A2%98/4.8_IPv4%E5%92%8CIPv6%E7%9A%84%E5%8C%BA%E5%88%AB/","content":"\n","categories":["计算机理论"],"tags":["计算机网络原理-计算机网络原理面试题"]},{"title":"三次握手连接阶段，最后一次ACK包丢失，会发生什么","url":"/2020/05/15/%E8%AE%A1%E7%AE%97%E6%9C%BA%E7%90%86%E8%AE%BA/%E8%AE%A1%E7%AE%97%E6%9C%BA%E7%BD%91%E7%BB%9C%E5%8E%9F%E7%90%86/%E8%AE%A1%E7%AE%97%E6%9C%BA%E7%BD%91%E7%BB%9C%E5%8E%9F%E7%90%86%E9%9D%A2%E8%AF%95%E9%A2%98/5.13_%E4%B8%89%E6%AC%A1%E6%8F%A1%E6%89%8B%E8%BF%9E%E6%8E%A5%E9%98%B6%E6%AE%B5%EF%BC%8C%E6%9C%80%E5%90%8E%E4%B8%80%E6%AC%A1ACK%E5%8C%85%E4%B8%A2%E5%A4%B1%EF%BC%8C%E4%BC%9A%E5%8F%91%E7%94%9F%E4%BB%80%E4%B9%88/","content":"服务端：\n\n第三次的ACK在网络中丢失，那么服务端该TCP连接的状态为SYN_RECV,并且会根据 TCP的超时重传机制，会等待3秒、6秒、12秒后重新发送SYN+ACK包，以便客户端重新发送ACK包。\n如果重发指定次数之后，仍然未收到客户端的ACK应答，那么一段时间后，服务端自动关闭这个连接。\n\n客户端：\n客户端认为这个连接已经建立，如果客户端向服务端发送数据，服务端将以RST包（Reset，标示复位，用于异常的关闭连接）响应。此时，客户端知道第三次握手失败。\n","categories":["计算机理论"],"tags":["计算机网络原理-计算机网络原理面试题"]},{"title":"什么是SYN洪泛攻击？如何防范","url":"/2020/05/15/%E8%AE%A1%E7%AE%97%E6%9C%BA%E7%90%86%E8%AE%BA/%E8%AE%A1%E7%AE%97%E6%9C%BA%E7%BD%91%E7%BB%9C%E5%8E%9F%E7%90%86/%E8%AE%A1%E7%AE%97%E6%9C%BA%E7%BD%91%E7%BB%9C%E5%8E%9F%E7%90%86%E9%9D%A2%E8%AF%95%E9%A2%98/5.20_%E4%BB%80%E4%B9%88%E6%98%AFSYN%E6%B4%AA%E6%B3%9B%E6%94%BB%E5%87%BB%EF%BC%9F%E5%A6%82%E4%BD%95%E9%98%B2%E8%8C%83/","content":"SYN洪泛攻击属于 DOS 攻击的一种，它利用 TCP 协议缺陷，通过发送大量的半连接请求，耗费 CPU 和内存资源。\n原理：\n\n在三次握手过程中，服务器发送 [SYN&#x2F;ACK] 包（第二个包）之后、收到客户端的 [ACK] 包（第三个包）之前的 TCP 连接称为半连接（half-open connect），此时服务器处于 SYN_RECV（等待客户端响应）状态。如果接收到客户端的 [ACK]，则 TCP 连接成功，如果未接受到，则会不断重发请求直至成功。\nSYN 攻击的攻击者在短时间内伪造大量不存在的 IP 地址，向服务器不断地发送 [SYN] 包，服务器回复 [SYN&#x2F;ACK] 包，并等待客户的确认。由于源地址是不存在的，服务器需要不断的重发直至超时。\n这些伪造的 [SYN] 包将长时间占用未连接队列，影响了正常的 SYN，导致目标系统运行缓慢、网络堵塞甚至系统瘫痪。\n\n检测：当在服务器上看到大量的半连接状态时，特别是源 IP 地址是随机的，基本上可以断定这是一次 SYN 攻击。\n防范：\n\n通过加固 TCP&#x2F;IP 协议栈防范，如增加最大半连接数，缩短超时时间。\nSYN cookies技术。SYN Cookies 是对 TCP 服务器端的三次握手做一些修改，专门用来防范 SYN 洪泛攻击的一种手段。\n\n","categories":["计算机理论"],"tags":["计算机网络原理-计算机网络原理面试题"]},{"title":"为什么连接的时候是三次握手，关闭的时候却是四次挥手","url":"/2020/05/15/%E8%AE%A1%E7%AE%97%E6%9C%BA%E7%90%86%E8%AE%BA/%E8%AE%A1%E7%AE%97%E6%9C%BA%E7%BD%91%E7%BB%9C%E5%8E%9F%E7%90%86/%E8%AE%A1%E7%AE%97%E6%9C%BA%E7%BD%91%E7%BB%9C%E5%8E%9F%E7%90%86%E9%9D%A2%E8%AF%95%E9%A2%98/5.22_%E4%B8%BA%E4%BB%80%E4%B9%88%E8%BF%9E%E6%8E%A5%E7%9A%84%E6%97%B6%E5%80%99%E6%98%AF%E4%B8%89%E6%AC%A1%E6%8F%A1%E6%89%8B%EF%BC%8C%E5%85%B3%E9%97%AD%E7%9A%84%E6%97%B6%E5%80%99%E5%8D%B4%E6%98%AF%E5%9B%9B%E6%AC%A1%E6%8C%A5%E6%89%8B/","content":"服务器在收到客户端的 FIN 报文段后，可能还有一些数据要传输，所以不能马上关闭连接，但是会做出应答，返回 ACK 报文段。\n接下来可能会继续发送数据，在数据发送完后，服务器会向客户单发送 FIN 报文，表示数据已经发送完毕，请求关闭连接。服务器的ACK和FIN一般都会分开发送，从而导致多了一次，因此一共需要四次挥手。\n","categories":["计算机理论"],"tags":["计算机网络原理-计算机网络原理面试题"]},{"title":"路由算法与路由协议","url":"/2020/05/15/%E8%AE%A1%E7%AE%97%E6%9C%BA%E7%90%86%E8%AE%BA/%E8%AE%A1%E7%AE%97%E6%9C%BA%E7%BD%91%E7%BB%9C%E5%8E%9F%E7%90%86/%E8%AE%A1%E7%AE%97%E6%9C%BA%E7%BD%91%E7%BB%9C%E5%8E%9F%E7%90%86%E9%9D%A2%E8%AF%95%E9%A2%98/4.6_%E8%B7%AF%E7%94%B1%E7%AE%97%E6%B3%95%E4%B8%8E%E8%B7%AF%E7%94%B1%E5%8D%8F%E8%AE%AE/","content":"路由算法的分类：\n\n静态路由算法（非自适应路由算法）：管理员手工配置路由信息\n动态路由算法（自适应路由算法）：路由期间彼此交换信息，按照路由算法优化出路由表项\n内部网关协议(一个AS内使用的)：RIP（路由器只掌握物理相连的邻居及链路费用）、OSPF（所有路由器掌握完整的网络拓扑和链路费用信息）\n外部网关协议(AS之间使用的)：BGP\n\n\n\n","categories":["计算机理论"],"tags":["计算机网络原理-计算机网络原理面试题"]},{"title":"了解的端口及对应的服务","url":"/2020/05/15/%E8%AE%A1%E7%AE%97%E6%9C%BA%E7%90%86%E8%AE%BA/%E8%AE%A1%E7%AE%97%E6%9C%BA%E7%BD%91%E7%BB%9C%E5%8E%9F%E7%90%86/%E8%AE%A1%E7%AE%97%E6%9C%BA%E7%BD%91%E7%BB%9C%E5%8E%9F%E7%90%86%E9%9D%A2%E8%AF%95%E9%A2%98/5.3_%E4%BA%86%E8%A7%A3%E7%9A%84%E7%AB%AF%E5%8F%A3%E5%8F%8A%E5%AF%B9%E5%BA%94%E7%9A%84%E6%9C%8D%E5%8A%A1/","content":"\n\n\n端口\n服务\n\n\n\n21\nFTP\n\n\n23\nTELNET\n\n\n25\nSMTP\n\n\n53\nDNS\n\n\n69\nTFTP\n\n\n80\nHTTP\n\n\n161\nSNMP\n\n\n443\nHTTPS\n\n\n端口是传输层的SAP，标识主机中的应用进程，端口号只有本地意义，在因特网中不同计算机的相同端口是没有联系的\n端口号长度为16bit，能表示65536个不同的端口号\n在网络中采用发送方和接收方的套接字组合来识别端点，套接字唯一标识了网络中的一个主机和它上面的一个进程\n套接字Socket&#x3D;（主机IP地址，端口号）\n","categories":["计算机理论"],"tags":["计算机网络原理-计算机网络原理面试题"]},{"title":"为什么要三次握手，而不是四次","url":"/2020/05/15/%E8%AE%A1%E7%AE%97%E6%9C%BA%E7%90%86%E8%AE%BA/%E8%AE%A1%E7%AE%97%E6%9C%BA%E7%BD%91%E7%BB%9C%E5%8E%9F%E7%90%86/%E8%AE%A1%E7%AE%97%E6%9C%BA%E7%BD%91%E7%BB%9C%E5%8E%9F%E7%90%86%E9%9D%A2%E8%AF%95%E9%A2%98/5.19_%E4%B8%BA%E4%BB%80%E4%B9%88%E8%A6%81%E4%B8%89%E6%AC%A1%E6%8F%A1%E6%89%8B%EF%BC%8C%E8%80%8C%E4%B8%8D%E6%98%AF%E5%9B%9B%E6%AC%A1/","content":"因为三次握手已经可以确认双方的发送接收能力正常，双方都知道彼此已经准备好，而且也可以完成对双方初始序号值得确认，也就无需再第四次握手了。\n\n第一次握手：服务端确认“自己收、客户端发”报文功能正常。\n第二次握手：客户端确认“自己发、自己收、服务端发、服务端收”报文功能正常，客户端认为连接已建立。\n第三次握手：服务端确认“自己发、自己收、客户端发、客户端收”报文功能正常，此时双方均建立连接，可以正常通信。\n\n","categories":["计算机理论"],"tags":["计算机网络原理-计算机网络原理面试题"]},{"title":"详细介绍一下TCP的四次挥手过程","url":"/2020/05/15/%E8%AE%A1%E7%AE%97%E6%9C%BA%E7%90%86%E8%AE%BA/%E8%AE%A1%E7%AE%97%E6%9C%BA%E7%BD%91%E7%BB%9C%E5%8E%9F%E7%90%86/%E8%AE%A1%E7%AE%97%E6%9C%BA%E7%BD%91%E7%BB%9C%E5%8E%9F%E7%90%86%E9%9D%A2%E8%AF%95%E9%A2%98/5.21_%E8%AF%A6%E7%BB%86%E4%BB%8B%E7%BB%8D%E4%B8%80%E4%B8%8BTCP%E7%9A%84%E5%9B%9B%E6%AC%A1%E6%8C%A5%E6%89%8B%E8%BF%87%E7%A8%8B/","content":"\n第一次挥手：客户端向服务端发送连接释放报文（FIN&#x3D;1），主动关闭连接，同时等待服务端的确认。\n第二次挥手：服务端收到连接释放报文后，立即发出确认报文（ACK&#x3D;1），序列号 seq &#x3D; k，确认号 ack &#x3D; u + 1。\n这时 TCP 连接处于半关闭状态，即客户端到服务端的连接已经释放了，但是服务端到客户端的连接还未释放。这表示客户端已经没有数据发送了，但是服务端可能还要给客户端发送数据。\n第三次挥手：服务端向客户端发送连接释放报文（FIN&#x3D;1，ACK&#x3D;1），主动关闭连接，同时等待 A 的确认。\n\n序列号 seq &#x3D; w，即服务端上次发送的报文的最后一个字节的序号 + 1。\n确认号 ack &#x3D; u + 1，与第二次挥手相同，因为这段时间客户端没有发送数据\n\n第四次挥手：客户端收到服务端的连接释放报文后，立即发出确认报文（ACK&#x3D;1），序列号 seq &#x3D; u + 1，确认号为 ack &#x3D; w + 1。\n此时，客户端就进入了 TIME-WAIT 状态。注意此时客户端到 TCP 连接还没有释放，必须经过 2*MSL（最长报文段寿命）的时间后，才进入 CLOSED 状态。而服务端只要收到客户端发出的确认，就立即进入 CLOSED 状态。可以看到，服务端结束 TCP 连接的时间要比客户端早一些。\n","categories":["计算机理论"],"tags":["计算机网络原理-计算机网络原理面试题"]},{"title":"详细讲一下TCP的滑动窗口","url":"/2020/05/15/%E8%AE%A1%E7%AE%97%E6%9C%BA%E7%90%86%E8%AE%BA/%E8%AE%A1%E7%AE%97%E6%9C%BA%E7%BD%91%E7%BB%9C%E5%8E%9F%E7%90%86/%E8%AE%A1%E7%AE%97%E6%9C%BA%E7%BD%91%E7%BB%9C%E5%8E%9F%E7%90%86%E9%9D%A2%E8%AF%95%E9%A2%98/5.6_%E8%AF%A6%E7%BB%86%E8%AE%B2%E4%B8%80%E4%B8%8BTCP%E7%9A%84%E6%BB%91%E5%8A%A8%E7%AA%97%E5%8F%A3/","content":"在进行数据传输时，如果传输的数据比较大，就需要拆分为多个数据包进行发送。TCP 协议需要对数据进行确认后，才可以发送下一个数据包。这样一来，就会在等待确认应答包环节浪费时间。\n为了避免这种情况，TCP引入了窗口概念。窗口大小指的是不需要等待确认应答包而可以继续发送数据包的最大值。\n\n从上面的图可以看到滑动窗口左边的是已发送并且被确认的分组，滑动窗口右边是还没有轮到的分组。滑动窗口里面也分为两块，一块是已经发送但是未被确认的分组，另一块是窗口内等待发送的分组。随着已发送的分组不断被确认，窗口内等待发送的分组也会不断被发送。整个窗口就会往右移动，让还没轮到的分组进入窗口内。\n可以看到滑动窗口起到了一个限流的作用，也就是说当前滑动窗口的大小决定了当前 TCP 发送包的速率，而滑动窗口的大小取决于拥塞控制窗口和流量控制窗口的两者间的最小值。\n","categories":["计算机理论"],"tags":["计算机网络原理-计算机网络原理面试题"]},{"title":"详细讲一下拥塞控制","url":"/2020/05/15/%E8%AE%A1%E7%AE%97%E6%9C%BA%E7%90%86%E8%AE%BA/%E8%AE%A1%E7%AE%97%E6%9C%BA%E7%BD%91%E7%BB%9C%E5%8E%9F%E7%90%86/%E8%AE%A1%E7%AE%97%E6%9C%BA%E7%BD%91%E7%BB%9C%E5%8E%9F%E7%90%86%E9%9D%A2%E8%AF%95%E9%A2%98/5.7_%E8%AF%A6%E7%BB%86%E8%AE%B2%E4%B8%80%E4%B8%8B%E6%8B%A5%E5%A1%9E%E6%8E%A7%E5%88%B6/","content":"拥塞控制和流量控制不同，前者是一个全局性的过程，而后者指点对点通信量的 控制。在某段时间，若对网络中某资源的需求超过 了该资源所能提供的可用部分，网络的性能就要变坏。这种情况就叫拥塞。\n拥塞控制就是为了防止过多的数据注入到网络中，这样就可以使网络中的路由器或链路不致于过载。拥塞控制所要做的都有一个前提，就是网络能够承受现有的网络负荷。拥塞控制是-一个全局性的过程，涉及到所有的主机，所有的路由器，以及与降低网络传输性能有关的所有因素。相反，流量控制往往是点对点通信量的控制，是个端到端的问题。流量控制所要做到的就是抑制发送端发送数据的速率，以便使接收端来得及接收。\n发送方维持一个叫做拥塞窗口cwnd（congestion window）的状态变量。\nTCP 一共使用了四种算法来实现拥塞控制：\n\n慢开始 (slow-start)；\n拥塞避免 (congestion avoidance)；\n快速重传 (fast retransmit)；\n快速恢复 (fast recovery)。\n\n慢开始：不要一开始就发送大量的数据，由小到大逐渐增加拥塞窗口的大小。\n拥塞避免：拥塞避免算法让拥塞窗口缓慢增长，即每经过一个往返时间RTT就把发送方的拥塞窗口cwnd加1而不是加倍。这样拥塞窗口按线性规律缓慢增长。\n快重传：我们可以剔除一些不必要的拥塞报文，提高网络吞吐量。比如接收方在收到一个失序的报文段后就立即发出重复确认，而不要等到自己发送数据时捎带确认。快重传规定：发送方只要一连收到三个重复确认就应当立即重传对方尚未收到的报文段，而不必继续等待设置的重传计时器时间到期。\n\n快恢复：主要是配合快重传。当发送方连续收到三个重复确认时，就执行“乘法减小”算法，把ssthresh门限减半（为了预防网络发生拥塞），但接下来并不执行慢开始算法，因为如果网络出现拥塞的话就不会收到好几个重复的确认，收到三个重复确认说明网络状况还可以。\n\n","categories":["计算机理论"],"tags":["计算机网络原理-计算机网络原理面试题"]},{"title":"TCP协议如何保证可靠性","url":"/2020/05/15/%E8%AE%A1%E7%AE%97%E6%9C%BA%E7%90%86%E8%AE%BA/%E8%AE%A1%E7%AE%97%E6%9C%BA%E7%BD%91%E7%BB%9C%E5%8E%9F%E7%90%86/%E8%AE%A1%E7%AE%97%E6%9C%BA%E7%BD%91%E7%BB%9C%E5%8E%9F%E7%90%86%E9%9D%A2%E8%AF%95%E9%A2%98/5.4_TCP%E5%8D%8F%E8%AE%AE%E5%A6%82%E4%BD%95%E4%BF%9D%E8%AF%81%E5%8F%AF%E9%9D%A0%E6%80%A7/","content":"TCP主要提供了检验和、序列号&#x2F;确认应答、超时重传、滑动窗口、拥塞控制和 流量控制等方法实现了可靠性传输。\n\n检验和：通过检验和的方式，接收端可以检测出来数据是否有差错和异常，假如有差错就会直接丢弃TCP段，重新发送。\n\n序列号&#x2F;确认应答：\n序列号的作用不仅仅是应答的作用，有了序列号能够将接收到的数据根据序列号排序，并且去掉重复序列号的数据。\nTCP传输的过程中，每次接收方收到数据后，都会对传输方进行确认应答。也就是发送ACK报文，这个ACK报文当中带有对应的确认序列号，告诉发送方，接收到了哪些数据，下一次的数据从哪里发。\n\n超时重传：超时重传是指发送出去的数据包到接收到确认包之间的时间，如果超过了这个时间会被认为是丢包了，需要重传。最大超时时间是动态计算的。\n\n滑动窗口：滑动窗口既提高了报文传输的效率，也避免了发送方发送过多的数据而导致接收方无法正常处理的异常。\n\n流量控制：如果主机A 一直向主机B发送数据，不考虑主机B的接受能力，则可能导致主机B的接受缓冲区满了而无法再接受数据，从而会导致大量的数据丢包，引发重传机制。而在重传的过程中，若主机B的接收缓冲区情况仍未好转，则会将大量的时间浪费在重传数据上，降低传送数据的效率。所以引入流量控制机制，主机B通过告诉主机A自己接收缓冲区的大小，来使主机A控制发送的数据量。流量控制与TCP协议报头中的窗口大小有关。\n\n拥塞控制：在数据传输过程中，可能由于网络状态的问题，造成网络拥堵，此时引入拥塞控制机制，在保证TCP可靠性的同时，提高性能。\n\n\n","categories":["计算机理论"],"tags":["计算机网络原理-计算机网络原理面试题"]},{"title":"TCP粘包是怎么产生的","url":"/2020/05/15/%E8%AE%A1%E7%AE%97%E6%9C%BA%E7%90%86%E8%AE%BA/%E8%AE%A1%E7%AE%97%E6%9C%BA%E7%BD%91%E7%BB%9C%E5%8E%9F%E7%90%86/%E8%AE%A1%E7%AE%97%E6%9C%BA%E7%BD%91%E7%BB%9C%E5%8E%9F%E7%90%86%E9%9D%A2%E8%AF%95%E9%A2%98/5.9_TCP%E7%B2%98%E5%8C%85%E6%98%AF%E6%80%8E%E4%B9%88%E4%BA%A7%E7%94%9F%E7%9A%84/","content":"发送方产生粘包：\n\n采用TCP协议传输数据的客户端与服务器经常是保持一个 长连接的状态(一次连接发一次数据不存在粘包)，双方在连接不断开的情况下，可以一直传输数据。 但当发送的数据包过于的小时，那么TCP协议默认的会启用Nagle 算法，将这 些较小的数据包进行合并发送（缓冲区数据发送是一个堆压的过程），这个合并过程就是在发送缓冲区中进行的，也就是说数据发送出来它已经是粘包的状态了。\n\n接收方产生粘包：\n\n接收方采用TCP协议接收数据时的过程是这样的：数据到接收方，从网络模型 的下方传递至传输层，传输层的TCP 协议处理是将其放置接收缓冲区一然后由 应用层来主动获取，这时会出现一个问题，就是我们在程序中调用的读取数据函数不能及时的把缓冲区中的数据拿出来，而下一个数据又到来并有一部分放入的缓冲区末尾，等我们读取数据时就是一个粘包(放数据的速度&gt;应用层拿数据速度)\n\nUDP没有粘包问题，但是有丢包和乱序，不完整的包是不会有的，收到的都是完全正确的包，传送的数据单位是报文，发送的时候既不合并，也不拆分\n","categories":["计算机理论"],"tags":["计算机网络原理-计算机网络原理面试题"]},{"title":"HTTP常见的状态码有哪些","url":"/2020/05/15/%E8%AE%A1%E7%AE%97%E6%9C%BA%E7%90%86%E8%AE%BA/%E8%AE%A1%E7%AE%97%E6%9C%BA%E7%BD%91%E7%BB%9C%E5%8E%9F%E7%90%86/%E8%AE%A1%E7%AE%97%E6%9C%BA%E7%BD%91%E7%BB%9C%E5%8E%9F%E7%90%86%E9%9D%A2%E8%AF%95%E9%A2%98/6.10_HTTP%E5%B8%B8%E8%A7%81%E7%9A%84%E7%8A%B6%E6%80%81%E7%A0%81%E6%9C%89%E5%93%AA%E4%BA%9B/","content":"常见状态码：\n\n100：表明到目前为止都很正常，客户端可以继续发送请求或者忽略这个响应\n\n200：服务器已成功处理了请求。 通常，这表示服务器提供了请求的网页。\n\n301 ： (永久移动) 请求的网页已永久移动到新位置。 服务器返回此响应(对 GET 或 HEAD 请求的响应)时，会自动将请求者转到新位置。\n\n302：(临时移动) 服务器目前从不同位置的网页响应请求，但请求者应继续使用原有位置来进行以后的请求。\n\n400 ：客户端请求有语法错误，不能被服务器所理解。\n\n403 ：服务器收到请求，但是拒绝提供服务。\n\n404 ：(未找到) 服务器找不到请求的网页。\n\n500： (服务器内部错误) 服务器遇到错误，无法完成请求。\n\n\n状态码开头代表的类型：\n\n\n\n\n类别\n原因短语\n\n\n\n1XX\n信息性状态码\n接收的请求正在处理\n\n\n2XX\n成功状态码\n请求正常处理完毕\n\n\n3XX\n重定向状态码\n需要进行附加操作以完成请求\n\n\n4XX\n客户端错误状态码\n服务器无法处理请求\n\n\n5XX\n服务器错误状态码\n服务器处理请求出错\n\n\n状态码301和302的区别是什么？\n\n共同点：301和302状态码都表示重定向，就是说浏览器在拿到服务器返回的这个状态码后会自动跳转到一个新的URL地址，这个地址可以从响应的Location首部中获取（用户看到的效果就是他输入的地址A瞬间变成了另一个地址B）。 \n\n不同点：301表示旧地址A的资源已经被永久地移除了(这个资源不可访问了)，搜索引擎在抓取新内容的同时也将旧的网址交换为重定向之后的网址；302表示旧地址A的资源还在（仍然可以访问），这个重定向只是临时地从旧地址A跳转到地址B，搜索引擎会抓取新的内容而保存旧的网址。 SEO中302好于301。\n\n重定向原因：网站调整（如改变网页目录结构）、网页被移到一个新地址、网页扩展名改变(如应用需要把.php改成.Html或.shtml)。\n\n\n","categories":["计算机理论"],"tags":["计算机网络原理-计算机网络原理面试题"]},{"title":"TCP和UDP对应的应用层协议","url":"/2020/05/15/%E8%AE%A1%E7%AE%97%E6%9C%BA%E7%90%86%E8%AE%BA/%E8%AE%A1%E7%AE%97%E6%9C%BA%E7%BD%91%E7%BB%9C%E5%8E%9F%E7%90%86/%E8%AE%A1%E7%AE%97%E6%9C%BA%E7%BD%91%E7%BB%9C%E5%8E%9F%E7%90%86%E9%9D%A2%E8%AF%95%E9%A2%98/5.2_TCP%E5%92%8CUDP%E5%AF%B9%E5%BA%94%E7%9A%84%E5%BA%94%E7%94%A8%E5%B1%82%E5%8D%8F%E8%AE%AE/","content":"TCP 是面向连接，能保证数据的可靠性交付，因此经常用于：\n\nFTP文件传输\nHTTP &#x2F; HTTPS\n\nUDP 面向无连接，它可以随时发送数据，再加上UDP本身的处理既简单又高效，因此经常用于：\n\n包总量较少的通信，如 DNS 、SNMP等\n视频、音频等多媒体通信\n广播通信\n\n\n\n\n应用层协议\n应用\n传输层协议\n\n\n\nSMTP\n电子邮件\nTCP\n\n\nTELNET\n远程登录\nTCP\n\n\nHTTP\n万维网\nTCP\n\n\nFTP\n文件传输\nTCP\n\n\nDNS\n域名转换\nUDP\n\n\nTFTP\n文件传输\nUDP\n\n\nSNMP\n网络管理\nUDP\n\n\nNFS\n远程文件服务器\nUDP\n\n\n","categories":["计算机理论"],"tags":["计算机网络原理-计算机网络原理面试题"]},{"title":"HTTP1.1和HTTP2.0的区别","url":"/2020/05/15/%E8%AE%A1%E7%AE%97%E6%9C%BA%E7%90%86%E8%AE%BA/%E8%AE%A1%E7%AE%97%E6%9C%BA%E7%BD%91%E7%BB%9C%E5%8E%9F%E7%90%86/%E8%AE%A1%E7%AE%97%E6%9C%BA%E7%BD%91%E7%BB%9C%E5%8E%9F%E7%90%86%E9%9D%A2%E8%AF%95%E9%A2%98/6.12_HTTP1.1%E5%92%8CHTTP2.0%E7%9A%84%E5%8C%BA%E5%88%AB/","content":"HTTP2.0相比HTTP1.1支持的特性：\n\n新的二进制格式：HTTP1.1的解析是基于文本。基于文本协议的格式解析存在天然缺陷，文本的表现形式有多样性，要做到健壮性考虑的场景必然很多，二进制则不同，只认0和1的组合。基于这种考虑HTTP2.0的协议解析决定采用二进制格式，实现方便且健壮。\n\n多路复用，即连接共享，即每一个request都是用作连接共享机制的。一个request对应一个id，这样一个连接上可以有多个request，每个连接的request可以随机的混杂在一起，接收方可以根据request的 id将request再归属到各自不同的服务端请求里面。\n\n头部压缩，HTTP1.1的头部（header）带有大量信息，而且每次都要重复发送；HTTP2.0使用encoder来减少需要传输的header大小，通讯双方各自cache一份header fields表，既避免了重复header的传输，又减小了需要传输的大小。\n\n服务端推送：服务器除了对最初请求的响应外，服务器还可以额外的向客户端推送资源，而无需客户端明确的请求。\n\n\n","categories":["计算机理论"],"tags":["计算机网络原理-计算机网络原理面试题"]},{"title":"HTTPS的优缺点","url":"/2020/05/15/%E8%AE%A1%E7%AE%97%E6%9C%BA%E7%90%86%E8%AE%BA/%E8%AE%A1%E7%AE%97%E6%9C%BA%E7%BD%91%E7%BB%9C%E5%8E%9F%E7%90%86/%E8%AE%A1%E7%AE%97%E6%9C%BA%E7%BD%91%E7%BB%9C%E5%8E%9F%E7%90%86%E9%9D%A2%E8%AF%95%E9%A2%98/6.15_HTTPS%E7%9A%84%E4%BC%98%E7%BC%BA%E7%82%B9/","content":"优点：\n安全性：\n\n使用HTTPS协议可认证用户和服务器，确保数据发送到正确的客户机和服务器；\n\nHTTPS协议是由SSL+HTTP协议构建的可进行加密传输、身份认证的网络协议，要比http协议安全，可防止数据在传输过程中不被窃取、改变，确保数据的完整性。\n\nHTTPS是现行架构下最安全的解决方案，虽然不是绝对安全，但它大幅增加了中间人攻击的成本。\n\n\nSEO方面：谷歌曾在2014年8月份调整搜索引擎算法，并称“比起同等HTTP网站，采用HTTPS加密的网站在搜索结果中的排名将会更高”。\n缺点：\n\n在相同网络环境中，HTTPS 相比 HTTP 无论是响应时间还是耗电量都有大幅度上升。\nHTTPS 的安全是有范围的，在黑客攻击、服务器劫持等情况下几乎起不到作用。\n在现有的证书机制下，中间人攻击依然有可能发生。\nHTTPS 需要更多的服务器资源，也会导致成本的升高。\n\n","categories":["计算机理论"],"tags":["计算机网络原理-计算机网络原理面试题"]},{"title":"讲一讲HTTPS的原理","url":"/2020/05/15/%E8%AE%A1%E7%AE%97%E6%9C%BA%E7%90%86%E8%AE%BA/%E8%AE%A1%E7%AE%97%E6%9C%BA%E7%BD%91%E7%BB%9C%E5%8E%9F%E7%90%86/%E8%AE%A1%E7%AE%97%E6%9C%BA%E7%BD%91%E7%BB%9C%E5%8E%9F%E7%90%86%E9%9D%A2%E8%AF%95%E9%A2%98/6.14_%E8%AE%B2%E4%B8%80%E8%AE%B2HTTPS%E7%9A%84%E5%8E%9F%E7%90%86/","content":"\n客户端请求 HTTPS 网址，然后连接到 server 的 443 端口 (HTTPS 默认端口，类似于 HTTP 的80端口)。\n\n采用 HTTPS 协议的服务器必须要有一套数字 CA (Certification Authority)证书。颁发证书的同时会产生一个私钥和公钥。私钥由服务端自己保存，不可泄漏。公钥则是附带在证书的信息中，可以公开的。证书本身也附带一个证书电子签名，这个签名用来验证证书的完整性和真实性，可以防止证书被篡改。\n\n服务器响应客户端请求，将证书传递给客户端，证书包含公钥和大量其他信息，比如证书颁发机构信息，公司信息和证书有效期等。\n\n客户端解析证书并对其进行验证。如果证书不是可信机构颁布，或者证书中的域名与实际域名不一致，或者证书已经过期，就会向访问者显示一个警告，由其选择是否还要继续通信。\n\n如果证书没有问题，客户端就会从服务器证书中取出服务器的公钥A。然后客户端还会生成一个随机码 KEY，并使用公钥A将其加密。\n\n客户端把加密后的随机码 KEY 发送给服务器，作为后面对称加密的密钥。\n\n服务器在收到随机码 KEY 之后会使用私钥B将其解密。经过以上这些步骤，客户端和服务器终于建立了安全连接，完美解决了对称加密的密钥泄露问题，接下来就可以用对称加密愉快地进行通信了。\n\n服务器使用密钥 (随机码 KEY)对数据进行对称加密并发送给客户端，客户端使用相同的密钥 (随机码 KEY)解密数据。\n\n双方使用对称加密愉快地传输所有数据。\n\n\n","categories":["计算机理论"],"tags":["计算机网络原理-计算机网络原理面试题"]},{"title":"谈谈你对停止等待协议和ARQ协议的理解","url":"/2020/05/15/%E8%AE%A1%E7%AE%97%E6%9C%BA%E7%90%86%E8%AE%BA/%E8%AE%A1%E7%AE%97%E6%9C%BA%E7%BD%91%E7%BB%9C%E5%8E%9F%E7%90%86/%E8%AE%A1%E7%AE%97%E6%9C%BA%E7%BD%91%E7%BB%9C%E5%8E%9F%E7%90%86%E9%9D%A2%E8%AF%95%E9%A2%98/5.5_%E8%B0%88%E8%B0%88%E4%BD%A0%E5%AF%B9%E5%81%9C%E6%AD%A2%E7%AD%89%E5%BE%85%E5%8D%8F%E8%AE%AE%E5%92%8CARQ%E5%8D%8F%E8%AE%AE%E7%9A%84%E7%90%86%E8%A7%A3/","content":"停止等待协议是为了实现可靠传输的，它的基本原理就是每发完一个分组就停止发送，等待对方确认，在收到确认后再发下一个分组，在停止等待协议中，若接收方收到重复分组，就丢弃该分组，但同时还要发送确认\nARQ协议：\n\n自动重传请求ARQ协议：停止等待协议中超时重传是指只要超过一段时间仍然没有收到确认，就重传前面 发送过的分组(认为刚才发送过的分组丢失了)。因此每发送完一 个分组需要设置一个超时计时器,其重传时间应比数据在分组传输的平均往返时间更长一一些。这种自动重传方式常称为自动重传请求ARQ。\n连续ARQ协议：连续ARQ协议可提高信道利用率。发送方维持一个发送窗口，凡位于发送窗口内的分组可以连续发送出去，而不需要等待对方确认。接收方一般采用累计确认，对按序到达的最后一个分组发送确认，表明到这个分组为止的所有分组都已经正确收到了。\n\n","categories":["计算机理论"],"tags":["计算机网络原理-计算机网络原理面试题"]},{"title":"负载均衡算法有哪些","url":"/2020/05/15/%E8%AE%A1%E7%AE%97%E6%9C%BA%E7%90%86%E8%AE%BA/%E8%AE%A1%E7%AE%97%E6%9C%BA%E7%BD%91%E7%BB%9C%E5%8E%9F%E7%90%86/%E8%AE%A1%E7%AE%97%E6%9C%BA%E7%BD%91%E7%BB%9C%E5%8E%9F%E7%90%86%E9%9D%A2%E8%AF%95%E9%A2%98/6.17_%E8%B4%9F%E8%BD%BD%E5%9D%87%E8%A1%A1%E7%AE%97%E6%B3%95%E6%9C%89%E5%93%AA%E4%BA%9B/","content":"多台服务器以对称的方式组成一个服务器集合，每台服务器都具有等价的地位，能互相分担负载。\n\n轮询法：将请求按照顺序轮流的分配到服务器上。大锅饭，不能发挥某些高性能服务器的优势。\n随机法：随机获取一台，和轮询类似。\n哈希法：通过ip地址哈希化来确定要选择的服务器编号。好处是,每次客户端访问的服务器都是同一个服务器，能很好地利用session或者cookie。\n加权轮询：根据服务器性能不同加权。\n\n","categories":["计算机理论"],"tags":["计算机网络原理-计算机网络原理面试题"]},{"title":"forward和redirect的区别","url":"/2020/05/15/%E8%AE%A1%E7%AE%97%E6%9C%BA%E7%90%86%E8%AE%BA/%E8%AE%A1%E7%AE%97%E6%9C%BA%E7%BD%91%E7%BB%9C%E5%8E%9F%E7%90%86/%E8%AE%A1%E7%AE%97%E6%9C%BA%E7%BD%91%E7%BB%9C%E5%8E%9F%E7%90%86%E9%9D%A2%E8%AF%95%E9%A2%98/6.18_forward%E5%92%8Credirect%E7%9A%84%E5%8C%BA%E5%88%AB/","content":"Forward和Redirect代表了两种请求转发方式：直接转发和间接转发。 \n\n直接转发方式(Forward)：客户端和浏览器只发出一次请求，由第二个信息资源响应该请求，在请求对象request 中，保存的对象对于每个信息资源是共享的。\n\n间接转发方式(Redirect)：实际是两次HTTP 请求，服务器端在响应第一次请求的时候，让浏览器再向另外一个URL 发出请求，从而达到转发的目的。\n\n\n举个通俗的例子：\n直接转发就相当于：“A找B借钱，B说没有，B去找C借，借到借不到都会把消息传递给A” \n间接转发就相当于：“A找B借钱，B说没有，让A去找C借”\n","categories":["计算机理论"],"tags":["计算机网络原理-计算机网络原理面试题"]},{"title":"什么是Cookie和Session","url":"/2020/05/15/%E8%AE%A1%E7%AE%97%E6%9C%BA%E7%90%86%E8%AE%BA/%E8%AE%A1%E7%AE%97%E6%9C%BA%E7%BD%91%E7%BB%9C%E5%8E%9F%E7%90%86/%E8%AE%A1%E7%AE%97%E6%9C%BA%E7%BD%91%E7%BB%9C%E5%8E%9F%E7%90%86%E9%9D%A2%E8%AF%95%E9%A2%98/6.19_%E4%BB%80%E4%B9%88%E6%98%AFCookie%E5%92%8CSession/","content":"HTTP Cookie（也叫 Web Cookie或浏览器 Cookie）是服务器发送到用户浏览器并保存在本地的一小块数据，它会在浏览器下次向同一服务器再发起请求时被携带并发送到服务器上。通常，它用于告知服务端两个请求是否来自同一浏览器，如保持用户的登录状态。Cookie 使基于无状态的 HTTP 协议记录稳定的状态信息成为了可能。\nCookie 主要用于以下三个方面：\n\n会话状态管理（如用户登录状态、购物车、游戏分数或其它需要记录的信息）\n个性化设置（如用户自定义设置、主题等）\n浏览器行为跟踪（如跟踪分析用户行为等）\n\nSession 代表着服务器和客户端一次会话的过程。Session 对象存储特定用户会话所需的属性及配置信息。这样，当用户在应用程序的 Web 页之间跳转时，存储在 Session 对象中的变量将不会丢失，而是在整个用户会话中一直存在下去。当客户端关闭会话，或者 Session 超时失效时会话结束。\n","categories":["计算机理论"],"tags":["计算机网络原理-计算机网络原理面试题"]},{"title":"URL和URI的区别","url":"/2020/05/15/%E8%AE%A1%E7%AE%97%E6%9C%BA%E7%90%86%E8%AE%BA/%E8%AE%A1%E7%AE%97%E6%9C%BA%E7%BD%91%E7%BB%9C%E5%8E%9F%E7%90%86/%E8%AE%A1%E7%AE%97%E6%9C%BA%E7%BD%91%E7%BB%9C%E5%8E%9F%E7%90%86%E9%9D%A2%E8%AF%95%E9%A2%98/6.1_URL%E5%92%8CURI%E7%9A%84%E5%8C%BA%E5%88%AB/","content":"URI：统一资源标识符\nURL：统一资源定位符\nURI用字符串标识某一互联网资源，而URL表示资源的位置，URL是URI的子集\n","categories":["计算机理论"],"tags":["计算机网络原理-计算机网络原理面试题"]},{"title":"Cookie和Session的区别","url":"/2020/05/15/%E8%AE%A1%E7%AE%97%E6%9C%BA%E7%90%86%E8%AE%BA/%E8%AE%A1%E7%AE%97%E6%9C%BA%E7%BD%91%E7%BB%9C%E5%8E%9F%E7%90%86/%E8%AE%A1%E7%AE%97%E6%9C%BA%E7%BD%91%E7%BB%9C%E5%8E%9F%E7%90%86%E9%9D%A2%E8%AF%95%E9%A2%98/6.20_Cookie%E5%92%8CSession%E7%9A%84%E5%8C%BA%E5%88%AB/","content":"\n作用范围不同，Cookie 保存在客户端（浏览器），Session 保存在服务器端。\n存取方式的不同，Cookie 只能保存 ASCII，Session 可以存任意数据类型，一般情况下我们可以在 Session 中保持一些常用变量信息，比如说 UserId 等。\n有效期不同，Cookie 可设置为长时间保持，比如我们经常使用的默认登录功能，Session 一般失效时间较短，客户端关闭或者 Session 超时都会失效。\n隐私策略不同，Cookie 存储在客户端，比较容易遭到不法获取，早期有人将用户的登录名和密码存储在 Cookie 中导致信息被窃取；Session 存储在服务端，安全性相对 Cookie 要好一些。\n存储大小不同， 单个 Cookie 保存的数据不能超过 4K，Session 可存储数据远高于 Cookie。\n\n","categories":["计算机理论"],"tags":["计算机网络原理-计算机网络原理面试题"]},{"title":"什么是粘包","url":"/2020/05/15/%E8%AE%A1%E7%AE%97%E6%9C%BA%E7%90%86%E8%AE%BA/%E8%AE%A1%E7%AE%97%E6%9C%BA%E7%BD%91%E7%BB%9C%E5%8E%9F%E7%90%86/%E8%AE%A1%E7%AE%97%E6%9C%BA%E7%BD%91%E7%BB%9C%E5%8E%9F%E7%90%86%E9%9D%A2%E8%AF%95%E9%A2%98/5.8_%E4%BB%80%E4%B9%88%E6%98%AF%E7%B2%98%E5%8C%85/","content":"如果客户端连续不断的向服务端发送数据包时，服务端接收的数据会出现两个数据包粘在一起的情况。\n\nTCP是基于字节流的，虽然应用层和TCP传输层之间的数据交互是大小不等的数据块，但是TCP把这些数据块仅仅看成一连串无结构的字节流，没有边界;\n从TCP的帧结构也可以看出，在TCP的首部没有表示数据长度的字段。\n\n基于上面两点，在使用TCP传输数据时，才有粘包或者拆包现象发生的可能。一个数据包中包含了发送端发送的两个数据包的信息，这种现象即为粘包。\n接收端收到了两个数据包，但是这两个数据包要么是不完整的，要么就是多出来一块，这种情况即发生了拆包和粘包。拆包和粘包的问题导致接收端在处理的时候会非常困难，因为无法区分一个完整的数据包。\n","categories":["计算机理论"],"tags":["计算机网络原理-计算机网络原理面试题"]},{"title":"如何考虑分布式Session问题","url":"/2020/05/15/%E8%AE%A1%E7%AE%97%E6%9C%BA%E7%90%86%E8%AE%BA/%E8%AE%A1%E7%AE%97%E6%9C%BA%E7%BD%91%E7%BB%9C%E5%8E%9F%E7%90%86/%E8%AE%A1%E7%AE%97%E6%9C%BA%E7%BD%91%E7%BB%9C%E5%8E%9F%E7%90%86%E9%9D%A2%E8%AF%95%E9%A2%98/6.22_%E5%A6%82%E4%BD%95%E8%80%83%E8%99%91%E5%88%86%E5%B8%83%E5%BC%8FSession%E9%97%AE%E9%A2%98/","content":"在互联网公司为了可以支撑更大的流量，后端往往需要多台服务器共同来支撑前端用户请求，那如果用户在 A 服务器登录了，第二次请求跑到服务 B 就会出现登录失效问题。\n分布式 Session 一般会有以下几种解决方案：\n\n客户端存储：直接将信息存储在cookie中，cookie是存储在客户端上的一小段数据，客户端通过http协议和服务器进行cookie交互，通常用来存储一些不敏感信息\n\nNginx ip_hash 策略：服务端使用 Nginx 代理，每个请求按访问 IP 的 hash 分配，这样来自同一 IP 固定访问一个后台服务器，避免了在服务器 A 创建 Session，第二次分发到服务器 B 的现象。\n\nSession 复制：任何一个服务器上的 Session 发生改变（增删改），该节点会把这个 Session 的所有内容序列化，然后广播给所有其它节点。\n\n共享 Session：服务端无状态话，将用户的 Session 等信息使用缓存中间件（如Redis）来统一管理，保障分发到每一个服务器的响应结果都一致。\n\n\n建议采用共享 Session的方案。\n","categories":["计算机理论"],"tags":["计算机网络原理-计算机网络原理面试题"]},{"title":"SQL注入是什么，如何避免SQL注入","url":"/2020/05/15/%E8%AE%A1%E7%AE%97%E6%9C%BA%E7%90%86%E8%AE%BA/%E8%AE%A1%E7%AE%97%E6%9C%BA%E7%BD%91%E7%BB%9C%E5%8E%9F%E7%90%86/%E8%AE%A1%E7%AE%97%E6%9C%BA%E7%BD%91%E7%BB%9C%E5%8E%9F%E7%90%86%E9%9D%A2%E8%AF%95%E9%A2%98/6.23_SQL%E6%B3%A8%E5%85%A5%E6%98%AF%E4%BB%80%E4%B9%88%EF%BC%8C%E5%A6%82%E4%BD%95%E9%81%BF%E5%85%8DSQL%E6%B3%A8%E5%85%A5/","content":"SQL 注入就是在用户输入的字符串中加入 SQL 语句，如果在设计不良的程序中忽略了检查，那么这些注入进去的 SQL 语句就会被数据库服务器误认为是正常的 SQL 语句而运行，攻击者就可以执行计划外的命令或访问未被授权的数据。\nSQL注入的原理主要有以下 4 点：\n\n恶意拼接查询\n利用注释执行非法命令\n传入非法参数\n添加额外条件\n\n避免SQL注入的一些方法：\n\n限制数据库权限，给用户提供仅仅能够满足其工作的最低权限。\n对进入数据库的特殊字符转义处理。\n提供参数化查询接口，不要直接使用原生SQL。\n\n","categories":["计算机理论"],"tags":["计算机网络原理-计算机网络原理面试题"]},{"title":"什么是XSS攻击","url":"/2020/05/15/%E8%AE%A1%E7%AE%97%E6%9C%BA%E7%90%86%E8%AE%BA/%E8%AE%A1%E7%AE%97%E6%9C%BA%E7%BD%91%E7%BB%9C%E5%8E%9F%E7%90%86/%E8%AE%A1%E7%AE%97%E6%9C%BA%E7%BD%91%E7%BB%9C%E5%8E%9F%E7%90%86%E9%9D%A2%E8%AF%95%E9%A2%98/6.24_%E4%BB%80%E4%B9%88%E6%98%AFXSS%E6%94%BB%E5%87%BB/","content":"XSS也称 cross-site scripting，跨站脚本。这种攻击是由于服务器将攻击者存储的数据原原本本地显示给其他用户所致的。比如一个存在XSS漏洞的论坛，用户发帖时就可以引入带有＜script＞标签的代码，导致恶意代码的执行。\n预防措施有：\n\n前端：过滤。\n后端：转义，比如go自带的处理器就具有转义功能。\n\n","categories":["计算机理论"],"tags":["计算机网络原理-计算机网络原理面试题"]},{"title":"什么是DDos攻击","url":"/2020/05/15/%E8%AE%A1%E7%AE%97%E6%9C%BA%E7%90%86%E8%AE%BA/%E8%AE%A1%E7%AE%97%E6%9C%BA%E7%BD%91%E7%BB%9C%E5%8E%9F%E7%90%86/%E8%AE%A1%E7%AE%97%E6%9C%BA%E7%BD%91%E7%BB%9C%E5%8E%9F%E7%90%86%E9%9D%A2%E8%AF%95%E9%A2%98/6.25_%E4%BB%80%E4%B9%88%E6%98%AFDDos%E6%94%BB%E5%87%BB/","content":"DDos全称Distributed Denial of Service，分布式拒绝服务攻击。最基本的DOS攻击过程如下：\n\n客户端向服务端发送请求链接数据包。\n服务端向客户端发送确认数据包。\n客户端不向服务端发送确认数据包，服务器一直等待来自客户端的确认\n\nDDoS则是采用分布式的方法，通过在网络上占领多台“肉鸡”，用多台计算机发起攻击。\nDOS攻击现在基本没啥作用了，因为服务器的性能都很好，而且是多台服务器共同作用，1V1的模式黑客无法占上风。对于DDOS攻击，预防方法有：\n\n减少SYN timeout时间。在握手的第三步，服务器会等待30秒-120秒的时间，减少这个等待时间就能释放更多的资源。\n限制同时打开的SYN半连接数目。\n\n","categories":["计算机理论"],"tags":["计算机网络原理-计算机网络原理面试题"]},{"title":"HTTP1.0和HTTP1.1的区别","url":"/2020/05/15/%E8%AE%A1%E7%AE%97%E6%9C%BA%E7%90%86%E8%AE%BA/%E8%AE%A1%E7%AE%97%E6%9C%BA%E7%BD%91%E7%BB%9C%E5%8E%9F%E7%90%86/%E8%AE%A1%E7%AE%97%E6%9C%BA%E7%BD%91%E7%BB%9C%E5%8E%9F%E7%90%86%E9%9D%A2%E8%AF%95%E9%A2%98/6.11_HTTP1.0%E5%92%8CHTTP1.1%E7%9A%84%E5%8C%BA%E5%88%AB/","content":"\n长连接：HTTP 1.1支持长连接（Persistent Connection）和请求的流水线（Pipelining）处理，在一个TCP连接上可以传送多个HTTP请求和响应，减少了建立和关闭连接的消耗和延迟，在HTTP1.1中默认开启Connection： keep-alive，一定程度上弥补了HTTP1.0每次请求都要创建连接的缺点。\n\n缓存处理：在HTTP1.0中主要使用header里的If-Modified-Since,Expires来做为缓存判断的标准，HTTP1.1则引入了更多的缓存控制策略，可供选择的缓存头来控制缓存策略。\n\n带宽优化及网络连接的使用：HTTP1.0中，存在一些浪费带宽的现象，例如客户端只是需要某个对象的一部分，而服务器却将整个对象送过来了，并且不支持断点续传功能，HTTP1.1则在请求头引入了range头域，它允许只请求资源的某个部分，即返回码是206（Partial Content），这样就方便了开发者自由的选择以便于充分利用带宽和连接。\n\n错误通知的管理：在HTTP1.1中新增了24个错误状态响应码，如409（Conflict）表示请求的资源与资源的当前状态发生冲突；410（Gone）表示服务器上的某个资源被永久性的删除。\n\nHost头处理：在HTTP1.0中认为每台服务器都绑定一个唯一的IP地址，因此，请求消息中的URL并没有传递主机名（hostname）。但随着虚拟主机技术的发展，在一台物理服务器上可以存在多个虚拟主机（Multi-homed Web Servers），并且它们共享一个IP地址。HTTP1.1的请求消息和响应消息都应支持Host头域，且请求消息中如果没有Host头域会报告一个错误（400 Bad Request）。\n\n\n","categories":["计算机理论"],"tags":["计算机网络原理-计算机网络原理面试题"]},{"title":"DNS的解析过程","url":"/2020/05/15/%E8%AE%A1%E7%AE%97%E6%9C%BA%E7%90%86%E8%AE%BA/%E8%AE%A1%E7%AE%97%E6%9C%BA%E7%BD%91%E7%BB%9C%E5%8E%9F%E7%90%86/%E8%AE%A1%E7%AE%97%E6%9C%BA%E7%BD%91%E7%BB%9C%E5%8E%9F%E7%90%86%E9%9D%A2%E8%AF%95%E9%A2%98/6.2_DNS%E7%9A%84%E8%A7%A3%E6%9E%90%E8%BF%87%E7%A8%8B/","content":"\n主机向本地域名服务器的查询一般都是采用递归查询，所谓递归查询就是：如果主机所询问的本地域名服务器不知道被查询的域名的IP地址，那么本地域名服务器就以DNS 客户的身份，向根城名服务器继续发出查询请求报文(即替主机继续查询)，而不是让主机自己进行下一步查询。 因此，递归查询返回的查询 结果或者是所要查询的IP 地址.或者是报错，表示无法查询到所需的IP地址。\n\n本地域名服务器向根域名服务器的查询是迭代查询。迭代查询的特点:当根域名服务器收到本地域名服务器发出的迭代查询请求报文时，要么给出所要查询 的IP地址，要么告诉本地服务器: “你下一 步应当向哪一个域名服务器进行查询”。然后让本地服务器进行后续的查询。根域名服务器通常是把自已知道的顶级域名服务器的IP地址告诉本地域名服务器，让本地域名服务器再向顶级域名服务器查询。顶级域名服务器在收到本地城名服务器的查询请求后，要么给出所要查询的IP地址，要么告诉本地服务器下一步应当向哪个权限域名服务器进行在询。最后，本地域名服务器得到了所要解析的IP地址或报错，然后把这个结果返回给发起查询的主机。\n\n\n","categories":["计算机理论"],"tags":["计算机网络原理-计算机网络原理面试题"]},{"title":"谈谈你对域名缓存的了解","url":"/2020/05/15/%E8%AE%A1%E7%AE%97%E6%9C%BA%E7%90%86%E8%AE%BA/%E8%AE%A1%E7%AE%97%E6%9C%BA%E7%BD%91%E7%BB%9C%E5%8E%9F%E7%90%86/%E8%AE%A1%E7%AE%97%E6%9C%BA%E7%BD%91%E7%BB%9C%E5%8E%9F%E7%90%86%E9%9D%A2%E8%AF%95%E9%A2%98/6.3_%E8%B0%88%E8%B0%88%E4%BD%A0%E5%AF%B9%E5%9F%9F%E5%90%8D%E7%BC%93%E5%AD%98%E7%9A%84%E4%BA%86%E8%A7%A3/","content":"为了提高DNS的查询效率，并减轻服务器的负荷和减少因特网上的DNS查询报文数量，在域名服务器中广泛使用了高速缓存，用来存放最近查询过的域名以及从何处获得域名映射信息的记录\n不仅在本地域名服务器中需要高速缓存，在主机中也需要。许多主机在启动时从本地服务器下载名字和地址的全部数据库，维护存放自己最近使用的域名的高速缓存，并且只在从缓存中找不到名字时才使用域名服务器。维护本地域名服务器数据库的主机应当定期地检查域名服务器以获取新的映射信息，而且主机必须从缓存中删除无效的项。由于域名改动并不频繁，大多数网点不需花精力就能维护数据库的一致性。\n","categories":["计算机理论"],"tags":["计算机网络原理-计算机网络原理面试题"]},{"title":"在浏览器中输入URL地址后执行的全部过程","url":"/2020/05/15/%E8%AE%A1%E7%AE%97%E6%9C%BA%E7%90%86%E8%AE%BA/%E8%AE%A1%E7%AE%97%E6%9C%BA%E7%BD%91%E7%BB%9C%E5%8E%9F%E7%90%86/%E8%AE%A1%E7%AE%97%E6%9C%BA%E7%BD%91%E7%BB%9C%E5%8E%9F%E7%90%86%E9%9D%A2%E8%AF%95%E9%A2%98/6.4_%E5%9C%A8%E6%B5%8F%E8%A7%88%E5%99%A8%E4%B8%AD%E8%BE%93%E5%85%A5URL%E5%9C%B0%E5%9D%80%E5%90%8E%E6%89%A7%E8%A1%8C%E7%9A%84%E5%85%A8%E9%83%A8%E8%BF%87%E7%A8%8B/","content":"\nDNS解析\nTCP连接：浏览器获得域名对应的IP地址以后，浏览器向服务器请求建立连接，发起三次握手\n发送HTTP请求：TCP连接建立起来后，浏览器向服务器发送HTTP 请求\n服务器处理请求并返回HTTP报文：服务器接收到这个请求，并根据路径参数映射到特定的请求处理器进行处理，并将处理结果及相应的视图返回给浏览器\n浏览器解析渲染页面：浏览器解析并渲染视图，若遇到对js 文件、css文件及图片等静态资源的引用，则重复上述步骤并向服务器请求这些资源，浏览器根据其请求到的资源、数据渲染页面，最终向用户呈现一个完整的页面\n连接结束\n\n","categories":["计算机理论"],"tags":["计算机网络原理-计算机网络原理面试题"]},{"title":"HTTP与HTTPS的区别","url":"/2020/05/15/%E8%AE%A1%E7%AE%97%E6%9C%BA%E7%90%86%E8%AE%BA/%E8%AE%A1%E7%AE%97%E6%9C%BA%E7%BD%91%E7%BB%9C%E5%8E%9F%E7%90%86/%E8%AE%A1%E7%AE%97%E6%9C%BA%E7%BD%91%E7%BB%9C%E5%8E%9F%E7%90%86%E9%9D%A2%E8%AF%95%E9%A2%98/6.16_HTTP%E4%B8%8EHTTPS%E7%9A%84%E5%8C%BA%E5%88%AB/","content":"\n\n\n\nHTTP\nHTTPS\n\n\n\n端口\n80\n443\n\n\n安全性\n无加密，安全性较差\n有加密机制，安全性较高\n\n\n资源消耗\n较少\n由于加密处理，资源消耗更多\n\n\n是否需要证书\n不需要\n需要\n\n\n协议\n运行在TCP协议之上\n运行在SSL协议之上，SSL运行在TCP协议之上\n\n\n","categories":["计算机理论"],"tags":["计算机网络原理-计算机网络原理面试题"]},{"title":"什么是数字证书","url":"/2020/05/15/%E8%AE%A1%E7%AE%97%E6%9C%BA%E7%90%86%E8%AE%BA/%E8%AE%A1%E7%AE%97%E6%9C%BA%E7%BD%91%E7%BB%9C%E5%8E%9F%E7%90%86/%E8%AE%A1%E7%AE%97%E6%9C%BA%E7%BD%91%E7%BB%9C%E5%8E%9F%E7%90%86%E9%9D%A2%E8%AF%95%E9%A2%98/6.5_%E4%BB%80%E4%B9%88%E6%98%AF%E6%95%B0%E5%AD%97%E8%AF%81%E4%B9%A6/","content":"对称加密中，双方使用公钥进行解密。虽然数字签名可以保证数据不被替换，但是数据是由公钥加密的，如果公钥也被替换，则仍然可以伪造数据，因为用户不知道对方提供的公钥其实是假的。所以为了保证发送方的公钥是真的，CA证书机构会负责颁发一个证书，里面的公钥保证是真的，用户请求服务器时，服务器收证状发给用户。议个证书是经由系统内置证书的备案的。\n","categories":["计算机理论"],"tags":["计算机网络原理-计算机网络原理面试题"]},{"title":"什么是数字签名","url":"/2020/05/15/%E8%AE%A1%E7%AE%97%E6%9C%BA%E7%90%86%E8%AE%BA/%E8%AE%A1%E7%AE%97%E6%9C%BA%E7%BD%91%E7%BB%9C%E5%8E%9F%E7%90%86/%E8%AE%A1%E7%AE%97%E6%9C%BA%E7%BD%91%E7%BB%9C%E5%8E%9F%E7%90%86%E9%9D%A2%E8%AF%95%E9%A2%98/6.6_%E4%BB%80%E4%B9%88%E6%98%AF%E6%95%B0%E5%AD%97%E7%AD%BE%E5%90%8D/","content":"为了避免数据在传输过程中被替换，比如黑客修改了你的报文内容，但是你并不 知道，所以我们让发送端做一个数字签名， 把数据的摘要消息进行一个加密， 比 如MD5，得到一个签名，和数据一起发送。 然后接收端把数据摘要进行MD5解密，如果和签名一样， 则说明数据确实是真的。\n","categories":["计算机理论"],"tags":["计算机网络原理-计算机网络原理面试题"]},{"title":"什么是对称加密和非对称加密","url":"/2020/05/15/%E8%AE%A1%E7%AE%97%E6%9C%BA%E7%90%86%E8%AE%BA/%E8%AE%A1%E7%AE%97%E6%9C%BA%E7%BD%91%E7%BB%9C%E5%8E%9F%E7%90%86/%E8%AE%A1%E7%AE%97%E6%9C%BA%E7%BD%91%E7%BB%9C%E5%8E%9F%E7%90%86%E9%9D%A2%E8%AF%95%E9%A2%98/6.7_%E4%BB%80%E4%B9%88%E6%98%AF%E5%AF%B9%E7%A7%B0%E5%8A%A0%E5%AF%86%E5%92%8C%E9%9D%9E%E5%AF%B9%E7%A7%B0%E5%8A%A0%E5%AF%86/","content":"对称密钥加密是指加密和解密使用同一个密钥的方式，这种方式存在的最大问题就是密钥发送问题，即如何安全地将密钥发给对方\n非对称加密指使用一对非对称密钥，即:公钥和私钥，公钥可以随意发布，但私钥只有自己知道。发送密文的一方使用对方的公钥进行加密处理，对方接收到加密信息后，使用自己的私钥进行解密\n由于非对称加密的方式不需要发送用来解密的私钥，所以可以保证安全性。但是和对称加密比起来，它非常的慢，所以我们还是要用对称加密来传送消息，但对称加密所便用的密钥我们可以通过非对称加密的方式发送出去\n","categories":["计算机理论"],"tags":["计算机网络原理-计算机网络原理面试题"]},{"title":"Cookie和Session是如何配合的呢","url":"/2020/05/15/%E8%AE%A1%E7%AE%97%E6%9C%BA%E7%90%86%E8%AE%BA/%E8%AE%A1%E7%AE%97%E6%9C%BA%E7%BD%91%E7%BB%9C%E5%8E%9F%E7%90%86/%E8%AE%A1%E7%AE%97%E6%9C%BA%E7%BD%91%E7%BB%9C%E5%8E%9F%E7%90%86%E9%9D%A2%E8%AF%95%E9%A2%98/6.21_Cookie%E5%92%8CSession%E6%98%AF%E5%A6%82%E4%BD%95%E9%85%8D%E5%90%88%E7%9A%84%E5%91%A2/","content":"用户第一次请求服务器的时候，服务器根据用户提交的相关信息，创建对应的 Session ，请求返回时将此 Session 的唯一标识信息 SessionID 返回给浏览器，浏览器接收到服务器返回的 SessionID 信息后，会将此信息存入到 Cookie 中，同时 Cookie 记录此 SessionID 属于哪个域名。\n当用户第二次访问服务器的时候，请求会自动判断此域名下是否存在 Cookie 信息，如果存在自动将 Cookie 信息也发送给服务端，服务端会从 Cookie 中获取 SessionID，再根据 SessionID 查找对应的 Session 信息，如果没有找到说明用户没有登录或者登录失效，如果找到 Session 证明用户已经登录可执行后面操作。\n根据以上流程可知，SessionID 是连接 Cookie 和 Session 的一道桥梁，大部分系统也是根据此原理来验证用户登录状态。\n","categories":["计算机理论"],"tags":["计算机网络原理-计算机网络原理面试题"]},{"title":"HTTP常用的请求方式","url":"/2020/05/15/%E8%AE%A1%E7%AE%97%E6%9C%BA%E7%90%86%E8%AE%BA/%E8%AE%A1%E7%AE%97%E6%9C%BA%E7%BD%91%E7%BB%9C%E5%8E%9F%E7%90%86/%E8%AE%A1%E7%AE%97%E6%9C%BA%E7%BD%91%E7%BB%9C%E5%8E%9F%E7%90%86%E9%9D%A2%E8%AF%95%E9%A2%98/6.8_HTTP%E5%B8%B8%E7%94%A8%E7%9A%84%E8%AF%B7%E6%B1%82%E6%96%B9%E5%BC%8F/","content":"\n\n\n方法\n作用\n\n\n\nGET\n获取资源（查）\n\n\nPOST\n传输实体主体（改）\n\n\nPUT\n上传文件（增）\n\n\nDELETE\n删除文件（删）\n\n\nHEAD\n和GET方法类似，但只返回报文首部，不返回报文主体部分\n\n\nPATCH\n对资源进行部分修改\n\n\nOPTIONS\n查询指定的URL支持的方法\n\n\nCONNECT\n要求用隧道协议连接代理\n\n\nTRACE\n服务器会将通信路径返回给客户端\n\n\nGET请求和POST请求的区别？\n使用上的区别：\n\nGET使用URL或Cookie传参，而POST将数据放在BODY中”，这个是因为HTTP协议用法的约定。\n\nGET方式提交的数据有长度限制，则POST的数据则可以非常大，这个是因为它们使用的操作系统和浏览器设置的不同引起的区别。\n\nPOST比GET安全，因为数据在地址栏上不可见”，这个说法没毛病，但依然不是GET和POST本身的区别。\n\n\n本质区别：GET和POST最大的区别主要是GET请求是幂等性的，POST请求不是。这个是它们本质区别。幂等性是指一次和多次请求某一个资源应该具有同样的副作用。简单来说意味着对同一URL的多个请求应该返回同样的结果。\n","categories":["计算机理论"],"tags":["计算机网络原理-计算机网络原理面试题"]},{"title":"HTTP请求报文和响应报文的格式","url":"/2020/05/15/%E8%AE%A1%E7%AE%97%E6%9C%BA%E7%90%86%E8%AE%BA/%E8%AE%A1%E7%AE%97%E6%9C%BA%E7%BD%91%E7%BB%9C%E5%8E%9F%E7%90%86/%E8%AE%A1%E7%AE%97%E6%9C%BA%E7%BD%91%E7%BB%9C%E5%8E%9F%E7%90%86%E9%9D%A2%E8%AF%95%E9%A2%98/6.9_HTTP%E8%AF%B7%E6%B1%82%E6%8A%A5%E6%96%87%E5%92%8C%E5%93%8D%E5%BA%94%E6%8A%A5%E6%96%87%E7%9A%84%E6%A0%BC%E5%BC%8F/","content":"请求报文格式：\n\n请求行（请求方法+URI协议+版本）\n请求头部\n空行\n请求主体\n\nGET/sample.jspHTTP/1.1 请求行Accept:image/gif.image/jpeg, 请求头部Accept-Language:zh-cnConnection:Keep-AliveHost:localhostUser-Agent:Mozila/4.0(compatible;MSIE5.01;Window NT5.0)Accept-Encoding:gzip,deflateusername=jinqiao&amp;password=1234 请求主体\n\n响应报文：\n\n状态行（版本+状态码+原因短语）\n响应首部\n空行\n响应主体\n\nHTTP/1.1 200 OKServer:Apache Tomcat/5.0.12Date:Mon,6Oct2003 13:23:42 GMTContent-Length:112&lt;html&gt;    &lt;head&gt;        &lt;title&gt;HTTP响应示例&lt;title&gt;    &lt;/head&gt;    &lt;body&gt;        Hello HTTP!    &lt;/body&gt;&lt;/html&gt;\n\n","categories":["计算机理论"],"tags":["计算机网络原理-计算机网络原理面试题"]},{"title":"解释一下HTTP长连接和短连接","url":"/2020/05/15/%E8%AE%A1%E7%AE%97%E6%9C%BA%E7%90%86%E8%AE%BA/%E8%AE%A1%E7%AE%97%E6%9C%BA%E7%BD%91%E7%BB%9C%E5%8E%9F%E7%90%86/%E8%AE%A1%E7%AE%97%E6%9C%BA%E7%BD%91%E7%BB%9C%E5%8E%9F%E7%90%86%E9%9D%A2%E8%AF%95%E9%A2%98/6.13_%E8%A7%A3%E9%87%8A%E4%B8%80%E4%B8%8BHTTP%E9%95%BF%E8%BF%9E%E6%8E%A5%E5%92%8C%E7%9F%AD%E8%BF%9E%E6%8E%A5/","content":"在HTTP&#x2F;1.0中，默认使用的是短连接。也就是说，浏览器和服务器每进行一次HTTP操作，就建立一次连接，但任务结束就中断连接。如果客户端浏览器访问的某个HTML或其他类型的 Web页中包含有其他的Web资源，如JavaScript文件、图像文件、CSS文件等；当浏览器每遇到这样一个Web资源，就会建立一个HTTP会话。\n但从 HTTP&#x2F;1.1起，默认使用长连接，用以保持连接特性。使用长连接的HTTP协议，会在响应头有加入这行代码：Connection:keep-alive；在使用长连接的情况下，当一个网页打开完成后，客户端和服务器之间用于传输HTTP数据的 TCP连接不会关闭，如果客户端再次访问这个服务器上的网页，会继续使用这一条已经建立的连接。Keep-Alive不会永久保持连接，它有一个保持时间，可以在不同的服务器软件（如Apache）中设定这个时间。实现长连接要客户端和服务端都支持长连接。\nHTTP协议的长连接和短连接，实质上是TCP协议的长连接和短连接。\n","categories":["计算机理论"],"tags":["计算机网络原理-计算机网络原理面试题"]}]